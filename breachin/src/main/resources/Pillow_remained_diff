('', 'Makefile')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -9,9 +9,11 @@

 .PHONY: coverage
 coverage:
-	pytest -qq
+	python3 -c "import pytest" > /dev/null 2>&1 || python3 -m pip install pytest
+	python3 -m pytest -qq
 	rm -r htmlcov || true
-	coverage report
+	python3 -c "import coverage" > /dev/null 2>&1 || python3 -m pip install coverage
+	python3 -m coverage report

 .PHONY: doc
 doc:
@@ -33,33 +35,29 @@
 	@echo "Welcome to Pillow development. Please use \`make <target>\` where <target> is one of"
 	@echo "  clean              remove build products"
 	@echo "  coverage           run coverage test (in progress)"
-	@echo "  doc                make html docs"
-	@echo "  docserve           run an http server on the docs directory"
+	@echo "  doc                make HTML docs"
+	@echo "  docserve           run an HTTP server on the docs directory"
 	@echo "  html               to make standalone HTML files"
 	@echo "  inplace            make inplace extension"
 	@echo "  install            make and install"
 	@echo "  install-coverage   make and install with C coverage"
-	@echo "  install-req        install documentation and test dependencies"
-	@echo "  install-venv       (deprecated) install in virtualenv"
 	@echo "  lint               run the lint checks"
-	@echo "  lint-fix           run black and isort to (mostly) fix lint issues."
+	@echo "  lint-fix           run Black and isort to (mostly) fix lint issues"
 	@echo "  release-test       run code and package tests before release"
-	@echo "  test               run tests on installed pillow"
-	@echo "  upload             build and upload sdists to PyPI"
-	@echo "  upload-test        build and upload sdists to test.pythonpackages.com"
+	@echo "  test               run tests on installed Pillow"

 .PHONY: inplace
 inplace: clean
-	python3 setup.py develop build_ext --inplace
+	python3 -m pip install -e --global-option="build_ext" --global-option="--inplace" .

 .PHONY: install
 install:
-	python3 setup.py install
+	python3 -m pip install .
 	python3 selftest.py

 .PHONY: install-coverage
 install-coverage:
-	CFLAGS="-coverage -Werror=implicit-function-declaration" python3 setup.py build_ext install
+	CFLAGS="-coverage -Werror=implicit-function-declaration" python3 -m pip install --global-option="build_ext" .
 	python3 selftest.py

 .PHONY: debug
@@ -68,51 +66,52 @@
 # for our stuff, kills optimization, and redirects to dev null so we
 # see any build failures.
 	make clean > /dev/null
-	CFLAGS='-g -O0' python3 setup.py build_ext install > /dev/null
-
-.PHONY: install-req
-install-req:
-	python3 -m pip install -r requirements.txt
-
-.PHONY: install-venv
-install-venv:
-	echo "'install-venv' is deprecated and will be removed in a future Pillow release"
-	virtualenv .
-	bin/pip install -r requirements.txt
+	CFLAGS='-g -O0' python3 -m pip install --global-option="build_ext" . > /dev/null

 .PHONY: release-test
 release-test:
-	$(MAKE) install-req
-	python3 setup.py develop
+	python3 -m pip install -e .[tests]
 	python3 selftest.py
 	python3 -m pytest Tests
-	python3 setup.py install
+	python3 -m pip install .
 	-rm dist/*.egg
 	-rmdir dist
 	python3 -m pytest -qq
-	check-manifest
-	pyroma .
+	python3 -m check-manifest
+	python3 -m pyroma .
 	$(MAKE) readme

 .PHONY: sdist
 sdist:
-	python3 setup.py sdist --format=gztar
+	python3 -m build --help > /dev/null 2>&1 || python3 -m pip install build
+	python3 -m build --sdist

 .PHONY: test
 test:
-	pytest -qq
+	python3 -c "import pytest" > /dev/null 2>&1 || python3 -m pip install pytest
+	python3 -m pytest -qq
+
+.PHONY: valgrind
+valgrind:
+	python3 -c "import pytest_valgrind" > /dev/null 2>&1 || python3 -m pip install pytest-valgrind
+	PYTHONMALLOC=malloc valgrind --suppressions=Tests/oss-fuzz/python.supp --leak-check=no \
+            --log-file=/tmp/valgrind-output \
+            python3 -m pytest --no-memcheck -vv --valgrind --valgrind-log=/tmp/valgrind-output

 .PHONY: readme
 readme:
-	python3 setup.py --long-description | markdown2 > .long-description.html && open .long-description.html
+	python3 -c "import markdown2" > /dev/null 2>&1 || python3 -m pip install markdown2
+	python3 -m markdown2 README.md > .long-description.html && open .long-description.html


 .PHONY: lint
 lint:
-	tox --help > /dev/null || python3 -m pip install tox
-	tox -e lint
+	python3 -c "import tox" > /dev/null 2>&1 || python3 -m pip install tox
+	python3 -m tox -e lint

 .PHONY: lint-fix
 lint-fix:
-	black --target-version py36 .
-	isort .
+	python3 -c "import black" > /dev/null 2>&1 || python3 -m pip install black
+	python3 -c "import isort" > /dev/null 2>&1 || python3 -m pip install isort
+	python3 -m black --target-version py37 .
+	python3 -m isort .
('', '.appveyor.yml')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -10,29 +10,29 @@
   TEST_OPTIONS:
   DEPLOY: YES
   matrix:
-  - PYTHON: C:/Python39
+  - PYTHON: C:/Python310
     ARCHITECTURE: x86
-    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019
-  - PYTHON: C:/Python36-x64
+    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022
+  - PYTHON: C:/Python37-x64
     ARCHITECTURE: x64
     APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017


 install:
-- curl -fsSL -o pillow-depends.zip https://github.com/python-pillow/pillow-depends/archive/master.zip
+- '%PYTHON%\%EXECUTABLE% --version'
+- curl -fsSL -o pillow-depends.zip https://github.com/python-pillow/pillow-depends/archive/main.zip
 - 7z x pillow-depends.zip -oc:\
-- mv c:\pillow-depends-master c:\pillow-depends
+- mv c:\pillow-depends-main c:\pillow-depends
 - xcopy /S /Y c:\pillow-depends\test_images\* c:\pillow\tests\images
-- 7z x ..\pillow-depends\nasm-2.14.02-win64.zip -oc:\
-- ..\pillow-depends\gs9533w32.exe /S
-- path c:\nasm-2.14.02;C:\Program Files (x86)\gs\gs9.53.3\bin;%PATH%
+- 7z x ..\pillow-depends\nasm-2.15.05-win64.zip -oc:\
+- ..\pillow-depends\gs9550w32.exe /S
+- path c:\nasm-2.15.05;C:\Program Files (x86)\gs\gs9.55.0\bin;%PATH%
 - cd c:\pillow\winbuild\
 - ps: |
         c:\python37\python.exe c:\pillow\winbuild\build_prepare.py -v --depends=C:\pillow-depends\
         c:\pillow\winbuild\build\build_dep_all.cmd
         $host.SetShouldExit(0)
 - path C:\pillow\winbuild\build\bin;%PATH%
-- '%PYTHON%\%EXECUTABLE% -m pip install -U "setuptools>=49.3.2"'

 build_script:
 - ps: |
@@ -43,8 +43,9 @@

 test_script:
 - cd c:\pillow
-- '%PYTHON%\%EXECUTABLE% -m pip install pytest pytest-cov'
+- '%PYTHON%\%EXECUTABLE% -m pip install pytest pytest-cov pytest-timeout'
 - c:\"Program Files (x86)"\"Windows Kits"\10\Debuggers\x86\gflags.exe /p /enable %PYTHON%\%EXECUTABLE%
+- '%PYTHON%\%EXECUTABLE% -c "from PIL import Image"'
 - '%PYTHON%\%EXECUTABLE% -m pytest -vx --cov PIL --cov Tests --cov-report term --cov-report xml Tests'
 #- '%PYTHON%\%EXECUTABLE% test-installed.py -v -s %TEST_OPTIONS%' TODO TEST_OPTIONS with pytest?

@@ -83,7 +84,7 @@
   artifact: /.*egg|wheel/
   on:
     APPVEYOR_REPO_NAME: python-pillow/Pillow
-    branch: master
+    branch: main
     deploy: YES


('', 'selftest.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 # minimal sanity check

 import sys
@@ -14,17 +14,13 @@
     pass


-def _info(im):
-    im.load()
-    return im.format, im.mode, im.size
-
-
 def testimage():
     """
     PIL lets you create in-memory images with various pixel types:

     >>> from PIL import Image, ImageDraw, ImageFilter, ImageMath
     >>> im = Image.new("1", (128, 128)) # monochrome
+    >>> def _info(im): return (im.format, im.mode, im.size)
     >>> _info(im)
     (None, '1', (128, 128))
     >>> _info(Image.new("L", (128, 128))) # grayscale (luminance)
@@ -101,9 +97,9 @@
     10456
     >>> len(im.tobytes())
     49152
-    >>> _info(im.transform((512, 512), Image.AFFINE, (1,0,0,0,1,0)))
+    >>> _info(im.transform((512, 512), Image.Transform.AFFINE, (1,0,0,0,1,0)))
     (None, 'RGB', (512, 512))
-    >>> _info(im.transform((512, 512), Image.EXTENT, (32,32,96,96)))
+    >>> _info(im.transform((512, 512), Image.Transform.EXTENT, (32,32,96,96)))
     (None, 'RGB', (512, 512))

     The ImageDraw module lets you draw stuff in raster images:
@@ -147,9 +143,7 @@
     ('F', (128, 128))

     PIL can do many other things, but I'll leave that for another
-    day.  If you're curious, check the handbook, available from:
-
-        http://www.pythonware.com
+    day.

     Cheers /F
     """
('', 'setup.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 # > pyroma .
 # ------------------------------
 # Checking .
@@ -26,18 +26,19 @@
     return locals()["__version__"]


-NAME = "Pillow"
 PILLOW_VERSION = get_version()
 FREETYPE_ROOT = None
+HARFBUZZ_ROOT = None
+FRIBIDI_ROOT = None
 IMAGEQUANT_ROOT = None
 JPEG2K_ROOT = None
 JPEG_ROOT = None
 LCMS_ROOT = None
 TIFF_ROOT = None
 ZLIB_ROOT = None
-
-
-if sys.platform == "win32" and sys.version_info >= (3, 10):
+FUZZING_BUILD = "LIB_FUZZING_ENGINE" in os.environ
+
+if sys.platform == "win32" and sys.version_info >= (3, 11):
     import atexit

     atexit.register(
@@ -166,7 +167,7 @@
         # Assuming GLIBC's ldconfig (with option -p)
         # Alpine Linux uses musl that can't print cache
         args = ["/sbin/ldconfig", "-p"]
-        expr = fr".*\({abi_type}.*\) => (.*)"
+        expr = rf".*\({abi_type}.*\) => (.*)"
         env = dict(os.environ)
         env["LC_ALL"] = "C"
         env["LANG"] = "C"
@@ -184,7 +185,7 @@
         return []
     [data, _] = p.communicate()
     if isinstance(data, bytes):
-        data = data.decode()
+        data = data.decode("latin1")

     dirs = []
     for dll in re.findall(expr, data):
@@ -226,6 +227,19 @@
     else:
         _dbg("Couldn't find library %s in %s", (library, self.compiler.library_dirs))
     return ret
+
+
+def _find_include_dir(self, dirname, include):
+    for directory in self.compiler.include_dirs:
+        _dbg("Checking for include file %s in %s", (include, directory))
+        if os.path.isfile(os.path.join(directory, include)):
+            _dbg("Found %s in %s", (include, directory))
+            return True
+        subdir = os.path.join(directory, dirname)
+        _dbg("Checking for include file %s in %s", (include, subdir))
+        if os.path.isfile(os.path.join(subdir, include)):
+            _dbg("Found %s in %s", (include, subdir))
+            return subdir


 def _cmd_exists(cmd):
@@ -267,6 +281,7 @@
             "jpeg",
             "tiff",
             "freetype",
+            "raqm",
             "lcms",
             "webp",
             "webpmux",
@@ -276,6 +291,7 @@
         ]

         required = {"jpeg", "zlib"}
+        vendor = set()

         def __init__(self):
             for f in self.features:
@@ -286,6 +302,9 @@

         def want(self, feat):
             return getattr(self, feat) is None
+
+        def want_vendor(self, feat):
+            return feat in self.vendor

         def __iter__(self):
             yield from self.features
@@ -296,6 +315,10 @@
         build_ext.user_options
         + [(f"disable-{x}", None, f"Disable support for {x}") for x in feature]
         + [(f"enable-{x}", None, f"Enable support for {x}") for x in feature]
+        + [
+            (f"vendor-{x}", None, f"Use vendored version of {x}")
+            for x in ("raqm", "fribidi")
+        ]
         + [
             ("disable-platform-guessing", None, "Disable platform guessing on Linux"),
             ("debug", None, "Debug logging"),
@@ -310,6 +333,8 @@
         for x in self.feature:
             setattr(self, f"disable_{x}", None)
             setattr(self, f"enable_{x}", None)
+        for x in ("raqm", "fribidi"):
+            setattr(self, f"vendor_{x}", None)

     def finalize_options(self):
         build_ext.finalize_options(self)
@@ -334,18 +359,43 @@
                     raise ValueError(
                         f"Conflicting options: --enable-{x} and --disable-{x}"
                     )
+                if x == "freetype":
+                    _dbg("--disable-freetype implies --disable-raqm")
+                    if getattr(self, "enable_raqm"):
+                        raise ValueError(
+                            "Conflicting options: --enable-raqm and --disable-freetype"
+                        )
+                    setattr(self, "disable_raqm", True)
             if getattr(self, f"enable_{x}"):
                 _dbg("Requiring %s", x)
                 self.feature.required.add(x)
-
-    def _update_extension(self, name, libraries, define_macros=None, include_dirs=None):
+                if x == "raqm":
+                    _dbg("--enable-raqm implies --enable-freetype")
+                    self.feature.required.add("freetype")
+        for x in ("raqm", "fribidi"):
+            if getattr(self, f"vendor_{x}"):
+                if getattr(self, "disable_raqm"):
+                    raise ValueError(
+                        f"Conflicting options: --vendor-{x} and --disable-raqm"
+                    )
+                if x == "fribidi" and not getattr(self, "vendor_raqm"):
+                    raise ValueError(
+                        f"Conflicting options: --vendor-{x} and not --vendor-raqm"
+                    )
+                _dbg("Using vendored version of %s", x)
+                self.feature.vendor.add(x)
+
+    def _update_extension(self, name, libraries, define_macros=None, sources=None):
         for extension in self.extensions:
             if extension.name == name:
                 extension.libraries += libraries
                 if define_macros is not None:
                     extension.define_macros += define_macros
-                if include_dirs is not None:
-                    extension.include_dirs += include_dirs
+                if sources is not None:
+                    extension.sources += sources
+                if FUZZING_BUILD:
+                    extension.language = "c++"
+                    extension.extra_link_args = ["--stdlib=libc++"]
                 break

     def _remove_extension(self, name):
@@ -353,6 +403,27 @@
             if extension.name == name:
                 self.extensions.remove(extension)
                 break
+
+    def get_macos_sdk_path(self):
+        try:
+            sdk_path = (
+                subprocess.check_output(["xcrun", "--show-sdk-path"])
+                .strip()
+                .decode("latin1")
+            )
+        except Exception:
+            sdk_path = None
+        if (
+            not sdk_path
+            or sdk_path == "/Applications/Xcode.app/Contents/Developer"
+            "/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
+        ):
+            commandlinetools_sdk_path = (
+                "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
+            )
+            if os.path.exists(commandlinetools_sdk_path):
+                sdk_path = commandlinetools_sdk_path
+        return sdk_path

     def build_extensions(self):

@@ -371,6 +442,8 @@
             TIFF_ROOT=("libtiff-5", "libtiff-4"),
             ZLIB_ROOT="zlib",
             FREETYPE_ROOT="freetype2",
+            HARFBUZZ_ROOT="harfbuzz",
+            FRIBIDI_ROOT="fribidi",
             LCMS_ROOT="lcms2",
             IMAGEQUANT_ROOT="libimagequant",
         ).items():
@@ -479,15 +552,7 @@
                 _add_directory(library_dirs, "/usr/X11/lib")
                 _add_directory(include_dirs, "/usr/X11/include")

-            # SDK install path
-            try:
-                sdk_path = (
-                    subprocess.check_output(["xcrun", "--show-sdk-path"])
-                    .strip()
-                    .decode("latin1")
-                )
-            except Exception:
-                sdk_path = None
+            sdk_path = self.get_macos_sdk_path()
             if sdk_path:
                 _add_directory(library_dirs, os.path.join(sdk_path, "usr", "lib"))
                 _add_directory(include_dirs, os.path.join(sdk_path, "usr", "include"))
@@ -506,7 +571,11 @@
                 # headers are at $PREFIX/include
                 # user libs are at $PREFIX/lib
                 _add_directory(
-                    library_dirs, os.path.join(os.environ["ANDROID_ROOT"], "lib")
+                    library_dirs,
+                    os.path.join(
+                        os.environ["ANDROID_ROOT"],
+                        "lib" if struct.calcsize("l") == 4 else "lib64",
+                    ),
                 )

         elif sys.platform.startswith("netbsd"):
@@ -656,6 +725,39 @@
                     if subdir:
                         _add_directory(self.compiler.include_dirs, subdir, 0)

+        if feature.freetype and feature.want("raqm"):
+            if not feature.want_vendor("raqm"):  # want system Raqm
+                _dbg("Looking for Raqm")
+                if _find_include_file(self, "raqm.h"):
+                    if _find_library_file(self, "raqm"):
+                        feature.raqm = "raqm"
+                    elif _find_library_file(self, "libraqm"):
+                        feature.raqm = "libraqm"
+            else:  # want to build Raqm from src/thirdparty
+                _dbg("Looking for HarfBuzz")
+                feature.harfbuzz = None
+                hb_dir = _find_include_dir(self, "harfbuzz", "hb.h")
+                if hb_dir:
+                    if isinstance(hb_dir, str):
+                        _add_directory(self.compiler.include_dirs, hb_dir, 0)
+                    if _find_library_file(self, "harfbuzz"):
+                        feature.harfbuzz = "harfbuzz"
+                if feature.harfbuzz:
+                    if not feature.want_vendor("fribidi"):  # want system FriBiDi
+                        _dbg("Looking for FriBiDi")
+                        feature.fribidi = None
+                        fribidi_dir = _find_include_dir(self, "fribidi", "fribidi.h")
+                        if fribidi_dir:
+                            if isinstance(fribidi_dir, str):
+                                _add_directory(
+                                    self.compiler.include_dirs, fribidi_dir, 0
+                                )
+                            if _find_library_file(self, "fribidi"):
+                                feature.fribidi = "fribidi"
+                                feature.raqm = True
+                    else:  # want to build FriBiDi shim from src/thirdparty
+                        feature.raqm = True
+
         if feature.want("lcms"):
             _dbg("Looking for lcms")
             if _find_include_file(self, "lcms2.h"):
@@ -724,9 +826,11 @@
         if feature.tiff:
             libs.append(feature.tiff)
             defs.append(("HAVE_LIBTIFF", None))
-            # FIXME the following define should be detected automatically
-            #       based on system libtiff, see #4237
-            if PLATFORM_MINGW:
+            if sys.platform == "win32":
+                # This define needs to be defined if-and-only-if it was defined
+                # when compiling LibTIFF. LibTIFF doesn't expose it in `tiffconf.h`,
+                # so we have to guess; by default it is defined in all Windows builds.
+                # See #4237, #5243, #5359 for more information.
                 defs.append(("USE_WIN32_FILEIO", None))
         if feature.xcb:
             libs.append(feature.xcb)
@@ -751,9 +855,25 @@
         # additional libraries

         if feature.freetype:
+            srcs = []
             libs = ["freetype"]
             defs = []
-            self._update_extension("PIL._imagingft", libs, defs)
+            if feature.raqm:
+                if not feature.want_vendor("raqm"):  # using system Raqm
+                    defs.append(("HAVE_RAQM", None))
+                    defs.append(("HAVE_RAQM_SYSTEM", None))
+                    libs.append(feature.raqm)
+                else:  # building Raqm from src/thirdparty
+                    defs.append(("HAVE_RAQM", None))
+                    srcs.append("src/thirdparty/raqm/raqm.c")
+                    libs.append(feature.harfbuzz)
+                    if not feature.want_vendor("fribidi"):  # using system FriBiDi
+                        defs.append(("HAVE_FRIBIDI_SYSTEM", None))
+                        libs.append(feature.fribidi)
+                    else:  # building FriBiDi shim from src/thirdparty
+                        srcs.append("src/thirdparty/fribidi-shim/fribidi.c")
+            self._update_extension("PIL._imagingft", libs, defs, srcs)
+
         else:
             self._remove_extension("PIL._imagingft")

@@ -778,7 +898,7 @@
         else:
             self._remove_extension("PIL._webp")

-        tk_libs = ["psapi"] if sys.platform == "win32" else []
+        tk_libs = ["psapi"] if sys.platform in ("win32", "cygwin") else []
         self._update_extension("PIL._imagingtk", tk_libs)

         build_ext.build_extensions(self)
@@ -800,6 +920,12 @@
             print(f"             [{v.strip()}")
         print("-" * 68)

+        raqm_extra_info = ""
+        if feature.want_vendor("raqm"):
+            raqm_extra_info += "bundled"
+            if feature.want_vendor("fribidi"):
+                raqm_extra_info += ", FriBiDi shim"
+
         options = [
             (feature.jpeg, "JPEG"),
             (feature.jpeg2000, "OPENJPEG (JPEG2000)", feature.openjpeg_version),
@@ -807,6 +933,7 @@
             (feature.imagequant, "LIBIMAGEQUANT"),
             (feature.tiff, "LIBTIFF"),
             (feature.freetype, "FREETYPE2"),
+            (feature.raqm, "RAQM (Text shaping)", raqm_extra_info),
             (feature.lcms, "LITTLECMS2"),
             (feature.webp, "WEBP"),
             (feature.webpmux, "WEBPMUX"),
@@ -816,10 +943,10 @@
         all = 1
         for option in options:
             if option[0]:
-                version = ""
+                extra_info = ""
                 if len(option) >= 3 and option[2]:
-                    version = f" ({option[2]})"
-                print(f"--- {option[1]} support available{version}")
+                    extra_info = f" ({option[2]})"
+                print(f"--- {option[1]} support available{extra_info}")
             else:
                 print(f"*** {option[1]} support not available")
                 all = 0
@@ -840,7 +967,7 @@


 def debug_build():
-    return hasattr(sys, "gettotalrefcount")
+    return hasattr(sys, "gettotalrefcount") or FUZZING_BUILD


 files = ["src/_imaging.c"]
@@ -858,54 +985,14 @@
     Extension("PIL._imagingmorph", ["src/_imagingmorph.c"]),
 ]

-with open("README.md") as f:
-    long_description = f.read()
-
 try:
     setup(
-        name=NAME,
         version=PILLOW_VERSION,
-        description="Python Imaging Library (Fork)",
-        long_description=long_description,
-        long_description_content_type="text/markdown",
-        license="HPND",
-        author="Alex Clark (PIL Fork Author)",
-        author_email="aclark@python-pillow.org",
-        url="https://python-pillow.org",
-        project_urls={
-            "Documentation": "https://pillow.readthedocs.io",
-            "Source": "https://github.com/python-pillow/Pillow",
-            "Funding": "https://tidelift.com/subscription/pkg/pypi-pillow?"
-            "utm_source=pypi-pillow&utm_medium=pypi",
-            "Release notes": "https://pillow.readthedocs.io/en/stable/releasenotes/"
-            "index.html",
-            "Changelog": "https://github.com/python-pillow/Pillow/blob/master/"
-            "CHANGES.rst",
-        },
-        classifiers=[
-            "Development Status :: 6 - Mature",
-            "License :: OSI Approved :: Historical Permission Notice and Disclaimer (HPND)",  # noqa: E501
-            "Programming Language :: Python :: 3",
-            "Programming Language :: Python :: 3.6",
-            "Programming Language :: Python :: 3.7",
-            "Programming Language :: Python :: 3.8",
-            "Programming Language :: Python :: 3.9",
-            "Programming Language :: Python :: 3 :: Only",
-            "Programming Language :: Python :: Implementation :: CPython",
-            "Programming Language :: Python :: Implementation :: PyPy",
-            "Topic :: Multimedia :: Graphics",
-            "Topic :: Multimedia :: Graphics :: Capture :: Digital Camera",
-            "Topic :: Multimedia :: Graphics :: Capture :: Screen Capture",
-            "Topic :: Multimedia :: Graphics :: Graphics Conversion",
-            "Topic :: Multimedia :: Graphics :: Viewers",
-        ],
-        python_requires=">=3.6",
         cmdclass={"build_ext": pil_build_ext},
         ext_modules=ext_modules,
         include_package_data=True,
         packages=["PIL"],
         package_dir={"": "src"},
-        keywords=["Imaging"],
         zip_safe=not (debug_build() or PLATFORM_MINGW),
     )
 except RequiredDependencyException as err:
('', 'setup.cfg')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,61 @@
+[metadata]
+name = Pillow
+description = Python Imaging Library (Fork)
+long_description = file: README.md
+long_description_content_type = text/markdown
+url = https://python-pillow.org
+author = Alex Clark (PIL Fork Author)
+author_email = aclark@python-pillow.org
+license = HPND
+classifiers =
+    Development Status :: 6 - Mature
+    License :: OSI Approved :: Historical Permission Notice and Disclaimer (HPND)
+    Programming Language :: Python :: 3
+    Programming Language :: Python :: 3 :: Only
+    Programming Language :: Python :: 3.7
+    Programming Language :: Python :: 3.8
+    Programming Language :: Python :: 3.9
+    Programming Language :: Python :: 3.10
+    Programming Language :: Python :: Implementation :: CPython
+    Programming Language :: Python :: Implementation :: PyPy
+    Topic :: Multimedia :: Graphics
+    Topic :: Multimedia :: Graphics :: Capture :: Digital Camera
+    Topic :: Multimedia :: Graphics :: Capture :: Screen Capture
+    Topic :: Multimedia :: Graphics :: Graphics Conversion
+    Topic :: Multimedia :: Graphics :: Viewers
+keywords = Imaging
+project_urls =
+    Documentation=https://pillow.readthedocs.io
+    Source=https://github.com/python-pillow/Pillow
+    Funding=https://tidelift.com/subscription/pkg/pypi-pillow?utm_source=pypi-pillow&utm_medium=pypi
+    Release notes=https://pillow.readthedocs.io/en/stable/releasenotes/index.html
+    Changelog=https://github.com/python-pillow/Pillow/blob/main/CHANGES.rst
+    Twitter=https://twitter.com/PythonPillow
+
+[options]
+python_requires = >=3.7
+
+[options.extras_require]
+docs =
+    olefile
+    sphinx>=2.4
+    sphinx-copybutton
+    sphinx-issues>=3.0.1
+    sphinx-removed-in
+    sphinx-rtd-theme>=1.0
+    sphinxext-opengraph
+tests =
+    check-manifest
+    coverage
+    defusedxml
+    markdown2
+    olefile
+    packaging
+    pyroma
+    pytest
+    pytest-cov
+    pytest-timeout
+
 [flake8]
 extend-ignore = E203
 max-line-length = 88
('', 'CHANGES.rst')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,673 @@
 Changelog (Pillow)
 ==================

-8.1.0 (2020-01-02)
+9.1.0 (2022-04-01)
+------------------
+
+- Fix loading FriBiDi on Alpine #6165
+  [nulano]
+
+- Added setting for converting GIF P frames to RGB #6150
+  [radarhere]
+
+- Allow 1 mode images to be inverted #6034
+  [radarhere]
+
+- Raise ValueError when trying to save empty JPEG #6159
+  [radarhere]
+
+- Always save TIFF with contiguous planar configuration #5973
+  [radarhere]
+
+- Connected discontiguous polygon corners #5980
+  [radarhere]
+
+- Ensure Tkinter hook is activated for getimage() #6032
+  [radarhere]
+
+- Use screencapture arguments to crop on macOS #6152
+  [radarhere]
+
+- Do not mark L mode JPEG as 1 bit in PDF #6151
+  [radarhere]
+
+- Added support for reading I;16R TIFF images #6132
+  [radarhere]
+
+- If an error occurs after creating a file, remove the file #6134
+  [radarhere]
+
+- Fixed calling DisplayViewer or XVViewer without a title #6136
+  [radarhere]
+
+- Retain RGBA transparency when saving multiple GIF frames #6128
+  [radarhere]
+
+- Save additional ICO frames with other bit depths if supplied #6122
+  [radarhere]
+
+- Handle EXIF data truncated to just the header #6124
+  [radarhere]
+
+- Added support for reading BMP images with RLE8 compression #6102
+  [radarhere]
+
+- Support Python distributions where _tkinter is compiled in #6006
+  [lukegb]
+
+- Added support for PPM arbitrary maxval #6119
+  [radarhere]
+
+- Added BigTIFF reading #6097
+  [radarhere]
+
+- When converting, clip I;16 to be unsigned, not signed #6112
+  [radarhere]
+
+- Fixed loading L mode GIF with transparency #6086
+  [radarhere]
+
+- Improved handling of PPM header #5121
+  [Piolie, radarhere]
+
+- Reset size when seeking away from "Large Thumbnail" MPO frame #6101
+  [radarhere]
+
+- Replace requirements.txt with extras #6072
+  [hugovk, radarhere]
+
+- Added PyEncoder and support BLP saving #6069
+  [radarhere]
+
+- Handle TGA images with packets that cross scan lines #6087
+  [radarhere]
+
+- Added FITS reading #6056
+  [radarhere, hugovk]
+
+- Added rawmode argument to Image.getpalette() #6061
+  [radarhere]
+
+- Fixed BUFR, GRIB and HDF5 stub saving #6071
+  [radarhere]
+
+- Do not automatically remove temporary ImageShow files on Unix #6045
+  [radarhere]
+
+- Correctly read JPEG compressed BLP images #4685
+  [Meithal, radarhere]
+
+- Merged _MODE_CONV typ into ImageMode as typestr #6057
+  [radarhere]
+
+- Consider palette size when converting and in getpalette() #6060
+  [radarhere]
+
+- Added enums #5954
+  [radarhere]
+
+- Ensure image is opaque after converting P to PA with RGB palette #6052
+  [radarhere]
+
+- Attach RGBA palettes from putpalette() when suitable #6054
+  [radarhere]
+
+- Added get_photoshop_blocks() to parse Photoshop TIFF tag #6030
+  [radarhere]
+
+- Drop excess values in BITSPERSAMPLE #6041
+  [mikhail-iurkov]
+
+- Added unpacker from RGBA;15 to RGB #6031
+  [radarhere]
+
+- Enable arm64 for MSVC on Windows #5811
+  [gaborkertesz-linaro, gaborkertesz]
+
+- Keep IPython/Jupyter text/plain output stable #5891
+  [shamrin, radarhere]
+
+- Raise an error when performing a negative crop #5972
+  [radarhere, hugovk]
+
+- Deprecated show_file "file" argument in favour of "path" #5959
+  [radarhere]
+
+- Fixed SPIDER images for use with Bio-formats library #5956
+  [radarhere]
+
+- Ensure duplicated file pointer is closed #5946
+  [radarhere]
+
+- Added specific error if path coordinate type is incorrect #5942
+  [radarhere]
+
+- Return an empty bytestring from tobytes() for an empty image #5938
+  [radarhere]
+
+- Remove readonly from Image.__eq__ #5930
+  [hugovk]
+
+9.0.1 (2022-02-03)
+------------------
+
+- In show_file, use os.remove to remove temporary images. CVE-2022-24303 #6010
+  [radarhere, hugovk]
+
+- Restrict builtins within lambdas for ImageMath.eval. CVE-2022-22817 #6009
+  [radarhere]
+
+9.0.0 (2022-01-02)
+------------------
+
+- Restrict builtins for ImageMath.eval(). CVE-2022-22817 #5923
+  [radarhere]
+
+- Ensure JpegImagePlugin stops at the end of a truncated file #5921
+  [radarhere]
+
+- Fixed ImagePath.Path array handling. CVE-2022-22815, CVE-2022-22816 #5920
+  [radarhere]
+
+- Remove consecutive duplicate tiles that only differ by their offset #5919
+  [radarhere]
+
+- Improved I;16 operations on big endian #5901
+  [radarhere]
+
+- Limit quantized palette to number of colors #5879
+  [radarhere]
+
+- Fixed palette index for zeroed color in FASTOCTREE quantize #5869
+  [radarhere]
+
+- When saving RGBA to GIF, make use of first transparent palette entry #5859
+  [radarhere]
+
+- Pass SAMPLEFORMAT to libtiff #5848
+  [radarhere]
+
+- Added rounding when converting P and PA #5824
+  [radarhere]
+
+- Improved putdata() documentation and data handling #5910
+  [radarhere]
+
+- Exclude carriage return in PDF regex to help prevent ReDoS #5912
+  [hugovk]
+
+- Fixed freeing pointer in ImageDraw.Outline.transform #5909
+  [radarhere]
+
+- Added ImageShow support for xdg-open #5897
+  [m-shinder, radarhere]
+
+- Support 16-bit grayscale ImageQt conversion #5856
+  [cmbruns, radarhere]
+
+- Convert subsequent GIF frames to RGB or RGBA #5857
+  [radarhere]
+
+- Do not prematurely return in ImageFile when saving to stdout #5665
+  [infmagic2047, radarhere]
+
+- Added support for top right and bottom right TGA orientations #5829
+  [radarhere]
+
+- Corrected ICNS file length in header #5845
+  [radarhere]
+
+- Block tile TIFF tags when saving #5839
+  [radarhere]
+
+- Added line width argument to polygon #5694
+  [radarhere]
+
+- Do not redeclare class each time when converting to NumPy #5844
+  [radarhere]
+
+- Only prevent repeated polygon pixels when drawing with transparency #5835
+  [radarhere]
+
+- Add support for pickling TrueType fonts #5826
+  [hugovk, radarhere]
+
+- Only prefer command line tools SDK on macOS over default MacOSX SDK #5828
+  [radarhere]
+
+- Drop support for soon-EOL Python 3.6 #5768
+  [hugovk, nulano, radarhere]
+
+- Fix compilation on 64-bit Termux #5793
+  [landfillbaby]
+
+- Use title for display in ImageShow #5788
+  [radarhere]
+
+- Remove support for FreeType 2.7 and older #5777
+  [hugovk, radarhere]
+
+- Fix for PyQt6 #5775
+  [hugovk, radarhere]
+
+- Removed deprecated PILLOW_VERSION, Image.show command parameter, Image._showxv and ImageFile.raise_ioerror #5776
+  [radarhere]
+
+8.4.0 (2021-10-15)
+------------------
+
+- Prefer global transparency in GIF when replacing with background color #5756
+  [radarhere]
+
+- Added "exif" keyword argument to TIFF saving #5575
+  [radarhere]
+
+- Copy Python palette to new image in quantize() #5696
+  [radarhere]
+
+- Read ICO AND mask from end #5667
+  [radarhere]
+
+- Actually check the framesize in FliDecode.c #5659
+  [wiredfool]
+
+- Determine JPEG2000 mode purely from ihdr header box #5654
+  [radarhere]
+
+- Fixed using info dictionary when writing multiple APNG frames #5611
+  [radarhere]
+
+- Allow saving 1 and L mode TIFF with PhotometricInterpretation 0 #5655
+  [radarhere]
+
+- For GIF save_all with palette, do not include palette with each frame #5603
+  [radarhere]
+
+- Keep transparency when converting from P to LA or PA #5606
+  [radarhere]
+
+- Copy palette to new image in transform() #5647
+  [radarhere]
+
+- Added "transparency" argument to EpsImagePlugin load() #5620
+  [radarhere]
+
+- Corrected pathlib.Path detection when saving #5633
+  [radarhere]
+
+- Added WalImageFile class #5618
+  [radarhere]
+
+- Consider I;16 pixel size when drawing text #5598
+  [radarhere]
+
+- If default conversion from P is RGB with transparency, convert to RGBA #5594
+  [radarhere]
+
+- Speed up rotating square images by 90 or 270 degrees #5646
+  [radarhere]
+
+- Add support for reading DPI information from JPEG2000 images
+  [rogermb, radarhere]
+
+- Catch TypeError from corrupted DPI value in EXIF #5639
+  [homm, radarhere]
+
+- Do not close file pointer when saving SGI images #5645
+  [farizrahman4u, radarhere]
+
+- Deprecate ImagePalette size parameter #5641
+  [radarhere, hugovk]
+
+- Prefer command line tools SDK on macOS #5624
+  [radarhere]
+
+- Added tags when saving YCbCr TIFF #5597
+  [radarhere]
+
+- PSD layer count may be negative #5613
+  [radarhere]
+
+- Fixed ImageOps expand with tuple border on P image #5615
+  [radarhere]
+
+- Fixed error saving APNG with duplicate frames and different duration times #5609
+  [thak1411, radarhere]
+
+8.3.2 (2021-09-02)
+------------------
+
+- CVE-2021-23437 Raise ValueError if color specifier is too long
+  [hugovk, radarhere]
+
+- Fix 6-byte OOB read in FliDecode
+  [wiredfool]
+
+- Add support for Python 3.10 #5569, #5570
+  [hugovk, radarhere]
+
+- Ensure TIFF ``RowsPerStrip`` is multiple of 8 for JPEG compression #5588
+  [kmilos, radarhere]
+
+- Updates for ``ImagePalette`` channel order #5599
+  [radarhere]
+
+- Hide FriBiDi shim symbols to avoid conflict with real FriBiDi library #5651
+  [nulano]
+
+8.3.1 (2021-07-06)
+------------------
+
+- Catch OSError when checking if fp is sys.stdout #5585
+  [radarhere]
+
+- Handle removing orientation from alternate types of EXIF data #5584
+  [radarhere]
+
+- Make Image.__array__ take optional dtype argument #5572
+  [t-vi, radarhere]
+
+8.3.0 (2021-07-01)
+------------------
+
+- Use snprintf instead of sprintf. CVE-2021-34552 #5567
+  [radarhere]
+
+- Limit TIFF strip size when saving with LibTIFF #5514
+  [kmilos]
+
+- Allow ICNS save on all operating systems #4526
+  [baletu, radarhere, newpanjing, hugovk]
+
+- De-zigzag JPEG's DQT when loading; deprecate convert_dict_qtables #4989
+  [gofr, radarhere]
+
+- Replaced xml.etree.ElementTree #5565
+  [radarhere]
+
+- Moved CVE image to pillow-depends #5561
+  [radarhere]
+
+- Added tag data for IFD groups #5554
+  [radarhere]
+
+- Improved ImagePalette #5552
+  [radarhere]
+
+- Add DDS saving #5402
+  [radarhere]
+
+- Improved getxmp() #5455
+  [radarhere]
+
+- Convert to float for comparison with float in IFDRational __eq__ #5412
+  [radarhere]
+
+- Allow getexif() to access TIFF tag_v2 data #5416
+  [radarhere]
+
+- Read FITS image mode and size #5405
+  [radarhere]
+
+- Merge parallel horizontal edges in ImagingDrawPolygon #5347
+  [radarhere, hrdrq]
+
+- Use transparency behind first GIF frame and when disposing to background #5557
+  [radarhere, zewt]
+
+- Avoid unstable nature of qsort in Quant.c #5367
+  [radarhere]
+
+- Copy palette to new images in ImageOps expand #5551
+  [radarhere]
+
+- Ensure palette string matches RGB mode #5549
+  [radarhere]
+
+- Do not modify EXIF of original image instance in exif_transpose() #5547
+  [radarhere]
+
+- Fixed default numresolution for small JPEG2000 images #5540
+  [radarhere]
+
+- Added DDS BC5 reading #5501
+  [radarhere]
+
+- Raise an error if ImageDraw.textbbox is used without a TrueType font #5510
+  [radarhere]
+
+- Added ICO saving in BMP format #5513
+  [radarhere]
+
+- Ensure PNG seeks to end of previous chunk at start of load_end #5493
+  [radarhere]
+
+- Do not allow TIFF to seek to a past frame #5473
+  [radarhere]
+
+- Avoid race condition when displaying images with eog #5507
+  [mconst]
+
+- Added specific error messages when ink has incorrect number of bands #5504
+  [radarhere]
+
+- Allow converting an image to a numpy array to raise errors #5379
+  [radarhere]
+
+- Removed DPI rounding from BMP, JPEG, PNG and WMF loading #5476, #5470
+  [radarhere]
+
+- Remove spikes when drawing thin pieslices #5460
+  [xtsm]
+
+- Updated default value for SAMPLESPERPIXEL TIFF tag #5452
+  [radarhere]
+
+- Removed TIFF DPI rounding #5446
+  [radarhere, hugovk]
+
+- Include code in WebP error #5471
+  [radarhere]
+
+- Do not alter pixels outside mask when drawing text on an image with transparency #5434
+  [radarhere]
+
+- Reset handle when seeking backwards in TIFF #5443
+  [radarhere]
+
+- Replace sys.stdout with sys.stdout.buffer when saving #5437
+  [radarhere]
+
+- Fixed UNDEFINED TIFF tag of length 0 being changed in roundtrip #5426
+  [radarhere]
+
+- Fixed bug when checking FreeType2 version if it is not installed #5445
+  [radarhere]
+
+- Do not round dimensions when saving PDF #5459
+  [radarhere]
+
+- Added ImageOps contain() #5417
+  [radarhere, hugovk]
+
+- Changed WebP default "method" value to 4 #5450
+  [radarhere]
+
+- Switched to saving 1-bit PDFs with DCTDecode #5430
+  [radarhere]
+
+- Use bpp from ICO header #5429
+  [radarhere]
+
+- Corrected JPEG APP14 transform value #5408
+  [radarhere]
+
+- Changed TIFF tag 33723 length to 1 #5425
+  [radarhere]
+
+- Changed ImageMorph incorrect mode errors to ValueError #5414
+  [radarhere]
+
+- Add EXIF tags specified in EXIF 2.32 #5419
+  [gladiusglad]
+
+- Treat previous contents of first GIF frame as transparent #5391
+  [radarhere]
+
+- For special image modes, revert default resize resampling to NEAREST #5411
+  [radarhere]
+
+- JPEG2000: Support decoding subsampled RGB and YCbCr images #4996
+  [nulano, radarhere]
+
+- Stop decoding BC1 punchthrough alpha in BC2&3 #4144
+  [jansol]
+
+- Use zero if GIF background color index is missing #5390
+  [radarhere]
+
+- Fixed ensuring that GIF previous frame was loaded #5386
+  [radarhere]
+
+- Valgrind fixes #5397
+  [wiredfool]
+
+- Round down the radius in rounded_rectangle #5382
+  [radarhere]
+
+- Fixed reading uncompressed RGB data from DDS #5383
+  [radarhere]
+
+8.2.0 (2021-04-01)
+------------------
+
+- Added getxmp() method #5144
+  [UrielMaD, radarhere]
+
+- Add ImageShow support for GraphicsMagick #5349
+  [latosha-maltba, radarhere]
+
+- Do not load transparent pixels from subsequent GIF frames #5333
+  [zewt, radarhere]
+
+- Use LZW encoding when saving GIF images #5291
+  [raygard]
+
+- Set all transparent colors to be equal in quantize() #5282
+  [radarhere]
+
+- Allow PixelAccess to use Python __int__ when parsing x and y #5206
+  [radarhere]
+
+- Removed Image._MODEINFO #5316
+  [radarhere]
+
+- Add preserve_tone option to autocontrast #5350
+  [elejke, radarhere]
+
+- Fixed linear_gradient and radial_gradient I and F modes #5274
+  [radarhere]
+
+- Add support for reading TIFFs with PlanarConfiguration=2 #5364
+  [kkopachev, wiredfool, nulano]
+
+- Deprecated categories #5351
+  [radarhere]
+
+- Do not premultiply alpha when resizing with Image.NEAREST resampling #5304
+  [nulano]
+
+- Dynamically link FriBiDi instead of Raqm #5062
+  [nulano]
+
+- Allow fewer PNG palette entries than the bit depth maximum when saving #5330
+  [radarhere]
+
+- Use duration from info dictionary when saving WebP #5338
+  [radarhere]
+
+- Stop flattening EXIF IFD into getexif() #4947
+  [radarhere, kkopachev]
+
+- Replaced tiff_deflate with tiff_adobe_deflate compression when saving TIFF images #5343
+  [radarhere]
+
+- Save ICC profile from TIFF encoderinfo #5321
+  [radarhere]
+
+- Moved RGB fix inside ImageQt class #5268
+  [radarhere]
+
+- Allow alpha_composite destination to be negative #5313
+  [radarhere]
+
+- Ensure file is closed if it is opened by ImageQt.ImageQt #5260
+  [radarhere]
+
+- Added ImageDraw rounded_rectangle method #5208
+  [radarhere]
+
+- Added IPythonViewer #5289
+  [radarhere, Kipkurui-mutai]
+
+- Only draw each rectangle outline pixel once #5183
+  [radarhere]
+
+- Use mmap instead of built-in Win32 mapper #5224
+  [radarhere, cgohlke]
+
+- Handle PCX images with an odd stride #5214
+  [radarhere]
+
+- Only read different sizes for "Large Thumbnail" MPO frames #5168
+  [radarhere]
+
+- Added PyQt6 support #5258
+  [radarhere]
+
+- Changed Image.open formats parameter to be case-insensitive #5250
+  [Piolie, radarhere]
+
+- Deprecate Tk/Tcl 8.4, to be removed in Pillow 10 (2023-07-01) #5216
+  [radarhere]
+
+- Added tk version to pilinfo #5226
+  [radarhere, nulano]
+
+- Support for ignoring tests when running valgrind #5150
+  [wiredfool, radarhere, hugovk]
+
+- OSS-Fuzz support #5189
+  [wiredfool, radarhere]
+
+8.1.2 (2021-03-06)
+------------------
+
+- Fix Memory DOS in BLP (CVE-2021-27921), ICNS (CVE-2021-27922) and ICO (CVE-2021-27923) Image Plugins
+  [wiredfool]
+
+8.1.1 (2021-03-01)
+------------------
+
+- Use more specific regex chars to prevent ReDoS. CVE-2021-25292
+  [hugovk]
+
+- Fix OOB Read in TiffDecode.c, and check the tile validity before reading. CVE-2021-25291
+  [wiredfool]
+
+- Fix negative size read in TiffDecode.c. CVE-2021-25290
+  [wiredfool]
+
+- Fix OOB read in SgiRleDecode.c. CVE-2021-25293
+  [wiredfool]
+
+- Incorrect error code checking in TiffDecode.c. CVE-2021-25289
+  [wiredfool]
+
+- PyModule_AddObject fix for Python 3.10 #5194
+  [radarhere]
+
+8.1.0 (2021-01-02)
 ------------------

 - Fix TIFF OOB Write error. CVE-2020-35654 #5175
('.ci', 'after_success.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,7 +1,7 @@
 #!/bin/bash

 # gather the coverage data
-pip3 install codecov
+python3 -m pip install codecov
 if [[ $MATRIX_DOCKER ]]; then
   coverage xml --ignore-errors
 else
('.ci', 'install.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,26 +19,23 @@

 sudo apt-get -qq install libfreetype6-dev liblcms2-dev python3-tk\
                          ghostscript libffi-dev libjpeg-turbo-progs libopenjp2-7-dev\
-                         cmake imagemagick libharfbuzz-dev libfribidi-dev
+                         cmake meson imagemagick libharfbuzz-dev libfribidi-dev

 python3 -m pip install --upgrade pip
+python3 -m pip install --upgrade wheel
 PYTHONOPTIMIZE=0 python3 -m pip install cffi
 python3 -m pip install coverage
+python3 -m pip install defusedxml
 python3 -m pip install olefile
 python3 -m pip install -U pytest
 python3 -m pip install -U pytest-cov
+python3 -m pip install -U pytest-timeout
 python3 -m pip install pyroma
 python3 -m pip install test-image-results
-# TODO Remove condition when numpy supports 3.10
-if ! [ "$GHA_PYTHON_VERSION" == "3.10-dev" ]; then python3 -m pip install numpy ; fi
-
-# TODO Remove when 3.8 / 3.9 includes setuptools 49.3.2+:
-if [ "$GHA_PYTHON_VERSION" == "3.8" ]; then python3 -m pip install -U "setuptools>=49.3.2" ; fi
-if [ "$GHA_PYTHON_VERSION" == "3.9" ]; then python3 -m pip install -U "setuptools>=49.3.2" ; fi
+python3 -m pip install numpy

 # PyQt5 doesn't support PyPy3
-# Wheel doesn't yet support 3.10
-if [[ $GHA_PYTHON_VERSION == 3.* && $GHA_PYTHON_VERSION != "3.10-dev" ]]; then
+if [[ $GHA_PYTHON_VERSION == 3.* ]]; then
   # arm64, ppc64le, s390x CPUs:
   # "ERROR: Could not find a version that satisfies the requirement pyqt5"
     sudo apt-get -qq install libxcb-xinerama0 pyqt5-dev-tools
('.ci', 'test.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,4 +2,6 @@

 set -e

-python -bb -m pytest -v -x -W always --cov PIL --cov Tests --cov-report term Tests
+python3 -c "from PIL import Image"
+
+python3 -bb -m pytest -v -x -W always --cov PIL --cov Tests --cov-report term Tests $REVERSE
('winbuild', 'build.rst')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,7 +24,7 @@
 * `CMake 3.12 or newer <https://cmake.org/download/>`_
   (also available as Visual Studio component C++ CMake tools for Windows)

-* `NASM <https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=D>`_
+* x86/x64: `NASM <https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=D>`_

 Any version of Visual Studio 2017 or newer should be supported,
 including Visual Studio 2017 Community, or Build Tools for Visual Studio 2019.
@@ -42,8 +42,8 @@
   If ``PYTHON`` is unset, the version of Python used to run
   ``build_prepare.py`` will be used. If only ``PYTHON`` is set,
   ``EXECUTABLE`` defaults to ``python.exe``.
-* ``ARCHITECTURE`` is used to select a ``x86`` or ``x64`` build. By default,
-  uses same architecture as the version of Python used to run ``build_prepare.py``.
+* ``ARCHITECTURE`` is used to select a ``x86``, ``x64`` or ``ARM64``build.
+  By default, uses same architecture as the version of Python used to run ``build_prepare.py``.
   is used.
 * ``PILLOW_BUILD`` can be used to override the ``winbuild\build`` directory
   path, used to store generated build scripts and compiled libraries.
@@ -55,8 +55,8 @@

 * ``-v`` will print generated scripts.
 * ``--no-imagequant`` will skip GPL-licensed ``libimagequant`` optional dependency
-* ``--no-raqm`` will skip optional dependency Raqm (which itself depends on
-  LGPL-licensed ``fribidi``).
+* ``--no-fribidi`` or ``--no-raqm`` will skip optional LGPL-licensed dependency FriBiDi
+  (required for Raqm text shaping).
 * ``--python=<path>`` and ``--executable=<exe>`` override ``PYTHON`` and ``EXECUTABLE``.
 * ``--architecture=<arch>`` overrides ``ARCHITECTURE``.
 * ``--dir=<path>`` and ``--depends=<path>`` override ``PILLOW_BUILD``
@@ -87,7 +87,7 @@
 Testing Pillow
 --------------

-Some binary dependencies (e.g. ``libraqm.dll``) will be stored in the
+Some binary dependencies (e.g. ``fribidi.dll``) will be stored in the
 ``winbuild\build\bin`` directory; this directory should be added to ``PATH``
 before running tests.

('winbuild', 'fribidi.cmake')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -93,10 +93,10 @@
 file(GLOB FRIBIDI_SOURCES lib/*.c)
 file(GLOB FRIBIDI_HEADERS lib/*.h)

-add_library(fribidi STATIC
+add_library(fribidi SHARED
 	${FRIBIDI_SOURCES}
 	${FRIBIDI_HEADERS}
 	${FRIBIDI_SOURCES_GENERATED})
 fribidi_definitions(fribidi)
 target_compile_definitions(fribidi
-	PUBLIC -DFRIBIDI_LIB_STATIC)
+	PUBLIC "-DFRIBIDI_BUILD")
('winbuild', 'build_prepare.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,5 @@
 import os
+import platform
 import shutil
 import struct
 import subprocess
@@ -88,11 +89,12 @@
     )


-SF_MIRROR = "http://iweb.dl.sourceforge.net"
+SF_MIRROR = "https://iweb.dl.sourceforge.net"

 architectures = {
     "x86": {"vcvars_arch": "x86", "msbuild_arch": "Win32"},
     "x64": {"vcvars_arch": "x86_amd64", "msbuild_arch": "x64"},
+    "ARM64": {"vcvars_arch": "x86_arm64", "msbuild_arch": "ARM64"},
 }

 header = [
@@ -105,9 +107,9 @@
 # dependencies, listed in order of compilation
 deps = {
     "libjpeg": {
-        "url": SF_MIRROR + "/project/libjpeg-turbo/2.0.6/libjpeg-turbo-2.0.6.tar.gz",
-        "filename": "libjpeg-turbo-2.0.6.tar.gz",
-        "dir": "libjpeg-turbo-2.0.6",
+        "url": SF_MIRROR + "/project/libjpeg-turbo/2.1.3/libjpeg-turbo-2.1.3.tar.gz",
+        "filename": "libjpeg-turbo-2.1.3.tar.gz",
+        "dir": "libjpeg-turbo-2.1.3",
         "build": [
             cmd_cmake(
                 [
@@ -129,9 +131,9 @@
         "bins": ["cjpeg.exe", "djpeg.exe"],
     },
     "zlib": {
-        "url": "http://zlib.net/zlib1211.zip",
-        "filename": "zlib1211.zip",
-        "dir": "zlib-1.2.11",
+        "url": "https://zlib.net/zlib1212.zip",
+        "filename": "zlib1212.zip",
+        "dir": "zlib-1.2.12",
         "build": [
             cmd_nmake(r"win32\Makefile.msc", "clean"),
             cmd_nmake(r"win32\Makefile.msc", "zlib.lib"),
@@ -141,22 +143,22 @@
         "libs": [r"*.lib"],
     },
     "libtiff": {
-        "url": "https://download.osgeo.org/libtiff/tiff-4.2.0.tar.gz",
-        "filename": "tiff-4.2.0.tar.gz",
-        "dir": "tiff-4.2.0",
-        "build": [
-            cmd_copy(r"{winbuild_dir}\tiff.opt", "nmake.opt"),
-            cmd_nmake("makefile.vc", "clean"),
-            cmd_nmake("makefile.vc", "lib"),
+        "url": "https://download.osgeo.org/libtiff/tiff-4.3.0.tar.gz",
+        "filename": "tiff-4.3.0.tar.gz",
+        "dir": "tiff-4.3.0",
+        "build": [
+            cmd_cmake("-DBUILD_SHARED_LIBS:BOOL=OFF"),
+            cmd_nmake(target="clean"),
+            cmd_nmake(target="tiff"),
         ],
         "headers": [r"libtiff\tiff*.h"],
         "libs": [r"libtiff\*.lib"],
         # "bins": [r"libtiff\*.dll"],
     },
     "libwebp": {
-        "url": "http://downloads.webmproject.org/releases/webp/libwebp-1.1.0.tar.gz",
-        "filename": "libwebp-1.1.0.tar.gz",
-        "dir": "libwebp-1.1.0",
+        "url": "http://downloads.webmproject.org/releases/webp/libwebp-1.2.2.tar.gz",
+        "filename": "libwebp-1.2.2.tar.gz",
+        "dir": "libwebp-1.2.2",
         "build": [
             cmd_rmdir(r"output\release-static"),  # clean
             cmd_nmake(
@@ -184,9 +186,9 @@
         "libs": [r"libpng16.lib"],
     },
     "freetype": {
-        "url": "https://download.savannah.gnu.org/releases/freetype/freetype-2.10.4.tar.gz",  # noqa: E501
-        "filename": "freetype-2.10.4.tar.gz",
-        "dir": "freetype-2.10.4",
+        "url": "https://download.savannah.gnu.org/releases/freetype/freetype-2.12.0.tar.gz",  # noqa: E501
+        "filename": "freetype-2.12.0.tar.gz",
+        "dir": "freetype-2.12.0",
         "patch": {
             r"builds\windows\vc2010\freetype.vcxproj": {
                 # freetype setting is /MD for .dll and /MT for .lib, we need /MD
@@ -219,24 +221,26 @@
         # "bins": [r"objs\{msbuild_arch}\Release\freetype.dll"],
     },
     "lcms2": {
-        "url": SF_MIRROR + "/project/lcms/lcms/2.11/lcms2-2.11.tar.gz",
-        "filename": "lcms2-2.11.tar.gz",
-        "dir": "lcms2-2.11",
+        "url": SF_MIRROR + "/project/lcms/lcms/2.13/lcms2-2.13.1.tar.gz",
+        "filename": "lcms2-2.13.1.tar.gz",
+        "dir": "lcms2-2.13.1",
         "patch": {
-            r"Projects\VC2017\lcms2_static\lcms2_static.vcxproj": {
+            r"Projects\VC2019\lcms2_static\lcms2_static.vcxproj": {
                 # default is /MD for x86 and /MT for x64, we need /MD always
                 "<RuntimeLibrary>MultiThreaded</RuntimeLibrary>": "<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>",  # noqa: E501
                 # retarget to default toolset (selected by vcvarsall.bat)
-                "<PlatformToolset>v141</PlatformToolset>": "<PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>",  # noqa: E501
+                "<PlatformToolset>v142</PlatformToolset>": "<PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>",  # noqa: E501
                 # retarget to latest (selected by vcvarsall.bat)
-                "<WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>": "<WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>",  # noqa: E501
+                "<WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>": "<WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>",  # noqa: E501
             }
         },
         "build": [
             cmd_rmdir("Lib"),
-            cmd_rmdir(r"Projects\VC2017\Release"),
-            cmd_msbuild(r"Projects\VC2017\lcms2.sln", "Release", "Clean"),
-            cmd_msbuild(r"Projects\VC2017\lcms2.sln", "Release", "lcms2_static"),
+            cmd_rmdir(r"Projects\VC2019\Release"),
+            cmd_msbuild(r"Projects\VC2019\lcms2.sln", "Release", "Clean"),
+            cmd_msbuild(
+                r"Projects\VC2019\lcms2.sln", "Release", "lcms2_static:Rebuild"
+            ),
             cmd_xcopy("include", "{inc_dir}"),
         ],
         "libs": [r"Lib\MS\*.lib"],
@@ -255,29 +259,30 @@
         "libs": [r"bin\*.lib"],
     },
     "libimagequant": {
-        # e5d454b: Merge tag '2.12.6' into msvc
-        "url": "https://github.com/ImageOptim/libimagequant/archive/e5d454bc7f5eb63ee50c84a83a7fa5ac94f68ec4.zip",  # noqa: E501
-        "filename": "libimagequant-e5d454bc7f5eb63ee50c84a83a7fa5ac94f68ec4.zip",
-        "dir": "libimagequant-e5d454bc7f5eb63ee50c84a83a7fa5ac94f68ec4",
+        # commit: Merge branch 'master' into msvc (matches 2.17.0 tag)
+        "url": "https://github.com/ImageOptim/libimagequant/archive/e4c1334be0eff290af5e2b4155057c2953a313ab.zip",  # noqa: E501
+        "filename": "libimagequant-e4c1334be0eff290af5e2b4155057c2953a313ab.zip",
+        "dir": "libimagequant-e4c1334be0eff290af5e2b4155057c2953a313ab",
         "patch": {
             "CMakeLists.txt": {
-                "add_library": "add_compile_options(-openmp-)\r\nadd_library",
-                " SHARED": " STATIC",
+                "if(OPENMP_FOUND)": "if(false)",
+                "install": "#install",
             }
         },
         "build": [
             # lint: do not inline
             cmd_cmake(),
             cmd_nmake(target="clean"),
-            cmd_nmake(),
+            cmd_nmake(target="imagequant_a"),
+            cmd_copy("imagequant_a.lib", "imagequant.lib"),
         ],
         "headers": [r"*.h"],
-        "libs": [r"*.lib"],
+        "libs": [r"imagequant.lib"],
     },
     "harfbuzz": {
-        "url": "https://github.com/harfbuzz/harfbuzz/archive/2.7.4.zip",
-        "filename": "harfbuzz-2.7.4.zip",
-        "dir": "harfbuzz-2.7.4",
+        "url": "https://github.com/harfbuzz/harfbuzz/archive/4.2.0.zip",
+        "filename": "harfbuzz-4.2.0.zip",
+        "dir": "harfbuzz-4.2.0",
         "build": [
             cmd_cmake("-DHB_HAVE_FREETYPE:BOOL=TRUE"),
             cmd_nmake(target="clean"),
@@ -287,30 +292,16 @@
         "libs": [r"*.lib"],
     },
     "fribidi": {
-        "url": "https://github.com/fribidi/fribidi/archive/v1.0.10.zip",
-        "filename": "fribidi-1.0.10.zip",
-        "dir": "fribidi-1.0.10",
+        "url": "https://github.com/fribidi/fribidi/archive/v1.0.11.zip",
+        "filename": "fribidi-1.0.11.zip",
+        "dir": "fribidi-1.0.11",
         "build": [
             cmd_copy(r"{winbuild_dir}\fribidi.cmake", r"CMakeLists.txt"),
             cmd_cmake(),
             cmd_nmake(target="clean"),
             cmd_nmake(target="fribidi"),
         ],
-        "headers": [r"lib\*.h"],
-        "libs": [r"*.lib"],
-    },
-    "libraqm": {
-        "url": "https://github.com/HOST-Oman/libraqm/archive/v0.7.1.zip",
-        "filename": "libraqm-0.7.1.zip",
-        "dir": "libraqm-0.7.1",
-        "build": [
-            cmd_copy(r"{winbuild_dir}\raqm.cmake", r"CMakeLists.txt"),
-            cmd_cmake(),
-            cmd_nmake(target="clean"),
-            cmd_nmake(target="libraqm"),
-        ],
-        "headers": [r"src\*.h"],
-        "bins": [r"libraqm.dll"],
+        "bins": [r"*.dll"],
     },
 }

@@ -449,6 +440,7 @@
             assert patch_from in text
             text = text.replace(patch_from, patch_to)
         with open(patch_file, "w") as f:
+            print(f"Patching {patch_file}")
             f.write(text)

     banner = f"Building {name} ({dir})"
@@ -472,7 +464,7 @@
         if dep_name in disabled:
             continue
         script = build_dep(dep_name)
-        lines.append(fr'cmd.exe /c "{{build_dir}}\{script}"')
+        lines.append(rf'cmd.exe /c "{{build_dir}}\{script}"')
         lines.append("if errorlevel 1 echo Build failed! && exit /B 1")
     lines.append("@echo All Pillow dependencies built successfully!")
     write_script("build_dep_all.cmd", lines)
@@ -484,9 +476,7 @@
         cmd_cd("{pillow_dir}"),
         *prefs["header"],
         cmd_set("DISTUTILS_USE_SDK", "1"),  # use same compiler to build Pillow
-        cmd_set("MSSdk", "1"),  # for PyPy3.6
-        cmd_set("py_vcruntime_redist", "true"),  # use /MD, not /MT
-        r'"{python_dir}\{python_exe}" setup.py build_ext %*',
+        r'"{python_dir}\{python_exe}" setup.py build_ext --vendor-raqm --vendor-fribidi %*',  # noqa: E501
     ]

     write_script("build_pillow.cmd", lines)
@@ -502,7 +492,10 @@
     python_dir = os.environ.get("PYTHON")
     python_exe = os.environ.get("EXECUTABLE", "python.exe")
     architecture = os.environ.get(
-        "ARCHITECTURE", "x86" if struct.calcsize("P") == 4 else "x64"
+        "ARCHITECTURE",
+        "ARM64"
+        if platform.machine() == "ARM64"
+        else ("x86" if struct.calcsize("P") == 4 else "x64"),
     )
     build_dir = os.environ.get("PILLOW_BUILD", os.path.join(winbuild_dir, "build"))
     sources_dir = ""
@@ -511,8 +504,8 @@
             verbose = True
         elif arg == "--no-imagequant":
             disabled += ["libimagequant"]
-        elif arg == "--no-raqm":
-            disabled += ["fribidi", "libraqm"]
+        elif arg == "--no-raqm" or arg == "--no-fribidi":
+            disabled += ["fribidi"]
         elif arg.startswith("--depends="):
             depends_dir = arg[10:]
         elif arg.startswith("--python="):
('Tests', 'test_imagecms.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -8,7 +8,13 @@

 from PIL import Image, ImageMode, features

-from .helper import assert_image, assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image,
+    assert_image_equal,
+    assert_image_similar,
+    assert_image_similar_tofile,
+    hopper,
+)

 try:
     from PIL import ImageCms
@@ -134,7 +140,7 @@
     skip_missing()
     assert ImageCms.getDefaultIntent(SRGB) == 0
     support = ImageCms.isIntentSupported(
-        SRGB, ImageCms.INTENT_ABSOLUTE_COLORIMETRIC, ImageCms.DIRECTION_INPUT
+        SRGB, ImageCms.Intent.ABSOLUTE_COLORIMETRIC, ImageCms.Direction.INPUT
     )
     assert support == 1

@@ -147,7 +153,7 @@
     #     ["sRGB built-in", "", "WhitePoint : D65 (daylight)", "", ""]
     assert ImageCms.getDefaultIntent(p) == 0
     support = ImageCms.isIntentSupported(
-        p, ImageCms.INTENT_ABSOLUTE_COLORIMETRIC, ImageCms.DIRECTION_INPUT
+        p, ImageCms.Intent.ABSOLUTE_COLORIMETRIC, ImageCms.Direction.INPUT
     )
     assert support == 1

@@ -240,8 +246,7 @@

     # i.save('temp.lab.tif')  # visually verified vs PS.

-    with Image.open("Tests/images/hopper.Lab.tif") as target:
-        assert_image_similar(i, target, 3.5)
+    assert_image_similar_tofile(i, "Tests/images/hopper.Lab.tif", 3.5)


 def test_lab_srgb():
@@ -298,7 +303,7 @@
     def assert_truncated_tuple_equal(tup1, tup2, digits=10):
         # Helper function to reduce precision of tuples of floats
         # recursively and then check equality.
-        power = 10 ** digits
+        power = 10**digits

         def truncate_tuple(tuple_or_float):
             return tuple(
@@ -588,3 +593,13 @@
                 )

                 assert_image_equal(test_image.convert(dst_format[2]), reference_image)
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        ImageCms.Intent: "INTENT_",
+        ImageCms.Direction: "DIRECTION_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(ImageCms, prefix + name) == enum[name]
('Tests', 'test_qt_image_toqimage.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,8 @@
 import pytest

-from PIL import Image, ImageQt
+from PIL import ImageQt

-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper

 pytestmark = pytest.mark.skipif(
     not ImageQt.qt_is_installed, reason="Qt bindings are not installed"
@@ -40,5 +40,4 @@
         data.save(tempfile)

         # Check that it actually worked.
-        with Image.open(tempfile) as reloaded:
-            assert_image_equal(reloaded, src)
+        assert_image_equal_tofile(src, tempfile)
('Tests', 'check_large_memory.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,7 +23,7 @@
 XDIM = 48000


-pytestmark = pytest.mark.skipif(sys.maxsize <= 2 ** 32, reason="requires 64-bit system")
+pytestmark = pytest.mark.skipif(sys.maxsize <= 2**32, reason="requires 64-bit system")


 def _write_png(tmp_path, xdim, ydim):
@@ -33,7 +33,7 @@


 def test_large(tmp_path):
-    """ succeeded prepatch"""
+    """succeeded prepatch"""
     _write_png(tmp_path, XDIM, YDIM)


('Tests', 'test_tiff_ifdrational.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -27,6 +27,8 @@

     _test_equal(1, 2, Fraction(1, 2))
     _test_equal(1, 2, IFDRational(1, 2))
+
+    _test_equal(7, 5, 1.4)


 def test_ranges():
('Tests', 'test_image_paste.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -45,7 +45,7 @@

     @cached_property
     def mask_L(self):
-        return self.gradient_L.transpose(Image.ROTATE_270)
+        return self.gradient_L.transpose(Image.Transpose.ROTATE_270)

     @cached_property
     def gradient_L(self):
@@ -62,8 +62,18 @@
             "RGB",
             [
                 self.gradient_L,
-                self.gradient_L.transpose(Image.ROTATE_90),
-                self.gradient_L.transpose(Image.ROTATE_180),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_90),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_180),
+            ],
+        )
+
+    @cached_property
+    def gradient_LA(self):
+        return Image.merge(
+            "LA",
+            [
+                self.gradient_L,
+                self.gradient_L.transpose(Image.Transpose.ROTATE_90),
             ],
         )

@@ -73,9 +83,9 @@
             "RGBA",
             [
                 self.gradient_L,
-                self.gradient_L.transpose(Image.ROTATE_90),
-                self.gradient_L.transpose(Image.ROTATE_180),
-                self.gradient_L.transpose(Image.ROTATE_270),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_90),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_180),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_270),
             ],
         )

@@ -85,9 +95,9 @@
             "RGBa",
             [
                 self.gradient_L,
-                self.gradient_L.transpose(Image.ROTATE_90),
-                self.gradient_L.transpose(Image.ROTATE_180),
-                self.gradient_L.transpose(Image.ROTATE_270),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_90),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_180),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_270),
             ],
         )

@@ -141,6 +151,28 @@
                     (239, 239, 207, 207),
                     (128, 1, 128, 254),
                     (207, 113, 112, 207),
+                    (255, 191, 128, 191),
+                ],
+            )
+
+    def test_image_mask_LA(self):
+        for mode in ("RGBA", "RGB", "L"):
+            im = Image.new(mode, (200, 200), "white")
+            im2 = getattr(self, "gradient_" + mode)
+
+            self.assert_9points_paste(
+                im,
+                im2,
+                self.gradient_LA,
+                [
+                    (128, 191, 255, 191),
+                    (112, 207, 206, 111),
+                    (128, 254, 128, 1),
+                    (208, 208, 239, 239),
+                    (192, 191, 191, 191),
+                    (207, 207, 112, 113),
+                    (255, 255, 255, 255),
+                    (239, 207, 207, 239),
                     (255, 191, 128, 191),
                 ],
             )
@@ -236,7 +268,7 @@
                 [
                     (127, 191, 254, 191),
                     (111, 207, 206, 110),
-                    (255, 255, 255, 0) if mode == "RGBA" else (127, 254, 127, 0),
+                    (127, 254, 127, 0),
                     (207, 207, 239, 239),
                     (191, 191, 190, 191),
                     (207, 206, 111, 112),
('Tests', 'test_file_msp.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,7 @@

 from PIL import Image, MspImagePlugin

-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper

 TEST_FILE = "Tests/images/hopper.msp"
 EXTRA_DIR = "Tests/images/picins"
@@ -52,8 +52,7 @@

 def _assert_file_image_equal(source_path, target_path):
     with Image.open(source_path) as im:
-        with Image.open(target_path) as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, target_path)


 @pytest.mark.skipif(
('Tests', 'test_image_array.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,31 +4,44 @@

 from .helper import hopper

+numpy = pytest.importorskip("numpy", reason="NumPy not installed")
+
 im = hopper().resize((128, 100))


 def test_toarray():
     def test(mode):
-        ai = im.convert(mode).__array_interface__
-        return ai["version"], ai["shape"], ai["typestr"], len(ai["data"])
+        ai = numpy.array(im.convert(mode))
+        return ai.shape, ai.dtype.str, ai.nbytes

-    # assert test("1") == (3, (100, 128), '|b1', 1600))
-    assert test("L") == (3, (100, 128), "|u1", 12800)
+    def test_with_dtype(dtype):
+        ai = numpy.array(im, dtype=dtype)
+        assert ai.dtype == dtype
+
+    # assert test("1") == ((100, 128), '|b1', 1600))
+    assert test("L") == ((100, 128), "|u1", 12800)

     # FIXME: wrong?
-    assert test("I") == (3, (100, 128), Image._ENDIAN + "i4", 51200)
+    assert test("I") == ((100, 128), Image._ENDIAN + "i4", 51200)
     # FIXME: wrong?
-    assert test("F") == (3, (100, 128), Image._ENDIAN + "f4", 51200)
+    assert test("F") == ((100, 128), Image._ENDIAN + "f4", 51200)

-    assert test("LA") == (3, (100, 128, 2), "|u1", 25600)
-    assert test("RGB") == (3, (100, 128, 3), "|u1", 38400)
-    assert test("RGBA") == (3, (100, 128, 4), "|u1", 51200)
-    assert test("RGBX") == (3, (100, 128, 4), "|u1", 51200)
+    assert test("LA") == ((100, 128, 2), "|u1", 25600)
+    assert test("RGB") == ((100, 128, 3), "|u1", 38400)
+    assert test("RGBA") == ((100, 128, 4), "|u1", 51200)
+    assert test("RGBX") == ((100, 128, 4), "|u1", 51200)
+
+    test_with_dtype(numpy.float64)
+    test_with_dtype(numpy.uint8)
+
+    with Image.open("Tests/images/truncated_jpeg.jpg") as im_truncated:
+        with pytest.raises(OSError):
+            numpy.array(im_truncated)


 def test_fromarray():
     class Wrapper:
-        """ Class with API matching Image.fromarray """
+        """Class with API matching Image.fromarray"""

         def __init__(self, img, arr_params):
             self.img = img
@@ -39,10 +52,18 @@

     def test(mode):
         i = im.convert(mode)
-        a = i.__array_interface__
-        a["strides"] = 1  # pretend it's non-contiguous
+        a = numpy.array(i)
         # Make wrapper instance for image, new array interface
-        wrapped = Wrapper(i, a)
+        wrapped = Wrapper(
+            i,
+            {
+                "shape": a.shape,
+                "typestr": a.dtype.str,
+                "version": 3,
+                "data": a.data,
+                "strides": 1,  # pretend it's non-contiguous
+            },
+        )
         out = Image.fromarray(wrapped)
         return out.mode, out.size, list(i.getdata()) == list(out.getdata())

('Tests', 'test_file_xbm.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@

 import pytest

-from PIL import Image
+from PIL import Image, XbmImagePlugin

 from .helper import hopper

@@ -63,6 +63,13 @@
         assert im.size == (128, 128)


+def test_invalid_file():
+    invalid_file = "Tests/images/flower.jpg"
+
+    with pytest.raises(SyntaxError):
+        XbmImagePlugin.XbmImageFile(invalid_file)
+
+
 def test_save_wrong_mode(tmp_path):
     im = hopper()
     out = str(tmp_path / "temp.xbm")
('Tests', 'conftest.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -10,3 +10,22 @@
             return out.getvalue()
     except Exception as e:
         return f"pytest_report_header failed: {e}"
+
+
+def pytest_configure(config):
+    config.addinivalue_line(
+        "markers",
+        "pil_noop_mark: A conditional mark where nothing special happens",
+    )
+
+    # We're marking some tests to ignore valgrind errors and XFAIL them.
+    # Ensure that the mark is defined
+    # even in cases where pytest-valgrind isn't installed
+    try:
+        config.addinivalue_line(
+            "markers",
+            "valgrind_known_error: Tests that have known issues with valgrind",
+        )
+    except Exception:
+        # valgrind is already installed
+        pass
('Tests', 'test_font_pcf.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,11 @@

 from PIL import FontFile, Image, ImageDraw, ImageFont, PcfFontFile

-from .helper import assert_image_equal, assert_image_similar, skip_unless_feature
+from .helper import (
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
+    skip_unless_feature,
+)

 fontname = "Tests/fonts/10x20-ISO8859-1.pcf"

@@ -33,8 +37,7 @@
     font.save(tempname)

     with Image.open(tempname.replace(".pil", ".pbm")) as loaded:
-        with Image.open("Tests/fonts/10x20.pbm") as target:
-            assert_image_equal(loaded, target)
+        assert_image_equal_tofile(loaded, "Tests/fonts/10x20.pbm")

     with open(tempname, "rb") as f_loaded:
         with open("Tests/fonts/10x20.pil", "rb") as f_target:
@@ -58,8 +61,7 @@
     im = Image.new("L", (130, 30), "white")
     draw = ImageDraw.Draw(im)
     draw.text((0, 0), message, "black", font=font)
-    with Image.open("Tests/images/test_draw_pbm_target.png") as target:
-        assert_image_similar(im, target, 0)
+    assert_image_similar_tofile(im, "Tests/images/test_draw_pbm_target.png", 0)


 def test_textsize(request, tmp_path):
@@ -80,8 +82,7 @@
     im = Image.new("L", (750, 30), "white")
     draw = ImageDraw.Draw(im)
     draw.text((0, 0), message, "black", font=font)
-    with Image.open("Tests/images/high_ascii_chars.png") as target:
-        assert_image_similar(im, target, 0)
+    assert_image_similar_tofile(im, "Tests/images/high_ascii_chars.png", 0)


 def test_high_characters(request, tmp_path):
('Tests', 'test_tiff_crashes.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,10 +24,23 @@
         "Tests/images/crash_1.tif",
         "Tests/images/crash_2.tif",
         "Tests/images/crash-2020-10-test.tif",
+        "Tests/images/crash-0c7e0e8e11ce787078f00b5b0ca409a167f070e0.tif",
+        "Tests/images/crash-0e16d3bfb83be87356d026d66919deaefca44dac.tif",
+        "Tests/images/crash-1152ec2d1a1a71395b6f2ce6721c38924d025bf3.tif",
+        "Tests/images/crash-1185209cf7655b5aed8ae5e77784dfdd18ab59e9.tif",
+        "Tests/images/crash-338516dbd2f0e83caddb8ce256c22db3bd6dc40f.tif",
+        "Tests/images/crash-4f085cc12ece8cde18758d42608bed6a2a2cfb1c.tif",
+        "Tests/images/crash-86214e58da443d2b80820cff9677a38a33dcbbca.tif",
+        "Tests/images/crash-f46f5b2f43c370fe65706c11449f567ecc345e74.tif",
+        "Tests/images/crash-63b1dffefc8c075ddc606c0a2f5fdc15ece78863.tif",
+        "Tests/images/crash-74d2a78403a5a59db1fb0a2b8735ac068a75f6e3.tif",
+        "Tests/images/crash-81154a65438ba5aaeca73fd502fa4850fbde60f8.tif",
+        "Tests/images/crash-0da013a13571cc8eb457a39fee8db18f8a3c7127.tif",
     ],
 )
 @pytest.mark.filterwarnings("ignore:Possibly corrupt EXIF data")
 @pytest.mark.filterwarnings("ignore:Metadata warning")
+@pytest.mark.filterwarnings("ignore:Truncated File Read")
 def test_tiff_crashes(test_file):
     try:
         with Image.open(test_file) as im:
('Tests', 'test_file_psd.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+import warnings
+
 import pytest

 from PIL import Image, PsdImagePlugin
@@ -29,20 +31,16 @@


 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(test_file)
         im.load()
         im.close()

-    pytest.warns(None, open)
-

 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(test_file) as im:
             im.load()
-
-    pytest.warns(None, open)


 def test_invalid_file():
@@ -57,9 +55,10 @@
         assert im.n_frames == 1
         assert not im.is_animated

-    with Image.open(test_file) as im:
-        assert im.n_frames == 2
-        assert im.is_animated
+    for path in [test_file, "Tests/images/negative_layer_count.psd"]:
+        with Image.open(path) as im:
+            assert im.n_frames == 2
+            assert im.is_animated


 def test_eoferror():
@@ -122,10 +121,33 @@


 def test_combined_larger_than_size():
-    # The 'combined' sizes of the individual parts is larger than the
+    # The combined size of the individual parts is larger than the
     # declared 'size' of the extra data field, resulting in a backwards seek.

     # If we instead take the 'size' of the extra data field as the source of truth,
     # then the seek can't be negative
     with pytest.raises(OSError):
-        Image.open("Tests/images/combined_larger_than_size.psd")
+        with Image.open("Tests/images/combined_larger_than_size.psd"):
+            pass
+
+
+@pytest.mark.parametrize(
+    "test_file,raises",
+    [
+        (
+            "Tests/images/timeout-1ee28a249896e05b83840ae8140622de8e648ba9.psd",
+            Image.UnidentifiedImageError,
+        ),
+        (
+            "Tests/images/timeout-598843abc37fc080ec36a2699ebbd44f795d3a6f.psd",
+            Image.UnidentifiedImageError,
+        ),
+        ("Tests/images/timeout-c8efc3fded6426986ba867a399791bae544f59bc.psd", OSError),
+        ("Tests/images/timeout-dedc7a4ebd856d79b4359bbcc79e8ef231ce38f6.psd", OSError),
+    ],
+)
+def test_crashes(test_file, raises):
+    with open(test_file, "rb") as f:
+        with pytest.raises(raises):
+            with Image.open(f):
+                pass
('Tests', 'test_file_dcx.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+import warnings
+
 import pytest

 from PIL import DcxImagePlugin, Image
@@ -31,20 +33,16 @@


 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(TEST_FILE)
         im.load()
         im.close()

-    pytest.warns(None, open)
-

 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(TEST_FILE) as im:
             im.load()
-
-    pytest.warns(None, open)


 def test_invalid_file():
('Tests', 'test_imageshow.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -51,6 +51,16 @@
         assert ImageShow.show(im)


+def test_show_without_viewers():
+    viewers = ImageShow._viewers
+    ImageShow._viewers = []
+
+    im = hopper()
+    assert not ImageShow.show(im)
+
+    ImageShow._viewers = viewers
+
+
 def test_viewer():
     viewer = ImageShow.Viewer()

@@ -62,4 +72,37 @@

 def test_viewers():
     for viewer in ImageShow._viewers:
-        viewer.get_command("test.jpg")
+        try:
+            viewer.get_command("test.jpg")
+        except NotImplementedError:
+            pass
+
+
+def test_ipythonviewer():
+    pytest.importorskip("IPython", reason="IPython not installed")
+    for viewer in ImageShow._viewers:
+        if isinstance(viewer, ImageShow.IPythonViewer):
+            test_viewer = viewer
+            break
+    else:
+        assert False
+
+    im = hopper()
+    assert test_viewer.show(im) == 1
+
+
+@pytest.mark.skipif(
+    not on_ci() or is_win32(),
+    reason="Only run on CIs; hangs on Windows CIs",
+)
+def test_file_deprecated(tmp_path):
+    f = str(tmp_path / "temp.jpg")
+    for viewer in ImageShow._viewers:
+        hopper().save(f)
+        with pytest.warns(DeprecationWarning):
+            try:
+                viewer.show_file(file=f)
+            except NotImplementedError:
+                pass
+        with pytest.raises(TypeError):
+            viewer.show_file()
('Tests', 'test_font_leaks.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,7 @@


 class TestTTypeFontLeak(PillowLeakTestCase):
-    # fails at iteration 3 in master
+    # fails at iteration 3 in main
     iterations = 10
     mem_limit = 4096  # k

@@ -24,7 +24,7 @@


 class TestDefaultFontLeak(TestTTypeFontLeak):
-    # fails at iteration 37 in master
+    # fails at iteration 37 in main
     iterations = 100
     mem_limit = 1024  # k

('Tests', 'test_qt_image_qapplication.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,16 +2,26 @@

 from PIL import ImageQt

-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper

 if ImageQt.qt_is_installed:
     from PIL.ImageQt import QPixmap

-    if ImageQt.qt_version == "side6":
+    if ImageQt.qt_version == "6":
+        from PyQt6.QtCore import QPoint
+        from PyQt6.QtGui import QImage, QPainter, QRegion
+        from PyQt6.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget
+    elif ImageQt.qt_version == "side6":
+        from PySide6.QtCore import QPoint
+        from PySide6.QtGui import QImage, QPainter, QRegion
         from PySide6.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget
     elif ImageQt.qt_version == "5":
+        from PyQt5.QtCore import QPoint
+        from PyQt5.QtGui import QImage, QPainter, QRegion
         from PyQt5.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget
     elif ImageQt.qt_version == "side2":
+        from PySide2.QtCore import QPoint
+        from PySide2.QtGui import QImage, QPainter, QRegion
         from PySide2.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget

     class Example(QWidget):
@@ -47,7 +57,8 @@

     for mode in ("1", "RGB", "RGBA", "L", "P"):
         # to QPixmap
-        data = ImageQt.toqpixmap(hopper(mode))
+        im = hopper(mode)
+        data = ImageQt.toqpixmap(im)

         assert isinstance(data, QPixmap)
         assert not data.isNull()
@@ -56,6 +67,20 @@
         tempfile = str(tmp_path / f"temp_{mode}.png")
         data.save(tempfile)

+        # Render the image
+        qimage = ImageQt.ImageQt(im)
+        data = QPixmap.fromImage(qimage)
+        qt_format = QImage.Format if ImageQt.qt_version == "6" else QImage
+        qimage = QImage(128, 128, qt_format.Format_ARGB32)
+        painter = QPainter(qimage)
+        image_label = QLabel()
+        image_label.setPixmap(data)
+        image_label.render(painter, QPoint(0, 0), QRegion(0, 0, 128, 128))
+        painter.end()
+        rendered_tempfile = str(tmp_path / f"temp_rendered_{mode}.png")
+        qimage.save(rendered_tempfile)
+        assert_image_equal_tofile(im.convert("RGBA"), rendered_tempfile)
+
         # from QPixmap
         roundtrip(hopper(mode))

('Tests', 'test_core_resources.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -110,9 +110,9 @@

         with pytest.raises(ValueError):
             Image.core.set_blocks_max(-1)
-        if sys.maxsize < 2 ** 32:
+        if sys.maxsize < 2**32:
             with pytest.raises(ValueError):
-                Image.core.set_blocks_max(2 ** 29)
+                Image.core.set_blocks_max(2**29)

     @pytest.mark.skipif(is_pypy(), reason="Images not collected")
     def test_set_blocks_max_stats(self):
('Tests', 'test_file_pcx.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -42,6 +42,14 @@
         # larger, odd sized images are better here to ensure that
         # we handle interrupted scan lines properly.
         _roundtrip(tmp_path, hopper(mode).resize((511, 511)))
+
+
+def test_odd_read():
+    # Reading an image with an odd stride, making it malformed
+    with Image.open("Tests/images/odd_stride.pcx") as im:
+        im.load()
+
+        assert im.size == (371, 150)


 def test_pil184():
('Tests', 'test_file_png.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,6 @@
 import re
+import sys
+import warnings
 import zlib
 from io import BytesIO

@@ -10,11 +12,17 @@
     PillowLeakTestCase,
     assert_image,
     assert_image_equal,
+    assert_image_equal_tofile,
     hopper,
-    is_big_endian,
     is_win32,
+    mark_if_feature_version,
     skip_unless_feature,
 )
+
+try:
+    import defusedxml.ElementTree as ElementTree
+except ImportError:
+    ElementTree = None

 # sample png stream

@@ -69,7 +77,6 @@
                     png.crc(cid, s)
         return chunks

-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
     def test_sanity(self, tmp_path):

         # internal version number
@@ -106,7 +113,8 @@

         test_file = "Tests/images/broken.png"
         with pytest.raises(OSError):
-            Image.open(test_file)
+            with Image.open(test_file):
+                pass

     def test_bad_text(self):
         # Make sure PIL can read malformed tEXt chunks (@PIL152)
@@ -324,7 +332,8 @@

         with Image.open(TEST_PNG_FILE) as im:
             # Assert that there is no unclosed file warning
-            pytest.warns(None, im.verify)
+            with warnings.catch_warnings():
+                im.verify()

         with Image.open(TEST_PNG_FILE) as im:
             im.load()
@@ -380,25 +389,12 @@
         # Check dpi roundtripping

         with Image.open(TEST_PNG_FILE) as im:
-            im = roundtrip(im, dpi=(100, 100))
-        assert im.info["dpi"] == (100, 100)
-
-    def test_load_dpi_rounding(self):
-        # Round up
-        with Image.open(TEST_PNG_FILE) as im:
-            assert im.info["dpi"] == (96, 96)
-
-        # Round down
-        with Image.open("Tests/images/icc_profile_none.png") as im:
-            assert im.info["dpi"] == (72, 72)
-
-    def test_save_dpi_rounding(self):
-        with Image.open(TEST_PNG_FILE) as im:
-            im = roundtrip(im, dpi=(72.2, 72.2))
-        assert im.info["dpi"] == (72, 72)
-
-        im = roundtrip(im, dpi=(72.8, 72.8))
-        assert im.info["dpi"] == (73, 73)
+            im = roundtrip(im, dpi=(100.33, 100.33))
+        assert im.info["dpi"] == (100.33, 100.33)
+
+    def test_load_float_dpi(self):
+        with Image.open(TEST_PNG_FILE) as im:
+            assert im.info["dpi"] == (95.9866, 95.9866)

     def test_roundtrip_text(self):
         # Check text roundtripping
@@ -464,7 +460,8 @@

         pngfile = BytesIO(data)
         with pytest.raises(OSError):
-            Image.open(pngfile)
+            with Image.open(pngfile):
+                pass

     def test_trns_rgb(self):
         # Check writing and reading of tRNS chunks for RGB images.
@@ -513,6 +510,8 @@

     def test_discard_icc_profile(self):
         with Image.open("Tests/images/icc_profile.png") as im:
+            assert "icc_profile" in im.info
+
             im = roundtrip(im, icc_profile=None)
         assert "icc_profile" not in im.info

@@ -571,8 +570,8 @@
         assert len(chunks) == 3

     def test_read_private_chunks(self):
-        im = Image.open("Tests/images/exif.png")
-        assert im.private_chunks == [(b"orNT", b"\x01")]
+        with Image.open("Tests/images/exif.png") as im:
+            assert im.private_chunks == [(b"orNT", b"\x01")]

     def test_roundtrip_private_chunk(self):
         # Check private chunk roundtripping
@@ -619,6 +618,54 @@
         with Image.open("Tests/images/hopper_idat_after_image_end.png") as im:
             assert im.text == {"TXT": "VALUE", "ZIP": "VALUE"}

+    def test_padded_idat(self):
+        # This image has been manually hexedited
+        # so that the IDAT chunk has padding at the end
+        # Set MAXBLOCK to the length of the actual data
+        # so that the decoder finishes reading before the chunk ends
+        MAXBLOCK = ImageFile.MAXBLOCK
+        ImageFile.MAXBLOCK = 45
+        ImageFile.LOAD_TRUNCATED_IMAGES = True
+
+        with Image.open("Tests/images/padded_idat.png") as im:
+            im.load()
+
+            ImageFile.MAXBLOCK = MAXBLOCK
+            ImageFile.LOAD_TRUNCATED_IMAGES = False
+
+            assert_image_equal_tofile(im, "Tests/images/bw_gradient.png")
+
+    def test_specify_bits(self, tmp_path):
+        im = hopper("P")
+
+        out = str(tmp_path / "temp.png")
+        im.save(out, bits=4)
+
+        with Image.open(out) as reloaded:
+            assert len(reloaded.png.im_palette[1]) == 48
+
+    def test_plte_length(self, tmp_path):
+        im = Image.new("P", (1, 1))
+        im.putpalette((1, 1, 1))
+
+        out = str(tmp_path / "temp.png")
+        im.save(str(tmp_path / "temp.png"))
+
+        with Image.open(out) as reloaded:
+            assert len(reloaded.png.im_palette[1]) == 3
+
+    def test_getxmp(self):
+        with Image.open("Tests/images/color_snakes.png") as im:
+            if ElementTree is None:
+                with pytest.warns(UserWarning):
+                    assert im.getxmp() == {}
+            else:
+                xmp = im.getxmp()
+
+                description = xmp["xmpmeta"]["RDF"]["Description"]
+                assert description["PixelXDimension"] == "10"
+                assert description["subject"]["Seq"] is None
+
     def test_exif(self):
         # With an EXIF chunk
         with Image.open("Tests/images/exif.png") as im:
@@ -654,6 +701,9 @@
             exif = reloaded._getexif()
         assert exif[274] == 1

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_exif_from_jpg(self, tmp_path):
         with Image.open("Tests/images/pil_sample_rgb.jpg") as im:
             test_file = str(tmp_path / "temp.png")
@@ -681,6 +731,32 @@

             with pytest.raises(EOFError):
                 im.seek(1)
+
+    @pytest.mark.parametrize("buffer", (True, False))
+    def test_save_stdout(self, buffer):
+        old_stdout = sys.stdout
+
+        if buffer:
+
+            class MyStdOut:
+                buffer = BytesIO()
+
+            mystdout = MyStdOut()
+        else:
+            mystdout = BytesIO()
+
+        sys.stdout = mystdout
+
+        with Image.open(TEST_PNG_FILE) as im:
+            im.save(sys.stdout, "PNG")
+
+        # Reset stdout
+        sys.stdout = old_stdout
+
+        if buffer:
+            mystdout = mystdout.buffer
+        with Image.open(mystdout) as reloaded:
+            assert_image_equal_tofile(reloaded, TEST_PNG_FILE)


 @pytest.mark.skipif(is_win32(), reason="Requires Unix or macOS")
('Tests', 'test_imagegrab.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,7 +6,7 @@

 from PIL import Image, ImageGrab

-from .helper import assert_image, assert_image_equal_tofile, skip_unless_feature
+from .helper import assert_image_equal_tofile, skip_unless_feature


 class TestImageGrab:
@@ -14,25 +14,20 @@
         sys.platform not in ("win32", "darwin"), reason="requires Windows or macOS"
     )
     def test_grab(self):
-        for im in [
-            ImageGrab.grab(),
-            ImageGrab.grab(include_layered_windows=True),
-            ImageGrab.grab(all_screens=True),
-        ]:
-            assert_image(im, im.mode, im.size)
+        ImageGrab.grab()
+        ImageGrab.grab(include_layered_windows=True)
+        ImageGrab.grab(all_screens=True)

         im = ImageGrab.grab(bbox=(10, 20, 50, 80))
-        assert_image(im, im.mode, (40, 60))
+        assert im.size == (40, 60)

     @skip_unless_feature("xcb")
     def test_grab_x11(self):
         try:
             if sys.platform not in ("win32", "darwin"):
-                im = ImageGrab.grab()
-                assert_image(im, im.mode, im.size)
+                ImageGrab.grab()

-            im2 = ImageGrab.grab(xdisplay="")
-            assert_image(im2, im2.mode, im2.size)
+            ImageGrab.grab(xdisplay="")
         except OSError as e:
             pytest.skip(str(e))

@@ -71,8 +66,7 @@
             assert str(e.value) == "ImageGrab.grabclipboard() is macOS and Windows only"
             return

-        im = ImageGrab.grabclipboard()
-        assert_image(im, im.mode, im.size)
+        ImageGrab.grabclipboard()

     @pytest.mark.skipif(sys.platform != "win32", reason="Windows only")
     def test_grabclipboard_file(self):
('Tests', 'test_file_bmp.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,12 @@

 from PIL import BmpImagePlugin, Image

-from .helper import assert_image_equal, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
+    hopper,
+)


 def test_sanity(tmp_path):
@@ -63,7 +68,7 @@

     output.seek(0)
     with Image.open(output) as reloaded:
-        assert reloaded.info["dpi"] == dpi
+        assert reloaded.info["dpi"] == (72.008961115161, 72.008961115161)


 def test_save_bmp_with_dpi(tmp_path):
@@ -71,6 +76,7 @@
     # Arrange
     outfile = str(tmp_path / "temp.jpg")
     with Image.open("Tests/images/hopper.bmp") as im:
+        assert im.info["dpi"] == (95.98654816726399, 95.98654816726399)

         # Act
         im.save(outfile, "JPEG", dpi=im.info["dpi"])
@@ -78,31 +84,17 @@
         # Assert
         with Image.open(outfile) as reloaded:
             reloaded.load()
-            assert im.info["dpi"] == reloaded.info["dpi"]
-            assert im.size == reloaded.size
+            assert reloaded.info["dpi"] == (96, 96)
+            assert reloaded.size == im.size
             assert reloaded.format == "JPEG"


-def test_load_dpi_rounding():
-    # Round up
-    with Image.open("Tests/images/hopper.bmp") as im:
-        assert im.info["dpi"] == (96, 96)
-
-    # Round down
-    with Image.open("Tests/images/hopper_roundDown.bmp") as im:
-        assert im.info["dpi"] == (72, 72)
-
-
-def test_save_dpi_rounding(tmp_path):
+def test_save_float_dpi(tmp_path):
     outfile = str(tmp_path / "temp.bmp")
     with Image.open("Tests/images/hopper.bmp") as im:
-        im.save(outfile, dpi=(72.2, 72.2))
+        im.save(outfile, dpi=(72.21216100543306, 72.21216100543306))
         with Image.open(outfile) as reloaded:
-            assert reloaded.info["dpi"] == (72, 72)
-
-        im.save(outfile, dpi=(72.8, 72.8))
-    with Image.open(outfile) as reloaded:
-        assert reloaded.info["dpi"] == (73, 73)
+            assert reloaded.info["dpi"] == (72.21216100543306, 72.21216100543306)


 def test_load_dib():
@@ -111,8 +103,7 @@
         assert im.format == "DIB"
         assert im.get_format_mimetype() == "image/bmp"

-        with Image.open("Tests/images/clipboard_target.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/clipboard_target.png")


 def test_save_dib(tmp_path):
@@ -136,5 +127,47 @@
         b, g, r = im.split()[1:]
         im = Image.merge("RGB", (r, g, b))

-    with Image.open("Tests/images/bmp/q/rgb32bf-xbgr.bmp") as target:
-        assert_image_equal(im, target)
+    assert_image_equal_tofile(im, "Tests/images/bmp/q/rgb32bf-xbgr.bmp")
+
+
+def test_rle8():
+    with Image.open("Tests/images/hopper_rle8.bmp") as im:
+        assert_image_similar_tofile(im.convert("RGB"), "Tests/images/hopper.bmp", 12)
+
+    # This test image has been manually hexedited
+    # to have rows with too much data
+    with Image.open("Tests/images/hopper_rle8_row_overflow.bmp") as im:
+        assert_image_similar_tofile(im.convert("RGB"), "Tests/images/hopper.bmp", 12)
+
+    # Signal end of bitmap before the image is finished
+    with open("Tests/images/bmp/g/pal8rle.bmp", "rb") as fp:
+        data = fp.read(1063) + b"\x01"
+        with Image.open(io.BytesIO(data)) as im:
+            with pytest.raises(ValueError):
+                im.load()
+
+
+@pytest.mark.parametrize(
+    "file_name,length",
+    (
+        # EOF immediately after the header
+        ("Tests/images/hopper_rle8.bmp", 1078),
+        # EOF during delta
+        ("Tests/images/bmp/q/pal8rletrns.bmp", 3670),
+        # EOF when reading data in absolute mode
+        ("Tests/images/bmp/g/pal8rle.bmp", 1064),
+    ),
+)
+def test_rle8_eof(file_name, length):
+    with open(file_name, "rb") as fp:
+        data = fp.read(length)
+        with Image.open(io.BytesIO(data)) as im:
+            with pytest.raises(ValueError):
+                im.load()
+
+
+def test_offset():
+    # This image has been hexedited
+    # to exclude the palette size from the pixel data offset
+    with Image.open("Tests/images/pal8_offset.bmp") as im:
+        assert_image_equal_tofile(im, "Tests/images/bmp/g/pal8.bmp")
('Tests', 'test_file_im.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,10 +1,11 @@
 import filecmp
+import warnings

 import pytest

 from PIL import Image, ImImagePlugin

-from .helper import assert_image_equal, hopper, is_pypy
+from .helper import assert_image_equal_tofile, hopper, is_pypy

 # sample im
 TEST_IM = "Tests/images/hopper.im"
@@ -35,20 +36,16 @@


 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(TEST_IM)
         im.load()
         im.close()

-    pytest.warns(None, open)
-

 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(TEST_IM) as im:
             im.load()
-
-    pytest.warns(None, open)


 def test_tell():
@@ -86,8 +83,7 @@
         out = str(tmp_path / "temp.im")
         im = hopper(mode)
         im.save(out)
-        with Image.open(out) as reread:
-            assert_image_equal(reread, im)
+        assert_image_equal_tofile(im, out)

     for mode in ["RGB", "P", "PA"]:
         roundtrip(mode)
('Tests', 'test_image_rotate.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,11 @@
 from PIL import Image

-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar,
+    hopper,
+)


 def rotate(im, mode, angle, center=None, translate=None):
@@ -28,6 +33,9 @@
         with Image.open("Tests/images/test-card.png") as im:
             rotate(im, im.mode, angle)

+        im = hopper()
+        assert_image_equal(im.rotate(angle), im.rotate(angle, expand=1))
+

 def test_zero():
     for angle in (0, 45, 90, 180, 270):
@@ -38,14 +46,14 @@
 def test_resample():
     # Target image creation, inspected by eye.
     # >>> im = Image.open('Tests/images/hopper.ppm')
-    # >>> im = im.rotate(45, resample=Image.BICUBIC, expand=True)
+    # >>> im = im.rotate(45, resample=Image.Resampling.BICUBIC, expand=True)
     # >>> im.save('Tests/images/hopper_45.png')

     with Image.open("Tests/images/hopper_45.png") as target:
         for (resample, epsilon) in (
-            (Image.NEAREST, 10),
-            (Image.BILINEAR, 5),
-            (Image.BICUBIC, 0),
+            (Image.Resampling.NEAREST, 10),
+            (Image.Resampling.BILINEAR, 5),
+            (Image.Resampling.BICUBIC, 0),
         ):
             im = hopper()
             im = im.rotate(45, resample=resample, expand=True)
@@ -54,7 +62,7 @@

 def test_center_0():
     im = hopper()
-    im = im.rotate(45, center=(0, 0), resample=Image.BICUBIC)
+    im = im.rotate(45, center=(0, 0), resample=Image.Resampling.BICUBIC)

     with Image.open("Tests/images/hopper_45.png") as target:
         target_origin = target.size[1] / 2
@@ -65,7 +73,7 @@

 def test_center_14():
     im = hopper()
-    im = im.rotate(45, center=(14, 14), resample=Image.BICUBIC)
+    im = im.rotate(45, center=(14, 14), resample=Image.Resampling.BICUBIC)

     with Image.open("Tests/images/hopper_45.png") as target:
         target_origin = target.size[1] / 2 - 14
@@ -82,7 +90,7 @@
             (target_origin, target_origin, target_origin + 128, target_origin + 128)
         )

-    im = im.rotate(45, translate=(5, 5), resample=Image.BICUBIC)
+    im = im.rotate(45, translate=(5, 5), resample=Image.Resampling.BICUBIC)

     assert_image_similar(im, target, 1)

@@ -113,15 +121,13 @@
 def test_rotate_no_fill():
     im = Image.new("RGB", (100, 100), "green")
     im = im.rotate(45)
-    with Image.open("Tests/images/rotate_45_no_fill.png") as target:
-        assert_image_equal(im, target)
+    assert_image_equal_tofile(im, "Tests/images/rotate_45_no_fill.png")


 def test_rotate_with_fill():
     im = Image.new("RGB", (100, 100), "green")
     im = im.rotate(45, fillcolor="white")
-    with Image.open("Tests/images/rotate_45_with_fill.png") as target:
-        assert_image_equal(im, target)
+    assert_image_equal_tofile(im, "Tests/images/rotate_45_with_fill.png")


 def test_alpha_rotate_no_fill():
('Tests', 'test_pickle.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,9 +2,12 @@

 import pytest

-from PIL import Image
+from PIL import Image, ImageDraw, ImageFont

-from .helper import skip_unless_feature
+from .helper import assert_image_equal, skip_unless_feature
+
+FONT_SIZE = 20
+FONT_PATH = "Tests/fonts/DejaVuSans/DejaVuSans.ttf"


 def helper_pickle_file(tmp_path, pickle, protocol, test_file, mode):
@@ -85,10 +88,55 @@
 @skip_unless_feature("webp")
 def test_pickle_tell():
     # Arrange
-    image = Image.open("Tests/images/hopper.webp")
+    with Image.open("Tests/images/hopper.webp") as image:

-    # Act: roundtrip
-    unpickled_image = pickle.loads(pickle.dumps(image))
+        # Act: roundtrip
+        unpickled_image = pickle.loads(pickle.dumps(image))

     # Assert
     assert unpickled_image.tell() == 0
+
+
+def helper_assert_pickled_font_images(font1, font2):
+    # Arrange
+    im1 = Image.new(mode="RGBA", size=(300, 100))
+    im2 = Image.new(mode="RGBA", size=(300, 100))
+    draw1 = ImageDraw.Draw(im1)
+    draw2 = ImageDraw.Draw(im2)
+    txt = "Hello World!"
+
+    # Act
+    draw1.text((10, 10), txt, font=font1)
+    draw2.text((10, 10), txt, font=font2)
+
+    # Assert
+    assert_image_equal(im1, im2)
+
+
+@pytest.mark.parametrize("protocol", list(range(0, pickle.HIGHEST_PROTOCOL + 1)))
+def test_pickle_font_string(protocol):
+    # Arrange
+    font = ImageFont.truetype(FONT_PATH, FONT_SIZE)
+
+    # Act: roundtrip
+    pickled_font = pickle.dumps(font, protocol)
+    unpickled_font = pickle.loads(pickled_font)
+
+    # Assert
+    helper_assert_pickled_font_images(font, unpickled_font)
+
+
+@pytest.mark.parametrize("protocol", list(range(0, pickle.HIGHEST_PROTOCOL + 1)))
+def test_pickle_font_file(tmp_path, protocol):
+    # Arrange
+    font = ImageFont.truetype(FONT_PATH, FONT_SIZE)
+    filename = str(tmp_path / "temp.pkl")
+
+    # Act: roundtrip
+    with open(filename, "wb") as f:
+        pickle.dump(font, f, protocol)
+    with open(filename, "rb") as f:
+        unpickled_font = pickle.load(f)
+
+    # Assert
+    helper_assert_pickled_font_images(font, unpickled_font)
('Tests', 'test_file_blp.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,21 +1,82 @@
-from PIL import Image
+import pytest

-from .helper import assert_image_equal
+from PIL import BlpImagePlugin, Image
+
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar,
+    hopper,
+)
+
+
+def test_load_blp1():
+    with Image.open("Tests/images/blp/blp1_jpeg.blp") as im:
+        assert_image_equal_tofile(im, "Tests/images/blp/blp1_jpeg.png")


 def test_load_blp2_raw():
     with Image.open("Tests/images/blp/blp2_raw.blp") as im:
-        with Image.open("Tests/images/blp/blp2_raw.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/blp/blp2_raw.png")


 def test_load_blp2_dxt1():
     with Image.open("Tests/images/blp/blp2_dxt1.blp") as im:
-        with Image.open("Tests/images/blp/blp2_dxt1.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/blp/blp2_dxt1.png")


 def test_load_blp2_dxt1a():
     with Image.open("Tests/images/blp/blp2_dxt1a.blp") as im:
-        with Image.open("Tests/images/blp/blp2_dxt1a.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/blp/blp2_dxt1a.png")
+
+
+def test_save(tmp_path):
+    f = str(tmp_path / "temp.blp")
+
+    for version in ("BLP1", "BLP2"):
+        im = hopper("P")
+        im.save(f, blp_version=version)
+
+        with Image.open(f) as reloaded:
+            assert_image_equal(im.convert("RGB"), reloaded)
+
+        with Image.open("Tests/images/transparent.png") as im:
+            f = str(tmp_path / "temp.blp")
+            im.convert("P").save(f, blp_version=version)
+
+            with Image.open(f) as reloaded:
+                assert_image_similar(im, reloaded, 8)
+
+    im = hopper()
+    with pytest.raises(ValueError):
+        im.save(f)
+
+
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/images/timeout-060745d3f534ad6e4128c51d336ea5489182c69d.blp",
+        "Tests/images/timeout-31c8f86233ea728339c6e586be7af661a09b5b98.blp",
+        "Tests/images/timeout-60d8b7c8469d59fc9ffff6b3a3dc0faeae6ea8ee.blp",
+        "Tests/images/timeout-8073b430977660cdd48d96f6406ddfd4114e69c7.blp",
+        "Tests/images/timeout-bba4f2e026b5786529370e5dfe9a11b1bf991f07.blp",
+        "Tests/images/timeout-d6ec061c4afdef39d3edf6da8927240bb07fe9b7.blp",
+        "Tests/images/timeout-ef9112a065e7183fa7faa2e18929b03e44ee16bf.blp",
+    ],
+)
+def test_crashes(test_file):
+    with open(test_file, "rb") as f:
+        with Image.open(f) as im:
+            with pytest.raises(OSError):
+                im.load()
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        BlpImagePlugin.Format: "BLP_FORMAT_",
+        BlpImagePlugin.Encoding: "BLP_ENCODING_",
+        BlpImagePlugin.AlphaEncoding: "BLP_ALPHA_ENCODING_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(BlpImagePlugin, prefix + name) == enum[name]
('Tests', 'test_imagefont.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,7 +13,6 @@
 from .helper import (
     assert_image_equal,
     assert_image_equal_tofile,
-    assert_image_similar,
     assert_image_similar_tofile,
     is_win32,
     skip_unless_feature,
@@ -30,7 +29,7 @@


 class TestImageFont:
-    LAYOUT_ENGINE = ImageFont.LAYOUT_BASIC
+    LAYOUT_ENGINE = ImageFont.Layout.BASIC

     def get_font(self):
         return ImageFont.truetype(
@@ -52,7 +51,7 @@
         ttf_copy = ttf.font_variant(size=FONT_SIZE + 1)
         assert ttf_copy.size == FONT_SIZE + 1

-        second_font_path = "Tests/fonts/DejaVuSans.ttf"
+        second_font_path = "Tests/fonts/DejaVuSans/DejaVuSans.ttf"
         ttf_copy = ttf.font_variant(font=second_font_path)
         assert ttf_copy.path == second_font_path

@@ -89,19 +88,6 @@

         ImageFont.truetype(tempfile, FONT_SIZE)

-    def test_unavailable_layout_engine(self):
-        have_raqm = ImageFont.core.HAVE_RAQM
-        ImageFont.core.HAVE_RAQM = False
-
-        try:
-            ttf = ImageFont.truetype(
-                FONT_PATH, FONT_SIZE, layout_engine=ImageFont.LAYOUT_RAQM
-            )
-        finally:
-            ImageFont.core.HAVE_RAQM = have_raqm
-
-        assert ttf.layout_engine == ImageFont.LAYOUT_BASIC
-
     def _render(self, font):
         txt = "Hello World!"
         ttf = ImageFont.truetype(font, FONT_SIZE, layout_engine=self.LAYOUT_ENGINE)
@@ -130,8 +116,21 @@
         draw.text((10, 10), txt, font=ttf)

         target = "Tests/images/transparent_background_text.png"
-        with Image.open(target) as target_img:
-            assert_image_similar(im, target_img, 4.09)
+        assert_image_similar_tofile(im, target, 4.09)
+
+        target = "Tests/images/transparent_background_text_L.png"
+        assert_image_similar_tofile(im.convert("L"), target, 0.01)
+
+    def test_I16(self):
+        im = Image.new(mode="I;16", size=(300, 100))
+        draw = ImageDraw.Draw(im)
+        ttf = self.get_font()
+
+        txt = "Hello World!"
+        draw.text((10, 10), txt, font=ttf)
+
+        target = "Tests/images/transparent_background_text_L.png"
+        assert_image_similar_tofile(im.convert("L"), target, 0.01)

     def test_textsize_equal(self):
         im = Image.new(mode="RGB", size=(300, 100))
@@ -143,11 +142,9 @@
         draw.text((10, 10), txt, font=ttf)
         draw.rectangle((10, 10, 10 + size[0], 10 + size[1]))

-        target = "Tests/images/rectangle_surrounding_text.png"
-        with Image.open(target) as target_img:
-
-            # Epsilon ~.5 fails with FreeType 2.7
-            assert_image_similar(im, target_img, 2.5)
+        assert_image_similar_tofile(
+            im, "Tests/images/rectangle_surrounding_text.png", 2.5
+        )

     @pytest.mark.parametrize(
         "text, mode, font, size, length_basic, length_raqm",
@@ -156,8 +153,8 @@
             ("text", "L", "FreeMono.ttf", 15, 36, 36),
             ("text", "1", "FreeMono.ttf", 15, 36, 36),
             # issue 4177
-            ("rrr", "L", "DejaVuSans.ttf", 18, 21, 22.21875),
-            ("rrr", "1", "DejaVuSans.ttf", 18, 24, 22.21875),
+            ("rrr", "L", "DejaVuSans/DejaVuSans.ttf", 18, 21, 22.21875),
+            ("rrr", "1", "DejaVuSans/DejaVuSans.ttf", 18, 24, 22.21875),
             # test 'l' not including extra margin
             # using exact value 2047 / 64 for raqm, checked with debugger
             ("ill", "L", "OpenSansCondensed-LightItalic.ttf", 63, 33, 31.984375),
@@ -172,7 +169,7 @@
         im = Image.new(mode, (1, 1), 0)
         d = ImageDraw.Draw(im)

-        if self.LAYOUT_ENGINE == ImageFont.LAYOUT_BASIC:
+        if self.LAYOUT_ENGINE == ImageFont.Layout.BASIC:
             length = d.textlength(text, f)
             assert length == length_basic
         else:
@@ -191,13 +188,10 @@
             draw.text((0, y), line, font=ttf)
             y += line_spacing

-        target = "Tests/images/multiline_text.png"
-        with Image.open(target) as target_img:
-
-            # some versions of freetype have different horizontal spacing.
-            # setting a tight epsilon, I'm showing the original test failure
-            # at epsilon = ~38.
-            assert_image_similar(im, target_img, 6.2)
+        # some versions of freetype have different horizontal spacing.
+        # setting a tight epsilon, I'm showing the original test failure
+        # at epsilon = ~38.
+        assert_image_similar_tofile(im, "Tests/images/multiline_text.png", 6.2)

     def test_render_multiline_text(self):
         ttf = self.get_font()
@@ -208,11 +202,7 @@
         draw = ImageDraw.Draw(im)
         draw.text((0, 0), TEST_TEXT, font=ttf)

-        target = "Tests/images/multiline_text.png"
-        with Image.open(target) as target_img:
-
-            # Epsilon ~.5 fails with FreeType 2.7
-            assert_image_similar(im, target_img, 6.2)
+        assert_image_similar_tofile(im, "Tests/images/multiline_text.png", 0.01)

         # Test that text() can pass on additional arguments
         # to multiline_text()
@@ -227,11 +217,9 @@
             draw = ImageDraw.Draw(im)
             draw.multiline_text((0, 0), TEST_TEXT, font=ttf, align=align)

-            target = "Tests/images/multiline_text" + ext + ".png"
-            with Image.open(target) as target_img:
-
-                # Epsilon ~.5 fails with FreeType 2.7
-                assert_image_similar(im, target_img, 6.2)
+            assert_image_similar_tofile(
+                im, "Tests/images/multiline_text" + ext + ".png", 0.01
+            )

     def test_unknown_align(self):
         im = Image.new(mode="RGB", size=(300, 100))
@@ -285,11 +273,7 @@
         draw = ImageDraw.Draw(im)
         draw.multiline_text((0, 0), TEST_TEXT, font=ttf, spacing=10)

-        target = "Tests/images/multiline_text_spacing.png"
-        with Image.open(target) as target_img:
-
-            # Epsilon ~.5 fails with FreeType 2.7
-            assert_image_similar(im, target_img, 6.2)
+        assert_image_similar_tofile(im, "Tests/images/multiline_text_spacing.png", 2.5)

     def test_rotated_transposed_font(self):
         img_grey = Image.new("L", (100, 100))
@@ -297,7 +281,7 @@
         word = "testing"
         font = self.get_font()

-        orientation = Image.ROTATE_90
+        orientation = Image.Transpose.ROTATE_90
         transposed_font = ImageFont.TransposedFont(font, orientation=orientation)

         # Original font
@@ -336,7 +320,7 @@
         # Arrange
         text = "mask this"
         font = self.get_font()
-        orientation = Image.ROTATE_90
+        orientation = Image.Transpose.ROTATE_90
         transposed_font = ImageFont.TransposedFont(font, orientation=orientation)

         # Act
@@ -423,15 +407,12 @@
         im = Image.new(mode="RGB", size=(300, 100))
         draw = ImageDraw.Draw(im)

-        target = "Tests/images/default_font.png"
-        with Image.open(target) as target_img:
-
-            # Act
-            default_font = ImageFont.load_default()
-            draw.text((10, 10), txt, font=default_font)
-
-            # Assert
-            assert_image_equal(im, target_img)
+        # Act
+        default_font = ImageFont.load_default()
+        draw.text((10, 10), txt, font=default_font)
+
+        # Assert
+        assert_image_equal_tofile(im, "Tests/images/default_font.png")

     def test_getsize_empty(self):
         # issue #2614
@@ -610,7 +591,7 @@
         # Arrange
         t = self.get_font()
         # Act / Assert
-        if t.layout_engine == ImageFont.LAYOUT_BASIC:
+        if t.layout_engine == ImageFont.Layout.BASIC:
             with pytest.raises(KeyError):
                 t.getmask("абвг", direction="rtl")
             with pytest.raises(KeyError):
@@ -680,13 +661,11 @@
         d.text((10, 10), "Text", font=font, fill="black")

         try:
-            with Image.open(path) as expected:
-                assert_image_similar(im, expected, epsilon)
+            assert_image_similar_tofile(im, path, epsilon)
         except AssertionError:
             if "_adobe" in path:
                 path = path.replace("_adobe", "_adobe_older_harfbuzz")
-                with Image.open(path) as expected:
-                    assert_image_similar(im, expected, epsilon)
+                assert_image_similar_tofile(im, path, epsilon)
             else:
                 raise

@@ -734,31 +713,34 @@
         font.set_variation_by_axes([100])
         self._check_text(font, "Tests/images/variation_tiny_axes.png", 32.5)

+    def test_textbbox_non_freetypefont(self):
+        im = Image.new("RGB", (200, 200))
+        d = ImageDraw.Draw(im)
+        default_font = ImageFont.load_default()
+        with pytest.raises(ValueError):
+            d.textbbox((0, 0), "test", font=default_font)
+
     @pytest.mark.parametrize(
-        "anchor, left, left_old, top",
+        "anchor, left, top",
         (
             # test horizontal anchors
-            ("ls", 0, 0, -36),
-            ("ms", -64, -65, -36),
-            ("rs", -128, -129, -36),
+            ("ls", 0, -36),
+            ("ms", -64, -36),
+            ("rs", -128, -36),
             # test vertical anchors
-            ("ma", -64, -65, 16),
-            ("mt", -64, -65, 0),
-            ("mm", -64, -65, -17),
-            ("mb", -64, -65, -44),
-            ("md", -64, -65, -51),
+            ("ma", -64, 16),
+            ("mt", -64, 0),
+            ("mm", -64, -17),
+            ("mb", -64, -44),
+            ("md", -64, -51),
         ),
         ids=("ls", "ms", "rs", "ma", "mt", "mm", "mb", "md"),
     )
-    def test_anchor(self, anchor, left, left_old, top):
+    def test_anchor(self, anchor, left, top):
         name, text = "quick", "Quick"
         path = f"Tests/images/test_anchor_{name}_{anchor}.png"

-        freetype = parse_version(features.version_module("freetype2"))
-        if freetype < parse_version("2.4"):
-            width, height = (129, 44)
-            left = left_old
-        elif self.LAYOUT_ENGINE == ImageFont.LAYOUT_RAQM:
+        if self.LAYOUT_ENGINE == ImageFont.Layout.RAQM:
             width, height = (129, 44)
         else:
             width, height = (128, 44)
@@ -777,8 +759,7 @@

         assert d.textbbox((0, 0), text, f, anchor=anchor) == bbox_expected

-        with Image.open(path) as expected:
-            assert_image_similar(im, expected, 7)
+        assert_image_similar_tofile(im, path, 7)

     @pytest.mark.parametrize(
         "anchor, align",
@@ -816,8 +797,7 @@
             (300, 200), text, fill="black", anchor=anchor, font=f, align=align
         )

-        with Image.open(target) as expected:
-            assert_image_similar(im, expected, 4)
+        assert_image_similar_tofile(im, target, 4)

     def test_anchor_invalid(self):
         font = self.get_font()
@@ -855,7 +835,7 @@
         layout_name = ["basic", "raqm"][self.LAYOUT_ENGINE]
         target = f"Tests/images/bitmap_font_{bpp}_{layout_name}.png"
         font = ImageFont.truetype(
-            f"Tests/fonts/DejaVuSans-24-{bpp}-stripped.ttf",
+            f"Tests/fonts/DejaVuSans/DejaVuSans-24-{bpp}-stripped.ttf",
             24,
             layout_engine=self.LAYOUT_ENGINE,
         )
@@ -865,6 +845,22 @@
         draw.text((2, 2), text, "black", font)

         assert_image_equal_tofile(im, target)
+
+    def test_bitmap_font_stroke(self):
+        text = "Bitmap Font"
+        layout_name = ["basic", "raqm"][self.LAYOUT_ENGINE]
+        target = f"Tests/images/bitmap_font_stroke_{layout_name}.png"
+        font = ImageFont.truetype(
+            "Tests/fonts/DejaVuSans/DejaVuSans-24-8-stripped.ttf",
+            24,
+            layout_engine=self.LAYOUT_ENGINE,
+        )
+
+        im = Image.new("RGB", (160, 35), "white")
+        draw = ImageDraw.Draw(im)
+        draw.text((2, 2), text, "black", font, stroke_width=2, stroke_fill="red")
+
+        assert_image_similar_tofile(im, target, 0.03)

     def test_standard_embedded_color(self):
         txt = "Hello World!"
@@ -875,10 +871,8 @@
         d = ImageDraw.Draw(im)
         d.text((10, 10), txt, font=ttf, fill="#fa6", embedded_color=True)

-        with Image.open("Tests/images/standard_embedded.png") as expected:
-            assert_image_similar(im, expected, 6.2)
-
-    @skip_unless_feature_version("freetype2", "2.5.0")
+        assert_image_similar_tofile(im, "Tests/images/standard_embedded.png", 6.2)
+
     def test_cbdt(self):
         try:
             font = ImageFont.truetype(
@@ -890,15 +884,13 @@
             im = Image.new("RGB", (150, 150), "white")
             d = ImageDraw.Draw(im)

-            d.text((10, 10), "\U0001f469", embedded_color=True, font=font)
-
-            with Image.open("Tests/images/cbdt_notocoloremoji.png") as expected:
-                assert_image_similar(im, expected, 6.2)
-        except IOError as e:
+            d.text((10, 10), "\U0001f469", font=font, embedded_color=True)
+
+            assert_image_similar_tofile(im, "Tests/images/cbdt_notocoloremoji.png", 6.2)
+        except OSError as e:  # pragma: no cover
             assert str(e) in ("unimplemented feature", "unknown file format")
-            pytest.skip("freetype compiled without libpng or unsupported")
-
-    @skip_unless_feature_version("freetype2", "2.5.0")
+            pytest.skip("freetype compiled without libpng or CBDT support")
+
     def test_cbdt_mask(self):
         try:
             font = ImageFont.truetype(
@@ -912,11 +904,48 @@

             d.text((10, 10), "\U0001f469", "black", font=font)

-            with Image.open("Tests/images/cbdt_notocoloremoji_mask.png") as expected:
-                assert_image_similar(im, expected, 6.2)
-        except IOError as e:
+            assert_image_similar_tofile(
+                im, "Tests/images/cbdt_notocoloremoji_mask.png", 6.2
+            )
+        except OSError as e:  # pragma: no cover
             assert str(e) in ("unimplemented feature", "unknown file format")
-            pytest.skip("freetype compiled without libpng or unsupported")
+            pytest.skip("freetype compiled without libpng or CBDT support")
+
+    def test_sbix(self):
+        try:
+            font = ImageFont.truetype(
+                "Tests/fonts/chromacheck-sbix.woff",
+                size=300,
+                layout_engine=self.LAYOUT_ENGINE,
+            )
+
+            im = Image.new("RGB", (400, 400), "white")
+            d = ImageDraw.Draw(im)
+
+            d.text((50, 50), "\uE901", font=font, embedded_color=True)
+
+            assert_image_similar_tofile(im, "Tests/images/chromacheck-sbix.png", 1)
+        except OSError as e:  # pragma: no cover
+            assert str(e) in ("unimplemented feature", "unknown file format")
+            pytest.skip("freetype compiled without libpng or SBIX support")
+
+    def test_sbix_mask(self):
+        try:
+            font = ImageFont.truetype(
+                "Tests/fonts/chromacheck-sbix.woff",
+                size=300,
+                layout_engine=self.LAYOUT_ENGINE,
+            )
+
+            im = Image.new("RGB", (400, 400), "white")
+            d = ImageDraw.Draw(im)
+
+            d.text((50, 50), "\uE901", (100, 0, 0), font=font)
+
+            assert_image_similar_tofile(im, "Tests/images/chromacheck-sbix_mask.png", 1)
+        except OSError as e:  # pragma: no cover
+            assert str(e) in ("unimplemented feature", "unknown file format")
+            pytest.skip("freetype compiled without libpng or SBIX support")

     @skip_unless_feature_version("freetype2", "2.10.0")
     def test_colr(self):
@@ -929,10 +958,9 @@
         im = Image.new("RGB", (300, 75), "white")
         d = ImageDraw.Draw(im)

-        d.text((15, 5), "Bungee", embedded_color=True, font=font)
-
-        with Image.open("Tests/images/colr_bungee.png") as expected:
-            assert_image_similar(im, expected, 21)
+        d.text((15, 5), "Bungee", font=font, embedded_color=True)
+
+        assert_image_similar_tofile(im, "Tests/images/colr_bungee.png", 21)

     @skip_unless_feature_version("freetype2", "2.10.0")
     def test_colr_mask(self):
@@ -947,36 +975,59 @@

         d.text((15, 5), "Bungee", "black", font=font)

-        with Image.open("Tests/images/colr_bungee_mask.png") as expected:
-            assert_image_similar(im, expected, 22)
+        assert_image_similar_tofile(im, "Tests/images/colr_bungee_mask.png", 22)


 @skip_unless_feature("raqm")
 class TestImageFont_RaqmLayout(TestImageFont):
-    LAYOUT_ENGINE = ImageFont.LAYOUT_RAQM
-
-
-@skip_unless_feature_version("freetype2", "2.4", "Different metrics")
+    LAYOUT_ENGINE = ImageFont.Layout.RAQM
+
+
 def test_render_mono_size():
     # issue 4177

     im = Image.new("P", (100, 30), "white")
     draw = ImageDraw.Draw(im)
     ttf = ImageFont.truetype(
-        "Tests/fonts/DejaVuSans.ttf", 18, layout_engine=ImageFont.LAYOUT_BASIC
+        "Tests/fonts/DejaVuSans/DejaVuSans.ttf",
+        18,
+        layout_engine=ImageFont.Layout.BASIC,
     )

     draw.text((10, 10), "r" * 10, "black", ttf)
     assert_image_equal_tofile(im, "Tests/images/text_mono.gif")


-def test_freetype_deprecation(monkeypatch):
-    # Arrange: mock features.version_module to return fake FreeType version
-    def fake_version_module(module):
-        return "2.7"
-
-    monkeypatch.setattr(features, "version_module", fake_version_module)
-
-    # Act / Assert
-    with pytest.warns(DeprecationWarning):
-        ImageFont.truetype(FONT_PATH, FONT_SIZE)
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/fonts/oom-e8e927ba6c0d38274a37c1567560eb33baf74627.ttf",
+    ],
+)
+def test_oom(test_file):
+    with open(test_file, "rb") as f:
+        font = ImageFont.truetype(BytesIO(f.read()))
+        with pytest.raises(Image.DecompressionBombError):
+            font.getmask("Test Text")
+
+
+def test_raqm_missing_warning(monkeypatch):
+    monkeypatch.setattr(ImageFont.core, "HAVE_RAQM", False)
+    with pytest.warns(UserWarning) as record:
+        font = ImageFont.truetype(
+            FONT_PATH, FONT_SIZE, layout_engine=ImageFont.Layout.RAQM
+        )
+    assert font.layout_engine == ImageFont.Layout.BASIC
+    assert str(record[-1].message) == (
+        "Raqm layout was requested, but Raqm is not available. "
+        "Falling back to basic layout."
+    )
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        ImageFont.Layout: "LAYOUT_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(ImageFont, prefix + name) == enum[name]
('Tests', 'test_mode_i16.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -34,7 +34,7 @@
         imOut = imIn.copy()
         verify(imOut)  # copy

-        imOut = imIn.transform((w, h), Image.EXTENT, (0, 0, w, h))
+        imOut = imIn.transform((w, h), Image.Transform.EXTENT, (0, 0, w, h))
         verify(imOut)  # transform

         filename = str(tmp_path / "temp.im")
('Tests', 'test_file_dds.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,16 +5,21 @@

 from PIL import DdsImagePlugin, Image

-from .helper import assert_image_equal
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper

 TEST_FILE_DXT1 = "Tests/images/dxt1-rgb-4bbp-noalpha_MipMaps-1.dds"
 TEST_FILE_DXT3 = "Tests/images/dxt3-argb-8bbp-explicitalpha_MipMaps-1.dds"
 TEST_FILE_DXT5 = "Tests/images/dxt5-argb-8bbp-interpolatedalpha_MipMaps-1.dds"
+TEST_FILE_DX10_BC5_TYPELESS = "Tests/images/bc5_typeless.dds"
+TEST_FILE_DX10_BC5_UNORM = "Tests/images/bc5_unorm.dds"
+TEST_FILE_DX10_BC5_SNORM = "Tests/images/bc5_snorm.dds"
+TEST_FILE_BC5S = "Tests/images/bc5s.dds"
 TEST_FILE_DX10_BC7 = "Tests/images/bc7-argb-8bpp_MipMaps-1.dds"
 TEST_FILE_DX10_BC7_UNORM_SRGB = "Tests/images/DXGI_FORMAT_BC7_UNORM_SRGB.dds"
 TEST_FILE_DX10_R8G8B8A8 = "Tests/images/argb-32bpp_MipMaps-1.dds"
 TEST_FILE_DX10_R8G8B8A8_UNORM_SRGB = "Tests/images/DXGI_FORMAT_R8G8B8A8_UNORM_SRGB.dds"
-TEST_FILE_UNCOMPRESSED_RGB = "Tests/images/uncompressed_rgb.dds"
+TEST_FILE_UNCOMPRESSED_RGB = "Tests/images/hopper.dds"
+TEST_FILE_UNCOMPRESSED_RGB_WITH_ALPHA = "Tests/images/uncompressed_rgb.dds"


 def test_sanity_dxt1():
@@ -31,6 +36,19 @@
         assert_image_equal(im, target)


+def test_sanity_dxt3():
+    """Check DXT3 images can be opened"""
+
+    with Image.open(TEST_FILE_DXT3) as im:
+        im.load()
+
+        assert im.format == "DDS"
+        assert im.mode == "RGBA"
+        assert im.size == (256, 256)
+
+        assert_image_equal_tofile(im, TEST_FILE_DXT3.replace(".dds", ".png"))
+
+
 def test_sanity_dxt5():
     """Check DXT5 images can be opened"""

@@ -41,22 +59,31 @@
     assert im.mode == "RGBA"
     assert im.size == (256, 256)

-    with Image.open(TEST_FILE_DXT5.replace(".dds", ".png")) as target:
-        assert_image_equal(target, im)
-
-
-def test_sanity_dxt3():
-    """Check DXT3 images can be opened"""
-
-    with Image.open(TEST_FILE_DXT3.replace(".dds", ".png")) as target:
-        with Image.open(TEST_FILE_DXT3) as im:
-            im.load()
-
-            assert im.format == "DDS"
-            assert im.mode == "RGBA"
-            assert im.size == (256, 256)
-
-            assert_image_equal(target, im)
+    assert_image_equal_tofile(im, TEST_FILE_DXT5.replace(".dds", ".png"))
+
+
+@pytest.mark.parametrize(
+    ("image_path", "expected_path"),
+    (
+        # hexeditted to be typeless
+        (TEST_FILE_DX10_BC5_TYPELESS, TEST_FILE_DX10_BC5_UNORM),
+        (TEST_FILE_DX10_BC5_UNORM, TEST_FILE_DX10_BC5_UNORM),
+        # hexeditted to use DX10 FourCC
+        (TEST_FILE_DX10_BC5_SNORM, TEST_FILE_BC5S),
+        (TEST_FILE_BC5S, TEST_FILE_BC5S),
+    ),
+)
+def test_dx10_bc5(image_path, expected_path):
+    """Check DX10 BC5 images can be opened"""
+
+    with Image.open(image_path) as im:
+        im.load()
+
+        assert im.format == "DDS"
+        assert im.mode == "RGB"
+        assert im.size == (256, 256)
+
+        assert_image_equal_tofile(im, expected_path.replace(".dds", ".png"))


 def test_dx10_bc7():
@@ -69,8 +96,7 @@
         assert im.mode == "RGBA"
         assert im.size == (256, 256)

-        with Image.open(TEST_FILE_DX10_BC7.replace(".dds", ".png")) as target:
-            assert_image_equal(target, im)
+        assert_image_equal_tofile(im, TEST_FILE_DX10_BC7.replace(".dds", ".png"))


 def test_dx10_bc7_unorm_srgb():
@@ -84,10 +110,9 @@
         assert im.size == (16, 16)
         assert im.info["gamma"] == 1 / 2.2

-        with Image.open(
-            TEST_FILE_DX10_BC7_UNORM_SRGB.replace(".dds", ".png")
-        ) as target:
-            assert_image_equal(target, im)
+        assert_image_equal_tofile(
+            im, TEST_FILE_DX10_BC7_UNORM_SRGB.replace(".dds", ".png")
+        )


 def test_dx10_r8g8b8a8():
@@ -100,8 +125,7 @@
         assert im.mode == "RGBA"
         assert im.size == (256, 256)

-        with Image.open(TEST_FILE_DX10_R8G8B8A8.replace(".dds", ".png")) as target:
-            assert_image_equal(target, im)
+        assert_image_equal_tofile(im, TEST_FILE_DX10_R8G8B8A8.replace(".dds", ".png"))


 def test_dx10_r8g8b8a8_unorm_srgb():
@@ -115,69 +139,85 @@
         assert im.size == (16, 16)
         assert im.info["gamma"] == 1 / 2.2

-        with Image.open(
-            TEST_FILE_DX10_R8G8B8A8_UNORM_SRGB.replace(".dds", ".png")
-        ) as target:
-            assert_image_equal(target, im)
+        assert_image_equal_tofile(
+            im, TEST_FILE_DX10_R8G8B8A8_UNORM_SRGB.replace(".dds", ".png")
+        )


 def test_unimplemented_dxgi_format():
     with pytest.raises(NotImplementedError):
-        Image.open("Tests/images/unimplemented_dxgi_format.dds")
+        with Image.open("Tests/images/unimplemented_dxgi_format.dds"):
+            pass


 def test_uncompressed_rgb():
     """Check uncompressed RGB images can be opened"""

+    # convert -format dds -define dds:compression=none hopper.jpg hopper.dds
     with Image.open(TEST_FILE_UNCOMPRESSED_RGB) as im:
-        im.load()
-
+        assert im.format == "DDS"
+        assert im.mode == "RGB"
+        assert im.size == (128, 128)
+
+        assert_image_equal_tofile(im, "Tests/images/hopper.png")
+
+    # Test image with alpha
+    with Image.open(TEST_FILE_UNCOMPRESSED_RGB_WITH_ALPHA) as im:
         assert im.format == "DDS"
         assert im.mode == "RGBA"
         assert im.size == (800, 600)

-        with Image.open(TEST_FILE_UNCOMPRESSED_RGB.replace(".dds", ".png")) as target:
-            assert_image_equal(target, im)
-
-
-def test__validate_true():
+        assert_image_equal_tofile(
+            im, TEST_FILE_UNCOMPRESSED_RGB_WITH_ALPHA.replace(".dds", ".png")
+        )
+
+
+def test__accept_true():
     """Check valid prefix"""
     # Arrange
     prefix = b"DDS etc"

     # Act
-    output = DdsImagePlugin._validate(prefix)
+    output = DdsImagePlugin._accept(prefix)

     # Assert
     assert output


-def test__validate_false():
+def test__accept_false():
     """Check invalid prefix"""
     # Arrange
     prefix = b"something invalid"

     # Act
-    output = DdsImagePlugin._validate(prefix)
+    output = DdsImagePlugin._accept(prefix)

     # Assert
     assert not output


+def test_invalid_file():
+    invalid_file = "Tests/images/flower.jpg"
+
+    with pytest.raises(SyntaxError):
+        DdsImagePlugin.DdsImageFile(invalid_file)
+
+
 def test_short_header():
-    """ Check a short header"""
+    """Check a short header"""
     with open(TEST_FILE_DXT5, "rb") as f:
         img_file = f.read()

     def short_header():
-        Image.open(BytesIO(img_file[:119]))
+        with Image.open(BytesIO(img_file[:119])):
+            pass  # pragma: no cover

     with pytest.raises(OSError):
         short_header()


 def test_short_file():
-    """ Check that the appropriate error is thrown for a short file"""
+    """Check that the appropriate error is thrown for a short file"""

     with open(TEST_FILE_DXT5, "rb") as f:
         img_file = f.read()
@@ -190,6 +230,46 @@
         short_file()


+def test_dxt5_colorblock_alpha_issue_4142():
+    """Check that colorblocks are decoded correctly in DXT5"""
+
+    with Image.open("Tests/images/dxt5-colorblock-alpha-issue-4142.dds") as im:
+        px = im.getpixel((0, 0))
+        assert px[0] != 0
+        assert px[1] != 0
+        assert px[2] != 0
+
+        px = im.getpixel((1, 0))
+        assert px[0] != 0
+        assert px[1] != 0
+        assert px[2] != 0
+
+
 def test_unimplemented_pixel_format():
     with pytest.raises(NotImplementedError):
-        Image.open("Tests/images/unimplemented_pixel_format.dds")
+        with Image.open("Tests/images/unimplemented_pixel_format.dds"):
+            pass
+
+
+def test_save_unsupported_mode(tmp_path):
+    out = str(tmp_path / "temp.dds")
+    im = hopper("HSV")
+    with pytest.raises(OSError):
+        im.save(out)
+
+
+@pytest.mark.parametrize(
+    ("mode", "test_file"),
+    [
+        ("RGB", "Tests/images/hopper.png"),
+        ("RGBA", "Tests/images/pil123rgba.png"),
+    ],
+)
+def test_save(mode, test_file, tmp_path):
+    out = str(tmp_path / "temp.dds")
+    with Image.open(test_file) as im:
+        assert im.mode == mode
+        im.save(out)
+
+        with Image.open(out) as reloaded:
+            assert_image_equal(im, reloaded)
('Tests', 'test_file_webp_metadata.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,10 @@
 from io import BytesIO
+
+import pytest

 from PIL import Image

-from .helper import skip_unless_feature
+from .helper import mark_if_feature_version, skip_unless_feature

 pytestmark = [
     skip_unless_feature("webp"),
@@ -39,6 +41,9 @@
         assert exif[305] == "Adobe Photoshop CS6 (Macintosh)"


+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 def test_write_exif_metadata():
     file_path = "Tests/images/flower.jpg"
     test_buffer = BytesIO()
@@ -71,6 +76,9 @@
             assert icc == expected_icc


+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 def test_write_icc_metadata():
     file_path = "Tests/images/flower2.jpg"
     test_buffer = BytesIO()
@@ -88,6 +96,9 @@
         assert webp_icc_profile == expected_icc_profile, "Webp ICC didn't match"


+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 def test_read_no_exif():
     file_path = "Tests/images/flower.jpg"
     test_buffer = BytesIO()
('Tests', 'test_image_point.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -32,7 +32,7 @@


 def test_f_lut():
-    """ Tests for floating point lut of 8bit gray image """
+    """Tests for floating point lut of 8bit gray image"""
     im = hopper("L")
     lut = [0.5 * float(x) for x in range(256)]

('Tests', 'test_file_sgi.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,12 @@

 from PIL import Image, SgiImagePlugin

-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar,
+    hopper,
+)


 def test_rgb():
@@ -16,10 +21,7 @@


 def test_rgb16():
-    test_file = "Tests/images/hopper16.rgb"
-
-    with Image.open(test_file) as im:
-        assert_image_equal(im, hopper())
+    assert_image_equal_tofile(hopper(), "Tests/images/hopper16.rgb")


 def test_l():
@@ -38,8 +40,7 @@
     test_file = "Tests/images/transparent.sgi"

     with Image.open(test_file) as im:
-        with Image.open("Tests/images/transparent.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/transparent.png")
         assert im.get_format_mimetype() == "image/sgi"


@@ -49,16 +50,14 @@
     test_file = "Tests/images/hopper.sgi"

     with Image.open(test_file) as im:
-        with Image.open("Tests/images/hopper.rgb") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/hopper.rgb")


 def test_rle16():
     test_file = "Tests/images/tv16.sgi"

     with Image.open(test_file) as im:
-        with Image.open("Tests/images/tv.rgb") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/tv.rgb")


 def test_invalid_file():
@@ -72,8 +71,14 @@
     def roundtrip(img):
         out = str(tmp_path / "temp.sgi")
         img.save(out, format="sgi")
-        with Image.open(out) as reloaded:
-            assert_image_equal(img, reloaded)
+        assert_image_equal_tofile(img, out)
+
+        out = str(tmp_path / "fp.sgi")
+        with open(out, "wb") as fp:
+            img.save(fp)
+            assert_image_equal_tofile(img, out)
+
+            assert not fp.closed

     for mode in ("L", "RGB", "RGBA"):
         roundtrip(hopper(mode))
@@ -89,8 +94,7 @@
         out = str(tmp_path / "temp.sgi")
         im.save(out, format="sgi", bpc=2)

-        with Image.open(out) as reloaded:
-            assert_image_equal(im, reloaded)
+        assert_image_equal_tofile(im, out)


 def test_unsupported_mode(tmp_path):
('Tests', 'test_file_webp_animated.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,7 @@
 import pytest
+from packaging.version import parse as parse_version

-from PIL import Image
+from PIL import Image, features

 from .helper import (
     assert_image_equal,
@@ -27,7 +28,6 @@
         assert im.is_animated


-@pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
 def test_write_animation_L(tmp_path):
     """
     Convert an animated GIF to animated WebP, then compare the frame count, and first
@@ -45,15 +45,19 @@
             # Compare first and last frames to the original animated GIF
             orig.load()
             im.load()
-            assert_image_similar(im, orig.convert("RGBA"), 25.0)
+            assert_image_similar(im, orig.convert("RGBA"), 32.9)
+
+            if is_big_endian():
+                webp = parse_version(features.version_module("webp"))
+                if webp < parse_version("1.2.2"):
+                    pytest.skip("Fails with libwebp earlier than 1.2.2")
             orig.seek(orig.n_frames - 1)
             im.seek(im.n_frames - 1)
             orig.load()
             im.load()
-            assert_image_similar(im, orig.convert("RGBA"), 25.0)
+            assert_image_similar(im, orig.convert("RGBA"), 32.9)


-@pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
 def test_write_animation_RGB(tmp_path):
     """
     Write an animated WebP from RGB frames, and ensure the frames
@@ -69,6 +73,10 @@
             assert_image_equal(im, frame1.convert("RGBA"))

             # Compare second frame to original
+            if is_big_endian():
+                webp = parse_version(features.version_module("webp"))
+                if webp < parse_version("1.2.2"):
+                    pytest.skip("Fails with libwebp earlier than 1.2.2")
             im.seek(1)
             im.load()
             assert_image_equal(im, frame2.convert("RGBA"))
('Tests', 'test_color_lut.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -43,107 +43,158 @@
         im = Image.new("RGB", (10, 10), 0)

         with pytest.raises(ValueError, match="filter"):
-            im.im.color_lut_3d("RGB", Image.CUBIC, *self.generate_identity_table(3, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BICUBIC, *self.generate_identity_table(3, 3)
+            )

         with pytest.raises(ValueError, match="image mode"):
             im.im.color_lut_3d(
-                "wrong", Image.LINEAR, *self.generate_identity_table(3, 3)
+                "wrong", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
             )

         with pytest.raises(ValueError, match="table_channels"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(5, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(5, 3)
+            )

         with pytest.raises(ValueError, match="table_channels"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(1, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(1, 3)
+            )

         with pytest.raises(ValueError, match="table_channels"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(2, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(2, 3)
+            )

         with pytest.raises(ValueError, match="Table size"):
             im.im.color_lut_3d(
-                "RGB", Image.LINEAR, *self.generate_identity_table(3, (1, 3, 3))
+                "RGB",
+                Image.Resampling.BILINEAR,
+                *self.generate_identity_table(3, (1, 3, 3)),
             )

         with pytest.raises(ValueError, match="Table size"):
             im.im.color_lut_3d(
-                "RGB", Image.LINEAR, *self.generate_identity_table(3, (66, 3, 3))
+                "RGB",
+                Image.Resampling.BILINEAR,
+                *self.generate_identity_table(3, (66, 3, 3)),
             )

         with pytest.raises(ValueError, match=r"size1D \* size2D \* size3D"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, 3, 2, 2, 2, [0, 0, 0] * 7)
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, 0] * 7
+            )

         with pytest.raises(ValueError, match=r"size1D \* size2D \* size3D"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, 3, 2, 2, 2, [0, 0, 0] * 9)
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, 0] * 9
+            )

         with pytest.raises(TypeError):
-            im.im.color_lut_3d("RGB", Image.LINEAR, 3, 2, 2, 2, [0, 0, "0"] * 8)
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, "0"] * 8
+            )

         with pytest.raises(TypeError):
-            im.im.color_lut_3d("RGB", Image.LINEAR, 3, 2, 2, 2, 16)
+            im.im.color_lut_3d("RGB", Image.Resampling.BILINEAR, 3, 2, 2, 2, 16)

     def test_correct_args(self):
         im = Image.new("RGB", (10, 10), 0)

-        im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(3, 3))
-
-        im.im.color_lut_3d("CMYK", Image.LINEAR, *self.generate_identity_table(4, 3))
-
-        im.im.color_lut_3d(
-            "RGB", Image.LINEAR, *self.generate_identity_table(3, (2, 3, 3))
-        )
-
-        im.im.color_lut_3d(
-            "RGB", Image.LINEAR, *self.generate_identity_table(3, (65, 3, 3))
-        )
-
-        im.im.color_lut_3d(
-            "RGB", Image.LINEAR, *self.generate_identity_table(3, (3, 65, 3))
-        )
-
-        im.im.color_lut_3d(
-            "RGB", Image.LINEAR, *self.generate_identity_table(3, (3, 3, 65))
+        im.im.color_lut_3d(
+            "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+        )
+
+        im.im.color_lut_3d(
+            "CMYK", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)
+        )
+
+        im.im.color_lut_3d(
+            "RGB",
+            Image.Resampling.BILINEAR,
+            *self.generate_identity_table(3, (2, 3, 3)),
+        )
+
+        im.im.color_lut_3d(
+            "RGB",
+            Image.Resampling.BILINEAR,
+            *self.generate_identity_table(3, (65, 3, 3)),
+        )
+
+        im.im.color_lut_3d(
+            "RGB",
+            Image.Resampling.BILINEAR,
+            *self.generate_identity_table(3, (3, 65, 3)),
+        )
+
+        im.im.color_lut_3d(
+            "RGB",
+            Image.Resampling.BILINEAR,
+            *self.generate_identity_table(3, (3, 3, 65)),
         )

     def test_wrong_mode(self):
         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("L", (10, 10), 0)
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(3, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+            )

         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("RGB", (10, 10), 0)
-            im.im.color_lut_3d("L", Image.LINEAR, *self.generate_identity_table(3, 3))
+            im.im.color_lut_3d(
+                "L", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+            )

         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("L", (10, 10), 0)
-            im.im.color_lut_3d("L", Image.LINEAR, *self.generate_identity_table(3, 3))
+            im.im.color_lut_3d(
+                "L", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+            )

         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("RGB", (10, 10), 0)
             im.im.color_lut_3d(
-                "RGBA", Image.LINEAR, *self.generate_identity_table(3, 3)
+                "RGBA", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
             )

         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("RGB", (10, 10), 0)
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(4, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)
+            )

     def test_correct_mode(self):
         im = Image.new("RGBA", (10, 10), 0)
-        im.im.color_lut_3d("RGBA", Image.LINEAR, *self.generate_identity_table(3, 3))
+        im.im.color_lut_3d(
+            "RGBA", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+        )

         im = Image.new("RGBA", (10, 10), 0)
-        im.im.color_lut_3d("RGBA", Image.LINEAR, *self.generate_identity_table(4, 3))
+        im.im.color_lut_3d(
+            "RGBA", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)
+        )

         im = Image.new("RGB", (10, 10), 0)
-        im.im.color_lut_3d("HSV", Image.LINEAR, *self.generate_identity_table(3, 3))
+        im.im.color_lut_3d(
+            "HSV", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+        )

         im = Image.new("RGB", (10, 10), 0)
-        im.im.color_lut_3d("RGBA", Image.LINEAR, *self.generate_identity_table(4, 3))
+        im.im.color_lut_3d(
+            "RGBA", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)
+        )

     def test_identities(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )

         # Fast test with small cubes
@@ -152,7 +203,9 @@
                 im,
                 im._new(
                     im.im.color_lut_3d(
-                        "RGB", Image.LINEAR, *self.generate_identity_table(3, size)
+                        "RGB",
+                        Image.Resampling.BILINEAR,
+                        *self.generate_identity_table(3, size),
                     )
                 ),
             )
@@ -162,7 +215,9 @@
             im,
             im._new(
                 im.im.color_lut_3d(
-                    "RGB", Image.LINEAR, *self.generate_identity_table(3, (2, 2, 65))
+                    "RGB",
+                    Image.Resampling.BILINEAR,
+                    *self.generate_identity_table(3, (2, 2, 65)),
                 )
             ),
         )
@@ -170,7 +225,12 @@
     def test_identities_4_channels(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )

         # Red channel copied to alpha
@@ -178,7 +238,9 @@
             Image.merge("RGBA", (im.split() * 2)[:4]),
             im._new(
                 im.im.color_lut_3d(
-                    "RGBA", Image.LINEAR, *self.generate_identity_table(4, 17)
+                    "RGBA",
+                    Image.Resampling.BILINEAR,
+                    *self.generate_identity_table(4, 17),
                 )
             ),
         )
@@ -189,9 +251,9 @@
             "RGBA",
             [
                 g,
-                g.transpose(Image.ROTATE_90),
-                g.transpose(Image.ROTATE_180),
-                g.transpose(Image.ROTATE_270),
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+                g.transpose(Image.Transpose.ROTATE_270),
             ],
         )

@@ -199,7 +261,9 @@
             im,
             im._new(
                 im.im.color_lut_3d(
-                    "RGBA", Image.LINEAR, *self.generate_identity_table(3, 17)
+                    "RGBA",
+                    Image.Resampling.BILINEAR,
+                    *self.generate_identity_table(3, 17),
                 )
             ),
         )
@@ -207,14 +271,19 @@
     def test_channels_order(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )

         # Reverse channels by splitting and using table
         # fmt: off
         assert_image_equal(
             Image.merge('RGB', im.split()[::-1]),
-            im._new(im.im.color_lut_3d('RGB', Image.LINEAR,
+            im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,
                     3, 2, 2, 2, [
                         0, 0, 0,  0, 0, 1,
                         0, 1, 0,  0, 1, 1,
@@ -227,11 +296,16 @@
     def test_overflow(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
-        )
-
-        # fmt: off
-        transformed = im._new(im.im.color_lut_3d('RGB', Image.LINEAR,
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
+        )
+
+        # fmt: off
+        transformed = im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,
                               3, 2, 2, 2,
                               [
                                   -1, -1, -1,   2, -1, -1,
@@ -251,7 +325,7 @@
         assert transformed[205, 205] == (255, 255, 0)

         # fmt: off
-        transformed = im._new(im.im.color_lut_3d('RGB', Image.LINEAR,
+        transformed = im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,
                               3, 2, 2, 2,
                               [
                                   -3, -3, -3,   5, -3, -3,
@@ -354,7 +428,12 @@
     def test_numpy_formats(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )

         lut = ImageFilter.Color3DLUT.generate((7, 9, 11), lambda r, g, b: (r, g, b))
@@ -445,7 +524,12 @@

         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )
         assert im == im.filter(lut)

('Tests', 'test_imagewin_pointers.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,3 @@
-import ctypes
 from io import BytesIO

 from PIL import Image, ImageWin
@@ -8,6 +7,7 @@
 # see https://github.com/python-pillow/Pillow/pull/1431#issuecomment-144692652

 if is_win32():
+    import ctypes
     import ctypes.wintypes

     class BITMAPFILEHEADER(ctypes.Structure):
@@ -110,4 +110,5 @@
         DeleteObject(dib)
         DeleteDC(hdc)

-        Image.open(BytesIO(bitmap)).save(opath)
+        with Image.open(BytesIO(bitmap)) as im:
+            im.save(opath)
('Tests', 'test_image_transpose.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,12 +1,4 @@
-from PIL.Image import (
-    FLIP_LEFT_RIGHT,
-    FLIP_TOP_BOTTOM,
-    ROTATE_90,
-    ROTATE_180,
-    ROTATE_270,
-    TRANSPOSE,
-    TRANSVERSE,
-)
+from PIL.Image import Transpose

 from . import helper
 from .helper import assert_image_equal
@@ -20,7 +12,7 @@
 def test_flip_left_right():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(FLIP_LEFT_RIGHT)
+        out = im.transpose(Transpose.FLIP_LEFT_RIGHT)
         assert out.mode == mode
         assert out.size == im.size

@@ -37,7 +29,7 @@
 def test_flip_top_bottom():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(FLIP_TOP_BOTTOM)
+        out = im.transpose(Transpose.FLIP_TOP_BOTTOM)
         assert out.mode == mode
         assert out.size == im.size

@@ -54,7 +46,7 @@
 def test_rotate_90():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(ROTATE_90)
+        out = im.transpose(Transpose.ROTATE_90)
         assert out.mode == mode
         assert out.size == im.size[::-1]

@@ -71,7 +63,7 @@
 def test_rotate_180():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(ROTATE_180)
+        out = im.transpose(Transpose.ROTATE_180)
         assert out.mode == mode
         assert out.size == im.size

@@ -88,7 +80,7 @@
 def test_rotate_270():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(ROTATE_270)
+        out = im.transpose(Transpose.ROTATE_270)
         assert out.mode == mode
         assert out.size == im.size[::-1]

@@ -105,7 +97,7 @@
 def test_transpose():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(TRANSPOSE)
+        out = im.transpose(Transpose.TRANSPOSE)
         assert out.mode == mode
         assert out.size == im.size[::-1]

@@ -122,7 +114,7 @@
 def test_tranverse():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(TRANSVERSE)
+        out = im.transpose(Transpose.TRANSVERSE)
         assert out.mode == mode
         assert out.size == im.size[::-1]

@@ -143,20 +135,31 @@
         def transpose(first, second):
             return im.transpose(first).transpose(second)

-        assert_image_equal(im, transpose(FLIP_LEFT_RIGHT, FLIP_LEFT_RIGHT))
-        assert_image_equal(im, transpose(FLIP_TOP_BOTTOM, FLIP_TOP_BOTTOM))
-        assert_image_equal(im, transpose(ROTATE_90, ROTATE_270))
-        assert_image_equal(im, transpose(ROTATE_180, ROTATE_180))
         assert_image_equal(
-            im.transpose(TRANSPOSE), transpose(ROTATE_90, FLIP_TOP_BOTTOM)
+            im, transpose(Transpose.FLIP_LEFT_RIGHT, Transpose.FLIP_LEFT_RIGHT)
         )
         assert_image_equal(
-            im.transpose(TRANSPOSE), transpose(ROTATE_270, FLIP_LEFT_RIGHT)
+            im, transpose(Transpose.FLIP_TOP_BOTTOM, Transpose.FLIP_TOP_BOTTOM)
+        )
+        assert_image_equal(im, transpose(Transpose.ROTATE_90, Transpose.ROTATE_270))
+        assert_image_equal(im, transpose(Transpose.ROTATE_180, Transpose.ROTATE_180))
+        assert_image_equal(
+            im.transpose(Transpose.TRANSPOSE),
+            transpose(Transpose.ROTATE_90, Transpose.FLIP_TOP_BOTTOM),
         )
         assert_image_equal(
-            im.transpose(TRANSVERSE), transpose(ROTATE_90, FLIP_LEFT_RIGHT)
+            im.transpose(Transpose.TRANSPOSE),
+            transpose(Transpose.ROTATE_270, Transpose.FLIP_LEFT_RIGHT),
         )
         assert_image_equal(
-            im.transpose(TRANSVERSE), transpose(ROTATE_270, FLIP_TOP_BOTTOM)
+            im.transpose(Transpose.TRANSVERSE),
+            transpose(Transpose.ROTATE_90, Transpose.FLIP_LEFT_RIGHT),
         )
-        assert_image_equal(im.transpose(TRANSVERSE), transpose(ROTATE_180, TRANSPOSE))
+        assert_image_equal(
+            im.transpose(Transpose.TRANSVERSE),
+            transpose(Transpose.ROTATE_270, Transpose.FLIP_TOP_BOTTOM),
+        )
+        assert_image_equal(
+            im.transpose(Transpose.TRANSVERSE),
+            transpose(Transpose.ROTATE_180, Transpose.TRANSPOSE),
+        )
('Tests', 'test_file_ico.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,10 +1,11 @@
 import io
+import os

 import pytest

 from PIL import IcoImagePlugin, Image, ImageDraw

-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper

 TEST_ICO_FILE = "Tests/images/hopper.ico"

@@ -18,6 +19,22 @@
     assert im.get_format_mimetype() == "image/x-icon"


+def test_load():
+    with Image.open(TEST_ICO_FILE) as im:
+        assert im.load()[0, 0] == (1, 1, 9, 255)
+
+
+def test_mask():
+    with Image.open("Tests/images/hopper_mask.ico") as im:
+        assert_image_equal_tofile(im, "Tests/images/hopper_mask.png")
+
+
+def test_black_and_white():
+    with Image.open("Tests/images/black_and_white.ico") as im:
+        assert im.mode == "RGBA"
+        assert im.size == (16, 16)
+
+
 def test_invalid_file():
     with open("Tests/images/flower.jpg", "rb") as fp:
         with pytest.raises(SyntaxError):
@@ -37,7 +54,9 @@
         assert im.mode == reloaded.mode
         assert (64, 64) == reloaded.size
         assert reloaded.format == "ICO"
-        assert_image_equal(reloaded, hopper().resize((64, 64), Image.LANCZOS))
+        assert_image_equal(
+            reloaded, hopper().resize((64, 64), Image.Resampling.LANCZOS)
+        )

     # The other one
     output.seek(0)
@@ -47,7 +66,85 @@
         assert im.mode == reloaded.mode
         assert (32, 32) == reloaded.size
         assert reloaded.format == "ICO"
-        assert_image_equal(reloaded, hopper().resize((32, 32), Image.LANCZOS))
+        assert_image_equal(
+            reloaded, hopper().resize((32, 32), Image.Resampling.LANCZOS)
+        )
+
+
+def test_no_duplicates(tmp_path):
+    temp_file = str(tmp_path / "temp.ico")
+    temp_file2 = str(tmp_path / "temp2.ico")
+
+    im = hopper()
+    sizes = [(32, 32), (64, 64)]
+    im.save(temp_file, "ico", sizes=sizes)
+
+    sizes.append(sizes[-1])
+    im.save(temp_file2, "ico", sizes=sizes)
+
+    assert os.path.getsize(temp_file) == os.path.getsize(temp_file2)
+
+
+def test_different_bit_depths(tmp_path):
+    temp_file = str(tmp_path / "temp.ico")
+    temp_file2 = str(tmp_path / "temp2.ico")
+
+    im = hopper()
+    im.save(temp_file, "ico", bitmap_format="bmp", sizes=[(128, 128)])
+
+    hopper("1").save(
+        temp_file2,
+        "ico",
+        bitmap_format="bmp",
+        sizes=[(128, 128)],
+        append_images=[im],
+    )
+
+    assert os.path.getsize(temp_file) != os.path.getsize(temp_file2)
+
+    # Test that only matching sizes of different bit depths are saved
+    temp_file3 = str(tmp_path / "temp3.ico")
+    temp_file4 = str(tmp_path / "temp4.ico")
+
+    im.save(temp_file3, "ico", bitmap_format="bmp", sizes=[(128, 128)])
+    im.save(
+        temp_file4,
+        "ico",
+        bitmap_format="bmp",
+        sizes=[(128, 128)],
+        append_images=[Image.new("P", (64, 64))],
+    )
+
+    assert os.path.getsize(temp_file3) == os.path.getsize(temp_file4)
+
+
+@pytest.mark.parametrize("mode", ("1", "L", "P", "RGB", "RGBA"))
+def test_save_to_bytes_bmp(mode):
+    output = io.BytesIO()
+    im = hopper(mode)
+    im.save(output, "ico", bitmap_format="bmp", sizes=[(32, 32), (64, 64)])
+
+    # The default image
+    output.seek(0)
+    with Image.open(output) as reloaded:
+        assert reloaded.info["sizes"] == {(32, 32), (64, 64)}
+
+        assert "RGBA" == reloaded.mode
+        assert (64, 64) == reloaded.size
+        assert reloaded.format == "ICO"
+        im = hopper(mode).resize((64, 64), Image.Resampling.LANCZOS).convert("RGBA")
+        assert_image_equal(reloaded, im)
+
+    # The other one
+    output.seek(0)
+    with Image.open(output) as reloaded:
+        reloaded.size = (32, 32)
+
+        assert "RGBA" == reloaded.mode
+        assert (32, 32) == reloaded.size
+        assert reloaded.format == "ICO"
+        im = hopper(mode).resize((32, 32), Image.Resampling.LANCZOS).convert("RGBA")
+        assert_image_equal(reloaded, im)


 def test_incorrect_size():
@@ -119,6 +216,4 @@
         im.save(outfile)

     with Image.open(outfile) as im:
-        im.save("Tests/images/hopper_draw.ico")
-        with Image.open("Tests/images/hopper_draw.ico") as reloaded:
-            assert_image_equal(im, reloaded)
+        assert_image_equal_tofile(im, "Tests/images/hopper_draw.ico")
('Tests', 'test_bmp_reference.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,5 @@
 import os
-
-import pytest
+import warnings

 from PIL import Image

@@ -20,15 +19,13 @@
     either"""
     for f in get_files("b"):

-        def open(f):
+        # Assert that there is no unclosed file warning
+        with warnings.catch_warnings():
             try:
                 with Image.open(f) as im:
                     im.load()
             except Exception:  # as msg:
                 pass
-
-        # Assert that there is no unclosed file warning
-        pytest.warns(None, open, f)


 def test_questionable():
@@ -43,6 +40,7 @@
         "rgb32fakealpha.bmp",
         "rgb24largepal.bmp",
         "pal8os2sp.bmp",
+        "pal8rletrns.bmp",
         "rgb32bf-xbgr.bmp",
     ]
     for f in get_files("q"):
('Tests', 'test_image.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,19 +1,22 @@
 import io
 import os
 import shutil
+import sys
 import tempfile
+import warnings

 import pytest

-import PIL
-from PIL import Image, ImageDraw, ImagePalette, ImageShow, UnidentifiedImageError
+from PIL import Image, ImageDraw, ImagePalette, UnidentifiedImageError

 from .helper import (
     assert_image_equal,
-    assert_image_similar,
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
     assert_not_all_same,
     hopper,
     is_win32,
+    mark_if_feature_version,
     skip_unless_feature,
 )

@@ -87,16 +90,29 @@
         # with pytest.raises(MemoryError):
         #   Image.new("L", (1000000, 1000000))

+    def test_repr_pretty(self):
+        class Pretty:
+            def text(self, text):
+                self.pretty_output = text
+
+        im = Image.new("L", (100, 100))
+
+        p = Pretty()
+        im._repr_pretty_(p, None)
+        assert p.pretty_output == "<PIL.Image.Image image mode=L size=100x100>"
+
     def test_open_formats(self):
         PNGFILE = "Tests/images/hopper.png"
         JPGFILE = "Tests/images/hopper.jpg"

         with pytest.raises(TypeError):
-            Image.open(PNGFILE, formats=123)
-
-        for formats in [["JPEG"], ("JPEG",)]:
+            with Image.open(PNGFILE, formats=123):
+                pass
+
+        for formats in [["JPEG"], ("JPEG",), ["jpeg"], ["Jpeg"], ["jPeG"], ["JpEg"]]:
             with pytest.raises(UnidentifiedImageError):
-                Image.open(PNGFILE, formats=formats)
+                with Image.open(PNGFILE, formats=formats):
+                    pass

             with Image.open(JPGFILE, formats=formats) as im:
                 assert im.mode == "RGB"
@@ -120,15 +136,18 @@

         im = io.BytesIO(b"")
         with pytest.raises(UnidentifiedImageError):
-            Image.open(im)
+            with Image.open(im):
+                pass

     def test_bad_mode(self):
         with pytest.raises(ValueError):
-            Image.open("filename", "bad mode")
+            with Image.open("filename", "bad mode"):
+                pass

     def test_stringio(self):
         with pytest.raises(ValueError):
-            Image.open(io.StringIO())
+            with Image.open(io.StringIO()):
+                pass

     def test_pathlib(self, tmp_path):
         from PIL.Image import Path
@@ -141,10 +160,11 @@
             assert im.mode == "RGB"
             assert im.size == (128, 128)

-            temp_file = str(tmp_path / "temp.jpg")
-            if os.path.exists(temp_file):
-                os.remove(temp_file)
-            im.save(Path(temp_file))
+            for ext in (".jpg", ".jp2"):
+                temp_file = str(tmp_path / ("temp." + ext))
+                if os.path.exists(temp_file):
+                    os.remove(temp_file)
+                im.save(Path(temp_file))

     def test_fp_name(self, tmp_path):
         temp_file = str(tmp_path / "temp.jpg")
@@ -166,8 +186,7 @@
         with tempfile.TemporaryFile() as fp:
             im.save(fp, "JPEG")
             fp.seek(0)
-            with Image.open(fp) as reloaded:
-                assert_image_similar(im, reloaded, 20)
+            assert_image_similar_tofile(im, fp, 20)

     def test_unknown_extension(self, tmp_path):
         im = hopper()
@@ -186,6 +205,10 @@
         assert not im.readonly

     @pytest.mark.skipif(is_win32(), reason="Test requires opening tempfile twice")
+    @pytest.mark.skipif(
+        sys.platform == "cygwin",
+        reason="Test requires opening an mmaped file for writing",
+    )
     def test_readonly_save(self, tmp_path):
         temp_file = str(tmp_path / "temp.bmp")
         shutil.copy("Tests/images/rgb32bf-rgba.bmp", temp_file)
@@ -339,6 +362,12 @@
         assert_image_equal(offset.crop((64, 64, 127, 127)), target.crop((0, 0, 63, 63)))
         assert offset.size == (128, 128)

+        # with negative offset
+        offset = src.copy()
+        offset.alpha_composite(over, (-64, -64))
+        assert_image_equal(offset.crop((0, 0, 63, 63)), target.crop((64, 64, 127, 127)))
+        assert offset.size == (128, 128)
+
         # offset and crop
         box = src.copy()
         box.alpha_composite(over, (64, 64), (0, 0, 32, 32))
@@ -363,8 +392,6 @@
         with pytest.raises(ValueError):
             source.alpha_composite(over, (0, 0), 0)
         with pytest.raises(ValueError):
-            source.alpha_composite(over, (0, -1))
-        with pytest.raises(ValueError):
             source.alpha_composite(over, (0, 0), (0, -1))

     def test_registered_extensions_uninitialized(self):
@@ -408,8 +435,7 @@

         # Assert
         assert im.size == (512, 512)
-        with Image.open("Tests/images/effect_mandelbrot.png") as im2:
-            assert_image_equal(im, im2)
+        assert_image_equal_tofile(im, "Tests/images/effect_mandelbrot.png")

     def test_effect_mandelbrot_bad_arguments(self):
         # Arrange
@@ -451,8 +477,7 @@

         # Assert
         assert im.size == (128, 128)
-        with Image.open("Tests/images/effect_spread.png") as im3:
-            assert_image_similar(im2, im3, 110)
+        assert_image_similar_tofile(im2, "Tests/images/effect_spread.png", 110)

     def test_effect_spread_zero(self):
         # Arrange
@@ -516,7 +541,7 @@

         # Arrange
         target_file = "Tests/images/linear_gradient.png"
-        for mode in ["L", "P"]:
+        for mode in ["L", "P", "I", "F"]:

             # Act
             im = Image.linear_gradient(mode)
@@ -542,7 +567,7 @@

         # Arrange
         target_file = "Tests/images/radial_gradient.png"
-        for mode in ["L", "P"]:
+        for mode in ["L", "P", "I", "F"]:

             # Act
             im = Image.radial_gradient(mode)
@@ -573,6 +598,10 @@
         assert ext_individual == ext_multiple

     def test_remap_palette(self):
+        # Test identity transform
+        with Image.open("Tests/images/hopper.gif") as im:
+            assert_image_equal(im, im.remap_palette(list(range(256))))
+
         # Test illegal image mode
         with hopper() as im:
             with pytest.raises(ValueError):
@@ -597,7 +626,7 @@
             else:
                 assert new_im.palette is None

-        _make_new(im, im_p, im_p.palette)
+        _make_new(im, im_p, ImagePalette.ImagePalette(list(range(256)) * 3))
         _make_new(im_p, im, None)
         _make_new(im, blank_p, ImagePalette.ImagePalette())
         _make_new(im, blank_pa, ImagePalette.ImagePalette())
@@ -612,22 +641,6 @@
             expected = Image.new(mode, (100, 100), color)
             assert_image_equal(im.convert(mode), expected)

-    def test_showxv_deprecation(self):
-        class TestViewer(ImageShow.Viewer):
-            def show_image(self, image, **options):
-                return True
-
-        viewer = TestViewer()
-        ImageShow.register(viewer, -1)
-
-        im = Image.new("RGB", (50, 50), "white")
-
-        with pytest.warns(DeprecationWarning):
-            Image._showxv(im)
-
-        # Restore original state
-        ImageShow._viewers.pop(0)
-
     def test_no_resource_warning_on_save(self, tmp_path):
         # https://github.com/python-pillow/Pillow/issues/835
         # Arrange
@@ -636,7 +649,17 @@

         # Act/Assert
         with Image.open(test_file) as im:
-            pytest.warns(None, im.save, temp_file)
+            with warnings.catch_warnings():
+                im.save(temp_file)
+
+    def test_no_new_file_on_error(self, tmp_path):
+        temp_file = str(tmp_path / "temp.jpg")
+
+        im = Image.new("RGB", (0, 0))
+        with pytest.raises(ValueError):
+            im.save(temp_file)
+
+        assert not os.path.exists(temp_file)

     def test_load_on_nonexclusive_multiframe(self):
         with open("Tests/images/frozenpond.mpo", "rb") as fp:
@@ -652,48 +675,64 @@

             assert not fp.closed

+    def test_empty_exif(self):
+        with Image.open("Tests/images/exif.png") as im:
+            exif = im.getexif()
+        assert dict(exif) != {}
+
+        # Test that exif data is cleared after another load
+        exif.load(None)
+        assert dict(exif) == {}
+
+        # Test loading just the EXIF header
+        exif.load(b"Exif\x00\x00")
+        assert dict(exif) == {}
+
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_exif_jpeg(self, tmp_path):
         with Image.open("Tests/images/exif-72dpi-int.jpg") as im:  # Little endian
             exif = im.getexif()
             assert 258 not in exif
             assert 274 in exif
-            assert 40960 in exif
-            assert exif[40963] == 450
+            assert 282 in exif
+            assert exif[296] == 2
             assert exif[11] == "gThumb 3.0.1"

             out = str(tmp_path / "temp.jpg")
             exif[258] = 8
             del exif[274]
-            del exif[40960]
-            exif[40963] = 455
+            del exif[282]
+            exif[296] = 455
             exif[11] = "Pillow test"
             im.save(out, exif=exif)
         with Image.open(out) as reloaded:
             reloaded_exif = reloaded.getexif()
             assert reloaded_exif[258] == 8
             assert 274 not in reloaded_exif
-            assert 40960 not in reloaded_exif
-            assert reloaded_exif[40963] == 455
+            assert 282 not in reloaded_exif
+            assert reloaded_exif[296] == 455
             assert reloaded_exif[11] == "Pillow test"

         with Image.open("Tests/images/no-dpi-in-exif.jpg") as im:  # Big endian
             exif = im.getexif()
             assert 258 not in exif
-            assert 40962 in exif
-            assert exif[40963] == 200
+            assert 306 in exif
+            assert exif[274] == 1
             assert exif[305] == "Adobe Photoshop CC 2017 (Macintosh)"

             out = str(tmp_path / "temp.jpg")
             exif[258] = 8
-            del exif[34665]
-            exif[40963] = 455
+            del exif[306]
+            exif[274] = 455
             exif[305] = "Pillow test"
             im.save(out, exif=exif)
         with Image.open(out) as reloaded:
             reloaded_exif = reloaded.getexif()
             assert reloaded_exif[258] == 8
-            assert 34665 not in reloaded_exif
-            assert reloaded_exif[40963] == 455
+            assert 306 not in reloaded_exif
+            assert reloaded_exif[274] == 455
             assert reloaded_exif[305] == "Pillow test"

     @skip_unless_feature("webp")
@@ -746,34 +785,80 @@
                 4098: 1704,
             }

-    @pytest.mark.parametrize(
-        "test_module",
-        [PIL, Image],
-    )
-    def test_pillow_version(self, test_module):
+            reloaded_exif = Image.Exif()
+            reloaded_exif.load(exif.tobytes())
+            assert reloaded_exif.get_ifd(0xA005) == exif.get_ifd(0xA005)
+
+    def test_exif_ifd(self):
+        with Image.open("Tests/images/flower.jpg") as im:
+            exif = im.getexif()
+        del exif.get_ifd(0x8769)[0xA005]
+
+        reloaded_exif = Image.Exif()
+        reloaded_exif.load(exif.tobytes())
+        assert reloaded_exif.get_ifd(0x8769) == exif.get_ifd(0x8769)
+
+    def test_exif_load_from_fp(self):
+        with Image.open("Tests/images/flower.jpg") as im:
+            data = im.info["exif"]
+            if data.startswith(b"Exif\x00\x00"):
+                data = data[6:]
+            fp = io.BytesIO(data)
+
+            exif = Image.Exif()
+            exif.load_from_fp(fp)
+            assert exif == {
+                271: "Canon",
+                272: "Canon PowerShot S40",
+                274: 1,
+                282: 180.0,
+                283: 180.0,
+                296: 2,
+                306: "2003:12:14 12:01:44",
+                531: 1,
+                34665: 196,
+            }
+
+    @pytest.mark.parametrize("size", ((1, 0), (0, 1), (0, 0)))
+    def test_zero_tobytes(self, size):
+        im = Image.new("RGB", size)
+        assert im.tobytes() == b""
+
+    def test_categories_deprecation(self):
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION == PIL.__version__
+            assert hopper().category == 0

         with pytest.warns(DeprecationWarning):
-            str(test_module.PILLOW_VERSION)
-
+            assert Image.NORMAL == 0
         with pytest.warns(DeprecationWarning):
-            assert int(test_module.PILLOW_VERSION[0]) >= 7
-
+            assert Image.SEQUENCE == 1
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION < "9.9.0"
-
+            assert Image.CONTAINER == 2
+
+    def test_constants_deprecation(self):
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION <= "9.9.0"
-
+            assert Image.NEAREST == 0
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION != "7.0.0"
+            assert Image.NONE == 0

         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION >= "7.0.0"
-
+            assert Image.LINEAR == Image.Resampling.BILINEAR
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION > "7.0.0"
+            assert Image.CUBIC == Image.Resampling.BICUBIC
+        with pytest.warns(DeprecationWarning):
+            assert Image.ANTIALIAS == Image.Resampling.LANCZOS
+
+        for enum in (
+            Image.Transpose,
+            Image.Transform,
+            Image.Resampling,
+            Image.Dither,
+            Image.Palette,
+            Image.Quantize,
+        ):
+            for name in enum.__members__:
+                with pytest.warns(DeprecationWarning):
+                    assert getattr(Image, name) == enum[name]

     @pytest.mark.parametrize(
         "path",
@@ -810,18 +895,6 @@
             except OSError as e:
                 assert str(e) == "buffer overrun when reading image file"

-    def test_show_deprecation(self, monkeypatch):
-        monkeypatch.setattr(Image, "_show", lambda *args, **kwargs: None)
-
-        im = Image.new("RGB", (50, 50), "white")
-
-        with pytest.warns(None) as raised:
-            im.show()
-        assert not raised
-
-        with pytest.warns(DeprecationWarning):
-            im.show(command="mock")
-

 class MockEncoder:
     pass
('Tests', 'test_imageqt.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,20 +1,27 @@
+import warnings
+
 import pytest

 from PIL import ImageQt

-from .helper import hopper
+from .helper import assert_image_similar, hopper
+
+pytestmark = pytest.mark.skipif(
+    not ImageQt.qt_is_installed, reason="Qt bindings are not installed"
+)

 if ImageQt.qt_is_installed:
     from PIL.ImageQt import qRgba


-@pytest.mark.skipif(not ImageQt.qt_is_installed, reason="Qt bindings are not installed")
 def test_rgb():
     # from https://doc.qt.io/archives/qt-4.8/qcolor.html
     # typedef QRgb
     # An ARGB quadruplet on the format #AARRGGBB,
     # equivalent to an unsigned int.
-    if ImageQt.qt_version == "side6":
+    if ImageQt.qt_version == "6":
+        from PyQt6.QtGui import qRgb
+    elif ImageQt.qt_version == "side6":
         from PySide6.QtGui import qRgb
     elif ImageQt.qt_version == "5":
         from PyQt5.QtGui import qRgb
@@ -25,10 +32,10 @@

     def checkrgb(r, g, b):
         val = ImageQt.rgb(r, g, b)
-        val = val % 2 ** 24  # drop the alpha
+        val = val % 2**24  # drop the alpha
         assert val >> 16 == r
-        assert ((val >> 8) % 2 ** 8) == g
-        assert val % 2 ** 8 == b
+        assert ((val >> 8) % 2**8) == g
+        assert val % 2**8 == b

     checkrgb(0, 0, 0)
     checkrgb(255, 0, 0)
@@ -36,7 +43,20 @@
     checkrgb(0, 0, 255)


-@pytest.mark.skipif(not ImageQt.qt_is_installed, reason="Qt bindings are not installed")
 def test_image():
-    for mode in ("1", "RGB", "RGBA", "L", "P"):
-        ImageQt.ImageQt(hopper(mode))
+    modes = ["1", "RGB", "RGBA", "L", "P"]
+    qt_format = ImageQt.QImage.Format if ImageQt.qt_version == "6" else ImageQt.QImage
+    if hasattr(qt_format, "Format_Grayscale16"):  # Qt 5.13+
+        modes.append("I;16")
+
+    for mode in modes:
+        im = hopper(mode)
+        roundtripped_im = ImageQt.fromqimage(ImageQt.ImageQt(im))
+        if mode not in ("RGB", "RGBA"):
+            im = im.convert("RGB")
+        assert_image_similar(roundtripped_im, im, 1)
+
+
+def test_closed_file():
+    with warnings.catch_warnings():
+        ImageQt.ImageQt("Tests/images/hopper.gif")
('Tests', 'test_file_ftex.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,15 +1,32 @@
-from PIL import Image
+import pytest

-from .helper import assert_image_equal, assert_image_similar
+from PIL import FtexImagePlugin, Image
+
+from .helper import assert_image_equal_tofile, assert_image_similar


 def test_load_raw():
     with Image.open("Tests/images/ftex_uncompressed.ftu") as im:
-        with Image.open("Tests/images/ftex_uncompressed.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/ftex_uncompressed.png")


 def test_load_dxt1():
     with Image.open("Tests/images/ftex_dxt1.ftc") as im:
         with Image.open("Tests/images/ftex_dxt1.png") as target:
             assert_image_similar(im, target.convert("RGBA"), 15)
+
+
+def test_invalid_file():
+    invalid_file = "Tests/images/flower.jpg"
+
+    with pytest.raises(SyntaxError):
+        FtexImagePlugin.FtexImageFile(invalid_file)
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        FtexImagePlugin.Format: "FORMAT_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(FtexImagePlugin, prefix + name) == enum[name]
('Tests', 'test_file_wmf.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@

 from PIL import Image, WmfImagePlugin

-from .helper import assert_image_similar, hopper
+from .helper import assert_image_similar_tofile, hopper


 def test_load_raw():
@@ -13,9 +13,7 @@
             # Currently, support for WMF/EMF is Windows-only
             im.load()
             # Compare to reference rendering
-            with Image.open("Tests/images/drawing_emf_ref.png") as imref:
-                imref.load()
-                assert_image_similar(im, imref, 0)
+            assert_image_similar_tofile(im, "Tests/images/drawing_emf_ref.png", 0)

     # Test basic WMF open and rendering
     with Image.open("Tests/images/drawing.wmf") as im:
@@ -23,9 +21,13 @@
             # Currently, support for WMF/EMF is Windows-only
             im.load()
             # Compare to reference rendering
-            with Image.open("Tests/images/drawing_wmf_ref.png") as imref:
-                imref.load()
-                assert_image_similar(im, imref, 2.0)
+            assert_image_similar_tofile(im, "Tests/images/drawing_wmf_ref.png", 2.0)
+
+
+def test_load():
+    with Image.open("Tests/images/drawing.emf") as im:
+        if hasattr(Image.core, "drawwmf"):
+            assert im.load()[0, 0] == (255, 255, 255)


 def test_register_handler(tmp_path):
@@ -48,14 +50,9 @@
     WmfImagePlugin.register_handler(original_handler)


-def test_load_dpi_rounding():
-    # Round up
+def test_load_float_dpi():
     with Image.open("Tests/images/drawing.emf") as im:
-        assert im.info["dpi"] == 1424
-
-    # Round down
-    with Image.open("Tests/images/drawing_roundDown.emf") as im:
-        assert im.info["dpi"] == 1426
+        assert im.info["dpi"] == 1423.7668161434979


 def test_load_set_dpi():
@@ -66,8 +63,7 @@
             im.load(144)
             assert im.size == (164, 164)

-            with Image.open("Tests/images/drawing_wmf_ref_144.png") as expected:
-                assert_image_similar(im, expected, 2.1)
+            assert_image_similar_tofile(im, "Tests/images/drawing_wmf_ref_144.png", 2.1)


 def test_save(tmp_path):
('Tests', 'test_imagepalette.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,31 +2,75 @@

 from PIL import Image, ImagePalette

-from .helper import assert_image_equal
+from .helper import assert_image_equal, assert_image_equal_tofile


 def test_sanity():

-    ImagePalette.ImagePalette("RGB", list(range(256)) * 3)
-    with pytest.raises(ValueError):
-        ImagePalette.ImagePalette("RGB", list(range(256)) * 2)
+    palette = ImagePalette.ImagePalette("RGB", list(range(256)) * 3)
+    assert len(palette.colors) == 256
+
+    with pytest.warns(DeprecationWarning):
+        with pytest.raises(ValueError):
+            ImagePalette.ImagePalette("RGB", list(range(256)) * 3, 10)
+
+
+def test_reload():
+    with Image.open("Tests/images/hopper.gif") as im:
+        original = im.copy()
+        im.palette.dirty = 1
+        assert_image_equal(im.convert("RGB"), original.convert("RGB"))


 def test_getcolor():

     palette = ImagePalette.ImagePalette()
+    assert len(palette.palette) == 0
+    assert len(palette.colors) == 0

     test_map = {}
     for i in range(256):
         test_map[palette.getcolor((i, i, i))] = i
+    assert len(test_map) == 256

-    assert len(test_map) == 256
+    # Colors can be converted between RGB and RGBA
+    rgba_palette = ImagePalette.ImagePalette("RGBA")
+    assert rgba_palette.getcolor((0, 0, 0)) == rgba_palette.getcolor((0, 0, 0, 255))
+
+    assert palette.getcolor((0, 0, 0)) == palette.getcolor((0, 0, 0, 255))
+
+    # An error is raised when the palette is full
     with pytest.raises(ValueError):
         palette.getcolor((1, 2, 3))
+    # But not if the image is not using one of the palette entries
+    palette.getcolor((1, 2, 3), image=Image.new("P", (1, 1)))

     # Test unknown color specifier
     with pytest.raises(ValueError):
         palette.getcolor("unknown")
+
+
+@pytest.mark.parametrize(
+    "index, palette",
+    [
+        # Test when the palette is not full
+        (0, ImagePalette.ImagePalette()),
+        # Test when the palette is full
+        (255, ImagePalette.ImagePalette("RGB", list(range(256)) * 3)),
+    ],
+)
+def test_getcolor_not_special(index, palette):
+    im = Image.new("P", (1, 1))
+
+    # Do not use transparency index as a new color
+    im.info["transparency"] = index
+    index1 = palette.getcolor((0, 0, 0), im)
+    assert index1 != index
+
+    # Do not use background index as a new color
+    im.info["background"] = index1
+    index2 = palette.getcolor((0, 0, 1), im)
+    assert index2 not in (index, index1)


 def test_file(tmp_path):
@@ -116,7 +160,7 @@
     mode, data_out = palette.getdata()

     # Assert
-    assert mode == "RGB;L"
+    assert mode == "RGB"


 def test_rawmode_getdata():
@@ -141,8 +185,7 @@
     img.putpalette(b"\xFF\x00\x00\x00\xFF\x00\x00\x00\xFF")  # RGB
     img.save(outfile, format="PNG")

-    with Image.open(outfile) as reloaded:
-        assert_image_equal(img, reloaded)
+    assert_image_equal_tofile(img, outfile)


 def test_invalid_palette():
('Tests', 'test_file_spider.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,11 +1,12 @@
 import tempfile
+import warnings
 from io import BytesIO

 import pytest

 from PIL import Image, ImageSequence, SpiderImagePlugin

-from .helper import assert_image_equal, hopper, is_pypy
+from .helper import assert_image_equal_tofile, hopper, is_pypy

 TEST_FILE = "Tests/images/hopper.spider"

@@ -28,20 +29,16 @@


 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(TEST_FILE)
         im.load()
         im.close()

-    pytest.warns(None, open)
-

 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(TEST_FILE) as im:
             im.load()
-
-    pytest.warns(None, open)


 def test_save(tmp_path):
@@ -136,7 +133,8 @@
     invalid_file = "Tests/images/invalid.spider"

     with pytest.raises(OSError):
-        Image.open(invalid_file)
+        with Image.open(invalid_file):
+            pass


 def test_nonstack_file():
@@ -159,5 +157,4 @@
     im.save(data, format="SPIDER")

     data.seek(0)
-    with Image.open(data) as im2:
-        assert_image_equal(im, im2)
+    assert_image_equal_tofile(im, data)
('Tests', 'test_file_eps.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,13 @@

 from PIL import EpsImagePlugin, Image, features

-from .helper import assert_image_similar, hopper, skip_unless_feature
+from .helper import (
+    assert_image_similar,
+    assert_image_similar_tofile,
+    hopper,
+    mark_if_feature_version,
+    skip_unless_feature,
+)

 HAS_GHOSTSCRIPT = EpsImagePlugin.has_ghostscript()

@@ -52,6 +58,15 @@
         assert image2_scale2.format == "EPS"


+@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason="Ghostscript not available")
+def test_load():
+    with Image.open(FILE1) as im:
+        assert im.load()[0, 0] == (255, 255, 255)
+
+        # Test again now that it has already been loaded once
+        assert im.load()[0, 0] == (255, 255, 255)
+
+
 def test_invalid_file():
     invalid_file = "Tests/images/flower.jpg"

@@ -59,6 +74,9 @@
         EpsImagePlugin.EpsImageFile(invalid_file)


+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 @pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason="Ghostscript not available")
 def test_cmyk():
     with Image.open("Tests/images/pil_sample_cmyk.eps") as cmyk_image:
@@ -71,8 +89,9 @@
         assert cmyk_image.mode == "RGB"

         if features.check("jpg"):
-            with Image.open("Tests/images/pil_sample_rgb.jpg") as target:
-                assert_image_similar(cmyk_image, target, 10)
+            assert_image_similar_tofile(
+                cmyk_image, "Tests/images/pil_sample_rgb.jpg", 10
+            )


 @pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason="Ghostscript not available")
@@ -82,6 +101,17 @@
         with Image.open("Tests/images/reqd_showpage.png") as target:
             # should not crash/hang
             plot_image.load()
+            #  fonts could be slightly different
+            assert_image_similar(plot_image, target, 6)
+
+
+@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason="Ghostscript not available")
+def test_transparency():
+    with Image.open("Tests/images/reqd_showpage.eps") as plot_image:
+        plot_image.load(transparency=True)
+        assert plot_image.mode == "RGBA"
+
+        with Image.open("Tests/images/reqd_showpage_transparency.png") as target:
             #  fonts could be slightly different
             assert_image_similar(plot_image, target, 6)

@@ -257,3 +287,15 @@
     assert image.mode == "RGB"
     assert image.size == (460, 352)
     assert image.format == "EPS"
+
+
+@pytest.mark.timeout(timeout=5)
+@pytest.mark.parametrize(
+    "test_file",
+    ["Tests/images/timeout-d675703545fee17acab56e5fec644c19979175de.eps"],
+)
+def test_timeout(test_file):
+    with open(test_file, "rb") as f:
+        with pytest.raises(Image.UnidentifiedImageError):
+            with Image.open(f):
+                pass
('Tests', 'test_image_transform.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -32,17 +32,24 @@
             new_im = im.transform((100, 100), transform)
         assert new_im.info["comment"] == comment

+    def test_palette(self):
+        with Image.open("Tests/images/hopper.gif") as im:
+            transformed = im.transform(
+                im.size, Image.Transform.AFFINE, [1, 0, 0, 0, 1, 0]
+            )
+            assert im.palette.palette == transformed.palette.palette
+
     def test_extent(self):
         im = hopper("RGB")
         (w, h) = im.size
         # fmt: off
-        transformed = im.transform(im.size, Image.EXTENT,
+        transformed = im.transform(im.size, Image.Transform.EXTENT,
                                    (0, 0,
                                     w//2, h//2),  # ul -> lr
-                                   Image.BILINEAR)
+                                   Image.Resampling.BILINEAR)
         # fmt: on

-        scaled = im.resize((w * 2, h * 2), Image.BILINEAR).crop((0, 0, w, h))
+        scaled = im.resize((w * 2, h * 2), Image.Resampling.BILINEAR).crop((0, 0, w, h))

         # undone -- precision?
         assert_image_similar(transformed, scaled, 23)
@@ -52,15 +59,18 @@
         im = hopper("RGB")
         (w, h) = im.size
         # fmt: off
-        transformed = im.transform(im.size, Image.QUAD,
+        transformed = im.transform(im.size, Image.Transform.QUAD,
                                    (0, 0, 0, h//2,
                                     # ul -> ccw around quad:
                                     w//2, h//2, w//2, 0),
-                                   Image.BILINEAR)
+                                   Image.Resampling.BILINEAR)
         # fmt: on

         scaled = im.transform(
-            (w, h), Image.AFFINE, (0.5, 0, 0, 0, 0.5, 0), Image.BILINEAR
+            (w, h),
+            Image.Transform.AFFINE,
+            (0.5, 0, 0, 0, 0.5, 0),
+            Image.Resampling.BILINEAR,
         )

         assert_image_equal(transformed, scaled)
@@ -75,9 +85,9 @@
             (w, h) = im.size
             transformed = im.transform(
                 im.size,
-                Image.EXTENT,
+                Image.Transform.EXTENT,
                 (0, 0, w * 2, h * 2),
-                Image.BILINEAR,
+                Image.Resampling.BILINEAR,
                 fillcolor="red",
             )

@@ -88,18 +98,21 @@
         im = hopper("RGBA")
         (w, h) = im.size
         # fmt: off
-        transformed = im.transform(im.size, Image.MESH,
+        transformed = im.transform(im.size, Image.Transform.MESH,
                                    [((0, 0, w//2, h//2),  # box
                                     (0, 0, 0, h,
                                      w, h, w, 0)),  # ul -> ccw around quad
                                     ((w//2, h//2, w, h),  # box
                                     (0, 0, 0, h,
                                      w, h, w, 0))],  # ul -> ccw around quad
-                                   Image.BILINEAR)
+                                   Image.Resampling.BILINEAR)
         # fmt: on

         scaled = im.transform(
-            (w // 2, h // 2), Image.AFFINE, (2, 0, 0, 0, 2, 0), Image.BILINEAR
+            (w // 2, h // 2),
+            Image.Transform.AFFINE,
+            (2, 0, 0, 0, 2, 0),
+            Image.Resampling.BILINEAR,
         )

         checker = Image.new("RGBA", im.size)
@@ -132,16 +145,55 @@

     def test_alpha_premult_resize(self):
         def op(im, sz):
-            return im.resize(sz, Image.BILINEAR)
+            return im.resize(sz, Image.Resampling.BILINEAR)

         self._test_alpha_premult(op)

     def test_alpha_premult_transform(self):
         def op(im, sz):
             (w, h) = im.size
-            return im.transform(sz, Image.EXTENT, (0, 0, w, h), Image.BILINEAR)
+            return im.transform(
+                sz, Image.Transform.EXTENT, (0, 0, w, h), Image.Resampling.BILINEAR
+            )

         self._test_alpha_premult(op)
+
+    def _test_nearest(self, op, mode):
+        # create white image with half transparent,
+        # do op,
+        # the image should remain white with half transparent
+        transparent, opaque = {
+            "RGBA": ((255, 255, 255, 0), (255, 255, 255, 255)),
+            "LA": ((255, 0), (255, 255)),
+        }[mode]
+        im = Image.new(mode, (10, 10), transparent)
+        im2 = Image.new(mode, (5, 10), opaque)
+        im.paste(im2, (0, 0))
+
+        im = op(im, (40, 10))
+
+        colors = im.getcolors()
+        assert colors == [
+            (20 * 10, opaque),
+            (20 * 10, transparent),
+        ]
+
+    @pytest.mark.parametrize("mode", ("RGBA", "LA"))
+    def test_nearest_resize(self, mode):
+        def op(im, sz):
+            return im.resize(sz, Image.Resampling.NEAREST)
+
+        self._test_nearest(op, mode)
+
+    @pytest.mark.parametrize("mode", ("RGBA", "LA"))
+    def test_nearest_transform(self, mode):
+        def op(im, sz):
+            (w, h) = im.size
+            return im.transform(
+                sz, Image.Transform.EXTENT, (0, 0, w, h), Image.Resampling.NEAREST
+            )
+
+        self._test_nearest(op, mode)

     def test_blank_fill(self):
         # attempting to hit
@@ -173,13 +225,15 @@
     def test_unknown_resampling_filter(self):
         with hopper() as im:
             (w, h) = im.size
-            for resample in (Image.BOX, "unknown"):
+            for resample in (Image.Resampling.BOX, "unknown"):
                 with pytest.raises(ValueError):
-                    im.transform((100, 100), Image.EXTENT, (0, 0, w, h), resample)
+                    im.transform(
+                        (100, 100), Image.Transform.EXTENT, (0, 0, w, h), resample
+                    )


 class TestImageTransformAffine:
-    transform = Image.AFFINE
+    transform = Image.Transform.AFFINE

     def _test_image(self):
         im = hopper("RGB")
@@ -207,7 +261,11 @@
         else:
             transposed = im

-        for resample in [Image.NEAREST, Image.BILINEAR, Image.BICUBIC]:
+        for resample in [
+            Image.Resampling.NEAREST,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.BICUBIC,
+        ]:
             transformed = im.transform(
                 transposed.size, self.transform, matrix, resample
             )
@@ -217,13 +275,13 @@
         self._test_rotate(0, None)

     def test_rotate_90_deg(self):
-        self._test_rotate(90, Image.ROTATE_90)
+        self._test_rotate(90, Image.Transpose.ROTATE_90)

     def test_rotate_180_deg(self):
-        self._test_rotate(180, Image.ROTATE_180)
+        self._test_rotate(180, Image.Transpose.ROTATE_180)

     def test_rotate_270_deg(self):
-        self._test_rotate(270, Image.ROTATE_270)
+        self._test_rotate(270, Image.Transpose.ROTATE_270)

     def _test_resize(self, scale, epsilonscale):
         im = self._test_image()
@@ -233,9 +291,9 @@
         matrix_down = [scale, 0, 0, 0, scale, 0, 0, 0]

         for resample, epsilon in [
-            (Image.NEAREST, 0),
-            (Image.BILINEAR, 2),
-            (Image.BICUBIC, 1),
+            (Image.Resampling.NEAREST, 0),
+            (Image.Resampling.BILINEAR, 2),
+            (Image.Resampling.BICUBIC, 1),
         ]:
             transformed = im.transform(size_up, self.transform, matrix_up, resample)
             transformed = transformed.transform(
@@ -266,9 +324,9 @@
         matrix_down = [1, 0, x, 0, 1, y, 0, 0]

         for resample, epsilon in [
-            (Image.NEAREST, 0),
-            (Image.BILINEAR, 1.5),
-            (Image.BICUBIC, 1),
+            (Image.Resampling.NEAREST, 0),
+            (Image.Resampling.BILINEAR, 1.5),
+            (Image.Resampling.BICUBIC, 1),
         ]:
             transformed = im.transform(size_up, self.transform, matrix_up, resample)
             transformed = transformed.transform(
@@ -288,4 +346,4 @@

 class TestImageTransformPerspective(TestImageTransformAffine):
     # Repeat all tests for AFFINE transformations with PERSPECTIVE
-    transform = Image.PERSPECTIVE
+    transform = Image.Transform.PERSPECTIVE
('Tests', '32bit_segfault_check.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,8 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3

 import sys

 from PIL import Image

-if sys.maxsize < 2 ** 32:
+if sys.maxsize < 2**32:
     im = Image.new("L", (999999, 999999), 0)
('Tests', 'test_image_resize.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -7,7 +7,12 @@

 from PIL import Image

-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar,
+    hopper,
+)


 class TestImagingCoreResize:
@@ -30,33 +35,33 @@
             "I;16",
         ]:  # exotic mode
             im = hopper(mode)
-            r = self.resize(im, (15, 12), Image.NEAREST)
+            r = self.resize(im, (15, 12), Image.Resampling.NEAREST)
             assert r.mode == mode
             assert r.size == (15, 12)
             assert r.im.bands == im.im.bands

     def test_convolution_modes(self):
         with pytest.raises(ValueError):
-            self.resize(hopper("1"), (15, 12), Image.BILINEAR)
-        with pytest.raises(ValueError):
-            self.resize(hopper("P"), (15, 12), Image.BILINEAR)
-        with pytest.raises(ValueError):
-            self.resize(hopper("I;16"), (15, 12), Image.BILINEAR)
+            self.resize(hopper("1"), (15, 12), Image.Resampling.BILINEAR)
+        with pytest.raises(ValueError):
+            self.resize(hopper("P"), (15, 12), Image.Resampling.BILINEAR)
+        with pytest.raises(ValueError):
+            self.resize(hopper("I;16"), (15, 12), Image.Resampling.BILINEAR)
         for mode in ["L", "I", "F", "RGB", "RGBA", "CMYK", "YCbCr"]:
             im = hopper(mode)
-            r = self.resize(im, (15, 12), Image.BILINEAR)
+            r = self.resize(im, (15, 12), Image.Resampling.BILINEAR)
             assert r.mode == mode
             assert r.size == (15, 12)
             assert r.im.bands == im.im.bands

     def test_reduce_filters(self):
         for f in [
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ]:
             r = self.resize(hopper("RGB"), (15, 12), f)
             assert r.mode == "RGB"
@@ -64,12 +69,12 @@

     def test_enlarge_filters(self):
         for f in [
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ]:
             r = self.resize(hopper("RGB"), (212, 195), f)
             assert r.mode == "RGB"
@@ -90,12 +95,12 @@
         samples["dirty"].putpixel((1, 1), 128)

         for f in [
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ]:
             # samples resized with current filter
             references = {
@@ -119,12 +124,12 @@

     def test_enlarge_zero(self):
         for f in [
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ]:
             r = self.resize(Image.new("RGB", (0, 0), "white"), (212, 195), f)
             assert r.mode == "RGB"
@@ -135,11 +140,22 @@
         with pytest.raises(ValueError):
             self.resize(hopper(), (10, 10), 9)

+    def test_cross_platform(self, tmp_path):
+        # This test is intended for only check for consistent behaviour across
+        # platforms. So if a future Pillow change requires that the test file
+        # be updated, that is okay.
+        im = hopper().resize((64, 64))
+        temp_file = str(tmp_path / "temp.gif")
+        im.save(temp_file)
+
+        with Image.open(temp_file) as reloaded:
+            assert_image_equal_tofile(reloaded, "Tests/images/hopper_resized.gif")
+

 @pytest.fixture
 def gradients_image():
-    im = Image.open("Tests/images/radial_gradients.png")
-    im.load()
+    with Image.open("Tests/images/radial_gradients.png") as im:
+        im.load()
     try:
         yield im
     finally:
@@ -148,15 +164,19 @@

 class TestReducingGapResize:
     def test_reducing_gap_values(self, gradients_image):
-        ref = gradients_image.resize((52, 34), Image.BICUBIC, reducing_gap=None)
-        im = gradients_image.resize((52, 34), Image.BICUBIC)
+        ref = gradients_image.resize(
+            (52, 34), Image.Resampling.BICUBIC, reducing_gap=None
+        )
+        im = gradients_image.resize((52, 34), Image.Resampling.BICUBIC)
         assert_image_equal(ref, im)

         with pytest.raises(ValueError):
-            gradients_image.resize((52, 34), Image.BICUBIC, reducing_gap=0)
-
-        with pytest.raises(ValueError):
-            gradients_image.resize((52, 34), Image.BICUBIC, reducing_gap=0.99)
+            gradients_image.resize((52, 34), Image.Resampling.BICUBIC, reducing_gap=0)
+
+        with pytest.raises(ValueError):
+            gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, reducing_gap=0.99
+            )

     def test_reducing_gap_1(self, gradients_image):
         for box, epsilon in [
@@ -164,9 +184,9 @@
             ((1.1, 2.2, 510.8, 510.9), 4),
             ((3, 10, 410, 256), 10),
         ]:
-            ref = gradients_image.resize((52, 34), Image.BICUBIC, box=box)
-            im = gradients_image.resize(
-                (52, 34), Image.BICUBIC, box=box, reducing_gap=1.0
+            ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=1.0
             )

             with pytest.raises(AssertionError):
@@ -180,9 +200,9 @@
             ((1.1, 2.2, 510.8, 510.9), 1.5),
             ((3, 10, 410, 256), 1),
         ]:
-            ref = gradients_image.resize((52, 34), Image.BICUBIC, box=box)
-            im = gradients_image.resize(
-                (52, 34), Image.BICUBIC, box=box, reducing_gap=2.0
+            ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=2.0
             )

             with pytest.raises(AssertionError):
@@ -196,9 +216,9 @@
             ((1.1, 2.2, 510.8, 510.9), 1),
             ((3, 10, 410, 256), 0.5),
         ]:
-            ref = gradients_image.resize((52, 34), Image.BICUBIC, box=box)
-            im = gradients_image.resize(
-                (52, 34), Image.BICUBIC, box=box, reducing_gap=3.0
+            ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=3.0
             )

             with pytest.raises(AssertionError):
@@ -208,9 +228,9 @@

     def test_reducing_gap_8(self, gradients_image):
         for box in [None, (1.1, 2.2, 510.8, 510.9), (3, 10, 410, 256)]:
-            ref = gradients_image.resize((52, 34), Image.BICUBIC, box=box)
-            im = gradients_image.resize(
-                (52, 34), Image.BICUBIC, box=box, reducing_gap=8.0
+            ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=8.0
             )

             assert_image_equal(ref, im)
@@ -220,8 +240,10 @@
             ((0, 0, 512, 512), 5.5),
             ((0.9, 1.7, 128, 128), 9.5),
         ]:
-            ref = gradients_image.resize((52, 34), Image.BOX, box=box)
-            im = gradients_image.resize((52, 34), Image.BOX, box=box, reducing_gap=1.0)
+            ref = gradients_image.resize((52, 34), Image.Resampling.BOX, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BOX, box=box, reducing_gap=1.0
+            )

             assert_image_similar(ref, im, epsilon)

@@ -245,8 +267,12 @@
     def test_default_filter(self):
         for mode in "L", "RGB", "I", "F":
             im = hopper(mode)
-            assert im.resize((20, 20), Image.BICUBIC) == im.resize((20, 20))
+            assert im.resize((20, 20), Image.Resampling.BICUBIC) == im.resize((20, 20))

         for mode in "1", "P":
             im = hopper(mode)
-            assert im.resize((20, 20), Image.NEAREST) == im.resize((20, 20))
+            assert im.resize((20, 20), Image.Resampling.NEAREST) == im.resize((20, 20))
+
+        for mode in "I;16", "I;16L", "I;16B", "BGR;15", "BGR;16":
+            im = hopper(mode)
+            assert im.resize((20, 20), Image.Resampling.NEAREST) == im.resize((20, 20))
('Tests', 'test_format_hsv.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -77,7 +77,7 @@


 def test_wedge():
-    src = wedge().resize((3 * 32, 32), Image.BILINEAR)
+    src = wedge().resize((3 * 32, 32), Image.Resampling.BILINEAR)
     im = src.convert("HSV")
     comparable = to_hsv_colorsys(src)

('Tests', 'test_file_tiff_metadata.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -122,7 +122,7 @@


 def test_write_metadata(tmp_path):
-    """ Test metadata writing through the python code """
+    """Test metadata writing through the python code"""
     with Image.open("Tests/images/hopper.tif") as img:
         f = str(tmp_path / "temp.tiff")
         img.save(f, tiffinfo=img.tag)
@@ -179,6 +179,27 @@
     assert TAG_IDS["BestQualityScale"] == 50780


+def test_iptc(tmp_path):
+    out = str(tmp_path / "temp.tiff")
+    with Image.open("Tests/images/hopper.Lab.tif") as im:
+        im.save(out)
+
+
+def test_undefined_zero(tmp_path):
+    # Check that the tag has not been changed since this test was created
+    tag = TiffTags.TAGS_V2[45059]
+    assert tag.type == TiffTags.UNDEFINED
+    assert tag.length == 0
+
+    info = TiffImagePlugin.ImageFileDirectory(b"II*\x00\x08\x00\x00\x00")
+    info[45059] = b"test"
+
+    # Assert that the tag value does not change by setting it to itself
+    original = info[45059]
+    info[45059] = info[45059]
+    assert info[45059] == original
+
+
 def test_empty_metadata():
     f = io.BytesIO(b"II*\x00\x08\x00\x00\x00")
     head = f.read(8)
@@ -237,7 +258,7 @@
     im = hopper()
     info = TiffImagePlugin.ImageFileDirectory_v2()

-    max_long = 2 ** 32 - 1
+    max_long = 2**32 - 1

     # 4 bytes unsigned long
     numerator = max_long
@@ -269,8 +290,8 @@
     info = TiffImagePlugin.ImageFileDirectory_v2()

     # pair of 4 byte signed longs
-    numerator = 2 ** 31 - 1
-    denominator = -(2 ** 31)
+    numerator = 2**31 - 1
+    denominator = -(2**31)

     info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)

@@ -281,8 +302,8 @@
         assert numerator == reloaded.tag_v2[37380].numerator
         assert denominator == reloaded.tag_v2[37380].denominator

-    numerator = -(2 ** 31)
-    denominator = 2 ** 31 - 1
+    numerator = -(2**31)
+    denominator = 2**31 - 1

     info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)

@@ -294,7 +315,7 @@
         assert denominator == reloaded.tag_v2[37380].denominator

     # out of bounds of 4 byte signed long
-    numerator = -(2 ** 31) - 1
+    numerator = -(2**31) - 1
     denominator = 1

     info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)
@@ -303,7 +324,7 @@
     im.save(out, tiffinfo=info, compression="raw")

     with Image.open(out) as reloaded:
-        assert 2 ** 31 - 1 == reloaded.tag_v2[37380].numerator
+        assert 2**31 - 1 == reloaded.tag_v2[37380].numerator
         assert -1 == reloaded.tag_v2[37380].denominator


@@ -355,3 +376,30 @@

     # Should not raise ValueError.
     pytest.warns(UserWarning, lambda: ifd[277])
+
+
+def test_tag_group_data():
+    base_ifd = TiffImagePlugin.ImageFileDirectory_v2()
+    interop_ifd = TiffImagePlugin.ImageFileDirectory_v2(group=40965)
+    for ifd in (base_ifd, interop_ifd):
+        ifd[2] = "test"
+        ifd[256] = 10
+
+    assert base_ifd.tagtype[256] == 4
+    assert interop_ifd.tagtype[256] != base_ifd.tagtype[256]
+
+    assert interop_ifd.tagtype[2] == 7
+    assert base_ifd.tagtype[2] != interop_ifd.tagtype[256]
+
+
+def test_empty_subifd(tmp_path):
+    out = str(tmp_path / "temp.jpg")
+
+    im = hopper()
+    exif = im.getexif()
+    exif[TiffImagePlugin.EXIFIFD] = {}
+    im.save(out, exif=exif)
+
+    with Image.open(out) as reloaded:
+        exif = reloaded.getexif()
+        assert exif.get_ifd(TiffImagePlugin.EXIFIFD) == {}
('Tests', 'test_image_access.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,3 @@
-import ctypes
 import os
 import subprocess
 import sys
@@ -23,6 +22,11 @@
     except ImportError:
         cffi = None

+try:
+    import numpy
+except ImportError:
+    numpy = None
+

 class AccessTest:
     # initial value
@@ -66,6 +70,10 @@
         pix1 = im1.load()
         pix2 = im2.load()

+        for x, y in ((0, "0"), ("0", 0)):
+            with pytest.raises(TypeError):
+                pix1[x, y]
+
         for y in range(im1.size[1]):
             for x in range(im1.size[0]):
                 pix2[x, y] = pix1[x, y]
@@ -108,6 +116,13 @@
                 pix2[x, y] = pix1[x, y]

         assert_image_equal(im1, im2)
+
+    @pytest.mark.skipif(numpy is None, reason="NumPy not installed")
+    def test_numpy(self):
+        im = hopper()
+        pix = im.load()
+
+        assert pix[numpy.int32(1), numpy.int32(2)] == (18, 20, 59)


 class TestImageGetPixel(AccessTest):
@@ -138,14 +153,17 @@

         # Check 0
         im = Image.new(mode, (0, 0), None)
-        with pytest.raises(IndexError):
+        assert im.load() is not None
+
+        error = ValueError if self._need_cffi_access else IndexError
+        with pytest.raises(error):
             im.putpixel((0, 0), c)
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.getpixel((0, 0))
         # Check 0 negative index
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.putpixel((-1, -1), c)
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.getpixel((-1, -1))

         # check initial color
@@ -160,10 +178,10 @@

         # Check 0
         im = Image.new(mode, (0, 0), c)
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.getpixel((0, 0))
         # Check 0 negative index
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.getpixel((-1, -1))

     def test_basic(self):
@@ -189,10 +207,10 @@
         # see https://github.com/python-pillow/Pillow/issues/452
         # pixelaccess is using signed int* instead of uint*
         for mode in ("I;16", "I;16B"):
-            self.check(mode, 2 ** 15 - 1)
-            self.check(mode, 2 ** 15)
-            self.check(mode, 2 ** 15 + 1)
-            self.check(mode, 2 ** 16 - 1)
+            self.check(mode, 2**15 - 1)
+            self.check(mode, 2**15)
+            self.check(mode, 2**15 + 1)
+            self.check(mode, 2**16 - 1)

     def test_p_putpixel_rgb_rgba(self):
         for color in [(255, 0, 0), (255, 0, 0, 255)]:
@@ -339,6 +357,24 @@
             with pytest.raises(TypeError, match="color must be int or tuple"):
                 im.putpixel((0, 0), v)

+    @pytest.mark.parametrize(
+        ("mode", "band_numbers", "match"),
+        (
+            ("L", (0, 2), "color must be int or single-element tuple"),
+            ("LA", (0, 3), "color must be int, or tuple of one or two elements"),
+            (
+                "RGB",
+                (0, 2, 5),
+                "color must be int, or tuple of one, three or four elements",
+            ),
+        ),
+    )
+    def test_putpixel_invalid_number_of_bands(self, mode, band_numbers, match):
+        im = hopper(mode)
+        for band_number in band_numbers:
+            with pytest.raises(TypeError, match=match):
+                im.putpixel((0, 0), (0,) * band_number)
+
     @pytest.mark.parametrize("mode", IMAGE_MODES2)
     def test_putpixel_type_error2(self, mode):
         im = hopper(mode)
@@ -352,7 +388,7 @@
     def test_putpixel_overflow_error(self, mode):
         im = hopper(mode)
         with pytest.raises(OverflowError):
-            im.putpixel((0, 0), 2 ** 80)
+            im.putpixel((0, 0), 2**80)

     def test_putpixel_unrecognized_mode(self):
         im = hopper("BGR;15")
@@ -367,6 +403,8 @@
         "not from shell",
     )
     def test_embeddable(self):
+        import ctypes
+
         with open("embed_pil.c", "w") as fh:
             fh.write(
                 """
('Tests', 'test_font_pcf_charsets.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,11 @@

 from PIL import FontFile, Image, ImageDraw, ImageFont, PcfFontFile

-from .helper import assert_image_equal, assert_image_similar, skip_unless_feature
+from .helper import (
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
+    skip_unless_feature,
+)

 fontname = "Tests/fonts/ter-x20b.pcf"

@@ -47,8 +51,7 @@
     font.save(tempname)

     with Image.open(tempname.replace(".pil", ".pbm")) as loaded:
-        with Image.open(f"Tests/fonts/ter-x20b-{encoding}.pbm") as target:
-            assert_image_equal(loaded, target)
+        assert_image_equal_tofile(loaded, f"Tests/fonts/ter-x20b-{encoding}.pbm")

     with open(tempname, "rb") as f_loaded:
         with open(f"Tests/fonts/ter-x20b-{encoding}.pil", "rb") as f_target:
@@ -79,8 +82,7 @@
     draw = ImageDraw.Draw(im)
     message = charsets[encoding]["message"].encode(encoding)
     draw.text((0, 0), message, "black", font=font)
-    with Image.open(charsets[encoding]["image1"]) as target:
-        assert_image_similar(im, target, 0)
+    assert_image_similar_tofile(im, charsets[encoding]["image1"], 0)


 def test_draw_iso8859_1(request, tmp_path):
('Tests', 'test_image_putdata.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,5 +1,7 @@
 import sys
 from array import array
+
+import pytest

 from PIL import Image

@@ -36,7 +38,7 @@
     assert put(0xFFFFFFFF) == (255, 255, 255, 255)
     assert put(-1) == (255, 255, 255, 255)
     assert put(-1) == (255, 255, 255, 255)
-    if sys.maxsize > 2 ** 32:
+    if sys.maxsize > 2**32:
         assert put(sys.maxsize) == (255, 255, 255, 255)
     else:
         assert put(sys.maxsize) == (255, 255, 255, 127)
@@ -45,6 +47,12 @@
 def test_pypy_performance():
     im = Image.new("L", (256, 256))
     im.putdata(list(range(256)) * 256)
+
+
+def test_mode_with_L_with_float():
+    im = Image.new("L", (1, 1), 0)
+    im.putdata([2.0])
+    assert im.getpixel((0, 0)) == 2


 def test_mode_i():
@@ -87,3 +95,18 @@
     im.putdata(arr)

     assert len(im.getdata()) == len(arr)
+
+
+def test_not_flattened():
+    im = Image.new("L", (1, 1))
+    with pytest.raises(TypeError):
+        im.putdata([[0]])
+    with pytest.raises(TypeError):
+        im.putdata([[0]], 2)
+
+    with pytest.raises(TypeError):
+        im = Image.new("I", (1, 1))
+        im.putdata([[0]])
+    with pytest.raises(TypeError):
+        im = Image.new("F", (1, 1))
+        im.putdata([[0]])
('Tests', 'test_file_sun.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,7 @@

 from PIL import Image, SunImagePlugin

-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import assert_image_equal_tofile, assert_image_similar, hopper

 EXTRA_DIR = "Tests/images/sunraster"

@@ -29,8 +29,7 @@

 def test_im1():
     with Image.open("Tests/images/sunraster.im1") as im:
-        with Image.open("Tests/images/sunraster.im1.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/sunraster.im1.png")


 @pytest.mark.skipif(
@@ -46,7 +45,4 @@
         with Image.open(path) as im:
             im.load()
             assert isinstance(im, SunImagePlugin.SunImageFile)
-            target_path = f"{os.path.splitext(path)[0]}.png"
-            # im.save(target_file)
-            with Image.open(target_path) as target:
-                assert_image_equal(im, target)
+            assert_image_equal_tofile(im, f"{os.path.splitext(path)[0]}.png")
('Tests', 'test_decompression_bomb.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -10,8 +10,7 @@


 class TestDecompressionBomb:
-    @classmethod
-    def teardown_class(cls):
+    def teardown_method(self, method):
         Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT

     def test_no_warning_small_file(self):
@@ -52,17 +51,21 @@
             with Image.open(TEST_FILE):
                 pass

+    @pytest.mark.xfail(reason="different exception")
     def test_exception_ico(self):
         with pytest.raises(Image.DecompressionBombError):
-            Image.open("Tests/images/decompression_bomb.ico")
+            with Image.open("Tests/images/decompression_bomb.ico"):
+                pass

     def test_exception_gif(self):
         with pytest.raises(Image.DecompressionBombError):
-            Image.open("Tests/images/decompression_bomb.gif")
+            with Image.open("Tests/images/decompression_bomb.gif"):
+                pass

     def test_exception_bmp(self):
         with pytest.raises(Image.DecompressionBombError):
-            Image.open("Tests/images/bmp/b/reallybig.bmp")
+            with Image.open("Tests/images/bmp/b/reallybig.bmp"):
+                pass


 class TestDecompressionCrop:
@@ -83,21 +86,12 @@
             pytest.warns(Image.DecompressionBombWarning, src.crop, box)

     def test_crop_decompression_checks(self):
-
         im = Image.new("RGB", (100, 100))

-        good_values = ((-9999, -9999, -9990, -9990), (-999, -999, -990, -990))
-
-        warning_values = ((-160, -160, 99, 99), (160, 160, -99, -99))
-
-        error_values = ((-99909, -99990, 99999, 99999), (99909, 99990, -99999, -99999))
-
-        for value in good_values:
+        for value in ((-9999, -9999, -9990, -9990), (-999, -999, -990, -990)):
             assert im.crop(value).size == (9, 9)

-        for value in warning_values:
-            pytest.warns(Image.DecompressionBombWarning, im.crop, value)
+        pytest.warns(Image.DecompressionBombWarning, im.crop, (-160, -160, 99, 99))

-        for value in error_values:
-            with pytest.raises(Image.DecompressionBombError):
-                im.crop(value)
+        with pytest.raises(Image.DecompressionBombError):
+            im.crop((-99909, -99990, 99999, 99999))
('Tests', 'test_imagechops.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -368,11 +368,11 @@

 def test_soft_light():
     # Arrange
-    im1 = Image.open("Tests/images/hopper.png")
-    im2 = Image.open("Tests/images/hopper-XYZ.png")
-
-    # Act
-    new = ImageChops.soft_light(im1, im2)
+    with Image.open("Tests/images/hopper.png") as im1:
+        with Image.open("Tests/images/hopper-XYZ.png") as im2:
+
+            # Act
+            new = ImageChops.soft_light(im1, im2)

     # Assert
     assert new.getpixel((64, 64)) == (163, 54, 32)
@@ -381,11 +381,11 @@

 def test_hard_light():
     # Arrange
-    im1 = Image.open("Tests/images/hopper.png")
-    im2 = Image.open("Tests/images/hopper-XYZ.png")
-
-    # Act
-    new = ImageChops.hard_light(im1, im2)
+    with Image.open("Tests/images/hopper.png") as im1:
+        with Image.open("Tests/images/hopper-XYZ.png") as im2:
+
+            # Act
+            new = ImageChops.hard_light(im1, im2)

     # Assert
     assert new.getpixel((64, 64)) == (144, 50, 27)
@@ -394,11 +394,11 @@

 def test_overlay():
     # Arrange
-    im1 = Image.open("Tests/images/hopper.png")
-    im2 = Image.open("Tests/images/hopper-XYZ.png")
-
-    # Act
-    new = ImageChops.overlay(im1, im2)
+    with Image.open("Tests/images/hopper.png") as im1:
+        with Image.open("Tests/images/hopper-XYZ.png") as im2:
+
+            # Act
+            new = ImageChops.overlay(im1, im2)

     # Assert
     assert new.getpixel((64, 64)) == (159, 50, 27)
('Tests', 'check_large_memory_numpy.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,7 +19,7 @@
 XDIM = 48000


-pytestmark = pytest.mark.skipif(sys.maxsize <= 2 ** 32, reason="requires 64-bit system")
+pytestmark = pytest.mark.skipif(sys.maxsize <= 2**32, reason="requires 64-bit system")


 def _write_png(tmp_path, xdim, ydim):
@@ -31,7 +31,7 @@


 def test_large(tmp_path):
-    """ succeeded prepatch"""
+    """succeeded prepatch"""
     _write_png(tmp_path, XDIM, YDIM)


('Tests', 'test_file_webp.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,11 +1,14 @@
 import io
 import re
+import sys
+import warnings

 import pytest

 from PIL import Image, WebPImagePlugin, features

 from .helper import (
+    assert_image_equal,
     assert_image_similar,
     assert_image_similar_tofile,
     hopper,
@@ -103,6 +106,26 @@
         hopper().save(buffer_method, format="WEBP", method=6)
         assert buffer_no_args.getbuffer() != buffer_method.getbuffer()

+    @skip_unless_feature("webp_anim")
+    def test_save_all(self, tmp_path):
+        temp_file = str(tmp_path / "temp.webp")
+        im = Image.new("RGB", (1, 1))
+        im2 = Image.new("RGB", (1, 1), "#f00")
+        im.save(temp_file, save_all=True, append_images=[im2])
+
+        with Image.open(temp_file) as reloaded:
+            assert_image_equal(im, reloaded)
+
+            reloaded.seek(1)
+            assert_image_similar(im2, reloaded, 1)
+
+    def test_icc_profile(self, tmp_path):
+        self._roundtrip(tmp_path, self.rgb_mode, 12.5, {"icc_profile": None})
+        if _webp.HAVE_WEBPANIM:
+            self._roundtrip(
+                tmp_path, self.rgb_mode, 12.5, {"icc_profile": None, "save_all": True}
+            )
+
     def test_write_unsupported_mode_L(self, tmp_path):
         """
         Saving a black-and-white file to WebP format should work, and be
@@ -118,6 +141,14 @@
         """

         self._roundtrip(tmp_path, "P", 50.0)
+
+    @pytest.mark.skipif(sys.maxsize <= 2**32, reason="Requires 64-bit system")
+    def test_write_encoding_error_message(self, tmp_path):
+        temp_file = str(tmp_path / "temp.webp")
+        im = Image.new("RGB", (15000, 15000))
+        with pytest.raises(ValueError) as e:
+            im.save(temp_file, method=0)
+        assert str(e.value) == "encoding error 6"

     def test_WebPEncode_with_invalid_args(self):
         """
@@ -145,7 +176,8 @@
         file_path = "Tests/images/hopper.webp"
         with Image.open(file_path) as image:
             temp_file = str(tmp_path / "temp.webp")
-            pytest.warns(None, image.save, temp_file)
+            with warnings.catch_warnings():
+                image.save(temp_file)

     def test_file_pointer_could_be_reused(self):
         file_path = "Tests/images/hopper.webp"
@@ -153,9 +185,14 @@
             Image.open(blob).load()
             Image.open(blob).load()

-    @skip_unless_feature("webp")
     @skip_unless_feature("webp_anim")
     def test_background_from_gif(self, tmp_path):
+        # Save L mode GIF with background
+        with Image.open("Tests/images/no_palette_with_background.gif") as im:
+            out_webp = str(tmp_path / "temp.webp")
+            im.save(out_webp, save_all=True)
+
+        # Save P mode GIF with background
         with Image.open("Tests/images/chi.gif") as im:
             original_value = im.convert("RGB").getpixel((1, 1))

@@ -165,11 +202,22 @@

         # Save as GIF
         out_gif = str(tmp_path / "temp.gif")
-        Image.open(out_webp).save(out_gif)
+        with Image.open(out_webp) as im:
+            im.save(out_gif)

         with Image.open(out_gif) as reread:
             reread_value = reread.convert("RGB").getpixel((1, 1))
-        difference = sum(
-            [abs(original_value[i] - reread_value[i]) for i in range(0, 3)]
-        )
+        difference = sum(abs(original_value[i] - reread_value[i]) for i in range(0, 3))
         assert difference < 5
+
+    @skip_unless_feature("webp_anim")
+    def test_duration(self, tmp_path):
+        with Image.open("Tests/images/dispose_bgnd.gif") as im:
+            assert im.info["duration"] == 1000
+
+            out_webp = str(tmp_path / "temp.webp")
+            im.save(out_webp, save_all=True)
+
+        with Image.open(out_webp) as reloaded:
+            reloaded.load()
+            assert reloaded.info["duration"] == 1000
('Tests', 'createfontdatachunk.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 import base64
 import os

('Tests', 'test_imagestat.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -51,8 +51,8 @@
     st = ImageStat.Stat(im)

     assert st.extrema[0] == (128, 128)
-    assert st.sum[0] == 128 ** 3
-    assert st.sum2[0] == 128 ** 4
+    assert st.sum[0] == 128**3
+    assert st.sum2[0] == 128**4
     assert st.mean[0] == 128
     assert st.median[0] == 128
     assert st.rms[0] == 128
('Tests', 'test_image_getpalette.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+from PIL import Image
+
 from .helper import hopper


@@ -17,3 +19,26 @@
     assert palette("RGBA") is None
     assert palette("CMYK") is None
     assert palette("YCbCr") is None
+
+
+def test_palette_rawmode():
+    im = Image.new("P", (1, 1))
+    im.putpalette((1, 2, 3))
+
+    for rawmode in ("RGB", None):
+        rgb = im.getpalette(rawmode)
+        assert rgb == [1, 2, 3]
+
+    # Convert the RGB palette to RGBA
+    rgba = im.getpalette("RGBA")
+    assert rgba == [1, 2, 3, 255]
+
+    im.putpalette((1, 2, 3, 4), "RGBA")
+
+    # Convert the RGBA palette to RGB
+    rgb = im.getpalette("RGB")
+    assert rgb == [1, 2, 3]
+
+    for rawmode in ("RGBA", None):
+        rgba = im.getpalette(rawmode)
+        assert rgba == [1, 2, 3, 4]
('Tests', 'test_file_fli.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,10 @@
+import warnings
+
 import pytest

 from PIL import FliImagePlugin, Image

-from .helper import assert_image_equal, is_pypy
+from .helper import assert_image_equal_tofile, is_pypy

 # created as an export of a palette image from Gimp2.6
 # save as...-> hopper.fli, default options.
@@ -38,20 +40,16 @@


 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(static_test_file)
         im.load()
         im.close()

-    pytest.warns(None, open)
-

 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(static_test_file) as im:
             im.load()
-
-    pytest.warns(None, open)


 def test_tell():
@@ -122,5 +120,32 @@
     with Image.open(animated_test_file) as im:
         im.seek(50)

-        with Image.open("Tests/images/a_fli.png") as expected:
-            assert_image_equal(im, expected)
+        assert_image_equal_tofile(im, "Tests/images/a_fli.png")
+
+
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/images/timeout-9139147ce93e20eb14088fe238e541443ffd64b3.fli",
+        "Tests/images/timeout-bff0a9dc7243a8e6ede2408d2ffa6a9964698b87.fli",
+    ],
+)
+@pytest.mark.timeout(timeout=3)
+def test_timeouts(test_file):
+    with open(test_file, "rb") as f:
+        with Image.open(f) as im:
+            with pytest.raises(OSError):
+                im.load()
+
+
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/images/crash-5762152299364352.fli",
+    ],
+)
+def test_crash(test_file):
+    with open(test_file, "rb") as f:
+        with Image.open(f) as im:
+            with pytest.raises(OSError):
+                im.load()
('Tests', 'test_imagemorph.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -3,7 +3,7 @@

 from PIL import Image, ImageMorph, _imagingmorph

-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal_tofile, hopper


 def string_to_img(image_string):
@@ -57,8 +57,7 @@


 def test_str_to_img():
-    with Image.open("Tests/images/morph_a.png") as im:
-        assert_image_equal(A, im)
+    assert_image_equal_tofile(A, "Tests/images/morph_a.png")


 def create_lut():
@@ -236,19 +235,19 @@
     )


-def test_non_binary_images():
+def test_incorrect_mode():
     im = hopper("RGB")
     mop = ImageMorph.MorphOp(op_name="erosion8")

-    with pytest.raises(Exception) as e:
+    with pytest.raises(ValueError) as e:
         mop.apply(im)
-    assert str(e.value) == "Image must be binary, meaning it must use mode L"
-    with pytest.raises(Exception) as e:
+    assert str(e.value) == "Image mode must be L"
+    with pytest.raises(ValueError) as e:
         mop.match(im)
-    assert str(e.value) == "Image must be binary, meaning it must use mode L"
-    with pytest.raises(Exception) as e:
+    assert str(e.value) == "Image mode must be L"
+    with pytest.raises(ValueError) as e:
         mop.get_on_pixels(im)
-    assert str(e.value) == "Image must be binary, meaning it must use mode L"
+    assert str(e.value) == "Image mode must be L"


 def test_add_patterns():
('Tests', 'test_imagefile.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@

 import pytest

-from PIL import EpsImagePlugin, Image, ImageFile, features
+from PIL import BmpImagePlugin, EpsImagePlugin, Image, ImageFile, _binary, features

 from .helper import (
     assert_image,
@@ -23,7 +23,7 @@
     def test_parser(self):
         def roundtrip(format):

-            im = hopper("L").resize((1000, 1000), Image.NEAREST)
+            im = hopper("L").resize((1000, 1000), Image.Resampling.NEAREST)
             if format in ("MSP", "XBM"):
                 im = im.convert("1")

@@ -82,6 +82,19 @@
             p.feed(data)
             assert (48, 48) == p.image.size

+    @skip_unless_feature("webp")
+    @skip_unless_feature("webp_anim")
+    def test_incremental_webp(self):
+        with ImageFile.Parser() as p:
+            with open("Tests/images/hopper.webp", "rb") as f:
+                p.feed(f.read(1024))
+
+                # Check that insufficient data was given in the first feed
+                assert not p.image
+
+                p.feed(f.read())
+            assert (128, 128) == p.image.size
+
     @skip_unless_feature("zlib")
     def test_safeblock(self):
         im1 = hopper()
@@ -93,12 +106,6 @@
             ImageFile.SAFEBLOCK = SAFEBLOCK

         assert_image_equal(im1, im2)
-
-    def test_raise_ioerror(self):
-        with pytest.raises(IOError):
-            with pytest.warns(DeprecationWarning) as record:
-                ImageFile.raise_ioerror(1)
-        assert len(record) == 1

     def test_raise_oserror(self):
         with pytest.raises(OSError):
@@ -117,6 +124,37 @@
         with pytest.raises(OSError):
             p.close()

+    def test_no_format(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        class DummyImageFile(ImageFile.ImageFile):
+            def _open(self):
+                self.mode = "RGB"
+                self._size = (1, 1)
+
+        im = DummyImageFile(buf)
+        assert im.format is None
+        assert im.get_format_mimetype() is None
+
+    def test_oserror(self):
+        im = Image.new("RGB", (1, 1))
+        with pytest.raises(OSError):
+            im.save(BytesIO(), "JPEG2000", num_resolutions=2)
+
+    def test_truncated(self):
+        b = BytesIO(
+            b"BM000000000000"  # head_data
+            + _binary.o32le(
+                ImageFile.SAFEBLOCK + 1 + 4
+            )  # header_size, so BmpImagePlugin will try to read SAFEBLOCK + 1 bytes
+            + (
+                b"0" * ImageFile.SAFEBLOCK
+            )  # only SAFEBLOCK bytes, so that the header is truncated
+        )
+        with pytest.raises(OSError) as e:
+            BmpImagePlugin.BmpImageFile(b)
+        assert str(e.value) == "Truncated File Read"
+
     @skip_unless_feature("zlib")
     def test_truncated_with_errors(self):
         with Image.open("Tests/images/truncated_image.png") as im:
@@ -156,6 +194,14 @@
     def decode(self, buffer):
         # eof
         return -1, 0
+
+
+class MockPyEncoder(ImageFile.PyEncoder):
+    def encode(self, buffer):
+        return 1, 1, b""
+
+    def cleanup(self):
+        self.cleanup_called = True


 xoff, yoff, xsize, ysize = 10, 20, 100, 100
@@ -169,53 +215,58 @@
         self.tile = [("MOCK", (xoff, yoff, xoff + xsize, yoff + ysize), 32, None)]


-class TestPyDecoder:
-    def get_decoder(self):
-        decoder = MockPyDecoder(None)
-
-        def closure(mode, *args):
-            decoder.__init__(mode, *args)
-            return decoder
-
-        Image.register_decoder("MOCK", closure)
-        return decoder
-
+class CodecsTest:
+    @classmethod
+    def setup_class(cls):
+        cls.decoder = MockPyDecoder(None)
+        cls.encoder = MockPyEncoder(None)
+
+        def decoder_closure(mode, *args):
+            cls.decoder.__init__(mode, *args)
+            return cls.decoder
+
+        def encoder_closure(mode, *args):
+            cls.encoder.__init__(mode, *args)
+            return cls.encoder
+
+        Image.register_decoder("MOCK", decoder_closure)
+        Image.register_encoder("MOCK", encoder_closure)
+
+
+class TestPyDecoder(CodecsTest):
     def test_setimage(self):
         buf = BytesIO(b"\x00" * 255)

         im = MockImageFile(buf)
-        d = self.get_decoder()

         im.load()

-        assert d.state.xoff == xoff
-        assert d.state.yoff == yoff
-        assert d.state.xsize == xsize
-        assert d.state.ysize == ysize
-
-        with pytest.raises(ValueError):
-            d.set_as_raw(b"\x00")
+        assert self.decoder.state.xoff == xoff
+        assert self.decoder.state.yoff == yoff
+        assert self.decoder.state.xsize == xsize
+        assert self.decoder.state.ysize == ysize
+
+        with pytest.raises(ValueError):
+            self.decoder.set_as_raw(b"\x00")

     def test_extents_none(self):
         buf = BytesIO(b"\x00" * 255)

         im = MockImageFile(buf)
         im.tile = [("MOCK", None, 32, None)]
-        d = self.get_decoder()

         im.load()

-        assert d.state.xoff == 0
-        assert d.state.yoff == 0
-        assert d.state.xsize == 200
-        assert d.state.ysize == 200
+        assert self.decoder.state.xoff == 0
+        assert self.decoder.state.yoff == 0
+        assert self.decoder.state.xsize == 200
+        assert self.decoder.state.ysize == 200

     def test_negsize(self):
         buf = BytesIO(b"\x00" * 255)

         im = MockImageFile(buf)
         im.tile = [("MOCK", (xoff, yoff, -10, yoff + ysize), 32, None)]
-        self.get_decoder()

         with pytest.raises(ValueError):
             im.load()
@@ -229,7 +280,6 @@

         im = MockImageFile(buf)
         im.tile = [("MOCK", (xoff, yoff, xoff + xsize + 100, yoff + ysize), 32, None)]
-        self.get_decoder()

         with pytest.raises(ValueError):
             im.load()
@@ -238,14 +288,92 @@
         with pytest.raises(ValueError):
             im.load()

-    def test_no_format(self):
-        buf = BytesIO(b"\x00" * 255)
-
-        im = MockImageFile(buf)
-        assert im.format is None
-        assert im.get_format_mimetype() is None
-
-    def test_oserror(self):
-        im = Image.new("RGB", (1, 1))
-        with pytest.raises(OSError):
-            im.save(BytesIO(), "JPEG2000")
+    def test_decode(self):
+        decoder = ImageFile.PyDecoder(None)
+        with pytest.raises(NotImplementedError):
+            decoder.decode(None)
+
+
+class TestPyEncoder(CodecsTest):
+    def test_setimage(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        im = MockImageFile(buf)
+
+        fp = BytesIO()
+        ImageFile._save(
+            im, fp, [("MOCK", (xoff, yoff, xoff + xsize, yoff + ysize), 0, "RGB")]
+        )
+
+        assert self.encoder.state.xoff == xoff
+        assert self.encoder.state.yoff == yoff
+        assert self.encoder.state.xsize == xsize
+        assert self.encoder.state.ysize == ysize
+
+    def test_extents_none(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        im = MockImageFile(buf)
+        im.tile = [("MOCK", None, 32, None)]
+
+        fp = BytesIO()
+        ImageFile._save(im, fp, [("MOCK", None, 0, "RGB")])
+
+        assert self.encoder.state.xoff == 0
+        assert self.encoder.state.yoff == 0
+        assert self.encoder.state.xsize == 200
+        assert self.encoder.state.ysize == 200
+
+    def test_negsize(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        im = MockImageFile(buf)
+
+        fp = BytesIO()
+        self.encoder.cleanup_called = False
+        with pytest.raises(ValueError):
+            ImageFile._save(
+                im, fp, [("MOCK", (xoff, yoff, -10, yoff + ysize), 0, "RGB")]
+            )
+        assert self.encoder.cleanup_called
+
+        with pytest.raises(ValueError):
+            ImageFile._save(
+                im, fp, [("MOCK", (xoff, yoff, xoff + xsize, -10), 0, "RGB")]
+            )
+
+    def test_oversize(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        im = MockImageFile(buf)
+
+        fp = BytesIO()
+        with pytest.raises(ValueError):
+            ImageFile._save(
+                im,
+                fp,
+                [("MOCK", (xoff, yoff, xoff + xsize + 100, yoff + ysize), 0, "RGB")],
+            )
+
+        with pytest.raises(ValueError):
+            ImageFile._save(
+                im,
+                fp,
+                [("MOCK", (xoff, yoff, xoff + xsize, yoff + ysize + 100), 0, "RGB")],
+            )
+
+    def test_encode(self):
+        encoder = ImageFile.PyEncoder(None)
+        with pytest.raises(NotImplementedError):
+            encoder.encode(None)
+
+        bytes_consumed, errcode = encoder.encode_to_pyfd()
+        assert bytes_consumed == 0
+        assert ImageFile.ERRORS[errcode] == "bad configuration"
+
+        encoder._pushes_fd = True
+        with pytest.raises(NotImplementedError):
+            encoder.encode_to_pyfd()
+
+        with pytest.raises(NotImplementedError):
+            encoder.encode_to_file(None, None)
('Tests', 'test_image_thumbnail.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -88,6 +88,8 @@
         assert im.size == (64, 64)


+# valgrind test is failing with memory allocated in libjpeg
+@pytest.mark.valgrind_known_error(reason="Known Failing")
 def test_DCT_scaling_edges():
     # Make an image with red borders and size (N * 8) + 1 to cross DCT grid
     im = Image.new("RGB", (257, 257), "red")
@@ -95,24 +97,24 @@

     thumb = fromstring(tostring(im, "JPEG", quality=99, subsampling=0))
     # small reducing_gap to amplify the effect
-    thumb.thumbnail((32, 32), Image.BICUBIC, reducing_gap=1.0)
+    thumb.thumbnail((32, 32), Image.Resampling.BICUBIC, reducing_gap=1.0)

-    ref = im.resize((32, 32), Image.BICUBIC)
+    ref = im.resize((32, 32), Image.Resampling.BICUBIC)
     # This is still JPEG, some error is present. Without the fix it is 11.5
     assert_image_similar(thumb, ref, 1.5)


 def test_reducing_gap_values():
     im = hopper()
-    im.thumbnail((18, 18), Image.BICUBIC)
+    im.thumbnail((18, 18), Image.Resampling.BICUBIC)

     ref = hopper()
-    ref.thumbnail((18, 18), Image.BICUBIC, reducing_gap=2.0)
+    ref.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=2.0)
     # reducing_gap=2.0 should be the default
     assert_image_equal(ref, im)

     ref = hopper()
-    ref.thumbnail((18, 18), Image.BICUBIC, reducing_gap=None)
+    ref.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=None)
     with pytest.raises(AssertionError):
         assert_image_equal(ref, im)

@@ -123,9 +125,9 @@
     with Image.open("Tests/images/hopper.jpg") as ref:
         # thumbnail should call draft with reducing_gap scale
         ref.draft(None, (18 * 3, 18 * 3))
-        ref = ref.resize((18, 18), Image.BICUBIC)
+        ref = ref.resize((18, 18), Image.Resampling.BICUBIC)

         with Image.open("Tests/images/hopper.jpg") as im:
-            im.thumbnail((18, 18), Image.BICUBIC, reducing_gap=3.0)
+            im.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=3.0)

             assert_image_equal(ref, im)
('Tests', 'test_file_gbr.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,27 @@

 from PIL import GbrImagePlugin, Image

-from .helper import assert_image_equal
+from .helper import assert_image_equal_tofile
+
+
+def test_gbr_file():
+    with Image.open("Tests/images/gbr.gbr") as im:
+        assert_image_equal_tofile(im, "Tests/images/gbr.png")
+
+
+def test_load():
+    with Image.open("Tests/images/gbr.gbr") as im:
+        assert im.load()[0, 0] == (0, 0, 0, 0)
+
+        # Test again now that it has already been loaded once
+        assert im.load()[0, 0] == (0, 0, 0, 0)
+
+
+def test_multiple_load_operations():
+    with Image.open("Tests/images/gbr.gbr") as im:
+        im.load()
+        im.load()
+        assert_image_equal_tofile(im, "Tests/images/gbr.png")


 def test_invalid_file():
@@ -10,17 +30,3 @@

     with pytest.raises(SyntaxError):
         GbrImagePlugin.GbrImageFile(invalid_file)
-
-
-def test_gbr_file():
-    with Image.open("Tests/images/gbr.gbr") as im:
-        with Image.open("Tests/images/gbr.png") as target:
-            assert_image_equal(target, im)
-
-
-def test_multiple_load_operations():
-    with Image.open("Tests/images/gbr.gbr") as im:
-        im.load()
-        im.load()
-        with Image.open("Tests/images/gbr.png") as target:
-            assert_image_equal(target, im)
('Tests', 'test_file_ppm.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,11 @@
+import sys
+from io import BytesIO
+
 import pytest

-from PIL import Image
+from PIL import Image, UnidentifiedImageError

-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import assert_image_equal_tofile, assert_image_similar, hopper

 # sample ppm stream
 TEST_FILE = "Tests/images/hopper.ppm"
@@ -10,33 +13,66 @@

 def test_sanity():
     with Image.open(TEST_FILE) as im:
-        im.load()
         assert im.mode == "RGB"
         assert im.size == (128, 128)
-        assert im.format, "PPM"
+        assert im.format == "PPM"
         assert im.get_format_mimetype() == "image/x-portable-pixmap"
+
+
+@pytest.mark.parametrize(
+    "data, mode, pixels",
+    (
+        (b"P5 3 1 4 \x00\x02\x04", "L", (0, 128, 255)),
+        (b"P5 3 1 257 \x00\x00\x00\x80\x01\x01", "I", (0, 32640, 65535)),
+        # P6 with maxval < 255
+        (
+            b"P6 3 1 17 \x00\x01\x02\x08\x09\x0A\x0F\x10\x11",
+            "RGB",
+            (
+                (0, 15, 30),
+                (120, 135, 150),
+                (225, 240, 255),
+            ),
+        ),
+        # P6 with maxval > 255
+        # Scale down to 255, since there is no RGB mode with more than 8-bit
+        (
+            b"P6 3 1 257 \x00\x00\x00\x01\x00\x02"
+            b"\x00\x80\x00\x81\x00\x82\x01\x00\x01\x01\xFF\xFF",
+            "RGB",
+            (
+                (0, 1, 2),
+                (127, 128, 129),
+                (254, 255, 255),
+            ),
+        ),
+    ),
+)
+def test_arbitrary_maxval(data, mode, pixels):
+    fp = BytesIO(data)
+    with Image.open(fp) as im:
+        assert im.size == (3, 1)
+        assert im.mode == mode
+
+        px = im.load()
+        assert tuple(px[x, 0] for x in range(3)) == pixels


 def test_16bit_pgm():
     with Image.open("Tests/images/16_bit_binary.pgm") as im:
-        im.load()
         assert im.mode == "I"
         assert im.size == (20, 100)
         assert im.get_format_mimetype() == "image/x-portable-graymap"

-        with Image.open("Tests/images/16_bit_binary_pgm.png") as tgt:
-            assert_image_equal(im, tgt)
+        assert_image_equal_tofile(im, "Tests/images/16_bit_binary_pgm.png")


 def test_16bit_pgm_write(tmp_path):
     with Image.open("Tests/images/16_bit_binary.pgm") as im:
-        im.load()
-
         f = str(tmp_path / "temp.pgm")
         im.save(f, "PPM")

-        with Image.open(f) as reloaded:
-            assert_image_equal(im, reloaded)
+        assert_image_equal_tofile(im, f)


 def test_pnm(tmp_path):
@@ -46,17 +82,67 @@
         f = str(tmp_path / "temp.pnm")
         im.save(f)

-        with Image.open(f) as reloaded:
-            assert_image_equal(im, reloaded)
+        assert_image_equal_tofile(im, f)
+
+
+def test_magic(tmp_path):
+    path = str(tmp_path / "temp.ppm")
+    with open(path, "wb") as f:
+        f.write(b"PyInvalid")
+
+    with pytest.raises(UnidentifiedImageError):
+        with Image.open(path):
+            pass
+
+
+def test_header_with_comments(tmp_path):
+    path = str(tmp_path / "temp.ppm")
+    with open(path, "wb") as f:
+        f.write(b"P6 #comment\n#comment\r12#comment\r8\n128 #comment\n255\n")
+
+    with Image.open(path) as im:
+        assert im.size == (128, 128)
+
+
+def test_non_integer_token(tmp_path):
+    path = str(tmp_path / "temp.ppm")
+    with open(path, "wb") as f:
+        f.write(b"P6\nTEST")
+
+    with pytest.raises(ValueError):
+        with Image.open(path):
+            pass
+
+
+def test_token_too_long(tmp_path):
+    path = str(tmp_path / "temp.ppm")
+    with open(path, "wb") as f:
+        f.write(b"P6\n 01234567890")
+
+    with pytest.raises(ValueError) as e:
+        with Image.open(path):
+            pass
+
+    assert str(e.value) == "Token too long in file header: b'01234567890'"


 def test_truncated_file(tmp_path):
+    # Test EOF in header
     path = str(tmp_path / "temp.pgm")
     with open(path, "w") as f:
         f.write("P6")

-    with pytest.raises(ValueError):
-        Image.open(path)
+    with pytest.raises(ValueError) as e:
+        with Image.open(path):
+            pass
+
+    assert str(e.value) == "Reached EOF while reading header"
+
+    # Test EOF for PyDecoder
+    fp = BytesIO(b"P5 3 1 4")
+    with Image.open(fp) as im:
+        with pytest.raises(ValueError):
+            im.load()


 def test_neg_ppm():
@@ -66,7 +152,8 @@
     # sizes.

     with pytest.raises(OSError):
-        Image.open("Tests/images/negative_size.ppm")
+        with Image.open("Tests/images/negative_size.ppm"):
+            pass


 def test_mimetypes(tmp_path):
@@ -81,3 +168,30 @@
         f.write("PyCMYK\n128 128\n255")
     with Image.open(path) as im:
         assert im.get_format_mimetype() == "image/x-portable-anymap"
+
+
+@pytest.mark.parametrize("buffer", (True, False))
+def test_save_stdout(buffer):
+    old_stdout = sys.stdout
+
+    if buffer:
+
+        class MyStdOut:
+            buffer = BytesIO()
+
+        mystdout = MyStdOut()
+    else:
+        mystdout = BytesIO()
+
+    sys.stdout = mystdout
+
+    with Image.open(TEST_FILE) as im:
+        im.save(sys.stdout, "PPM")
+
+    # Reset stdout
+    sys.stdout = old_stdout
+
+    if buffer:
+        mystdout = mystdout.buffer
+    with Image.open(mystdout) as reloaded:
+        assert_image_equal_tofile(reloaded, TEST_FILE)
('Tests', 'test_file_tiff.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,10 +1,11 @@
 import os
+import warnings
 from io import BytesIO

 import pytest

-from PIL import Image, TiffImagePlugin
-from PIL.TiffImagePlugin import RESOLUTION_UNIT, SUBIFD, X_RESOLUTION, Y_RESOLUTION
+from PIL import Image, ImageFile, TiffImagePlugin
+from PIL.TiffImagePlugin import RESOLUTION_UNIT, X_RESOLUTION, Y_RESOLUTION

 from .helper import (
     assert_image_equal,
@@ -16,6 +17,11 @@
     is_win32,
 )

+try:
+    import defusedxml.ElementTree as ElementTree
+except ImportError:
+    ElementTree = None
+

 class TestFileTiff:
     def test_sanity(self, tmp_path):
@@ -59,19 +65,15 @@
         pytest.warns(ResourceWarning, open)

     def test_closed_file(self):
-        def open():
+        with warnings.catch_warnings():
             im = Image.open("Tests/images/multipage.tiff")
             im.load()
             im.close()

-        pytest.warns(None, open)
-
     def test_context_manager(self):
-        def open():
+        with warnings.catch_warnings():
             with Image.open("Tests/images/multipage.tiff") as im:
                 im.load()
-
-        pytest.warns(None, open)

     def test_mac_tiff(self):
         # Read RGBa images from macOS [@PIL136]
@@ -85,11 +87,22 @@

             assert_image_similar_tofile(im, "Tests/images/pil136.png", 1)

-    def test_wrong_bits_per_sample(self):
-        with Image.open("Tests/images/tiff_wrong_bits_per_sample.tiff") as im:
-            assert im.mode == "RGBA"
-            assert im.size == (52, 53)
-            assert im.tile == [("raw", (0, 0, 52, 53), 160, ("RGBA", 0, 1))]
+    def test_bigtiff(self):
+        with Image.open("Tests/images/hopper_bigtiff.tif") as im:
+            assert_image_equal_tofile(im, "Tests/images/hopper.tif")
+
+    @pytest.mark.parametrize(
+        "file_name,mode,size,offset",
+        [
+            ("tiff_wrong_bits_per_sample.tiff", "RGBA", (52, 53), 160),
+            ("tiff_wrong_bits_per_sample_2.tiff", "RGB", (16, 16), 8),
+        ],
+    )
+    def test_wrong_bits_per_sample(self, file_name, mode, size, offset):
+        with Image.open("Tests/images/" + file_name) as im:
+            assert im.mode == mode
+            assert im.size == size
+            assert im.tile == [("raw", (0, 0) + size, offset, (mode, 0, 1))]
             im.load()

     def test_set_legacy_api(self):
@@ -137,46 +150,33 @@
             im._setup()
             assert im.info["dpi"] == (71.0, 71.0)

-    def test_load_dpi_rounding(self):
-        for resolutionUnit, dpi in ((None, (72, 73)), (2, (72, 73)), (3, (183, 185))):
-            with Image.open(
-                "Tests/images/hopper_roundDown_" + str(resolutionUnit) + ".tif"
-            ) as im:
-                assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit
-                assert im.info["dpi"] == (dpi[0], dpi[0])
-
-            with Image.open(
-                "Tests/images/hopper_roundUp_" + str(resolutionUnit) + ".tif"
-            ) as im:
-                assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit
-                assert im.info["dpi"] == (dpi[1], dpi[1])
-
-    def test_save_dpi_rounding(self, tmp_path):
+    @pytest.mark.parametrize(
+        "resolutionUnit, dpi",
+        [(None, 72.8), (2, 72.8), (3, 184.912)],
+    )
+    def test_load_float_dpi(self, resolutionUnit, dpi):
+        with Image.open(
+            "Tests/images/hopper_float_dpi_" + str(resolutionUnit) + ".tif"
+        ) as im:
+            assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit
+            assert im.info["dpi"] == (dpi, dpi)
+
+    def test_save_float_dpi(self, tmp_path):
         outfile = str(tmp_path / "temp.tif")
         with Image.open("Tests/images/hopper.tif") as im:
-            for dpi in (72.2, 72.8):
-                im.save(outfile, dpi=(dpi, dpi))
-
-                with Image.open(outfile) as reloaded:
-                    reloaded.load()
-                    assert (round(dpi), round(dpi)) == reloaded.info["dpi"]
-
-    def test_subifd(self, tmp_path):
-        outfile = str(tmp_path / "temp.tif")
-        with Image.open("Tests/images/g4_orientation_6.tif") as im:
-            im.tag_v2[SUBIFD] = 10000
-
-            # Should not segfault
-            im.save(outfile)
+            dpi = (72.2, 72.2)
+            im.save(outfile, dpi=dpi)
+
+            with Image.open(outfile) as reloaded:
+                assert reloaded.info["dpi"] == dpi

     def test_save_setting_missing_resolution(self):
         b = BytesIO()
-        Image.open("Tests/images/10ct_32bit_128.tiff").save(
-            b, format="tiff", resolution=123.45
-        )
+        with Image.open("Tests/images/10ct_32bit_128.tiff") as im:
+            im.save(b, format="tiff", resolution=123.45)
         with Image.open(b) as im:
-            assert float(im.tag_v2[X_RESOLUTION]) == 123.45
-            assert float(im.tag_v2[Y_RESOLUTION]) == 123.45
+            assert im.tag_v2[X_RESOLUTION] == 123.45
+            assert im.tag_v2[Y_RESOLUTION] == 123.45

     def test_invalid_file(self):
         invalid_file = "Tests/images/flower.jpg"
@@ -224,6 +224,15 @@
         # Bytes are in image native order (big endian)
         assert b[0] == ord(b"\x01")
         assert b[1] == ord(b"\xe0")
+
+    def test_16bit_r(self):
+        with Image.open("Tests/images/16bit.r.tif") as im:
+            assert im.getpixel((0, 0)) == 480
+            assert im.mode == "I;16"
+
+            b = im.tobytes()
+        assert b[0] == ord(b"\xe0")
+        assert b[1] == ord(b"\x01")

     def test_16bit_s(self):
         with Image.open("Tests/images/16bit.s.tif") as im:
@@ -256,7 +265,8 @@

     def test_unknown_pixel_mode(self):
         with pytest.raises(OSError):
-            Image.open("Tests/images/hopper_unknown_pixel_mode.tif")
+            with Image.open("Tests/images/hopper_unknown_pixel_mode.tif"):
+                pass

     def test_n_frames(self):
         for path, n_frames in [
@@ -308,6 +318,19 @@
             im.load()
             assert im.size == (20, 20)
             assert im.convert("RGB").getpixel((0, 0)) == (0, 0, 255)
+
+    def test_frame_order(self):
+        # A frame can't progress to itself after reading
+        with Image.open("Tests/images/multipage_single_frame_loop.tiff") as im:
+            assert im.n_frames == 1
+
+        # A frame can't progress to a frame that has already been read
+        with Image.open("Tests/images/multipage_multiple_frame_loop.tiff") as im:
+            assert im.n_frames == 2
+
+        # Frames don't have to be in sequence
+        with Image.open("Tests/images/multipage_out_of_order.tiff") as im:
+            assert im.n_frames == 3

     def test___str__(self):
         filename = "Tests/images/pil136.tiff"
@@ -396,6 +419,75 @@
     def test_ifd_tag_type(self):
         with Image.open("Tests/images/ifd_tag_type.tiff") as im:
             assert 0x8825 in im.tag_v2
+
+    def test_exif(self, tmp_path):
+        def check_exif(exif):
+            assert sorted(exif.keys()) == [
+                256,
+                257,
+                258,
+                259,
+                262,
+                271,
+                272,
+                273,
+                277,
+                278,
+                279,
+                282,
+                283,
+                284,
+                296,
+                297,
+                305,
+                339,
+                700,
+                34665,
+                34853,
+                50735,
+            ]
+            assert exif[256] == 640
+            assert exif[271] == "FLIR"
+
+            gps = exif.get_ifd(0x8825)
+            assert list(gps.keys()) == [0, 1, 2, 3, 4, 5, 6, 18]
+            assert gps[0] == b"\x03\x02\x00\x00"
+            assert gps[18] == "WGS-84"
+
+        outfile = str(tmp_path / "temp.tif")
+        with Image.open("Tests/images/ifd_tag_type.tiff") as im:
+            exif = im.getexif()
+            check_exif(exif)
+
+            im.save(outfile, exif=exif)
+
+        outfile2 = str(tmp_path / "temp2.tif")
+        with Image.open(outfile) as im:
+            exif = im.getexif()
+            check_exif(exif)
+
+            im.save(outfile2, exif=exif.tobytes())
+
+        with Image.open(outfile2) as im:
+            exif = im.getexif()
+            check_exif(exif)
+
+    def test_exif_frames(self):
+        # Test that EXIF data can change across frames
+        with Image.open("Tests/images/g4-multi.tiff") as im:
+            assert im.getexif()[273] == (328, 815)
+
+            im.seek(1)
+            assert im.getexif()[273] == (1408, 1907)
+
+    @pytest.mark.parametrize("mode", ("1", "L"))
+    def test_photometric(self, mode, tmp_path):
+        filename = str(tmp_path / "temp.tif")
+        im = hopper(mode)
+        im.save(filename, tiffinfo={262: 0})
+        with Image.open(filename) as reloaded:
+            assert reloaded.tag_v2[262] == 0
+            assert_image_equal(im, reloaded)

     def test_seek(self):
         filename = "Tests/images/pil136.tiff"
@@ -491,8 +583,7 @@
             tmpfile = str(tmp_path / "temp.tif")
             im.save(tmpfile)

-            with Image.open(tmpfile) as reloaded:
-                assert_image_equal(im, reloaded)
+            assert_image_equal_tofile(im, tmpfile)

     def test_strip_raw(self):
         infile = "Tests/images/tiff_strip_raw.tif"
@@ -520,6 +611,17 @@
         with Image.open(infile) as im:
             assert_image_equal_tofile(im, "Tests/images/tiff_adobe_deflate.png")

+    def test_planar_configuration_save(self, tmp_path):
+        infile = "Tests/images/tiff_tiled_planar_raw.tif"
+        with Image.open(infile) as im:
+            assert im._planar_configuration == 2
+
+            outfile = str(tmp_path / "temp.tif")
+            im.save(outfile)
+
+            with Image.open(outfile) as reloaded:
+                assert_image_equal_tofile(reloaded, infile)
+
     def test_palette(self, tmp_path):
         def roundtrip(mode):
             outfile = str(tmp_path / "temp.tif")
@@ -577,6 +679,66 @@
         with Image.open(tmpfile) as reloaded:
             assert b"Dummy value" == reloaded.info["icc_profile"]

+    def test_save_icc_profile(self, tmp_path):
+        im = hopper()
+        assert "icc_profile" not in im.info
+
+        outfile = str(tmp_path / "temp.tif")
+        icc_profile = b"Dummy value"
+        im.save(outfile, icc_profile=icc_profile)
+
+        with Image.open(outfile) as reloaded:
+            assert reloaded.info["icc_profile"] == icc_profile
+
+    def test_discard_icc_profile(self, tmp_path):
+        outfile = str(tmp_path / "temp.tif")
+
+        with Image.open("Tests/images/icc_profile.png") as im:
+            assert "icc_profile" in im.info
+
+            im.save(outfile, icc_profile=None)
+
+        with Image.open(outfile) as reloaded:
+            assert "icc_profile" not in reloaded.info
+
+    def test_getxmp(self):
+        with Image.open("Tests/images/lab.tif") as im:
+            if ElementTree is None:
+                with pytest.warns(UserWarning):
+                    assert im.getxmp() == {}
+            else:
+                xmp = im.getxmp()
+
+                description = xmp["xmpmeta"]["RDF"]["Description"]
+                assert description[0]["format"] == "image/tiff"
+                assert description[3]["BitsPerSample"]["Seq"]["li"] == ["8", "8", "8"]
+
+    def test_get_photoshop_blocks(self):
+        with Image.open("Tests/images/lab.tif") as im:
+            assert list(im.get_photoshop_blocks().keys()) == [
+                1061,
+                1002,
+                1005,
+                1062,
+                1037,
+                1049,
+                1011,
+                1034,
+                10000,
+                1013,
+                1016,
+                1032,
+                1054,
+                1050,
+                1064,
+                1041,
+                1044,
+                1036,
+                1057,
+                4000,
+                4001,
+            ]
+
     def test_close_on_load_exclusive(self, tmp_path):
         # similar to test_fd_leak, but runs on unixlike os
         tmpfile = str(tmp_path / "temp.tif")
@@ -606,14 +768,25 @@
     # Ignore this UserWarning which triggers for four tags:
     # "Possibly corrupt EXIF data.  Expecting to read 50404352 bytes but..."
     @pytest.mark.filterwarnings("ignore:Possibly corrupt EXIF data")
+    # Ignore this UserWarning:
+    @pytest.mark.filterwarnings("ignore:Truncated File Read")
     @pytest.mark.skipif(
         not os.path.exists("Tests/images/string_dimension.tiff"),
         reason="Extra image files not installed",
     )
     def test_string_dimension(self):
         # Assert that an error is raised if one of the dimensions is a string
-        with pytest.raises(ValueError):
-            Image.open("Tests/images/string_dimension.tiff")
+        with Image.open("Tests/images/string_dimension.tiff") as im:
+            with pytest.raises(OSError):
+                im.load()
+
+    @pytest.mark.timeout(6)
+    @pytest.mark.filterwarnings("ignore:Truncated File Read")
+    def test_timeout(self):
+        with Image.open("Tests/images/timeout-6646305047838720") as im:
+            ImageFile.LOAD_TRUNCATED_IMAGES = True
+            im.load()
+            ImageFile.LOAD_TRUNCATED_IMAGES = False


 @pytest.mark.skipif(not is_win32(), reason="Windows only")
('Tests', 'test_file_apng.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -120,9 +120,9 @@
     #     save_all=True,
     #     append_images=[green, blue],
     #     disposal=[
-    #         PngImagePlugin.APNG_DISPOSE_OP_NONE,
-    #         PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,
-    #         PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS
+    #         PngImagePlugin.Disposal.OP_NONE,
+    #         PngImagePlugin.Disposal.OP_PREVIOUS,
+    #         PngImagePlugin.Disposal.OP_PREVIOUS
     #     ],
     # )
     with Image.open("Tests/images/apng/dispose_op_previous_frame.png") as im:
@@ -249,8 +249,8 @@
         assert im.mode == "P"
         im.seek(im.n_frames - 1)
         im = im.convert("RGBA")
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+        assert im.getpixel((0, 0)) == (255, 0, 0, 0)
+        assert im.getpixel((64, 32)) == (255, 0, 0, 0)

     with Image.open("Tests/images/apng/mode_palette_1bit_alpha.png") as im:
         assert im.mode == "P"
@@ -312,7 +312,7 @@
             exception = e
         assert exception is None

-    with pytest.raises(SyntaxError):
+    with pytest.raises(OSError):
         with Image.open("Tests/images/apng/syntax_num_frames_high.png") as im:
             im.seek(im.n_frames - 1)
             im.load()
@@ -433,10 +433,18 @@

     # test removal of duplicated frames
     frame = Image.new("RGBA", (128, 64), (255, 0, 0, 255))
-    frame.save(test_file, save_all=True, append_images=[frame], duration=[500, 250])
+    frame.save(
+        test_file, save_all=True, append_images=[frame, frame], duration=[500, 100, 150]
+    )
     with Image.open(test_file) as im:
         im.load()
         assert im.n_frames == 1
+        assert im.info.get("duration") == 750
+
+    # test info duration
+    frame.info["duration"] = 750
+    frame.save(test_file, save_all=True)
+    with Image.open(test_file) as im:
         assert im.info.get("duration") == 750


@@ -447,31 +455,31 @@
     green = Image.new("RGBA", size, (0, 255, 0, 255))
     transparent = Image.new("RGBA", size, (0, 0, 0, 0))

-    # test APNG_DISPOSE_OP_NONE
+    # test OP_NONE
     red.save(
         test_file,
         save_all=True,
         append_images=[green, transparent],
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
-    )
-    with Image.open(test_file) as im:
-        im.seek(2)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
-
-    # test APNG_DISPOSE_OP_BACKGROUND
+        disposal=PngImagePlugin.Disposal.OP_NONE,
+        blend=PngImagePlugin.Blend.OP_OVER,
+    )
+    with Image.open(test_file) as im:
+        im.seek(2)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+
+    # test OP_BACKGROUND
     disposal = [
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        PngImagePlugin.APNG_DISPOSE_OP_BACKGROUND,
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
+        PngImagePlugin.Disposal.OP_NONE,
+        PngImagePlugin.Disposal.OP_BACKGROUND,
+        PngImagePlugin.Disposal.OP_NONE,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[red, transparent],
         disposal=disposal,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
+        blend=PngImagePlugin.Blend.OP_OVER,
     )
     with Image.open(test_file) as im:
         im.seek(2)
@@ -479,26 +487,26 @@
         assert im.getpixel((64, 32)) == (0, 0, 0, 0)

     disposal = [
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        PngImagePlugin.APNG_DISPOSE_OP_BACKGROUND,
+        PngImagePlugin.Disposal.OP_NONE,
+        PngImagePlugin.Disposal.OP_BACKGROUND,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[green],
         disposal=disposal,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
-    )
-    with Image.open(test_file) as im:
-        im.seek(1)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
-
-    # test APNG_DISPOSE_OP_PREVIOUS
+        blend=PngImagePlugin.Blend.OP_OVER,
+    )
+    with Image.open(test_file) as im:
+        im.seek(1)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+
+    # test OP_PREVIOUS
     disposal = [
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
+        PngImagePlugin.Disposal.OP_NONE,
+        PngImagePlugin.Disposal.OP_PREVIOUS,
+        PngImagePlugin.Disposal.OP_NONE,
     ]
     red.save(
         test_file,
@@ -506,7 +514,7 @@
         append_images=[green, red, transparent],
         default_image=True,
         disposal=disposal,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
+        blend=PngImagePlugin.Blend.OP_OVER,
     )
     with Image.open(test_file) as im:
         im.seek(3)
@@ -514,20 +522,31 @@
         assert im.getpixel((64, 32)) == (0, 255, 0, 255)

     disposal = [
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,
+        PngImagePlugin.Disposal.OP_NONE,
+        PngImagePlugin.Disposal.OP_PREVIOUS,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[green],
         disposal=disposal,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
-    )
-    with Image.open(test_file) as im:
-        im.seek(1)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+        blend=PngImagePlugin.Blend.OP_OVER,
+    )
+    with Image.open(test_file) as im:
+        im.seek(1)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+
+    # test info disposal
+    red.info["disposal"] = PngImagePlugin.Disposal.OP_BACKGROUND
+    red.save(
+        test_file,
+        save_all=True,
+        append_images=[Image.new("RGBA", (10, 10), (0, 255, 0, 255))],
+    )
+    with Image.open(test_file) as im:
+        im.seek(1)
+        assert im.getpixel((64, 32)) == (0, 0, 0, 0)


 def test_apng_save_disposal_previous(tmp_path):
@@ -537,12 +556,12 @@
     red = Image.new("RGBA", size, (255, 0, 0, 255))
     green = Image.new("RGBA", size, (0, 255, 0, 255))

-    # test APNG_DISPOSE_OP_NONE
+    # test OP_NONE
     transparent.save(
         test_file,
         save_all=True,
         append_images=[red, green],
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,
+        disposal=PngImagePlugin.Disposal.OP_PREVIOUS,
     )
     with Image.open(test_file) as im:
         im.seek(2)
@@ -557,17 +576,17 @@
     green = Image.new("RGBA", size, (0, 255, 0, 255))
     transparent = Image.new("RGBA", size, (0, 0, 0, 0))

-    # test APNG_BLEND_OP_SOURCE on solid color
+    # test OP_SOURCE on solid color
     blend = [
-        PngImagePlugin.APNG_BLEND_OP_OVER,
-        PngImagePlugin.APNG_BLEND_OP_SOURCE,
+        PngImagePlugin.Blend.OP_OVER,
+        PngImagePlugin.Blend.OP_SOURCE,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[red, green],
         default_image=True,
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,
+        disposal=PngImagePlugin.Disposal.OP_NONE,
         blend=blend,
     )
     with Image.open(test_file) as im:
@@ -575,17 +594,17 @@
         assert im.getpixel((0, 0)) == (0, 255, 0, 255)
         assert im.getpixel((64, 32)) == (0, 255, 0, 255)

-    # test APNG_BLEND_OP_SOURCE on transparent color
+    # test OP_SOURCE on transparent color
     blend = [
-        PngImagePlugin.APNG_BLEND_OP_OVER,
-        PngImagePlugin.APNG_BLEND_OP_SOURCE,
+        PngImagePlugin.Blend.OP_OVER,
+        PngImagePlugin.Blend.OP_SOURCE,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[red, transparent],
         default_image=True,
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,
+        disposal=PngImagePlugin.Disposal.OP_NONE,
         blend=blend,
     )
     with Image.open(test_file) as im:
@@ -593,19 +612,36 @@
         assert im.getpixel((0, 0)) == (0, 0, 0, 0)
         assert im.getpixel((64, 32)) == (0, 0, 0, 0)

-    # test APNG_BLEND_OP_OVER
+    # test OP_OVER
     red.save(
         test_file,
         save_all=True,
         append_images=[green, transparent],
         default_image=True,
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
-    )
-    with Image.open(test_file) as im:
-        im.seek(1)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
-        im.seek(2)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+        disposal=PngImagePlugin.Disposal.OP_NONE,
+        blend=PngImagePlugin.Blend.OP_OVER,
+    )
+    with Image.open(test_file) as im:
+        im.seek(1)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+        im.seek(2)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+
+    # test info blend
+    red.info["blend"] = PngImagePlugin.Blend.OP_OVER
+    red.save(test_file, save_all=True, append_images=[green, transparent])
+    with Image.open(test_file) as im:
+        im.seek(2)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        PngImagePlugin.Disposal: "APNG_DISPOSE_",
+        PngImagePlugin.Blend: "APNG_BLEND_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(PngImagePlugin, prefix + name) == enum[name]
('Tests', 'test_imagetk.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -75,8 +75,9 @@
         assert im_tk.width() == 100
         assert im_tk.height() == 100

-        # reloaded = ImageTk.getimage(im_tk)
-        # assert_image_equal(reloaded, im)
+        im = Image.new(mode, (100, 100))
+        reloaded = ImageTk.getimage(im_tk)
+        assert_image_equal(reloaded.convert(mode), im)


 def test_bitmapimage():
('Tests', 'test_file_gribstub.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -45,3 +45,35 @@
     # Act / Assert: stub cannot save without an implemented handler
     with pytest.raises(OSError):
         im.save(tmpfile)
+
+
+def test_handler(tmp_path):
+    class TestHandler:
+        opened = False
+        loaded = False
+        saved = False
+
+        def open(self, im):
+            self.opened = True
+
+        def load(self, im):
+            self.loaded = True
+            return Image.new("RGB", (1, 1))
+
+        def save(self, im, fp, filename):
+            self.saved = True
+
+    handler = TestHandler()
+    GribStubImagePlugin.register_handler(handler)
+    with Image.open(TEST_FILE) as im:
+        assert handler.opened
+        assert not handler.loaded
+
+        im.load()
+        assert handler.loaded
+
+        temp_file = str(tmp_path / "temp.grib")
+        im.save(temp_file)
+        assert handler.saved
+
+    GribStubImagePlugin._handler = None
('Tests', 'helper.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -29,7 +29,6 @@
         def upload(a, b):
             a.show()
             b.show()
-

 elif "GITHUB_ACTIONS" in os.environ:
     HAS_UPLOADER = True
@@ -43,7 +42,6 @@
             a.save(os.path.join(tmpdir, "a.png"))
             b.save(os.path.join(tmpdir, "b.png"))
             return tmpdir
-

 else:
     try:
@@ -171,6 +169,21 @@
     version_required = parse_version(version_required)
     version_available = parse_version(features.version(feature))
     return pytest.mark.skipif(version_available < version_required, reason=reason)
+
+
+def mark_if_feature_version(mark, feature, version_blacklist, reason=None):
+    if not features.check(feature):
+        return pytest.mark.pil_noop_mark()
+    if reason is None:
+        reason = f"{feature} is {version_blacklist}"
+    version_required = parse_version(version_blacklist)
+    version_available = parse_version(features.version(feature))
+    if (
+        version_available.major == version_required.major
+        and version_available.minor == version_required.minor
+    ):
+        return mark(reason=reason)
+    return pytest.mark.pil_noop_mark()


 @pytest.mark.skipif(sys.platform.startswith("win32"), reason="Requires Unix or macOS")
@@ -257,8 +270,23 @@
     return bool(shutil.which("ppmquant") and shutil.which("ppmtogif"))


-def imagemagick_available():
-    return bool(IMCONVERT and shutil.which(IMCONVERT))
+def magick_command():
+    if sys.platform == "win32":
+        magickhome = os.environ.get("MAGICK_HOME", "")
+        if magickhome:
+            imagemagick = [os.path.join(magickhome, "convert.exe")]
+            graphicsmagick = [os.path.join(magickhome, "gm.exe"), "convert"]
+        else:
+            imagemagick = None
+            graphicsmagick = None
+    else:
+        imagemagick = ["convert"]
+        graphicsmagick = ["gm", "convert"]
+
+    if imagemagick and shutil.which(imagemagick[0]):
+        return imagemagick
+    elif graphicsmagick and shutil.which(graphicsmagick[0]):
+        return graphicsmagick


 def on_appveyor():
@@ -296,14 +324,6 @@
     return sysconfig.get_platform() == "mingw"


-if sys.platform == "win32":
-    IMCONVERT = os.environ.get("MAGICK_HOME", "")
-    if IMCONVERT:
-        IMCONVERT = os.path.join(IMCONVERT, "convert.exe")
-else:
-    IMCONVERT = "convert"
-
-
 class cached_property:
     def __init__(self, func):
         self.func = func
('Tests', 'test_image_crop.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -47,16 +47,12 @@
     assert crop(-25, 75, 25, 125) == (1875, 625)


-def test_negative_crop():
-    # Check negative crop size (@PIL171)
+@pytest.mark.parametrize("box", ((8, 2, 2, 8), (2, 8, 8, 2), (8, 8, 2, 2)))
+def test_negative_crop(box):
+    im = Image.new("RGB", (10, 10))

-    im = Image.new("L", (512, 512))
-    im = im.crop((400, 400, 200, 200))
-
-    assert im.size == (0, 0)
-    assert len(im.getdata()) == 0
-    with pytest.raises(IndexError):
-        im.getdata()[0]
+    with pytest.raises(ValueError):
+        im.crop(box)


 def test_crop_float():
('Tests', 'test_file_tga.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,7 +6,7 @@

 from PIL import Image

-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper

 _TGA_DIR = os.path.join("Tests", "images", "tga")
 _TGA_DIR_COMMON = os.path.join(_TGA_DIR, "common")
@@ -65,6 +65,16 @@
                         roundtrip(original_im)


+def test_palette_depth_16(tmp_path):
+    with Image.open("Tests/images/p_16.tga") as im:
+        assert_image_equal_tofile(im.convert("RGB"), "Tests/images/p_16.png")
+
+        out = str(tmp_path / "temp.png")
+        im.save(out)
+        with Image.open(out) as reloaded:
+            assert_image_equal_tofile(reloaded.convert("RGB"), "Tests/images/p_16.png")
+
+
 def test_id_field():
     # tga file with id field
     test_file = "Tests/images/tga_id_field.tga"
@@ -85,6 +95,11 @@

         # Assert
         assert im.size == (199, 199)
+
+
+def test_cross_scan_line():
+    with Image.open("Tests/images/cross_scan_line.tga") as im:
+        assert_image_equal_tofile(im, "Tests/images/cross_scan_line.png")


 def test_save(tmp_path):
@@ -112,6 +127,14 @@
         im.save(out)


+def test_save_mapdepth():
+    # This image has been manually hexedited from 200x32_p_bl_raw.tga
+    # to include an origin
+    test_file = "Tests/images/200x32_p_bl_raw_origin.tga"
+    with Image.open(test_file) as im:
+        assert_image_equal_tofile(im, "Tests/images/tga/common/200x32_p.png")
+
+
 def test_save_id_section(tmp_path):
     test_file = "Tests/images/rgb32rle.tga"
     with Image.open(test_file) as im:
@@ -151,6 +174,15 @@
         im.save(out, orientation=1)
     with Image.open(out) as test_im:
         assert test_im.info["orientation"] == 1
+
+
+def test_horizontal_orientations():
+    # These images have been manually hexedited to have the relevant orientations
+    with Image.open("Tests/images/rgb32rle_top_right.tga") as im:
+        assert im.load()[90, 90][:3] == (0, 0, 0)
+
+    with Image.open("Tests/images/rgb32rle_bottom_right.tga") as im:
+        assert im.load()[90, 90][:3] == (0, 255, 0)


 def test_save_rle(tmp_path):
('Tests', 'test_file_jpeg2k.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,16 +1,19 @@
+import os
 import re
 from io import BytesIO

 import pytest

-from PIL import Image, ImageFile, Jpeg2KImagePlugin, features
+from PIL import Image, ImageFile, Jpeg2KImagePlugin, UnidentifiedImageError, features

 from .helper import (
     assert_image_equal,
     assert_image_similar,
-    is_big_endian,
+    assert_image_similar_tofile,
     skip_unless_feature,
 )
+
+EXTRA_DIR = "Tests/images/jpeg2000"

 pytestmark = skip_unless_feature("jpg_2000")

@@ -27,9 +30,9 @@
     im.save(out, "JPEG2000", **options)
     test_bytes = out.tell()
     out.seek(0)
-    im = Image.open(out)
-    im.bytes = test_bytes  # for testing only
-    im.load()
+    with Image.open(out) as im:
+        im.bytes = test_bytes  # for testing only
+        im.load()
     return im


@@ -62,9 +65,7 @@
 def test_bytesio():
     with open("Tests/images/test-card-lossless.jp2", "rb") as f:
         data = BytesIO(f.read())
-    with Image.open(data) as im:
-        im.load()
-        assert_image_similar(im, test_card, 1.0e-3)
+    assert_image_similar_tofile(test_card, data, 1.0e-3)


 # These two test pre-written JPEG 2000 files that were not written with
@@ -80,9 +81,9 @@


 def test_lossy_tiled():
-    with Image.open("Tests/images/test-card-lossy-tiled.jp2") as im:
-        im.load()
-        assert_image_similar(im, test_card, 2.0)
+    assert_image_similar_tofile(
+        test_card, "Tests/images/test-card-lossy-tiled.jp2", 2.0
+    )


 def test_lossless_rt():
@@ -125,6 +126,16 @@
     assert_image_equal(im, test_card)


+def test_default_num_resolutions():
+    for num_resolutions in range(2, 6):
+        d = 1 << (num_resolutions - 1)
+        im = test_card.resize((d - 1, d - 1))
+        with pytest.raises(OSError):
+            roundtrip(im, num_resolutions=num_resolutions)
+        reloaded = roundtrip(im)
+        assert_image_equal(im, reloaded)
+
+
 def test_reduce():
     with Image.open("Tests/images/test-card-lossless.jp2") as im:
         assert callable(im.reduce)
@@ -137,6 +148,38 @@

         im.thumbnail((40, 40))
         assert im.size == (40, 30)
+
+
+def test_load_dpi():
+    with Image.open("Tests/images/test-card-lossless.jp2") as im:
+        assert im.info["dpi"] == (71.9836, 71.9836)
+
+    with Image.open("Tests/images/zero_dpi.jp2") as im:
+        assert "dpi" not in im.info
+
+
+def test_restricted_icc_profile():
+    ImageFile.LOAD_TRUNCATED_IMAGES = True
+    try:
+        # JPEG2000 image with a restricted ICC profile and a known colorspace
+        with Image.open("Tests/images/balloon_eciRGBv2_aware.jp2") as im:
+            assert im.mode == "RGB"
+    finally:
+        ImageFile.LOAD_TRUNCATED_IMAGES = False
+
+
+def test_header_errors():
+    for path in (
+        "Tests/images/invalid_header_length.jp2",
+        "Tests/images/not_enough_data.jp2",
+    ):
+        with pytest.raises(UnidentifiedImageError):
+            with Image.open(path):
+                pass
+
+    with pytest.raises(OSError):
+        with Image.open("Tests/images/expected_to_read.jp2"):
+            pass


 def test_layers_type(tmp_path):
@@ -166,6 +209,49 @@
         assert_image_similar(im, test_card, 0.4)


+@pytest.mark.parametrize(
+    "name, args, offset, data",
+    (
+        ("foo.j2k", {}, 0, b"\xff\x4f"),
+        ("foo.jp2", {}, 4, b"jP"),
+        (None, {"no_jp2": True}, 0, b"\xff\x4f"),
+        ("foo.j2k", {"no_jp2": True}, 0, b"\xff\x4f"),
+        ("foo.jp2", {"no_jp2": True}, 0, b"\xff\x4f"),
+        ("foo.j2k", {"no_jp2": False}, 0, b"\xff\x4f"),
+        ("foo.jp2", {"no_jp2": False}, 4, b"jP"),
+        ("foo.jp2", {"no_jp2": False}, 4, b"jP"),
+    ),
+)
+def test_no_jp2(name, args, offset, data):
+    out = BytesIO()
+    if name:
+        out.name = name
+    test_card.save(out, "JPEG2000", **args)
+    out.seek(offset)
+    assert out.read(2) == data
+
+
+def test_mct():
+    # Three component
+    for val in (0, 1):
+        out = BytesIO()
+        test_card.save(out, "JPEG2000", mct=val, no_jp2=True)
+
+        assert out.getvalue()[59] == val
+        with Image.open(out) as im:
+            assert_image_similar(im, test_card, 1.0e-3)
+
+    # Single component should have MCT disabled
+    for val in (0, 1):
+        out = BytesIO()
+        with Image.open("Tests/images/16bit.cropped.jp2") as jp2:
+            jp2.save(out, "JPEG2000", mct=val, no_jp2=True)
+
+        assert out.getvalue()[53] == 0
+        with Image.open(out) as im:
+            assert_image_similar(im, jp2, 1.0e-3)
+
+
 def test_rgba():
     # Arrange
     with Image.open("Tests/images/rgb_trns_ycbc.j2k") as j2k:
@@ -190,18 +276,14 @@
         assert jp2.mode == "I;16"


-@pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
 def test_16bit_monochrome_jp2_like_tiff():
     with Image.open("Tests/images/16bit.cropped.tif") as tiff_16bit:
-        with Image.open("Tests/images/16bit.cropped.jp2") as jp2:
-            assert_image_similar(jp2, tiff_16bit, 1e-3)
-
-
-@pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+        assert_image_similar_tofile(tiff_16bit, "Tests/images/16bit.cropped.jp2", 1e-3)
+
+
 def test_16bit_monochrome_j2k_like_tiff():
     with Image.open("Tests/images/16bit.cropped.tif") as tiff_16bit:
-        with Image.open("Tests/images/16bit.cropped.j2k") as j2k:
-            assert_image_similar(j2k, tiff_16bit, 1e-3)
+        assert_image_similar_tofile(tiff_16bit, "Tests/images/16bit.cropped.j2k", 1e-3)


 def test_16bit_j2k_roundtrips():
@@ -219,7 +301,8 @@
 def test_unbound_local():
     # prepatch, a malformed jp2 file could cause an UnboundLocalError exception.
     with pytest.raises(OSError):
-        Image.open("Tests/images/unbound_variable.jp2")
+        with Image.open("Tests/images/unbound_variable.jp2"):
+            pass


 def test_parser_feed():
@@ -233,3 +316,42 @@

     # Assert
     assert p.image.size == (640, 480)
+
+
+@pytest.mark.skipif(
+    not os.path.exists(EXTRA_DIR), reason="Extra image files not installed"
+)
+@pytest.mark.parametrize("name", ("subsampling_1", "subsampling_2", "zoo1", "zoo2"))
+def test_subsampling_decode(name):
+    test = f"{EXTRA_DIR}/{name}.jp2"
+    reference = f"{EXTRA_DIR}/{name}.ppm"
+
+    with Image.open(test) as im:
+        epsilon = 3  # for YCbCr images
+        with Image.open(reference) as im2:
+            width, height = im2.size
+            if name[-1] == "2":
+                # RGB reference images are downscaled
+                epsilon = 3e-3
+                width, height = width * 2, height * 2
+            expected = im2.resize((width, height), Image.Resampling.NEAREST)
+        assert_image_similar(im, expected, epsilon)
+
+
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/images/crash-4fb027452e6988530aa5dabee76eecacb3b79f8a.j2k",
+        "Tests/images/crash-7d4c83eb92150fb8f1653a697703ae06ae7c4998.j2k",
+        "Tests/images/crash-ccca68ff40171fdae983d924e127a721cab2bd50.j2k",
+        "Tests/images/crash-d2c93af851d3ab9a19e34503626368b2ecde9c03.j2k",
+    ],
+)
+def test_crashes(test_file):
+    with open(test_file, "rb") as f:
+        with Image.open(f) as im:
+            # Valgrind should not complain here
+            try:
+                im.load()
+            except OSError:
+                pass
('Tests', 'test_image_mode.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,6 +21,7 @@
     assert m.bands == ("1",)
     assert m.basemode == "L"
     assert m.basetype == "L"
+    assert m.typestr == "|b1"

     for mode in (
         "I;16",
@@ -45,6 +46,7 @@
     assert m.bands == ("R", "G", "B")
     assert m.basemode == "RGB"
     assert m.basetype == "L"
+    assert m.typestr == "|u1"


 def test_properties():
@@ -65,6 +67,5 @@
     check("RGB", "RGB", "L", 3, ("R", "G", "B"))
     check("RGBA", "RGB", "L", 4, ("R", "G", "B", "A"))
     check("RGBX", "RGB", "L", 4, ("R", "G", "B", "X"))
-    check("RGBX", "RGB", "L", 4, ("R", "G", "B", "X"))
     check("CMYK", "RGB", "L", 4, ("C", "M", "Y", "K"))
     check("YCbCr", "RGB", "L", 3, ("Y", "Cb", "Cr"))
('Tests', 'test_image_resample.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,12 @@

 from PIL import Image, ImageDraw

-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_similar,
+    hopper,
+    mark_if_feature_version,
+)


 class TestImagingResampleVulnerability:
@@ -19,7 +24,7 @@
         ):
             with pytest.raises(MemoryError):
                 # any resampling filter will do here
-                im.im.resize((xsize, ysize), Image.BILINEAR)
+                im.im.resize((xsize, ysize), Image.Resampling.BILINEAR)

     def test_invalid_size(self):
         im = hopper()
@@ -98,7 +103,7 @@
     def test_reduce_box(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (8, 8), 0xE1)
-            case = case.resize((4, 4), Image.BOX)
+            case = case.resize((4, 4), Image.Resampling.BOX)
             # fmt: off
             data = ("e1 e1"
                     "e1 e1")
@@ -109,7 +114,7 @@
     def test_reduce_bilinear(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (8, 8), 0xE1)
-            case = case.resize((4, 4), Image.BILINEAR)
+            case = case.resize((4, 4), Image.Resampling.BILINEAR)
             # fmt: off
             data = ("e1 c9"
                     "c9 b7")
@@ -120,7 +125,7 @@
     def test_reduce_hamming(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (8, 8), 0xE1)
-            case = case.resize((4, 4), Image.HAMMING)
+            case = case.resize((4, 4), Image.Resampling.HAMMING)
             # fmt: off
             data = ("e1 da"
                     "da d3")
@@ -131,7 +136,7 @@
     def test_reduce_bicubic(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (12, 12), 0xE1)
-            case = case.resize((6, 6), Image.BICUBIC)
+            case = case.resize((6, 6), Image.Resampling.BICUBIC)
             # fmt: off
             data = ("e1 e3 d4"
                     "e3 e5 d6"
@@ -143,7 +148,7 @@
     def test_reduce_lanczos(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (16, 16), 0xE1)
-            case = case.resize((8, 8), Image.LANCZOS)
+            case = case.resize((8, 8), Image.Resampling.LANCZOS)
             # fmt: off
             data = ("e1 e0 e4 d7"
                     "e0 df e3 d6"
@@ -156,7 +161,7 @@
     def test_enlarge_box(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (2, 2), 0xE1)
-            case = case.resize((4, 4), Image.BOX)
+            case = case.resize((4, 4), Image.Resampling.BOX)
             # fmt: off
             data = ("e1 e1"
                     "e1 e1")
@@ -167,7 +172,7 @@
     def test_enlarge_bilinear(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (2, 2), 0xE1)
-            case = case.resize((4, 4), Image.BILINEAR)
+            case = case.resize((4, 4), Image.Resampling.BILINEAR)
             # fmt: off
             data = ("e1 b0"
                     "b0 98")
@@ -178,7 +183,7 @@
     def test_enlarge_hamming(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (2, 2), 0xE1)
-            case = case.resize((4, 4), Image.HAMMING)
+            case = case.resize((4, 4), Image.Resampling.HAMMING)
             # fmt: off
             data = ("e1 d2"
                     "d2 c5")
@@ -189,7 +194,7 @@
     def test_enlarge_bicubic(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (4, 4), 0xE1)
-            case = case.resize((8, 8), Image.BICUBIC)
+            case = case.resize((8, 8), Image.Resampling.BICUBIC)
             # fmt: off
             data = ("e1 e5 ee b9"
                     "e5 e9 f3 bc"
@@ -202,7 +207,7 @@
     def test_enlarge_lanczos(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (6, 6), 0xE1)
-            case = case.resize((12, 12), Image.LANCZOS)
+            case = case.resize((12, 12), Image.Resampling.LANCZOS)
             data = (
                 "e1 e0 db ed f5 b8"
                 "e0 df da ec f3 b7"
@@ -215,7 +220,9 @@
                 self.check_case(channel, self.make_sample(data, (12, 12)))

     def test_box_filter_correct_range(self):
-        im = Image.new("RGB", (8, 8), "#1688ff").resize((100, 100), Image.BOX)
+        im = Image.new("RGB", (8, 8), "#1688ff").resize(
+            (100, 100), Image.Resampling.BOX
+        )
         ref = Image.new("RGB", (100, 100), "#1688ff")
         assert_image_equal(im, ref)

@@ -223,7 +230,7 @@
 class TestCoreResampleConsistency:
     def make_case(self, mode, fill):
         im = Image.new(mode, (512, 9), fill)
-        return im.resize((9, 512), Image.LANCZOS), im.load()[0, 0]
+        return im.resize((9, 512), Image.Resampling.LANCZOS), im.load()[0, 0]

     def run_case(self, case):
         channel, color = case
@@ -278,20 +285,20 @@
     @pytest.mark.xfail(reason="Current implementation isn't precise enough")
     def test_levels_rgba(self):
         case = self.make_levels_case("RGBA")
-        self.run_levels_case(case.resize((512, 32), Image.BOX))
-        self.run_levels_case(case.resize((512, 32), Image.BILINEAR))
-        self.run_levels_case(case.resize((512, 32), Image.HAMMING))
-        self.run_levels_case(case.resize((512, 32), Image.BICUBIC))
-        self.run_levels_case(case.resize((512, 32), Image.LANCZOS))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BOX))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BILINEAR))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.HAMMING))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BICUBIC))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.LANCZOS))

     @pytest.mark.xfail(reason="Current implementation isn't precise enough")
     def test_levels_la(self):
         case = self.make_levels_case("LA")
-        self.run_levels_case(case.resize((512, 32), Image.BOX))
-        self.run_levels_case(case.resize((512, 32), Image.BILINEAR))
-        self.run_levels_case(case.resize((512, 32), Image.HAMMING))
-        self.run_levels_case(case.resize((512, 32), Image.BICUBIC))
-        self.run_levels_case(case.resize((512, 32), Image.LANCZOS))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BOX))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BILINEAR))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.HAMMING))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BICUBIC))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.LANCZOS))

     def make_dirty_case(self, mode, clean_pixel, dirty_pixel):
         i = Image.new(mode, (64, 64), dirty_pixel)
@@ -316,19 +323,27 @@

     def test_dirty_pixels_rgba(self):
         case = self.make_dirty_case("RGBA", (255, 255, 0, 128), (0, 0, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.BOX), (255, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.BILINEAR), (255, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.HAMMING), (255, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.BICUBIC), (255, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.LANCZOS), (255, 255, 0))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BOX), (255, 255, 0))
+        self.run_dirty_case(
+            case.resize((20, 20), Image.Resampling.BILINEAR), (255, 255, 0)
+        )
+        self.run_dirty_case(
+            case.resize((20, 20), Image.Resampling.HAMMING), (255, 255, 0)
+        )
+        self.run_dirty_case(
+            case.resize((20, 20), Image.Resampling.BICUBIC), (255, 255, 0)
+        )
+        self.run_dirty_case(
+            case.resize((20, 20), Image.Resampling.LANCZOS), (255, 255, 0)
+        )

     def test_dirty_pixels_la(self):
         case = self.make_dirty_case("LA", (255, 128), (0, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.BOX), (255,))
-        self.run_dirty_case(case.resize((20, 20), Image.BILINEAR), (255,))
-        self.run_dirty_case(case.resize((20, 20), Image.HAMMING), (255,))
-        self.run_dirty_case(case.resize((20, 20), Image.BICUBIC), (255,))
-        self.run_dirty_case(case.resize((20, 20), Image.LANCZOS), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BOX), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BILINEAR), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.HAMMING), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BICUBIC), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.LANCZOS), (255,))


 class TestCoreResamplePasses:
@@ -341,26 +356,26 @@
     def test_horizontal(self):
         im = hopper("L")
         with self.count(1):
-            im.resize((im.size[0] - 10, im.size[1]), Image.BILINEAR)
+            im.resize((im.size[0] - 10, im.size[1]), Image.Resampling.BILINEAR)

     def test_vertical(self):
         im = hopper("L")
         with self.count(1):
-            im.resize((im.size[0], im.size[1] - 10), Image.BILINEAR)
+            im.resize((im.size[0], im.size[1] - 10), Image.Resampling.BILINEAR)

     def test_both(self):
         im = hopper("L")
         with self.count(2):
-            im.resize((im.size[0] - 10, im.size[1] - 10), Image.BILINEAR)
+            im.resize((im.size[0] - 10, im.size[1] - 10), Image.Resampling.BILINEAR)

     def test_box_horizontal(self):
         im = hopper("L")
         box = (20, 0, im.size[0] - 20, im.size[1])
         with self.count(1):
             # the same size, but different box
-            with_box = im.resize(im.size, Image.BILINEAR, box)
+            with_box = im.resize(im.size, Image.Resampling.BILINEAR, box)
         with self.count(2):
-            cropped = im.crop(box).resize(im.size, Image.BILINEAR)
+            cropped = im.crop(box).resize(im.size, Image.Resampling.BILINEAR)
         assert_image_similar(with_box, cropped, 0.1)

     def test_box_vertical(self):
@@ -368,9 +383,9 @@
         box = (0, 20, im.size[0], im.size[1] - 20)
         with self.count(1):
             # the same size, but different box
-            with_box = im.resize(im.size, Image.BILINEAR, box)
+            with_box = im.resize(im.size, Image.Resampling.BILINEAR, box)
         with self.count(2):
-            cropped = im.crop(box).resize(im.size, Image.BILINEAR)
+            cropped = im.crop(box).resize(im.size, Image.Resampling.BILINEAR)
         assert_image_similar(with_box, cropped, 0.1)


@@ -383,7 +398,7 @@
             draw = ImageDraw.Draw(i)
             draw.rectangle((0, 0, i.size[0] // 2 - 1, 0), test_color)

-            px = i.resize((5, i.size[1]), Image.BICUBIC).load()
+            px = i.resize((5, i.size[1]), Image.Resampling.BICUBIC).load()
             if px[2, 0] != test_color // 2:
                 assert test_color // 2 == px[2, 0]

@@ -391,7 +406,7 @@
         # regression test for the wrong coefficients calculation
         # due to bug https://github.com/python-pillow/Pillow/issues/2161
         im = Image.new("RGBA", (1280, 1280), (0x20, 0x40, 0x60, 0xFF))
-        histogram = im.resize((256, 256), Image.BICUBIC).histogram()
+        histogram = im.resize((256, 256), Image.Resampling.BICUBIC).histogram()

         # first channel
         assert histogram[0x100 * 0 + 0x20] == 0x10000
@@ -407,12 +422,12 @@
     def test_wrong_arguments(self):
         im = hopper()
         for resample in (
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ):
             im.resize((32, 32), resample, (0, 0, im.width, im.height))
             im.resize((32, 32), resample, (20, 20, im.width, im.height))
@@ -451,20 +466,26 @@
         for y0, y1 in split_range(dst_size[1], ytiles):
             for x0, x1 in split_range(dst_size[0], xtiles):
                 box = (x0 * scale[0], y0 * scale[1], x1 * scale[0], y1 * scale[1])
-                tile = im.resize((x1 - x0, y1 - y0), Image.BICUBIC, box)
+                tile = im.resize((x1 - x0, y1 - y0), Image.Resampling.BICUBIC, box)
                 tiled.paste(tile, (x0, y0))
         return tiled

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_tiles(self):
         with Image.open("Tests/images/flower.jpg") as im:
             assert im.size == (480, 360)
             dst_size = (251, 188)
-            reference = im.resize(dst_size, Image.BICUBIC)
+            reference = im.resize(dst_size, Image.Resampling.BICUBIC)

             for tiles in [(1, 1), (3, 3), (9, 7), (100, 100)]:
                 tiled = self.resize_tiled(im, dst_size, *tiles)
                 assert_image_similar(reference, tiled, 0.01)

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_subsample(self):
         # This test shows advantages of the subpixel resizing
         # after supersampling (e.g. during JPEG decoding).
@@ -472,12 +493,16 @@
             assert im.size == (480, 360)
             dst_size = (48, 36)
             # Reference is cropped image resized to destination
-            reference = im.crop((0, 0, 473, 353)).resize(dst_size, Image.BICUBIC)
-            # Image.BOX emulates supersampling (480 / 8 = 60, 360 / 8 = 45)
-            supersampled = im.resize((60, 45), Image.BOX)
-
-        with_box = supersampled.resize(dst_size, Image.BICUBIC, (0, 0, 59.125, 44.125))
-        without_box = supersampled.resize(dst_size, Image.BICUBIC)
+            reference = im.crop((0, 0, 473, 353)).resize(
+                dst_size, Image.Resampling.BICUBIC
+            )
+            # Image.Resampling.BOX emulates supersampling (480 / 8 = 60, 360 / 8 = 45)
+            supersampled = im.resize((60, 45), Image.Resampling.BOX)
+
+        with_box = supersampled.resize(
+            dst_size, Image.Resampling.BICUBIC, (0, 0, 59.125, 44.125)
+        )
+        without_box = supersampled.resize(dst_size, Image.Resampling.BICUBIC)

         # error with box should be much smaller than without
         assert_image_similar(reference, with_box, 6)
@@ -485,7 +510,7 @@
             assert_image_similar(reference, without_box, 5)

     def test_formats(self):
-        for resample in [Image.NEAREST, Image.BILINEAR]:
+        for resample in [Image.Resampling.NEAREST, Image.Resampling.BILINEAR]:
             for mode in ["RGB", "L", "RGBA", "LA", "I", ""]:
                 im = hopper(mode)
                 box = (20, 20, im.size[0] - 20, im.size[1] - 20)
@@ -503,7 +528,7 @@
             ((40, 50), (10, 0, 50, 50)),
             ((40, 50), (10, 20, 50, 70)),
         ]:
-            res = im.resize(size, Image.LANCZOS, box)
+            res = im.resize(size, Image.Resampling.LANCZOS, box)
             assert res.size == size
             assert_image_equal(res, im.crop(box), f">>> {size} {box}")

@@ -517,7 +542,7 @@
             ((40, 50), (10.4, 0.4, 50.4, 50.4)),
             ((40, 50), (10.4, 20.4, 50.4, 70.4)),
         ]:
-            res = im.resize(size, Image.LANCZOS, box)
+            res = im.resize(size, Image.Resampling.LANCZOS, box)
             assert res.size == size
             with pytest.raises(AssertionError, match=r"difference \d"):
                 # check that the difference at least that much
@@ -527,7 +552,7 @@
         # Can skip resize for one dimension
         im = hopper()

-        for flt in [Image.NEAREST, Image.BICUBIC]:
+        for flt in [Image.Resampling.NEAREST, Image.Resampling.BICUBIC]:
             for size, box in [
                 ((40, 50), (0, 0, 40, 90)),
                 ((40, 50), (0, 20, 40, 90)),
@@ -548,7 +573,7 @@
         # Can skip resize for one dimension
         im = hopper()

-        for flt in [Image.NEAREST, Image.BICUBIC]:
+        for flt in [Image.Resampling.NEAREST, Image.Resampling.BICUBIC]:
             for size, box in [
                 ((40, 50), (0, 0, 90, 50)),
                 ((40, 50), (20, 0, 90, 50)),
('Tests', 'test_image_quantize.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,41 +1,40 @@
 import pytest
+from packaging.version import parse as parse_version

-from PIL import Image
+from PIL import Image, features

-from .helper import assert_image, assert_image_similar, hopper, is_ppc64le
+from .helper import assert_image_similar, hopper, is_ppc64le, skip_unless_feature


 def test_sanity():
     image = hopper()
     converted = image.quantize()
-    assert_image(converted, "P", converted.size)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 10)

     image = hopper()
     converted = image.quantize(palette=hopper("P"))
-    assert_image(converted, "P", converted.size)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 60)


-@pytest.mark.xfail(is_ppc64le(), reason="failing on ppc64le on GHA")
+@skip_unless_feature("libimagequant")
 def test_libimagequant_quantize():
     image = hopper()
-    try:
-        converted = image.quantize(100, Image.LIBIMAGEQUANT)
-    except ValueError as ex:  # pragma: no cover
-        if "dependency" in str(ex).lower():
-            pytest.skip("libimagequant support not available")
-        else:
-            raise
-    assert_image(converted, "P", converted.size)
+    if is_ppc64le():
+        libimagequant = parse_version(features.version_feature("libimagequant"))
+        if libimagequant < parse_version("4"):
+            pytest.skip("Fails with libimagequant earlier than 4.0.0 on ppc64le")
+    converted = image.quantize(100, Image.Quantize.LIBIMAGEQUANT)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 15)
     assert len(converted.getcolors()) == 100


 def test_octree_quantize():
     image = hopper()
-    converted = image.quantize(100, Image.FASTOCTREE)
-    assert_image(converted, "P", converted.size)
+    converted = image.quantize(100, Image.Quantize.FASTOCTREE)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 20)
     assert len(converted.getcolors()) == 100

@@ -52,7 +51,7 @@
     with Image.open("Tests/images/caption_6_33_22.png") as image:
         image = image.convert("RGB")
     converted = image.quantize()
-    assert_image(converted, "P", converted.size)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 1)


@@ -61,8 +60,9 @@
     with Image.open("Tests/images/caption_6_33_22.png") as palette:
         palette = palette.convert("P")

-    converted = image.quantize(dither=0, palette=palette)
-    assert_image(converted, "P", converted.size)
+    converted = image.quantize(dither=Image.Dither.NONE, palette=palette)
+    assert converted.mode == "P"
+    assert converted.palette.palette == palette.palette.palette


 def test_quantize_dither_diff():
@@ -70,7 +70,56 @@
     with Image.open("Tests/images/caption_6_33_22.png") as palette:
         palette = palette.convert("P")

-    dither = image.quantize(dither=1, palette=palette)
-    nodither = image.quantize(dither=0, palette=palette)
+    dither = image.quantize(dither=Image.Dither.FLOYDSTEINBERG, palette=palette)
+    nodither = image.quantize(dither=Image.Dither.NONE, palette=palette)

     assert dither.tobytes() != nodither.tobytes()
+
+
+def test_colors():
+    im = hopper()
+    colors = 2
+    converted = im.quantize(colors)
+    assert len(converted.palette.palette) == colors * len("RGB")
+
+
+def test_transparent_colors_equal():
+    im = Image.new("RGBA", (1, 2), (0, 0, 0, 0))
+    px = im.load()
+    px[0, 1] = (255, 255, 255, 0)
+
+    converted = im.quantize()
+    converted_px = converted.load()
+    assert converted_px[0, 0] == converted_px[0, 1]
+
+
+@pytest.mark.parametrize(
+    "method, color",
+    (
+        (Image.Quantize.MEDIANCUT, (0, 0, 0)),
+        (Image.Quantize.MAXCOVERAGE, (0, 0, 0)),
+        (Image.Quantize.FASTOCTREE, (0, 0, 0)),
+        (Image.Quantize.FASTOCTREE, (0, 0, 0, 0)),
+    ),
+)
+def test_palette(method, color):
+    im = Image.new("RGBA" if len(color) == 4 else "RGB", (1, 1), color)
+
+    converted = im.quantize(method=method)
+    converted_px = converted.load()
+    assert converted_px[0, 0] == converted.palette.colors[color]
+
+
+def test_small_palette():
+    # Arrange
+    im = hopper()
+
+    colors = (255, 0, 0, 0, 0, 255)
+    p = Image.new("P", (1, 1))
+    p.putpalette(colors)
+
+    # Act
+    im = im.quantize(palette=p)
+
+    # Assert
+    assert len(im.getcolors()) == 2
('Tests', 'test_imagedraw2.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,8 @@

 from .helper import (
     assert_image_equal,
-    assert_image_similar,
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
     hopper,
     skip_unless_feature,
 )
@@ -61,7 +62,7 @@
     draw.ellipse(bbox, pen, brush)

     # Assert
-    assert_image_similar(im, Image.open(expected), 1)
+    assert_image_similar_tofile(im, expected, 1)


 def test_ellipse1():
@@ -82,7 +83,7 @@
     draw.ellipse(((0, 0), (W - 1, H - 1)), brush)

     # Assert
-    assert_image_similar(im, Image.open("Tests/images/imagedraw_ellipse_edge.png"), 1)
+    assert_image_similar_tofile(im, "Tests/images/imagedraw_ellipse_edge.png", 1)


 def helper_line(points):
@@ -95,7 +96,7 @@
     draw.line(points, pen)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_line.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_line.png")


 def test_line1_pen():
@@ -118,7 +119,7 @@
     draw.line(POINTS1, pen, brush)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_line.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_line.png")


 def helper_polygon(points):
@@ -132,7 +133,7 @@
     draw.polygon(points, pen, brush)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_polygon.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_polygon.png")


 def test_polygon1():
@@ -154,7 +155,7 @@
     draw.rectangle(bbox, pen, brush)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_rectangle.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rectangle.png")


 def test_rectangle1():
@@ -178,7 +179,7 @@
     draw.rectangle(bbox, brush)

     # Assert
-    assert_image_similar(im, Image.open(expected), 1)
+    assert_image_similar_tofile(im, expected, 1)


 @skip_unless_feature("freetype2")
@@ -193,7 +194,7 @@
     draw.text((5, 5), "ImageDraw2", font)

     # Assert
-    assert_image_similar(im, Image.open(expected), 13)
+    assert_image_similar_tofile(im, expected, 13)


 @skip_unless_feature("freetype2")
('Tests', 'test_file_palm.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,9 +5,7 @@

 from PIL import Image

-from .helper import IMCONVERT, assert_image_equal, hopper, imagemagick_available
-
-_roundtrip = imagemagick_available()
+from .helper import assert_image_equal, hopper, magick_command


 def helper_save_as_palm(tmp_path, mode):
@@ -23,13 +21,10 @@
     assert os.path.getsize(outfile) > 0


-def open_with_imagemagick(tmp_path, f):
-    if not imagemagick_available():
-        raise OSError()
-
+def open_with_magick(magick, tmp_path, f):
     outfile = str(tmp_path / "temp.png")
     rc = subprocess.call(
-        [IMCONVERT, f, outfile], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT
+        magick + [f, outfile], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT
     )
     if rc:
         raise OSError
@@ -37,14 +32,15 @@


 def roundtrip(tmp_path, mode):
-    if not _roundtrip:
+    magick = magick_command()
+    if not magick:
         return

     im = hopper(mode)
     outfile = str(tmp_path / "temp.palm")

     im.save(outfile)
-    converted = open_with_imagemagick(tmp_path, outfile)
+    converted = open_with_magick(magick, tmp_path, outfile)
     assert_image_equal(converted, im)


('Tests', 'test_file_icns.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,11 +1,12 @@
 import io
-import sys
+import os
+import warnings

 import pytest

-from PIL import IcnsImagePlugin, Image, features
+from PIL import IcnsImagePlugin, Image, _binary, features

-from .helper import assert_image_equal, assert_image_similar
+from .helper import assert_image_equal, assert_image_similar_tofile

 # sample icon file
 TEST_FILE = "Tests/images/pillow.icns"
@@ -19,14 +20,22 @@
     with Image.open(TEST_FILE) as im:

         # Assert that there is no unclosed file warning
-        pytest.warns(None, im.load)
+        with warnings.catch_warnings():
+            im.load()

         assert im.mode == "RGBA"
         assert im.size == (1024, 1024)
         assert im.format == "ICNS"


-@pytest.mark.skipif(sys.platform != "darwin", reason="Requires macOS")
+def test_load():
+    with Image.open(TEST_FILE) as im:
+        assert im.load()[0, 0] == (0, 0, 0, 0)
+
+        # Test again now that it has already been loaded once
+        assert im.load()[0, 0] == (0, 0, 0, 0)
+
+
 def test_save(tmp_path):
     temp_file = str(tmp_path / "temp.icns")

@@ -38,8 +47,12 @@
         assert reread.size == (1024, 1024)
         assert reread.format == "ICNS"

+    file_length = os.path.getsize(temp_file)
+    with open(temp_file, "rb") as fp:
+        fp.seek(4)
+        assert _binary.i32be(fp.read(4)) == file_length

-@pytest.mark.skipif(sys.platform != "darwin", reason="Requires macOS")
+
 def test_save_append_images(tmp_path):
     temp_file = str(tmp_path / "temp.icns")
     provided_im = Image.new("RGBA", (32, 32), (255, 0, 0, 128))
@@ -47,8 +60,7 @@
     with Image.open(TEST_FILE) as im:
         im.save(temp_file, append_images=[provided_im])

-        with Image.open(temp_file) as reread:
-            assert_image_similar(reread, im, 1)
+        assert_image_similar_tofile(im, temp_file, 1)

         with Image.open(temp_file) as reread:
             reread.size = (16, 16, 2)
@@ -56,7 +68,6 @@
             assert_image_equal(reread, provided_im)


-@pytest.mark.skipif(sys.platform != "darwin", reason="Requires macOS")
 def test_save_fp():
     fp = io.BytesIO()

@@ -101,12 +112,9 @@


 def test_jp2_icon():
-    # This icon was made by using Uli Kusterer's oldiconutil to replace
-    # the PNG images with JPEG 2000 ones.  The advantage of doing this is
-    # that OS X 10.5 supports JPEG 2000 but not PNG; some commercial
-    # software therefore does just this.
-
-    # (oldiconutil is here: https://github.com/uliwitness/oldiconutil)
+    # This icon uses JPEG 2000 images instead of the PNG images.
+    # The advantage of doing this is that OS X 10.5 supports JPEG 2000
+    # but not PNG; some commercial software therefore does just this.

     if not ENABLE_JPEG2K:
         return
@@ -139,3 +147,11 @@
     with io.BytesIO(b"invalid\n") as fp:
         with pytest.raises(SyntaxError):
             IcnsImagePlugin.IcnsFile(fp)
+
+
+def test_icns_decompression_bomb():
+    with Image.open(
+        "Tests/images/oom-8ed3316a4109213ca96fb8a256a0bfefdece1461.icns"
+    ) as im:
+        with pytest.raises(Image.DecompressionBombError):
+            im.load()
('Tests', 'test_file_libtiff.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,11 +4,11 @@
 import os
 import re
 from collections import namedtuple
-from ctypes import c_float

 import pytest

 from PIL import Image, ImageFilter, TiffImagePlugin, TiffTags, features
+from PIL.TiffImagePlugin import SAMPLEFORMAT, STRIPOFFSETS, SUBIFD

 from .helper import (
     assert_image_equal,
@@ -16,7 +16,7 @@
     assert_image_similar,
     assert_image_similar_tofile,
     hopper,
-    is_big_endian,
+    mark_if_feature_version,
     skip_unless_feature,
 )

@@ -96,24 +96,22 @@
             self._assert_noerr(tmp_path, im)

     def test_g4_eq_png(self):
-        """ Checking that we're actually getting the data that we expect"""
+        """Checking that we're actually getting the data that we expect"""
         with Image.open("Tests/images/hopper_bw_500.png") as png:
-            with Image.open("Tests/images/hopper_g4_500.tif") as g4:
-                assert_image_equal(g4, png)
+            assert_image_equal_tofile(png, "Tests/images/hopper_g4_500.tif")

     # see https://github.com/python-pillow/Pillow/issues/279
     def test_g4_fillorder_eq_png(self):
-        """ Checking that we're actually getting the data that we expect"""
-        with Image.open("Tests/images/g4-fillorder-test.png") as png:
-            with Image.open("Tests/images/g4-fillorder-test.tif") as g4:
-                assert_image_equal(g4, png)
+        """Checking that we're actually getting the data that we expect"""
+        with Image.open("Tests/images/g4-fillorder-test.tif") as g4:
+            assert_image_equal_tofile(g4, "Tests/images/g4-fillorder-test.png")

     def test_g4_write(self, tmp_path):
         """Checking to see that the saved image is the same as what we wrote"""
         test_file = "Tests/images/hopper_g4_500.tif"
         with Image.open(test_file) as orig:
             out = str(tmp_path / "temp.tif")
-            rot = orig.transpose(Image.ROTATE_90)
+            rot = orig.transpose(Image.Transpose.ROTATE_90)
             assert rot.size == (500, 500)
             rot.save(out)

@@ -138,7 +136,7 @@
             assert_image_equal_tofile(im, "Tests/images/tiff_adobe_deflate.png")

     def test_write_metadata(self, tmp_path):
-        """ Test metadata writing through libtiff """
+        """Test metadata writing through libtiff"""
         for legacy_api in [False, True]:
             f = str(tmp_path / "temp.tiff")
             with Image.open("Tests/images/hopper_g4.tif") as img:
@@ -169,14 +167,11 @@
                     val = original[tag]
                     if tag.endswith("Resolution"):
                         if legacy_api:
-                            assert (
-                                c_float(val[0][0] / val[0][1]).value
-                                == c_float(value[0][0] / value[0][1]).value
+                            assert val[0][0] / val[0][1] == (
+                                4294967295 / 113653537
                             ), f"{tag} didn't roundtrip"
                         else:
-                            assert (
-                                c_float(val).value == c_float(value).value
-                            ), f"{tag} didn't roundtrip"
+                            assert val == 37.79000115940079, f"{tag} didn't roundtrip"
                     else:
                         assert val == value, f"{tag} didn't roundtrip"

@@ -185,6 +180,7 @@
             for field in requested_fields:
                 assert field in reloaded, f"{field} not in metadata"

+    @pytest.mark.valgrind_known_error(reason="Known invalid metadata")
     def test_additional_metadata(self, tmp_path):
         # these should not crash. Seriously dummy data, most of it doesn't make
         # any sense, so we're running up against limits where we're asking
@@ -218,7 +214,7 @@
             values = {
                 2: "test",
                 3: 1,
-                4: 2 ** 20,
+                4: 2**20,
                 5: TiffImagePlugin.IFDRational(100, 1),
                 12: 1.05,
             }
@@ -323,6 +319,14 @@
             )
         TiffImagePlugin.WRITE_LIBTIFF = False

+    def test_subifd(self, tmp_path):
+        outfile = str(tmp_path / "temp.tif")
+        with Image.open("Tests/images/g4_orientation_6.tif") as im:
+            im.tag_v2[SUBIFD] = 10000
+
+            # Should not segfault
+            im.save(outfile)
+
     def test_xmlpacket_tag(self, tmp_path):
         TiffImagePlugin.WRITE_LIBTIFF = True

@@ -427,10 +431,7 @@
         im = im.filter(ImageFilter.GaussianBlur(4))
         im.save(out, compression="tiff_adobe_deflate")

-        with Image.open(out) as im2:
-            im2.load()
-
-            assert_image_equal(im, im2)
+        assert_image_equal_tofile(im, out)

     def test_compressions(self, tmp_path):
         # Test various tiff compressions and assert similar image content but reduced
@@ -443,8 +444,7 @@
         for compression in ("packbits", "tiff_lzw"):
             im.save(out, compression=compression)
             size_compressed = os.path.getsize(out)
-            with Image.open(out) as im2:
-                assert_image_equal(im, im2)
+            assert_image_equal_tofile(im, out)

         im.save(out, compression="jpeg")
         size_jpeg = os.path.getsize(out)
@@ -453,8 +453,7 @@

         im.save(out, compression="jpeg", quality=30)
         size_jpeg_30 = os.path.getsize(out)
-        with Image.open(out) as im3:
-            assert_image_similar(im2, im3, 30)
+        assert_image_similar_tofile(im2, out, 30)

         assert size_raw > size_compressed
         assert size_compressed > size_jpeg
@@ -467,6 +466,14 @@

         with Image.open(out) as reloaded:
             assert reloaded.info["compression"] == "jpeg"
+
+    def test_tiff_deflate_compression(self, tmp_path):
+        im = hopper("RGB")
+        out = str(tmp_path / "temp.tif")
+        im.save(out, compression="tiff_deflate")
+
+        with Image.open(out) as reloaded:
+            assert reloaded.info["compression"] == "tiff_adobe_deflate"

     def test_quality(self, tmp_path):
         im = hopper("RGB")
@@ -488,8 +495,7 @@
         out = str(tmp_path / "temp.tif")

         im.save(out, compression="tiff_adobe_deflate")
-        with Image.open(out) as im2:
-            assert_image_equal(im, im2)
+        assert_image_equal_tofile(im, out)

     def test_palette_save(self, tmp_path):
         im = hopper("P")
@@ -565,6 +571,17 @@
                 im.seek(0)
                 # Should not raise ValueError: I/O operation on closed file
                 im.load()
+
+        TiffImagePlugin.READ_LIBTIFF = False
+
+    def test_multipage_seek_backwards(self):
+        TiffImagePlugin.READ_LIBTIFF = True
+        with Image.open("Tests/images/multipage.tiff") as im:
+            im.seek(1)
+            im.load()
+
+            im.seek(0)
+            assert im.convert("RGB").getpixel((0, 0)) == (0, 128, 0)

         TiffImagePlugin.READ_LIBTIFF = False

@@ -639,8 +656,7 @@
             pilim.save(buffer_io, format="tiff", compression=compression)
             buffer_io.seek(0)

-            with Image.open(buffer_io) as pilim_load:
-                assert_image_similar(pilim, pilim_load, 0)
+            assert_image_similar_tofile(pilim, buffer_io, 0)

         save_bytesio()
         save_bytesio("raw")
@@ -649,6 +665,15 @@

         TiffImagePlugin.WRITE_LIBTIFF = False
         TiffImagePlugin.READ_LIBTIFF = False
+
+    def test_save_ycbcr(self, tmp_path):
+        im = hopper("YCbCr")
+        outfile = str(tmp_path / "temp.tif")
+        im.save(outfile, compression="jpeg")
+
+        with Image.open(outfile) as reloaded:
+            assert reloaded.tag_v2[530] == (1, 1)
+            assert reloaded.tag_v2[532] == (0, 255, 128, 255, 128, 255)

     def test_crashing_metadata(self, tmp_path):
         # issue 1597
@@ -796,6 +821,17 @@

             assert_image_equal_tofile(im, "Tests/images/copyleft.png", mode="RGB")

+    def test_sampleformat_write(self, tmp_path):
+        im = Image.new("F", (1, 1))
+        out = str(tmp_path / "temp.tif")
+        TiffImagePlugin.WRITE_LIBTIFF = True
+        im.save(out)
+        TiffImagePlugin.WRITE_LIBTIFF = False
+
+        with Image.open(out) as reloaded:
+            assert reloaded.mode == "F"
+            assert reloaded.getexif()[SAMPLEFORMAT] == 3
+
     def test_lzw(self):
         with Image.open("Tests/images/hopper_lzw.tif") as im:
             assert im.mode == "RGB"
@@ -814,13 +850,17 @@
         with Image.open(infile) as im:
             assert_image_similar_tofile(im, "Tests/images/pil_sample_cmyk.jpg", 0.5)

-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_strip_ycbcr_jpeg_2x2_sampling(self):
         infile = "Tests/images/tiff_strip_ycbcr_jpeg_2x2_sampling.tif"
         with Image.open(infile) as im:
             assert_image_similar_tofile(im, "Tests/images/flower.jpg", 0.5)

-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_strip_ycbcr_jpeg_1x1_sampling(self):
         infile = "Tests/images/tiff_strip_ycbcr_jpeg_1x1_sampling.tif"
         with Image.open(infile) as im:
@@ -831,22 +871,87 @@
         with Image.open(infile) as im:
             assert_image_similar_tofile(im, "Tests/images/pil_sample_cmyk.jpg", 0.5)

-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_tiled_ycbcr_jpeg_1x1_sampling(self):
         infile = "Tests/images/tiff_tiled_ycbcr_jpeg_1x1_sampling.tif"
         with Image.open(infile) as im:
             assert_image_equal_tofile(im, "Tests/images/flower2.jpg")

-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_tiled_ycbcr_jpeg_2x2_sampling(self):
         infile = "Tests/images/tiff_tiled_ycbcr_jpeg_2x2_sampling.tif"
         with Image.open(infile) as im:
             assert_image_similar_tofile(im, "Tests/images/flower.jpg", 0.5)

-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    def test_strip_planar_rgb(self):
+        # gdal_translate -co TILED=no -co INTERLEAVE=BAND -co COMPRESS=LZW \
+        # tiff_strip_raw.tif tiff_strip_planar_lzw.tiff
+        infile = "Tests/images/tiff_strip_planar_lzw.tiff"
+        with Image.open(infile) as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_adobe_deflate.png")
+
+    def test_tiled_planar_rgb(self):
+        # gdal_translate -co TILED=yes -co INTERLEAVE=BAND -co COMPRESS=LZW \
+        # tiff_tiled_raw.tif tiff_tiled_planar_lzw.tiff
+        infile = "Tests/images/tiff_tiled_planar_lzw.tiff"
+        with Image.open(infile) as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_adobe_deflate.png")
+
+    def test_tiled_planar_16bit_RGB(self):
+        # gdal_translate -co TILED=yes -co INTERLEAVE=BAND -co COMPRESS=LZW \
+        # tiff_16bit_RGB.tiff tiff_tiled_planar_16bit_RGB.tiff
+        with Image.open("Tests/images/tiff_tiled_planar_16bit_RGB.tiff") as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_16bit_RGB_target.png")
+
+    def test_strip_planar_16bit_RGB(self):
+        # gdal_translate -co TILED=no -co INTERLEAVE=BAND -co COMPRESS=LZW \
+        # tiff_16bit_RGB.tiff tiff_strip_planar_16bit_RGB.tiff
+        with Image.open("Tests/images/tiff_strip_planar_16bit_RGB.tiff") as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_16bit_RGB_target.png")
+
+    def test_tiled_planar_16bit_RGBa(self):
+        # gdal_translate -co TILED=yes \
+        # -co INTERLEAVE=BAND -co COMPRESS=LZW -co ALPHA=PREMULTIPLIED \
+        # tiff_16bit_RGBa.tiff tiff_tiled_planar_16bit_RGBa.tiff
+        with Image.open("Tests/images/tiff_tiled_planar_16bit_RGBa.tiff") as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_16bit_RGBa_target.png")
+
+    def test_strip_planar_16bit_RGBa(self):
+        # gdal_translate -co TILED=no \
+        # -co INTERLEAVE=BAND -co COMPRESS=LZW -co ALPHA=PREMULTIPLIED \
+        # tiff_16bit_RGBa.tiff tiff_strip_planar_16bit_RGBa.tiff
+        with Image.open("Tests/images/tiff_strip_planar_16bit_RGBa.tiff") as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_16bit_RGBa_target.png")
+
+    @pytest.mark.parametrize("compression", (None, "jpeg"))
+    def test_block_tile_tags(self, compression, tmp_path):
+        im = hopper()
+        out = str(tmp_path / "temp.tif")
+
+        tags = {
+            TiffImagePlugin.TILEWIDTH: 256,
+            TiffImagePlugin.TILELENGTH: 256,
+            TiffImagePlugin.TILEOFFSETS: 256,
+            TiffImagePlugin.TILEBYTECOUNTS: 256,
+        }
+        im.save(out, exif=tags, compression=compression)
+
+        with Image.open(out) as reloaded:
+            for tag in tags.keys():
+                assert tag not in reloaded.getexif()
+
     def test_old_style_jpeg(self):
-        infile = "Tests/images/old-style-jpeg-compression.tif"
-        with Image.open(infile) as im:
+        with Image.open("Tests/images/old-style-jpeg-compression.tif") as im:
+            assert_image_equal_tofile(im, "Tests/images/old-style-jpeg-compression.png")
+
+    def test_open_missing_samplesperpixel(self):
+        with Image.open(
+            "Tests/images/old-style-jpeg-compression-no-samplesperpixel.tif"
+        ) as im:
             assert_image_equal_tofile(im, "Tests/images/old-style-jpeg-compression.png")

     def test_no_rows_per_strip(self):
@@ -864,6 +969,7 @@

                     assert_image_similar(base_im, im, 0.7)

+    @pytest.mark.valgrind_known_error(reason="Backtrace in Python Core")
     def test_sampleformat_not_corrupted(self):
         # Assert that a TIFF image with SampleFormat=UINT tag is not corrupted
         # when saving to a new file.
@@ -894,3 +1000,34 @@
             # Assert that the error code is IMAGING_CODEC_MEMORY
             assert str(e.value) == "-9"
         TiffImagePlugin.READ_LIBTIFF = False
+
+    @pytest.mark.parametrize("compression", ("tiff_adobe_deflate", "jpeg"))
+    def test_save_multistrip(self, compression, tmp_path):
+        im = hopper("RGB").resize((256, 256))
+        out = str(tmp_path / "temp.tif")
+        im.save(out, compression=compression)
+
+        with Image.open(out) as im:
+            # Assert that there are multiple strips
+            assert len(im.tag_v2[STRIPOFFSETS]) > 1
+
+    def test_save_single_strip(self, tmp_path):
+        im = hopper("RGB").resize((256, 256))
+        out = str(tmp_path / "temp.tif")
+
+        TiffImagePlugin.STRIP_SIZE = 2**18
+        try:
+
+            im.save(out, compression="tiff_adobe_deflate")
+
+            with Image.open(out) as im:
+                assert len(im.tag_v2[STRIPOFFSETS]) == 1
+        finally:
+            TiffImagePlugin.STRIP_SIZE = 65536
+
+    @pytest.mark.parametrize("compression", ("tiff_adobe_deflate", None))
+    def test_save_zero(self, compression, tmp_path):
+        im = Image.new("RGB", (0, 0))
+        out = str(tmp_path / "temp.tif")
+        with pytest.raises(SystemError):
+            im.save(out, compression=compression)
('Tests', 'test_map.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -3,10 +3,6 @@
 import pytest

 from PIL import Image
-
-from .helper import is_win32
-
-pytestmark = pytest.mark.skipif(is_win32(), reason="Win32 does not call map_buffer")


 def test_overflow():
@@ -27,7 +23,20 @@
     Image.MAX_IMAGE_PIXELS = max_pixels


-@pytest.mark.skipif(sys.maxsize <= 2 ** 32, reason="Requires 64-bit system")
+def test_tobytes():
+    # Note that this image triggers the decompression bomb warning:
+    max_pixels = Image.MAX_IMAGE_PIXELS
+    Image.MAX_IMAGE_PIXELS = None
+
+    # Previously raised an access violation on Windows
+    with Image.open("Tests/images/l2rgb_read.bmp") as im:
+        with pytest.raises((ValueError, MemoryError, OSError)):
+            im.tobytes()
+
+    Image.MAX_IMAGE_PIXELS = max_pixels
+
+
+@pytest.mark.skipif(sys.maxsize <= 2**32, reason="Requires 64-bit system")
 def test_ysize():
     numpy = pytest.importorskip("numpy", reason="NumPy not installed")

('Tests', 'test_imageops.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,6 +5,7 @@
 from .helper import (
     assert_image_equal,
     assert_image_similar,
+    assert_image_similar_tofile,
     assert_tuple_approx_equal,
     hopper,
 )
@@ -28,12 +29,16 @@
     ImageOps.autocontrast(hopper("L"), cutoff=(2, 10))
     ImageOps.autocontrast(hopper("L"), ignore=[0, 255])
     ImageOps.autocontrast(hopper("L"), mask=hopper("L"))
+    ImageOps.autocontrast(hopper("L"), preserve_tone=True)

     ImageOps.colorize(hopper("L"), (0, 0, 0), (255, 255, 255))
     ImageOps.colorize(hopper("L"), "black", "white")

     ImageOps.pad(hopper("L"), (128, 128))
     ImageOps.pad(hopper("RGB"), (128, 128))
+
+    ImageOps.contain(hopper("L"), (128, 128))
+    ImageOps.contain(hopper("RGB"), (128, 128))

     ImageOps.crop(hopper("L"), 1)
     ImageOps.crop(hopper("RGB"), 1)
@@ -58,6 +63,7 @@
     ImageOps.grayscale(hopper("L"))
     ImageOps.grayscale(hopper("RGB"))

+    ImageOps.invert(hopper("1"))
     ImageOps.invert(hopper("L"))
     ImageOps.invert(hopper("RGB"))

@@ -97,6 +103,13 @@
         assert new_im.size == (1000, 755)


+@pytest.mark.parametrize("new_size", ((256, 256), (512, 256), (256, 512)))
+def test_contain(new_size):
+    im = hopper()
+    new_im = ImageOps.contain(im, new_size)
+    assert new_im.size == (256, 256)
+
+
 def test_pad():
     # Same ratio
     im = hopper()
@@ -112,10 +125,9 @@
             new_im = ImageOps.pad(im, new_size, color=color, centering=centering)
             assert new_im.size == new_size

-            with Image.open(
-                "Tests/images/imageops_pad_" + label + "_" + str(i) + ".jpg"
-            ) as target:
-                assert_image_similar(new_im, target, 6)
+            assert_image_similar_tofile(
+                new_im, "Tests/images/imageops_pad_" + label + "_" + str(i) + ".jpg", 6
+            )


 def test_pil163():
@@ -143,6 +155,33 @@

     newimg = ImageOps.scale(i, 0.5)
     assert newimg.size == (25, 25)
+
+
+@pytest.mark.parametrize("border", (10, (1, 2, 3, 4)))
+def test_expand_palette(border):
+    with Image.open("Tests/images/p_16.tga") as im:
+        im_expanded = ImageOps.expand(im, border, (255, 0, 0))
+
+        if isinstance(border, int):
+            left = top = right = bottom = border
+        else:
+            left, top, right, bottom = border
+        px = im_expanded.convert("RGB").load()
+        for x in range(im_expanded.width):
+            for b in range(top):
+                assert px[x, b] == (255, 0, 0)
+            for b in range(bottom):
+                assert px[x, im_expanded.height - 1 - b] == (255, 0, 0)
+        for y in range(im_expanded.height):
+            for b in range(left):
+                assert px[b, y] == (255, 0, 0)
+            for b in range(right):
+                assert px[im_expanded.width - 1 - b, y] == (255, 0, 0)
+
+        im_cropped = im_expanded.crop(
+            (left, top, im_expanded.width - right, im_expanded.height - bottom)
+        )
+        assert_image_equal(im_cropped, im)


 def test_colorize_2color():
@@ -291,6 +330,7 @@
                     else:
                         assert transposed_im.info["exif"] != original_exif

+                        assert 0x0112 in im.getexif()
                         assert 0x0112 not in transposed_im.getexif()

                     # Repeat the operation to test that it does not keep transposing
@@ -303,6 +343,28 @@
                     "Tests/images/hopper_orientation_" + str(i) + ext
                 ) as orientation_im:
                     check(orientation_im)
+
+    # Orientation from "XML:com.adobe.xmp" info key
+    with Image.open("Tests/images/xmp_tags_orientation.png") as im:
+        assert im.getexif()[0x0112] == 3
+
+        transposed_im = ImageOps.exif_transpose(im)
+        assert 0x0112 not in transposed_im.getexif()
+
+    # Orientation from "Raw profile type exif" info key
+    # This test image has been manually hexedited from exif_imagemagick.png
+    # to have a different orientation
+    with Image.open("Tests/images/exif_imagemagick_orientation.png") as im:
+        assert im.getexif()[0x0112] == 3
+
+        transposed_im = ImageOps.exif_transpose(im)
+        assert 0x0112 not in transposed_im.getexif()
+
+    # Orientation set directly on Image.Exif
+    im = hopper()
+    im.getexif()[0x0112] = 3
+    transposed_im = ImageOps.exif_transpose(im)
+    assert 0x0112 not in transposed_im.getexif()


 def test_autocontrast_cutoff():
@@ -336,7 +398,7 @@
         assert ImageStat.Stat(result_nomask).median == [128]


-def test_auto_contrast_mask_real_input():
+def test_autocontrast_mask_real_input():
     # Test the autocontrast with a rectangular mask
     with Image.open("Tests/images/iptc.jpg") as img:

@@ -362,3 +424,52 @@
             threshold=2,
             msg="autocontrast without mask pixel incorrect",
         )
+
+
+def test_autocontrast_preserve_tone():
+    def autocontrast(mode, preserve_tone):
+        im = hopper(mode)
+        return ImageOps.autocontrast(im, preserve_tone=preserve_tone).histogram()
+
+    assert autocontrast("RGB", True) != autocontrast("RGB", False)
+    assert autocontrast("L", True) == autocontrast("L", False)
+
+
+def test_autocontrast_preserve_gradient():
+    gradient = Image.linear_gradient("L")
+
+    # test with a grayscale gradient that extends to 0,255.
+    # Should be a noop.
+    out = ImageOps.autocontrast(gradient, cutoff=0, preserve_tone=True)
+
+    assert_image_equal(gradient, out)
+
+    # cutoff the top and bottom
+    # autocontrast should make the first and last histogram entries equal
+    # and, with rounding, should be 10% of the image pixels
+    out = ImageOps.autocontrast(gradient, cutoff=10, preserve_tone=True)
+    hist = out.histogram()
+    assert hist[0] == hist[-1]
+    assert hist[-1] == 256 * round(256 * 0.10)
+
+    # in rgb
+    img = gradient.convert("RGB")
+    out = ImageOps.autocontrast(img, cutoff=0, preserve_tone=True)
+    assert_image_equal(img, out)
+
+
+@pytest.mark.parametrize(
+    "color", ((255, 255, 255), (127, 255, 0), (127, 127, 127), (0, 0, 0))
+)
+def test_autocontrast_preserve_one_color(color):
+    img = Image.new("RGB", (10, 10), color)
+
+    # single color images shouldn't change
+    out = ImageOps.autocontrast(img, cutoff=0, preserve_tone=True)
+    assert_image_equal(img, out)  # single color, no cutoff
+
+    # even if there is a cutoff
+    out = ImageOps.autocontrast(
+        img, cutoff=10, preserve_tone=True
+    )  # single color 10 cutoff
+    assert_image_equal(img, out)
('Tests', 'test_image_putpalette.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@

 from PIL import Image, ImagePalette

-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper


 def test_putpalette():
@@ -36,9 +36,15 @@
 def test_imagepalette():
     im = hopper("P")
     im.putpalette(ImagePalette.negative())
+    assert_image_equal_tofile(im.convert("RGB"), "Tests/images/palette_negative.png")
+
     im.putpalette(ImagePalette.random())
+
     im.putpalette(ImagePalette.sepia())
+    assert_image_equal_tofile(im.convert("RGB"), "Tests/images/palette_sepia.png")
+
     im.putpalette(ImagePalette.wedge())
+    assert_image_equal_tofile(im.convert("RGB"), "Tests/images/palette_wedge.png")


 def test_putpalette_with_alpha_values():
@@ -56,3 +62,17 @@
         im.putpalette(palette_with_alpha_values, "RGBA")

         assert_image_equal(im.convert("RGBA"), expected)
+
+
+@pytest.mark.parametrize(
+    "mode, palette",
+    (
+        ("RGBA", (1, 2, 3, 4)),
+        ("RGBAX", (1, 2, 3, 4, 0)),
+    ),
+)
+def test_rgba_palette(mode, palette):
+    im = Image.new("P", (1, 1))
+    im.putpalette(palette, mode)
+    assert im.getpalette() == [1, 2, 3]
+    assert im.palette.colors == {(1, 2, 3, 4): 0}
('Tests', 'test_file_pdf.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -8,7 +8,7 @@

 from PIL import Image, PdfParser

-from .helper import hopper
+from .helper import hopper, mark_if_feature_version


 def helper_save_as_pdf(tmp_path, mode, **kwargs):
@@ -30,7 +30,7 @@
     with open(outfile, "rb") as fp:
         contents = fp.read()
     size = tuple(
-        int(d) for d in contents.split(b"/MediaBox [ 0 0 ")[1].split(b"]")[0].split()
+        float(d) for d in contents.split(b"/MediaBox [ 0 0 ")[1].split(b"]")[0].split()
     )
     assert im.size == size

@@ -42,7 +42,8 @@
     mode = "1"

     # Act / Assert
-    helper_save_as_pdf(tmp_path, mode)
+    outfile = helper_save_as_pdf(tmp_path, mode)
+    assert os.path.getsize(outfile) < 15000


 def test_greyscale(tmp_path):
@@ -85,6 +86,30 @@
         im.save(outfile)


+def test_resolution(tmp_path):
+    im = hopper()
+
+    outfile = str(tmp_path / "temp.pdf")
+    im.save(outfile, resolution=150)
+
+    with open(outfile, "rb") as fp:
+        contents = fp.read()
+
+    size = tuple(
+        float(d)
+        for d in contents.split(b"stream\nq ")[1].split(b" 0 0 cm")[0].split(b" 0 0 ")
+    )
+    assert size == (61.44, 61.44)
+
+    size = tuple(
+        float(d) for d in contents.split(b"/MediaBox [ 0 0 ")[1].split(b"]")[0].split()
+    )
+    assert size == (61.44, 61.44)
+
+
+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 def test_save_all(tmp_path):
     # Single frame image
     helper_save_as_pdf(tmp_path, "RGB", save_all=True)
@@ -285,3 +310,14 @@
     f = io.BytesIO(f.getvalue())
     im.save(f, format="PDF", append=True)
     assert len(f.getvalue()) > initial_size
+
+
+@pytest.mark.timeout(1)
+@pytest.mark.parametrize("newline", (b"\r", b"\n"))
+def test_redos(newline):
+    malicious = b" trailer<<>>" + newline * 3456
+
+    # This particular exception isn't relevant here.
+    # The important thing is it doesn't timeout, cause a ReDoS (CVE-2021-25292).
+    with pytest.raises(PdfParser.PdfFormatError):
+        PdfParser.PdfParser(buf=malicious)
('Tests', 'check_fli_oob.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3

 from PIL import Image

@@ -61,8 +61,8 @@


 for path in repro_ss2 + repro_lc + repro_advance + repro_brun + repro_copy:
-    im = Image.open(path)
-    try:
-        im.load()
-    except Exception as msg:
-        print(msg)
+    with Image.open(path) as im:
+        try:
+            im.load()
+        except Exception as msg:
+            print(msg)
('Tests', 'test_imagepath.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -70,8 +70,10 @@
     coords = ["a", "b"]

     # Act / Assert
-    with pytest.raises(SystemError):
+    with pytest.raises(ValueError) as e:
         ImagePath.Path(coords)
+
+    assert str(e.value) == "incorrect coordinate type"


 def test_path_odd_number_of_coordinates():
@@ -90,6 +92,8 @@
     [
         ([0, 1, 2, 3], (0.0, 1.0, 2.0, 3.0)),
         ([3, 2, 1, 0], (1.0, 0.0, 3.0, 2.0)),
+        (0, (0.0, 0.0, 0.0, 0.0)),
+        (1, (0.0, 0.0, 0.0, 0.0)),
     ],
 )
 def test_getbbox(coords, expected):
('Tests', 'test_file_mcidas.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@

 from PIL import Image, McIdasImagePlugin

-from .helper import assert_image_equal
+from .helper import assert_image_equal_tofile


 def test_invalid_file():
@@ -27,5 +27,4 @@
         assert im.format == "MCIDAS"
         assert im.mode == "I"
         assert im.size == (1800, 400)
-        with Image.open(saved_file) as im2:
-            assert_image_equal(im, im2)
+        assert_image_equal_tofile(im, saved_file)
('Tests', 'test_file_wal.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,15 +1,25 @@
 from PIL import WalImageFile
+
+from .helper import assert_image_equal_tofile
+
+TEST_FILE = "Tests/images/hopper.wal"


 def test_open():
-    # Arrange
-    TEST_FILE = "Tests/images/hopper.wal"
+    with WalImageFile.open(TEST_FILE) as im:
+        assert im.format == "WAL"
+        assert im.format_description == "Quake2 Texture"
+        assert im.mode == "P"
+        assert im.size == (128, 128)

-    # Act
-    im = WalImageFile.open(TEST_FILE)
+        assert isinstance(im, WalImageFile.WalImageFile)

-    # Assert
-    assert im.format == "WAL"
-    assert im.format_description == "Quake2 Texture"
-    assert im.mode == "P"
-    assert im.size == (128, 128)
+        assert_image_equal_tofile(im, "Tests/images/hopper_wal.png")
+
+
+def test_load():
+    with WalImageFile.open(TEST_FILE) as im:
+        assert im.load()[0, 0] == 122
+
+        # Test again now that it has already been loaded once
+        assert im.load()[0, 0] == 122
('Tests', 'test_image_convert.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -41,11 +41,15 @@
 def test_default():

     im = hopper("P")
-    assert_image(im, "P", im.size)
-    im = im.convert()
-    assert_image(im, "RGB", im.size)
-    im = im.convert()
-    assert_image(im, "RGB", im.size)
+    assert im.mode == "P"
+    converted_im = im.convert()
+    assert_image(converted_im, "RGB", im.size)
+    converted_im = im.convert()
+    assert_image(converted_im, "RGB", im.size)
+
+    im.info["transparency"] = 0
+    converted_im = im.convert()
+    assert_image(converted_im, "RGBA", im.size)


 # ref https://github.com/python-pillow/Pillow/issues/274
@@ -66,12 +70,24 @@
     with Image.open("Tests/images/16bit.cropped.tif") as im:
         _test_float_conversion(im)

+    for color in (65535, 65536):
+        im = Image.new("I", (1, 1), color)
+        im_i16 = im.convert("I;16")
+        assert im_i16.getpixel((0, 0)) == 65535
+

 def test_16bit_workaround():
     with Image.open("Tests/images/16bit.cropped.tif") as im:
         _test_float_conversion(im.convert("I"))


+def test_opaque():
+    alpha = hopper("P").convert("PA").getchannel("A")
+
+    solid = Image.new("L", (128, 128), 255)
+    assert_image_equal(alpha, solid)
+
+
 def test_rgba_p():
     im = hopper("RGBA")
     im.putalpha(hopper("L"))
@@ -89,29 +105,33 @@
     f = str(tmp_path / "temp.png")

     im_l = im.convert("L")
-    assert im_l.info["transparency"] == 0  # undone
+    assert im_l.info["transparency"] == 1  # undone
     im_l.save(f)

     im_rgb = im.convert("RGB")
-    assert im_rgb.info["transparency"] == (0, 0, 0)  # undone
+    assert im_rgb.info["transparency"] == (0, 1, 2)  # undone
     im_rgb.save(f)


 # ref https://github.com/python-pillow/Pillow/issues/664


-def test_trns_p_rgba():
+@pytest.mark.parametrize("mode", ("LA", "PA", "RGBA"))
+def test_trns_p_transparency(mode):
     # Arrange
     im = hopper("P")
     im.info["transparency"] = 128

     # Act
-    im_rgba = im.convert("RGBA")
+    converted_im = im.convert(mode)

     # Assert
-    assert "transparency" not in im_rgba.info
-    # https://github.com/python-pillow/Pillow/issues/2702
-    assert im_rgba.palette is None
+    assert "transparency" not in converted_im.info
+    if mode == "PA":
+        assert converted_im.palette is not None
+    else:
+        # https://github.com/python-pillow/Pillow/issues/2702
+        assert converted_im.palette is None


 def test_trns_l(tmp_path):
@@ -120,6 +140,10 @@

     f = str(tmp_path / "temp.png")

+    im_la = im.convert("LA")
+    assert "transparency" not in im_la.info
+    im_la.save(f)
+
     im_rgb = im.convert("RGB")
     assert im_rgb.info["transparency"] == (128, 128, 128)  # undone
     im_rgb.save(f)
@@ -128,8 +152,8 @@
     assert "transparency" in im_p.info
     im_p.save(f)

-    im_p = pytest.warns(UserWarning, im.convert, "P", palette=Image.ADAPTIVE)
-    assert "transparency" not in im_p.info
+    im_p = im.convert("P", palette=Image.Palette.ADAPTIVE)
+    assert "transparency" in im_p.info
     im_p.save(f)


@@ -151,9 +175,29 @@
     assert "transparency" not in im_rgba.info
     im_rgba.save(f)

-    im_p = pytest.warns(UserWarning, im.convert, "P", palette=Image.ADAPTIVE)
+    im_p = pytest.warns(UserWarning, im.convert, "P", palette=Image.Palette.ADAPTIVE)
     assert "transparency" not in im_p.info
     im_p.save(f)
+
+    im = Image.new("RGB", (1, 1))
+    im.info["transparency"] = im.getpixel((0, 0))
+    im_p = im.convert("P", palette=Image.Palette.ADAPTIVE)
+    assert im_p.info["transparency"] == im_p.getpixel((0, 0))
+    im_p.save(f)
+
+
+@pytest.mark.parametrize("convert_mode", ("L", "LA", "I"))
+def test_l_macro_rounding(convert_mode):
+    for mode in ("P", "PA"):
+        im = Image.new(mode, (1, 1))
+        im.palette.getcolor((0, 1, 2))
+
+        converted_im = im.convert(convert_mode)
+        px = converted_im.load()
+        converted_color = px[0, 0]
+        if convert_mode == "LA":
+            converted_color = converted_color[0]
+        assert converted_color == 1


 def test_gif_with_rgba_palette_to_p():
@@ -161,7 +205,7 @@
     with Image.open("Tests/images/hopper.gif") as im:
         im.info["transparency"] = 255
         im.load()
-        assert im.palette.mode == "RGBA"
+        assert im.palette.mode == "RGB"
         im_p = im.convert("P")

     # Should not raise ValueError: unrecognized raw mode
('Tests', 'test_image_reduce.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -97,7 +97,7 @@
         bands = [gradients_image]
         for _ in mode_info.bands[1:]:
             # rotate previous image
-            band = bands[-1].transpose(Image.ROTATE_90)
+            band = bands[-1].transpose(Image.Transpose.ROTATE_90)
             bands.append(band)
         # Correct alpha channel by transforming completely transparent pixels.
         # Low alpha values also emphasize error after alpha multiplication.
@@ -138,24 +138,26 @@
     reference = Image.new(im.mode, reduced.size)
     area_size = (im.size[0] // factor[0], im.size[1] // factor[1])
     area_box = (0, 0, area_size[0] * factor[0], area_size[1] * factor[1])
-    area = im.resize(area_size, Image.BOX, area_box)
+    area = im.resize(area_size, Image.Resampling.BOX, area_box)
     reference.paste(area, (0, 0))

     if area_size[0] < reduced.size[0]:
         assert reduced.size[0] - area_size[0] == 1
         last_column_box = (area_box[2], 0, im.size[0], area_box[3])
-        last_column = im.resize((1, area_size[1]), Image.BOX, last_column_box)
+        last_column = im.resize(
+            (1, area_size[1]), Image.Resampling.BOX, last_column_box
+        )
         reference.paste(last_column, (area_size[0], 0))

     if area_size[1] < reduced.size[1]:
         assert reduced.size[1] - area_size[1] == 1
         last_row_box = (0, area_box[3], area_box[2], im.size[1])
-        last_row = im.resize((area_size[0], 1), Image.BOX, last_row_box)
+        last_row = im.resize((area_size[0], 1), Image.Resampling.BOX, last_row_box)
         reference.paste(last_row, (0, area_size[1]))

     if area_size[0] < reduced.size[0] and area_size[1] < reduced.size[1]:
         last_pixel_box = (area_box[2], area_box[3], im.size[0], im.size[1])
-        last_pixel = im.resize((1, 1), Image.BOX, last_pixel_box)
+        last_pixel = im.resize((1, 1), Image.Resampling.BOX, last_pixel_box)
         reference.paste(last_pixel, area_size)

     assert_compare_images(reduced, reference, average_diff, max_diff)
('Tests', 'test_psdraw.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,8 @@
 import os
 import sys
-from io import StringIO
+from io import BytesIO
+
+import pytest

 from PIL import Image, PSDraw

@@ -44,10 +46,21 @@
     assert os.path.getsize(tempfile) > 0


-def test_stdout():
+@pytest.mark.parametrize("buffer", (True, False))
+def test_stdout(buffer):
     # Temporarily redirect stdout
     old_stdout = sys.stdout
-    sys.stdout = mystdout = StringIO()
+
+    if buffer:
+
+        class MyStdOut:
+            buffer = BytesIO()
+
+        mystdout = MyStdOut()
+    else:
+        mystdout = BytesIO()
+
+    sys.stdout = mystdout

     ps = PSDraw.PSDraw()
     _create_document(ps)
@@ -55,4 +68,6 @@
     # Reset stdout
     sys.stdout = old_stdout

-    assert mystdout.getvalue() != ""
+    if buffer:
+        mystdout = mystdout.buffer
+    assert mystdout.getvalue() != b""
('Tests', 'test_sgi_crash.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,3 @@
-#!/usr/bin/env python
 import pytest

 from PIL import Image
@@ -11,10 +10,17 @@
         "Tests/images/sgi_crash.bin",
         "Tests/images/crash-6b7f2244da6d0ae297ee0754a424213444e92778.sgi",
         "Tests/images/ossfuzz-5730089102868480.sgi",
+        "Tests/images/crash-754d9c7ec485ffb76a90eeaab191ef69a2a3a3cd.sgi",
+        "Tests/images/crash-465703f71a0f0094873a3e0e82c9f798161171b8.sgi",
+        "Tests/images/crash-64834657ee604b8797bf99eac6a194c124a9a8ba.sgi",
+        "Tests/images/crash-abcf1c97b8fe42a6c68f1fb0b978530c98d57ced.sgi",
+        "Tests/images/crash-b82e64d4f3f76d7465b6af535283029eda211259.sgi",
+        "Tests/images/crash-c1b2595b8b0b92cc5f38b6635e98e3a119ade807.sgi",
+        "Tests/images/crash-db8bfa78b19721225425530c5946217720d7df4e.sgi",
     ],
 )
 def test_crashes(test_file):
     with open(test_file, "rb") as f:
-        im = Image.open(f)
-        with pytest.raises(OSError):
-            im.load()
+        with Image.open(f) as im:
+            with pytest.raises(OSError):
+                im.load()
('Tests', 'check_j2k_dos.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,4 +5,7 @@

 from PIL import Image

-Image.open(BytesIO(b"\x00\x00\x00\x0cjP\x20\x20\x0d\x0a\x87\x0a\x00\x00\x00\x00hang"))
+with Image.open(
+    BytesIO(b"\x00\x00\x00\x0cjP\x20\x20\x0d\x0a\x87\x0a\x00\x00\x00\x00hang")
+):
+    pass
('Tests', 'test_imagedraw.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,6 +6,7 @@

 from .helper import (
     assert_image_equal,
+    assert_image_equal_tofile,
     assert_image_similar_tofile,
     hopper,
     skip_unless_feature,
@@ -96,7 +97,7 @@
     draw.arc(BBOX1, start=start, end=end)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_arc_end_le_start.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_arc_end_le_start.png")


 def test_arc_no_loops():
@@ -174,7 +175,7 @@
     draw.arc([110, 10, 189, 189], 20, 150, width=20, fill="white")

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_arc_high.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_arc_high.png")


 def test_bitmap():
@@ -182,13 +183,13 @@
     im = Image.new("RGB", (W, H))
     draw = ImageDraw.Draw(im)
     with Image.open("Tests/images/pil123rgba.png") as small:
-        small = small.resize((50, 50), Image.NEAREST)
+        small = small.resize((50, 50), Image.Resampling.NEAREST)

         # Act
         draw.bitmap((10, 10), small)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_bitmap.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_bitmap.png")


 def helper_chord(mode, bbox, start, end):
@@ -247,8 +248,7 @@
     draw.chord(BBOX1, 10, 260, fill="red", outline="yellow", width=0)

     # Assert
-    with Image.open("Tests/images/imagedraw_chord_zero_width.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_chord_zero_width.png")


 def test_chord_too_fat():
@@ -260,7 +260,7 @@
     draw.chord([-150, -150, 99, 99], 15, 60, width=10, fill="white", outline="red")

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_chord_too_fat.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_chord_too_fat.png")


 def helper_ellipse(mode, bbox):
@@ -319,7 +319,7 @@
         im = Image.new("RGB", (width, 100))
         draw = ImageDraw.Draw(im)
         draw.ellipse(bbox, fill="green", outline="blue")
-        assert_image_equal(im, im.transpose(Image.FLIP_LEFT_RIGHT))
+        assert_image_equal(im, im.transpose(Image.Transpose.FLIP_LEFT_RIGHT))


 def test_ellipse_width():
@@ -367,8 +367,7 @@
     draw.ellipse(BBOX1, fill="green", outline="blue", width=0)

     # Assert
-    with Image.open("Tests/images/imagedraw_ellipse_zero_width.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_ellipse_zero_width.png")


 def ellipse_various_sizes_helper(filled):
@@ -395,17 +394,15 @@
 def test_ellipse_various_sizes():
     im = ellipse_various_sizes_helper(False)

-    with Image.open("Tests/images/imagedraw_ellipse_various_sizes.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_ellipse_various_sizes.png")


 def test_ellipse_various_sizes_filled():
     im = ellipse_various_sizes_helper(True)

-    with Image.open(
-        "Tests/images/imagedraw_ellipse_various_sizes_filled.png"
-    ) as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(
+        im, "Tests/images/imagedraw_ellipse_various_sizes_filled.png"
+    )


 def helper_line(points):
@@ -417,7 +414,7 @@
     draw.line(points, fill="yellow", width=2)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_line.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_line.png")


 def test_line1():
@@ -446,7 +443,7 @@
     draw.shape(s, fill=1)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_shape1.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_shape1.png")


 def test_shape2():
@@ -467,7 +464,24 @@
     draw.shape(s, outline="blue")

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_shape2.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_shape2.png")
+
+
+def test_transform():
+    # Arrange
+    im = Image.new("RGB", (100, 100), "white")
+    expected = im.copy()
+    draw = ImageDraw.Draw(im)
+
+    # Act
+    s = ImageDraw.Outline()
+    s.line(0, 0)
+    s.transform((0, 0, 0, 0, 0, 0))
+
+    draw.shape(s, fill=1)
+
+    # Assert
+    assert_image_equal(im, expected)


 def helper_pieslice(bbox, start, end):
@@ -526,8 +540,7 @@
     draw.pieslice(BBOX1, 10, 260, fill="white", outline="blue", width=0)

     # Assert
-    with Image.open("Tests/images/imagedraw_pieslice_zero_width.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_pieslice_zero_width.png")


 def test_pieslice_wide():
@@ -539,7 +552,37 @@
     draw.pieslice([0, 0, 199, 99], 190, 170, width=10, fill="white", outline="red")

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_pieslice_wide.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_pieslice_wide.png")
+
+
+def test_pieslice_no_spikes():
+    im = Image.new("RGB", (161, 161), "white")
+    draw = ImageDraw.Draw(im)
+    cxs = (
+        [140] * 3
+        + list(range(140, 19, -20))
+        + [20] * 5
+        + list(range(20, 141, 20))
+        + [140] * 2
+    )
+    cys = (
+        list(range(80, 141, 20))
+        + [140] * 5
+        + list(range(140, 19, -20))
+        + [20] * 5
+        + list(range(20, 80, 20))
+    )
+
+    for cx, cy, angle in zip(cxs, cys, range(0, 360, 15)):
+        draw.pieslice(
+            [cx - 100, cy - 100, cx + 100, cy + 100], angle, angle + 1, fill="black"
+        )
+        draw.point([cx, cy], fill="red")
+
+    im_pre_erase = im.copy()
+    draw.rectangle([21, 21, 139, 139], fill="white")
+
+    assert_image_equal(im, im_pre_erase)


 def helper_point(points):
@@ -551,7 +594,7 @@
     draw.point(points, fill="yellow")

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_point.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_point.png")


 def test_point1():
@@ -571,7 +614,7 @@
     draw.polygon(points, fill="red", outline="blue")

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_polygon.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_polygon.png")


 def test_polygon1():
@@ -595,7 +638,7 @@
         draw.polygon(KITE_POINTS, fill="blue", outline="yellow")

         # Assert
-        assert_image_equal(im, Image.open(expected))
+        assert_image_equal_tofile(im, expected)


 def test_polygon_1px_high():
@@ -609,7 +652,20 @@
     draw.polygon([(0, 1), (0, 1), (2, 1), (2, 1)], "#f00")

     # Assert
-    assert_image_equal(im, Image.open(expected))
+    assert_image_equal_tofile(im, expected)
+
+
+def test_polygon_translucent():
+    # Arrange
+    im = Image.new("RGB", (W, H))
+    draw = ImageDraw.Draw(im, "RGBA")
+
+    # Act
+    draw.polygon([(20, 80), (80, 80), (80, 20)], fill=(0, 255, 0, 127))
+
+    # Assert
+    expected = "Tests/images/imagedraw_polygon_translucent.png"
+    assert_image_equal_tofile(im, expected)


 def helper_rectangle(bbox):
@@ -621,7 +677,7 @@
     draw.rectangle(bbox, fill="black", outline="green")

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_rectangle.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rectangle.png")


 def test_rectangle1():
@@ -656,7 +712,7 @@
     draw.rectangle(BBOX1, outline="green", width=5)

     # Assert
-    assert_image_equal(im, Image.open(expected))
+    assert_image_equal_tofile(im, expected)


 def test_rectangle_width_fill():
@@ -669,7 +725,7 @@
     draw.rectangle(BBOX1, fill="blue", outline="green", width=5)

     # Assert
-    assert_image_equal(im, Image.open(expected))
+    assert_image_equal_tofile(im, expected)


 def test_rectangle_zero_width():
@@ -681,8 +737,7 @@
     draw.rectangle(BBOX1, fill="blue", outline="green", width=0)

     # Assert
-    with Image.open("Tests/images/imagedraw_rectangle_zero_width.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rectangle_zero_width.png")


 def test_rectangle_I16():
@@ -694,8 +749,95 @@
     draw.rectangle(BBOX1, fill="black", outline="green")

     # Assert
-    assert_image_equal(
-        im.convert("I"), Image.open("Tests/images/imagedraw_rectangle_I.png")
+    assert_image_equal_tofile(im.convert("I"), "Tests/images/imagedraw_rectangle_I.png")
+
+
+def test_rectangle_translucent_outline():
+    # Arrange
+    im = Image.new("RGB", (W, H))
+    draw = ImageDraw.Draw(im, "RGBA")
+
+    # Act
+    draw.rectangle(BBOX1, fill="black", outline=(0, 255, 0, 127), width=5)
+
+    # Assert
+    assert_image_equal_tofile(
+        im, "Tests/images/imagedraw_rectangle_translucent_outline.png"
+    )
+
+
+@pytest.mark.parametrize(
+    "xy",
+    [(10, 20, 190, 180), ([10, 20], [190, 180]), ((10, 20), (190, 180))],
+)
+def test_rounded_rectangle(xy):
+    # Arrange
+    im = Image.new("RGB", (200, 200))
+    draw = ImageDraw.Draw(im)
+
+    # Act
+    draw.rounded_rectangle(xy, 30, fill="red", outline="green", width=5)
+
+    # Assert
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rounded_rectangle.png")
+
+
+@pytest.mark.parametrize(
+    "xy, radius, type",
+    [
+        ((10, 20, 190, 180), 30.5, "given"),
+        ((10, 10, 181, 190), 90, "width"),
+        ((10, 20, 190, 181), 85, "height"),
+    ],
+)
+def test_rounded_rectangle_non_integer_radius(xy, radius, type):
+    # Arrange
+    im = Image.new("RGB", (200, 200))
+    draw = ImageDraw.Draw(im)
+
+    # Act
+    draw.rounded_rectangle(xy, radius, fill="red", outline="green", width=5)
+
+    # Assert
+    assert_image_equal_tofile(
+        im,
+        "Tests/images/imagedraw_rounded_rectangle_non_integer_radius_" + type + ".png",
+    )
+
+
+def test_rounded_rectangle_zero_radius():
+    # Arrange
+    im = Image.new("RGB", (W, H))
+    draw = ImageDraw.Draw(im)
+
+    # Act
+    draw.rounded_rectangle(BBOX1, 0, fill="blue", outline="green", width=5)
+
+    # Assert
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rectangle_width_fill.png")
+
+
+@pytest.mark.parametrize(
+    "xy, suffix",
+    [
+        ((20, 10, 80, 90), "x"),
+        ((10, 20, 90, 80), "y"),
+        ((20, 20, 80, 80), "both"),
+    ],
+)
+def test_rounded_rectangle_translucent(xy, suffix):
+    # Arrange
+    im = Image.new("RGB", (W, H))
+    draw = ImageDraw.Draw(im, "RGBA")
+
+    # Act
+    draw.rounded_rectangle(
+        xy, 30, fill=(255, 0, 0, 127), outline=(0, 255, 0, 127), width=5
+    )
+
+    # Assert
+    assert_image_equal_tofile(
+        im, "Tests/images/imagedraw_rounded_rectangle_" + suffix + ".png"
     )


@@ -749,7 +891,7 @@
     )

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_floodfill2.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_floodfill2.png")


 def test_floodfill_thresh():
@@ -765,7 +907,7 @@
     ImageDraw.floodfill(im, centre_point, ImageColor.getrgb("red"), thresh=30)

     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_floodfill2.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_floodfill2.png")


 def test_floodfill_not_negative():
@@ -782,9 +924,7 @@
     ImageDraw.floodfill(im, (int(W / 4), int(H / 4)), ImageColor.getrgb("red"))

     # Assert
-    assert_image_equal(
-        im, Image.open("Tests/images/imagedraw_floodfill_not_negative.png")
-    )
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_floodfill_not_negative.png")


 def create_base_image_draw(
@@ -799,147 +939,156 @@


 def test_square():
-    with Image.open(os.path.join(IMAGES_PATH, "square.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((10, 10))
-        draw.polygon([(2, 2), (2, 7), (7, 7), (7, 2)], BLACK)
-        assert_image_equal(img, expected, "square as normal polygon failed")
-        img, draw = create_base_image_draw((10, 10))
-        draw.polygon([(7, 7), (7, 2), (2, 2), (2, 7)], BLACK)
-        assert_image_equal(img, expected, "square as inverted polygon failed")
-        img, draw = create_base_image_draw((10, 10))
-        draw.rectangle((2, 2, 7, 7), BLACK)
-        assert_image_equal(img, expected, "square as normal rectangle failed")
-        img, draw = create_base_image_draw((10, 10))
-        draw.rectangle((7, 7, 2, 2), BLACK)
-        assert_image_equal(img, expected, "square as inverted rectangle failed")
+    expected = os.path.join(IMAGES_PATH, "square.png")
+    img, draw = create_base_image_draw((10, 10))
+    draw.polygon([(2, 2), (2, 7), (7, 7), (7, 2)], BLACK)
+    assert_image_equal_tofile(img, expected, "square as normal polygon failed")
+    img, draw = create_base_image_draw((10, 10))
+    draw.polygon([(7, 7), (7, 2), (2, 2), (2, 7)], BLACK)
+    assert_image_equal_tofile(img, expected, "square as inverted polygon failed")
+    img, draw = create_base_image_draw((10, 10))
+    draw.rectangle((2, 2, 7, 7), BLACK)
+    assert_image_equal_tofile(img, expected, "square as normal rectangle failed")
+    img, draw = create_base_image_draw((10, 10))
+    draw.rectangle((7, 7, 2, 2), BLACK)
+    assert_image_equal_tofile(img, expected, "square as inverted rectangle failed")


 def test_triangle_right():
-    with Image.open(os.path.join(IMAGES_PATH, "triangle_right.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.polygon([(3, 5), (17, 5), (10, 12)], BLACK)
-        assert_image_equal(img, expected, "triangle right failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.polygon([(3, 5), (17, 5), (10, 12)], BLACK)
+    assert_image_equal_tofile(
+        img, os.path.join(IMAGES_PATH, "triangle_right.png"), "triangle right failed"
+    )
+
+
+@pytest.mark.parametrize(
+    "fill, suffix",
+    ((BLACK, "width"), (None, "width_no_fill")),
+)
+def test_triangle_right_width(fill, suffix):
+    img, draw = create_base_image_draw((100, 100))
+    draw.polygon([(15, 25), (85, 25), (50, 60)], fill, WHITE, width=5)
+    assert_image_equal_tofile(
+        img, os.path.join(IMAGES_PATH, "triangle_right_" + suffix + ".png")
+    )


 def test_line_horizontal():
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_horizontal_w2px_normal.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 14, 5), BLACK, 2)
-        assert_image_equal(
-            img, expected, "line straight horizontal normal 2px wide failed"
-        )
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_horizontal_w2px_inverted.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((14, 5, 5, 5), BLACK, 2)
-        assert_image_equal(
-            img, expected, "line straight horizontal inverted 2px wide failed"
-        )
-    with Image.open(os.path.join(IMAGES_PATH, "line_horizontal_w3px.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 14, 5), BLACK, 3)
-        assert_image_equal(
-            img, expected, "line straight horizontal normal 3px wide failed"
-        )
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((14, 5, 5, 5), BLACK, 3)
-        assert_image_equal(
-            img, expected, "line straight horizontal inverted 3px wide failed"
-        )
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_horizontal_w101px.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((200, 110))
-        draw.line((5, 55, 195, 55), BLACK, 101)
-        assert_image_equal(img, expected, "line straight horizontal 101px wide failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 14, 5), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_horizontal_w2px_normal.png"),
+        "line straight horizontal normal 2px wide failed",
+    )
+
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((14, 5, 5, 5), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_horizontal_w2px_inverted.png"),
+        "line straight horizontal inverted 2px wide failed",
+    )
+
+    expected = os.path.join(IMAGES_PATH, "line_horizontal_w3px.png")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 14, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line straight horizontal normal 3px wide failed"
+    )
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((14, 5, 5, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line straight horizontal inverted 3px wide failed"
+    )
+
+    img, draw = create_base_image_draw((200, 110))
+    draw.line((5, 55, 195, 55), BLACK, 101)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_horizontal_w101px.png"),
+        "line straight horizontal 101px wide failed",
+    )


 def test_line_h_s1_w2():
     pytest.skip("failing")
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_horizontal_slope1px_w2px.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 14, 6), BLACK, 2)
-        assert_image_equal(img, expected, "line horizontal 1px slope 2px wide failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 14, 6), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_horizontal_slope1px_w2px.png"),
+        "line horizontal 1px slope 2px wide failed",
+    )


 def test_line_vertical():
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_vertical_w2px_normal.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 5, 14), BLACK, 2)
-        assert_image_equal(
-            img, expected, "line straight vertical normal 2px wide failed"
-        )
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_vertical_w2px_inverted.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 14, 5, 5), BLACK, 2)
-        assert_image_equal(
-            img, expected, "line straight vertical inverted 2px wide failed"
-        )
-    with Image.open(os.path.join(IMAGES_PATH, "line_vertical_w3px.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 5, 14), BLACK, 3)
-        assert_image_equal(
-            img, expected, "line straight vertical normal 3px wide failed"
-        )
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 14, 5, 5), BLACK, 3)
-        assert_image_equal(
-            img, expected, "line straight vertical inverted 3px wide failed"
-        )
-    with Image.open(os.path.join(IMAGES_PATH, "line_vertical_w101px.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((110, 200))
-        draw.line((55, 5, 55, 195), BLACK, 101)
-        assert_image_equal(img, expected, "line straight vertical 101px wide failed")
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_vertical_slope1px_w2px.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 6, 14), BLACK, 2)
-        assert_image_equal(img, expected, "line vertical 1px slope 2px wide failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 5, 14), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_vertical_w2px_normal.png"),
+        "line straight vertical normal 2px wide failed",
+    )
+
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 14, 5, 5), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_vertical_w2px_inverted.png"),
+        "line straight vertical inverted 2px wide failed",
+    )
+
+    expected = os.path.join(IMAGES_PATH, "line_vertical_w3px.png")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 5, 14), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line straight vertical normal 3px wide failed"
+    )
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 14, 5, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line straight vertical inverted 3px wide failed"
+    )
+
+    img, draw = create_base_image_draw((110, 200))
+    draw.line((55, 5, 55, 195), BLACK, 101)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_vertical_w101px.png"),
+        "line straight vertical 101px wide failed",
+    )
+
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 6, 14), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_vertical_slope1px_w2px.png"),
+        "line vertical 1px slope 2px wide failed",
+    )


 def test_line_oblique_45():
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_oblique_45_w3px_a.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 14, 14), BLACK, 3)
-        assert_image_equal(img, expected, "line oblique 45 normal 3px wide A failed")
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((14, 14, 5, 5), BLACK, 3)
-        assert_image_equal(img, expected, "line oblique 45 inverted 3px wide A failed")
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_oblique_45_w3px_b.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((14, 5, 5, 14), BLACK, 3)
-        assert_image_equal(img, expected, "line oblique 45 normal 3px wide B failed")
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 14, 14, 5), BLACK, 3)
-        assert_image_equal(img, expected, "line oblique 45 inverted 3px wide B failed")
+    expected = os.path.join(IMAGES_PATH, "line_oblique_45_w3px_a.png")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 14, 14), BLACK, 3)
+    assert_image_equal_tofile(img, expected, "line oblique 45 normal 3px wide A failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((14, 14, 5, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line oblique 45 inverted 3px wide A failed"
+    )
+
+    expected = os.path.join(IMAGES_PATH, "line_oblique_45_w3px_b.png")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((14, 5, 5, 14), BLACK, 3)
+    assert_image_equal_tofile(img, expected, "line oblique 45 normal 3px wide B failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 14, 14, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line oblique 45 inverted 3px wide B failed"
+    )


 def test_wide_line_dot():
@@ -1185,7 +1334,7 @@
     draw = ImageDraw.Draw(im)
     bounding_circle = ((W // 2, H // 2), 25)
     draw.regular_polygon(bounding_circle, n_sides, rotation=rotation, fill="red")
-    assert_image_equal(im, Image.open(filename))
+    assert_image_equal_tofile(im, filename)


 @pytest.mark.parametrize(
@@ -1272,3 +1421,34 @@
     with pytest.raises(expected_error) as e:
         ImageDraw._compute_regular_polygon_vertices(bounding_circle, n_sides, rotation)
     assert str(e.value) == error_message
+
+
+def test_continuous_horizontal_edges_polygon():
+    xy = [
+        (2, 6),
+        (6, 6),
+        (12, 6),
+        (12, 12),
+        (8, 12),
+        (8, 8),
+        (4, 8),
+        (2, 8),
+    ]
+    img, draw = create_base_image_draw((16, 16))
+    draw.polygon(xy, BLACK)
+    expected = os.path.join(IMAGES_PATH, "continuous_horizontal_edges_polygon.png")
+    assert_image_equal_tofile(
+        img, expected, "continuous horizontal edges polygon failed"
+    )
+
+
+def test_discontiguous_corners_polygon():
+    img, draw = create_base_image_draw((84, 68))
+    draw.polygon(((1, 21), (34, 4), (71, 1), (38, 18)), BLACK)
+    draw.polygon(((71, 44), (38, 27), (1, 24)), BLACK)
+    draw.polygon(
+        ((38, 66), (5, 49), (77, 49), (47, 66), (82, 63), (82, 47), (1, 47), (1, 63)),
+        BLACK,
+    )
+    expected = os.path.join(IMAGES_PATH, "discontiguous_corners_polygon.png")
+    assert_image_similar_tofile(img, expected, 1)
('Tests', 'test_lib_pack.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -320,6 +320,23 @@
         self.assert_unpack("RGB", "G", 1, (0, 1, 0), (0, 2, 0), (0, 3, 0))
         self.assert_unpack("RGB", "B", 1, (0, 0, 1), (0, 0, 2), (0, 0, 3))

+        self.assert_unpack("RGB", "R;16B", 2, (1, 0, 0), (3, 0, 0), (5, 0, 0))
+        self.assert_unpack("RGB", "G;16B", 2, (0, 1, 0), (0, 3, 0), (0, 5, 0))
+        self.assert_unpack("RGB", "B;16B", 2, (0, 0, 1), (0, 0, 3), (0, 0, 5))
+
+        self.assert_unpack("RGB", "R;16L", 2, (2, 0, 0), (4, 0, 0), (6, 0, 0))
+        self.assert_unpack("RGB", "G;16L", 2, (0, 2, 0), (0, 4, 0), (0, 6, 0))
+        self.assert_unpack("RGB", "B;16L", 2, (0, 0, 2), (0, 0, 4), (0, 0, 6))
+
+        if sys.byteorder == "little":
+            self.assert_unpack("RGB", "R;16N", 2, (2, 0, 0), (4, 0, 0), (6, 0, 0))
+            self.assert_unpack("RGB", "G;16N", 2, (0, 2, 0), (0, 4, 0), (0, 6, 0))
+            self.assert_unpack("RGB", "B;16N", 2, (0, 0, 2), (0, 0, 4), (0, 0, 6))
+        else:
+            self.assert_unpack("RGB", "R;16N", 2, (1, 0, 0), (3, 0, 0), (5, 0, 0))
+            self.assert_unpack("RGB", "G;16N", 2, (0, 1, 0), (0, 3, 0), (0, 5, 0))
+            self.assert_unpack("RGB", "B;16N", 2, (0, 0, 1), (0, 0, 3), (0, 0, 5))
+
     def test_RGBA(self):
         self.assert_unpack("RGBA", "LA", 2, (1, 1, 1, 2), (3, 3, 3, 4), (5, 5, 5, 6))
         self.assert_unpack(
@@ -449,6 +466,43 @@
         self.assert_unpack("RGBA", "G", 1, (0, 1, 0, 0), (0, 2, 0, 0), (0, 3, 0, 0))
         self.assert_unpack("RGBA", "B", 1, (0, 0, 1, 0), (0, 0, 2, 0), (0, 0, 3, 0))
         self.assert_unpack("RGBA", "A", 1, (0, 0, 0, 1), (0, 0, 0, 2), (0, 0, 0, 3))
+
+        self.assert_unpack("RGBA", "R;16B", 2, (1, 0, 0, 0), (3, 0, 0, 0), (5, 0, 0, 0))
+        self.assert_unpack("RGBA", "G;16B", 2, (0, 1, 0, 0), (0, 3, 0, 0), (0, 5, 0, 0))
+        self.assert_unpack("RGBA", "B;16B", 2, (0, 0, 1, 0), (0, 0, 3, 0), (0, 0, 5, 0))
+        self.assert_unpack("RGBA", "A;16B", 2, (0, 0, 0, 1), (0, 0, 0, 3), (0, 0, 0, 5))
+
+        self.assert_unpack("RGBA", "R;16L", 2, (2, 0, 0, 0), (4, 0, 0, 0), (6, 0, 0, 0))
+        self.assert_unpack("RGBA", "G;16L", 2, (0, 2, 0, 0), (0, 4, 0, 0), (0, 6, 0, 0))
+        self.assert_unpack("RGBA", "B;16L", 2, (0, 0, 2, 0), (0, 0, 4, 0), (0, 0, 6, 0))
+        self.assert_unpack("RGBA", "A;16L", 2, (0, 0, 0, 2), (0, 0, 0, 4), (0, 0, 0, 6))
+
+        if sys.byteorder == "little":
+            self.assert_unpack(
+                "RGBA", "R;16N", 2, (2, 0, 0, 0), (4, 0, 0, 0), (6, 0, 0, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "G;16N", 2, (0, 2, 0, 0), (0, 4, 0, 0), (0, 6, 0, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "B;16N", 2, (0, 0, 2, 0), (0, 0, 4, 0), (0, 0, 6, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "A;16N", 2, (0, 0, 0, 2), (0, 0, 0, 4), (0, 0, 0, 6)
+            )
+        else:
+            self.assert_unpack(
+                "RGBA", "R;16N", 2, (1, 0, 0, 0), (3, 0, 0, 0), (5, 0, 0, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "G;16N", 2, (0, 1, 0, 0), (0, 3, 0, 0), (0, 5, 0, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "B;16N", 2, (0, 0, 1, 0), (0, 0, 3, 0), (0, 0, 5, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "A;16N", 2, (0, 0, 0, 1), (0, 0, 0, 3), (0, 0, 0, 5)
+            )

     def test_RGBa(self):
         self.assert_unpack(
('Tests', 'test_image_getdata.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,7 +14,7 @@

 def test_roundtrip():
     def getdata(mode):
-        im = hopper(mode).resize((32, 30), Image.NEAREST)
+        im = hopper(mode).resize((32, 30), Image.Resampling.NEAREST)
         data = im.getdata()
         return data[0], len(data), len(list(data))

('Tests', 'test_numpy.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+import warnings
+
 import pytest

 from PIL import Image
@@ -31,7 +33,7 @@
         return i

     # Check supported 1-bit integer formats
-    assert_image(to_image(numpy.bool, 1, 1), "1", TEST_IMAGE_SIZE)
+    assert_image(to_image(bool, 1, 1), "1", TEST_IMAGE_SIZE)
     assert_image(to_image(numpy.bool8, 1, 1), "1", TEST_IMAGE_SIZE)

     # Check supported 8-bit integer formats
@@ -65,7 +67,7 @@
         to_image(numpy.int64)

     # Check floating-point formats
-    assert_image(to_image(numpy.float), "F", TEST_IMAGE_SIZE)
+    assert_image(to_image(float), "F", TEST_IMAGE_SIZE)
     with pytest.raises(TypeError):
         to_image(numpy.float16)
     assert_image(to_image(numpy.float32), "F", TEST_IMAGE_SIZE)
@@ -189,9 +191,10 @@
     assert len(im.getdata()) == len(arr)


-def test_roundtrip_eye():
-    for dtype in (
-        numpy.bool,
+@pytest.mark.parametrize(
+    "dtype",
+    (
+        bool,
         numpy.bool8,
         numpy.int8,
         numpy.int16,
@@ -199,12 +202,14 @@
         numpy.uint8,
         numpy.uint16,
         numpy.uint32,
-        numpy.float,
+        float,
         numpy.float32,
         numpy.float64,
-    ):
-        arr = numpy.eye(10, dtype=dtype)
-        numpy.testing.assert_array_equal(arr, numpy.array(Image.fromarray(arr)))
+    ),
+)
+def test_roundtrip_eye(dtype):
+    arr = numpy.eye(10, dtype=dtype)
+    numpy.testing.assert_array_equal(arr, numpy.array(Image.fromarray(arr)))


 def test_zero_size():
@@ -218,7 +223,7 @@

 def test_bool():
     # https://github.com/python-pillow/Pillow/issues/2044
-    a = numpy.zeros((10, 2), dtype=numpy.bool)
+    a = numpy.zeros((10, 2), dtype=bool)
     a[0][0] = True

     im2 = Image.fromarray(a)
@@ -234,4 +239,5 @@
     with Image.open(test_file) as im:

         # Act/Assert
-        pytest.warns(None, lambda: array(im))
+        with warnings.catch_warnings():
+            array(im)
('Tests', 'test_file_tar.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+import warnings
+
 import pytest

 from PIL import Image, TarIO, features
@@ -31,16 +33,12 @@


 def test_close():
-    def open():
+    with warnings.catch_warnings():
         tar = TarIO.TarIO(TEST_TAR_FILE, "hopper.jpg")
         tar.close()

-    pytest.warns(None, open)
-

 def test_contextmanager():
-    def open():
+    with warnings.catch_warnings():
         with TarIO.TarIO(TEST_TAR_FILE, "hopper.jpg"):
             pass
-
-    pytest.warns(None, open)
('Tests', 'check_jp2_overflow.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3

 # Reproductions/tests for OOB read errors in FliDecode.c

@@ -19,8 +19,8 @@
 repro = ("00r0_gray_l.jp2", "00r1_graya_la.jp2")

 for path in repro:
-    im = Image.open(path)
-    try:
-        im.load()
-    except Exception as msg:
-        print(msg)
+    with Image.open(path) as im:
+        try:
+            im.load()
+        except Exception as msg:
+            print(msg)
('Tests', 'check_imaging_leaks.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 import pytest

 from PIL import Image
('Tests', 'test_file_fpx.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,4 +21,5 @@

 def test_fpx_invalid_number_of_bands():
     with pytest.raises(OSError, match="Invalid number of bands"):
-        Image.open("Tests/images/input_bw_five_bands.fpx")
+        with Image.open("Tests/images/input_bw_five_bands.fpx"):
+            pass
('Tests', 'test_imagemath.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,9 +1,11 @@
+import pytest
+
 from PIL import Image, ImageMath


 def pixel(im):
     if hasattr(im, "im"):
-        return "{} {}".format(im.mode, repr(im.getpixel((0, 0))))
+        return f"{im.mode} {repr(im.getpixel((0, 0)))}"
     else:
         if isinstance(im, int):
             return int(im)  # hack to deal with booleans
@@ -50,6 +52,19 @@
     assert pixel(ImageMath.eval("float(B)**33", images)) == "F 8589934592.0"


+@pytest.mark.parametrize(
+    "expression",
+    (
+        "exec('pass')",
+        "(lambda: exec('pass'))()",
+        "(lambda: (lambda: exec('pass'))())()",
+    ),
+)
+def test_prevent_exec(expression):
+    with pytest.raises(ValueError):
+        ImageMath.eval(expression)
+
+
 def test_logical():
     assert pixel(ImageMath.eval("not A", images)) == 0
     assert pixel(ImageMath.eval("A and B", images)) == "L 2"
('Tests', 'test_file_gif.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,4 @@
+import warnings
 from io import BytesIO

 import pytest
@@ -6,6 +7,7 @@

 from .helper import (
     assert_image_equal,
+    assert_image_equal_tofile,
     assert_image_similar,
     hopper,
     is_pypy,
@@ -38,27 +40,68 @@


 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(TEST_GIF)
         im.load()
         im.close()

-    pytest.warns(None, open)
-

 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(TEST_GIF) as im:
             im.load()

-    pytest.warns(None, open)
-

 def test_invalid_file():
     invalid_file = "Tests/images/flower.jpg"

     with pytest.raises(SyntaxError):
         GifImagePlugin.GifImageFile(invalid_file)
+
+
+def test_l_mode_transparency():
+    with Image.open("Tests/images/no_palette_with_transparency.gif") as im:
+        assert im.mode == "L"
+        assert im.load()[0, 0] == 128
+        assert im.info["transparency"] == 255
+
+        im.seek(1)
+        assert im.mode == "L"
+        assert im.load()[0, 0] == 128
+
+
+def test_strategy():
+    with Image.open("Tests/images/chi.gif") as im:
+        expected_zero = im.convert("RGB")
+
+        im.seek(1)
+        expected_one = im.convert("RGB")
+
+    try:
+        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_ALWAYS
+        with Image.open("Tests/images/chi.gif") as im:
+            assert im.mode == "RGB"
+            assert_image_equal(im, expected_zero)
+
+        GifImagePlugin.LOADING_STRATEGY = (
+            GifImagePlugin.LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY
+        )
+        # Stay in P mode with only a global palette
+        with Image.open("Tests/images/chi.gif") as im:
+            assert im.mode == "P"
+
+            im.seek(1)
+            assert im.mode == "P"
+            assert_image_equal(im.convert("RGB"), expected_one)
+
+        # Change to RGB mode when a frame has an individual palette
+        with Image.open("Tests/images/iss634.gif") as im:
+            assert im.mode == "P"
+
+            im.seek(1)
+            assert im.mode == "RGB"
+    finally:
+        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST


 def test_optimize():
@@ -162,6 +205,32 @@
         assert reread.n_frames == 5


+@pytest.mark.parametrize(
+    "path, mode",
+    (
+        ("Tests/images/dispose_bgnd.gif", "RGB"),
+        # Hexeditted copy of dispose_bgnd to add transparency
+        ("Tests/images/dispose_bgnd_rgba.gif", "RGBA"),
+    ),
+)
+def test_loading_multiple_palettes(path, mode):
+    with Image.open(path) as im:
+        assert im.mode == "P"
+        first_frame_colors = im.palette.colors.keys()
+        original_color = im.convert("RGB").load()[0, 0]
+
+        im.seek(1)
+        assert im.mode == mode
+        if mode == "RGBA":
+            im = im.convert("RGB")
+
+        # Check a color only from the old palette
+        assert im.load()[0, 0] == original_color
+
+        # Check a color from the new palette
+        assert im.load()[24, 24] not in first_frame_colors
+
+
 def test_headers_saving_for_animated_gifs(tmp_path):
     important_headers = ["background", "version", "duration", "loop"]
     # Multiframe image
@@ -183,8 +252,8 @@
     with Image.open(TEST_GIF) as im:
         im = im.convert("RGB")

-        im = im.resize((100, 100), Image.LANCZOS)
-        im2 = im.convert("P", palette=Image.ADAPTIVE, colors=256)
+        im = im.resize((100, 100), Image.Resampling.LANCZOS)
+        im2 = im.convert("P", palette=Image.Palette.ADAPTIVE, colors=256)

         f = str(tmp_path / "temp.gif")
         im2.save(f, optimize=True)
@@ -284,6 +353,22 @@
             assert im.is_animated == (n_frames != 1)


+def test_no_change():
+    # Test n_frames does not change the image
+    with Image.open("Tests/images/dispose_bgnd.gif") as im:
+        im.seek(1)
+        expected = im.copy()
+        assert im.n_frames == 5
+        assert_image_equal(im, expected)
+
+    # Test is_animated does not change the image
+    with Image.open("Tests/images/dispose_bgnd.gif") as im:
+        im.seek(3)
+        expected = im.copy()
+        assert im.is_animated
+        assert_image_equal(im, expected)
+
+
 def test_eoferror():
     with Image.open(TEST_GIF) as im:
         n_frames = im.n_frames
@@ -295,6 +380,12 @@

         # Test that seeking to the last frame does not raise an error
         im.seek(n_frames - 1)
+
+
+def test_first_frame_transparency():
+    with Image.open("Tests/images/first_frame_transparency.gif") as im:
+        px = im.load()
+        assert px[0, 0] == im.info["transparency"]


 def test_dispose_none():
@@ -317,8 +408,7 @@
     with Image.open("Tests/images/dispose_none_load_end.gif") as img:
         img.seek(1)

-        with Image.open("Tests/images/dispose_none_load_end_second.gif") as expected:
-            assert_image_equal(img, expected)
+        assert_image_equal_tofile(img, "Tests/images/dispose_none_load_end_second.png")


 def test_dispose_background():
@@ -331,6 +421,47 @@
             pass


+def test_dispose_background_transparency():
+    with Image.open("Tests/images/dispose_bgnd_transparency.gif") as img:
+        img.seek(2)
+        px = img.load()
+        assert px[35, 30][3] == 0
+
+
+@pytest.mark.parametrize(
+    "loading_strategy, expected_colors",
+    (
+        (
+            GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST,
+            (
+                (2, 1, 2),
+                ((0, 255, 24, 255), (0, 0, 255, 255), (0, 255, 24, 255)),
+                ((0, 0, 0, 0), (0, 0, 255, 255), (0, 0, 0, 0)),
+            ),
+        ),
+        (
+            GifImagePlugin.LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY,
+            (
+                (2, 1, 2),
+                (0, 1, 0),
+                (2, 1, 2),
+            ),
+        ),
+    ),
+)
+def test_transparent_dispose(loading_strategy, expected_colors):
+    GifImagePlugin.LOADING_STRATEGY = loading_strategy
+    try:
+        with Image.open("Tests/images/transparent_dispose.gif") as img:
+            for frame in range(3):
+                img.seek(frame)
+                for x in range(3):
+                    color = img.getpixel((x, 0))
+                    assert color == expected_colors[frame][x]
+    finally:
+        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST
+
+
 def test_dispose_previous():
     with Image.open("Tests/images/dispose_prev.gif") as img:
         try:
@@ -339,6 +470,25 @@
                 assert img.disposal_method == 3
         except EOFError:
             pass
+
+
+def test_dispose_previous_first_frame():
+    with Image.open("Tests/images/dispose_prev_first_frame.gif") as im:
+        im.seek(1)
+        assert_image_equal_tofile(
+            im, "Tests/images/dispose_prev_first_frame_seeked.png"
+        )
+
+
+def test_previous_frame_loaded():
+    with Image.open("Tests/images/dispose_none.gif") as img:
+        img.load()
+        img.seek(1)
+        img.load()
+        img.seek(2)
+        with Image.open("Tests/images/dispose_none.gif") as img_skipped:
+            img_skipped.seek(2)
+            assert_image_equal(img_skipped, img)


 def test_save_dispose(tmp_path):
@@ -373,14 +523,15 @@
 def test_dispose2_palette(tmp_path):
     out = str(tmp_path / "temp.gif")

-    # 4 backgrounds: White, Grey, Black, Red
+    # Four colors: white, grey, black, red
     circles = [(255, 255, 255), (153, 153, 153), (0, 0, 0), (255, 0, 0)]

     im_list = []
     for circle in circles:
+        # Red background
         img = Image.new("RGB", (100, 100), (255, 0, 0))

-        # Red circle in center of each frame
+        # Circle in center of each frame
         d = ImageDraw.Draw(img)
         d.ellipse([(40, 40), (60, 60)], fill=circle)

@@ -465,15 +616,28 @@

     with Image.open(out) as im:
         im.seek(1)
-        assert im.getpixel((0, 0)) == 0
-
-
-def test_iss634():
+        assert im.getpixel((0, 0)) == (255, 0, 0)
+
+
+def test_transparency_in_second_frame():
+    with Image.open("Tests/images/different_transparency.gif") as im:
+        assert im.info["transparency"] == 0
+
+        # Seek to the second frame
+        im.seek(im.tell() + 1)
+        assert "transparency" not in im.info
+
+        assert_image_equal_tofile(im, "Tests/images/different_transparency_merged.png")
+
+
+def test_no_transparency_in_second_frame():
     with Image.open("Tests/images/iss634.gif") as img:
         # Seek to the second frame
         img.seek(img.tell() + 1)
+        assert "transparency" not in img.info
+
         # All transparent pixels should be replaced with the color from the first frame
-        assert img.histogram()[img.info["transparency"]] == 0
+        assert img.histogram()[255] == 0


 def test_duration(tmp_path):
@@ -629,8 +793,7 @@

 def test_zero_comment_subblocks():
     with Image.open("Tests/images/hopper_zero_comment_subblocks.gif") as im:
-        with Image.open(TEST_GIF) as expected:
-            assert_image_equal(im, expected)
+        assert_image_equal_tofile(im, TEST_GIF)


 def test_version(tmp_path):
@@ -718,10 +881,10 @@
     # Single frame
     im = Image.new("RGB", (1, 1))
     im.info["transparency"] = (255, 0, 0)
-    pytest.warns(UserWarning, im.save, out)
+    im.save(out)

     with Image.open(out) as reloaded:
-        assert "transparency" not in reloaded.info
+        assert "transparency" in reloaded.info

     # Multiple frames
     im = Image.new("RGB", (1, 1))
@@ -733,6 +896,17 @@
         assert "transparency" not in reloaded.info


+def test_rgba_transparency(tmp_path):
+    out = str(tmp_path / "temp.gif")
+
+    im = hopper("P")
+    im.save(out, save_all=True, append_images=[Image.new("RGBA", im.size)])
+
+    with Image.open(out) as reloaded:
+        reloaded.seek(1)
+        assert_image_equal(hopper("P").convert("RGB"), reloaded)
+
+
 def test_bbox(tmp_path):
     out = str(tmp_path / "temp.gif")

@@ -763,7 +937,7 @@
     # Forcing a non-straight grayscale palette.

     im = hopper("P")
-    palette = bytes([255 - i // 3 for i in range(768)])
+    palette = bytes(255 - i // 3 for i in range(768))

     out = str(tmp_path / "temp.gif")
     im.save(out, palette=palette)
@@ -773,6 +947,29 @@
         assert_image_equal(reloaded, im)


+def test_palette_save_all_P(tmp_path):
+    frames = []
+    colors = ((255, 0, 0), (0, 255, 0))
+    for color in colors:
+        frame = Image.new("P", (100, 100))
+        frame.putpalette(color)
+        frames.append(frame)
+
+    out = str(tmp_path / "temp.gif")
+    frames[0].save(
+        out, save_all=True, palette=[255, 0, 0, 0, 255, 0], append_images=frames[1:]
+    )
+
+    with Image.open(out) as im:
+        # Assert that the frames are correct, and each frame has the same palette
+        assert_image_equal(im.convert("RGB"), frames[0].convert("RGB"))
+        assert im.palette.palette == im.global_palette.palette
+
+        im.seek(1)
+        assert_image_equal(im.convert("RGB"), frames[1].convert("RGB"))
+        assert im.palette.palette == im.global_palette.palette
+
+
 def test_palette_save_ImagePalette(tmp_path):
     # Pass in a different palette, as an ImagePalette.ImagePalette
     # effectively the same as test_palette_save_P
@@ -785,7 +982,7 @@

     with Image.open(out) as reloaded:
         im.putpalette(palette)
-        assert_image_equal(reloaded, im)
+        assert_image_equal(reloaded.convert("RGB"), im.convert("RGB"))


 def test_save_I(tmp_path):
@@ -803,11 +1000,11 @@
 def test_getdata():
     # Test getheader/getdata against legacy values.
     # Create a 'P' image with holes in the palette.
-    im = Image._wedge().resize((16, 16), Image.NEAREST)
+    im = Image._wedge().resize((16, 16), Image.Resampling.NEAREST)
     im.putpalette(ImagePalette.ImagePalette("RGB"))
     im.info = {"background": 0}

-    passed_palette = bytes([255 - i // 3 for i in range(768)])
+    passed_palette = bytes(255 - i // 3 for i in range(768))

     GifImagePlugin._FORCE_OPTIMIZE = True
     try:
@@ -839,5 +1036,28 @@
 def test_extents():
     with Image.open("Tests/images/test_extents.gif") as im:
         assert im.size == (100, 100)
+
+        # Check that n_frames does not change the size
+        assert im.n_frames == 2
+        assert im.size == (100, 100)
+
         im.seek(1)
         assert im.size == (150, 150)
+
+
+def test_missing_background():
+    # The Global Color Table Flag isn't set, so there is no background color index,
+    # but the disposal method is "Restore to background color"
+    with Image.open("Tests/images/missing_background.gif") as im:
+        im.seek(1)
+        assert_image_equal_tofile(im, "Tests/images/missing_background_first_frame.png")
+
+
+def test_saving_rgba(tmp_path):
+    out = str(tmp_path / "temp.gif")
+    with Image.open("Tests/images/transparent.png") as im:
+        im.save(out)
+
+    with Image.open(out) as reloaded:
+        reloaded_rgba = reloaded.convert("RGBA")
+        assert reloaded_rgba.load()[0, 0][3] == 0
('Tests', 'test_file_webp_alpha.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,12 @@

 from PIL import Image

-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_similar,
+    assert_image_similar_tofile,
+    hopper,
+)

 _webp = pytest.importorskip("PIL._webp", reason="WebP support not installed")

@@ -29,8 +34,7 @@

         image.tobytes()

-        with Image.open("Tests/images/transparent.png") as target:
-            assert_image_similar(image, target, 20.0)
+        assert_image_similar_tofile(image, "Tests/images/transparent.png", 20.0)


 def test_write_lossless_rgb(tmp_path):
('Tests', 'test_imagecolor.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -191,3 +191,12 @@
     assert (255, 255) == ImageColor.getcolor("white", "LA")
     assert (163, 33) == ImageColor.getcolor("rgba(0, 255, 115, 33)", "LA")
     Image.new("LA", (1, 1), "white")
+
+
+def test_color_too_long():
+    # Arrange
+    color_too_long = "hsl(" + "1" * 40 + "," + "1" * 40 + "%," + "1" * 40 + "%)"
+
+    # Act / Assert
+    with pytest.raises(ValueError):
+        ImageColor.getrgb(color_too_long)
('Tests', 'test_file_bufrstub.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -45,3 +45,35 @@
     # Act / Assert: stub cannot save without an implemented handler
     with pytest.raises(OSError):
         im.save(tmpfile)
+
+
+def test_handler(tmp_path):
+    class TestHandler:
+        opened = False
+        loaded = False
+        saved = False
+
+        def open(self, im):
+            self.opened = True
+
+        def load(self, im):
+            self.loaded = True
+            return Image.new("RGB", (1, 1))
+
+        def save(self, im, fp, filename):
+            self.saved = True
+
+    handler = TestHandler()
+    BufrStubImagePlugin.register_handler(handler)
+    with Image.open(TEST_FILE) as im:
+        assert handler.opened
+        assert not handler.loaded
+
+        im.load()
+        assert handler.loaded
+
+        temp_file = str(tmp_path / "temp.bufr")
+        im.save(temp_file)
+        assert handler.saved
+
+    BufrStubImagePlugin._handler = None
('Tests', 'check_icns_dos.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,4 +5,5 @@

 from PIL import Image

-Image.open(BytesIO(b"icns\x00\x00\x00\x10hang\x00\x00\x00\x00"))
+with Image.open(BytesIO(b"icns\x00\x00\x00\x10hang\x00\x00\x00\x00")):
+    pass
('Tests', 'test_file_mpo.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,4 @@
+import warnings
 from io import BytesIO

 import pytest
@@ -41,20 +42,16 @@


 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(test_files[0])
         im.load()
         im.close()

-    pytest.warns(None, open)
-

 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(test_files[0]) as im:
             im.load()
-
-    pytest.warns(None, open)


 def test_app():
@@ -88,6 +85,23 @@
         im.seek(1)
         assert im.size == (680, 480)

+        im.seek(0)
+        assert im.size == (640, 480)
+
+
+def test_ignore_frame_size():
+    # Ignore the different size of the second frame
+    # since this is not a "Large Thumbnail" image
+    with Image.open("Tests/images/ignore_frame_size.mpo") as im:
+        assert im.size == (64, 64)
+
+        im.seek(1)
+        assert (
+            im.mpinfo[0xB002][1]["Attribute"]["MPType"]
+            == "Multi-Frame Image: (Disparity)"
+        )
+        assert im.size == (64, 64)
+

 def test_parallax():
     # Nintendo
@@ -132,7 +146,7 @@
         with Image.open(test_file) as im:
             mpinfo = im._getmp()
         frameNumber = 0
-        for mpentry in mpinfo[45058]:
+        for mpentry in mpinfo[0xB002]:
             mpattr = mpentry["Attribute"]
             if frameNumber:
                 assert not mpattr["RepresentativeImageFlag"]
('Tests', 'test_pdfparser.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -115,6 +115,6 @@
     assert pdf_repr(True) == b"true"
     assert pdf_repr(False) == b"false"
     assert pdf_repr(None) == b"null"
-    assert pdf_repr(b"a)/b\\(c") == br"(a\)/b\\\(c)"
+    assert pdf_repr(b"a)/b\\(c") == rb"(a\)/b\\\(c)"
     assert pdf_repr([123, True, {"a": PdfName(b"b")}]) == b"[ 123 true <<\n/a /b\n>> ]"
     assert pdf_repr(PdfBinary(b"\x90\x1F\xA0")) == b"<901FA0>"
('Tests', 'test_imagefontctl.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,16 +1,11 @@
 import pytest
-from packaging.version import parse as parse_version
-
-from PIL import Image, ImageDraw, ImageFont, features
-
-from .helper import (
-    assert_image_similar,
-    skip_unless_feature,
-    skip_unless_feature_version,
-)
+
+from PIL import Image, ImageDraw, ImageFont
+
+from .helper import assert_image_similar_tofile, skip_unless_feature

 FONT_SIZE = 20
-FONT_PATH = "Tests/fonts/DejaVuSans.ttf"
+FONT_PATH = "Tests/fonts/DejaVuSans/DejaVuSans.ttf"

 pytestmark = skip_unless_feature("raqm")

@@ -31,8 +26,7 @@
     draw.text((0, 0), "اهلا عمان", font=ttf, fill=500)

     target = "Tests/images/test_text.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)


 def test_y_offset():
@@ -43,8 +37,7 @@
     draw.text((0, 0), "العالم العربي", font=ttf, fill=500)

     target = "Tests/images/test_y_offset.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 1.7)
+    assert_image_similar_tofile(im, target, 1.7)


 def test_complex_unicode_text():
@@ -55,8 +48,7 @@
     draw.text((0, 0), "السلام عليكم", font=ttf, fill=500)

     target = "Tests/images/test_complex_unicode_text.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)

     ttf = ImageFont.truetype("Tests/fonts/KhmerOSBattambang-Regular.ttf", FONT_SIZE)

@@ -65,8 +57,7 @@
     draw.text((0, 0), "លោកុប្បត្តិ", font=ttf, fill=500)

     target = "Tests/images/test_complex_unicode_text2.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 2.33)
+    assert_image_similar_tofile(im, target, 2.33)


 def test_text_direction_rtl():
@@ -77,8 +68,7 @@
     draw.text((0, 0), "English عربي", font=ttf, fill=500, direction="rtl")

     target = "Tests/images/test_direction_rtl.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)


 def test_text_direction_ltr():
@@ -89,8 +79,7 @@
     draw.text((0, 0), "سلطنة عمان Oman", font=ttf, fill=500, direction="ltr")

     target = "Tests/images/test_direction_ltr.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)


 def test_text_direction_rtl2():
@@ -101,8 +90,7 @@
     draw.text((0, 0), "Oman سلطنة عمان", font=ttf, fill=500, direction="rtl")

     target = "Tests/images/test_direction_ltr.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)


 def test_text_direction_ttb():
@@ -117,8 +105,7 @@
             pytest.skip("libraqm 0.7 or greater not available")

     target = "Tests/images/test_direction_ttb.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 2.8)
+    assert_image_similar_tofile(im, target, 2.8)


 def test_text_direction_ttb_stroke():
@@ -141,8 +128,7 @@
             pytest.skip("libraqm 0.7 or greater not available")

     target = "Tests/images/test_direction_ttb_stroke.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 19.4)
+    assert_image_similar_tofile(im, target, 19.4)


 def test_ligature_features():
@@ -152,8 +138,7 @@
     draw = ImageDraw.Draw(im)
     draw.text((0, 0), "filling", font=ttf, fill=500, features=["-liga"])
     target = "Tests/images/test_ligature_features.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)

     liga_size = ttf.getsize("fi", features=["-liga"])
     assert liga_size == (13, 19)
@@ -167,8 +152,7 @@
     draw.text((0, 0), "TeToAV", font=ttf, fill=500, features=["-kern"])

     target = "Tests/images/test_kerning_features.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)


 def test_arabictext_features():
@@ -185,8 +169,7 @@
     )

     target = "Tests/images/test_arabictext_features.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)


 def test_x_max_and_y_offset():
@@ -197,8 +180,7 @@
     draw.text((0, 0), "لح", font=ttf, fill=500)

     target = "Tests/images/test_x_max_and_y_offset.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)


 def test_language():
@@ -209,8 +191,7 @@
     draw.text((0, 0), "абвг", font=ttf, fill=500, language="sr")

     target = "Tests/images/test_language.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)


 @pytest.mark.parametrize("mode", ("L", "1"))
@@ -266,11 +247,6 @@
             pytest.skip("libraqm 0.7 or greater not available")


-# FreeType 2.5.1 README: Miscellaneous Changes:
-# Improved computation of emulated vertical metrics for TrueType fonts.
-@skip_unless_feature_version(
-    "freetype2", "2.5.1", "FreeType <2.5.1 has incompatible ttb metrics"
-)
 @pytest.mark.parametrize("anchor", ("lt", "mm", "rb", "sm"))
 def test_anchor_ttb(anchor):
     text = "f"
@@ -287,8 +263,7 @@
         if str(ex) == "libraqm 0.7 or greater required for 'ttb' direction":
             pytest.skip("libraqm 0.7 or greater not available")

-    with Image.open(path) as expected:
-        assert_image_similar(im, expected, 1)  # fails at 5
+    assert_image_similar_tofile(im, path, 1)  # fails at 5


 combine_tests = (
@@ -330,14 +305,6 @@
     "name, text, anchor, dir, epsilon", combine_tests, ids=[r[0] for r in combine_tests]
 )
 def test_combine(name, text, dir, anchor, epsilon):
-    if (
-        parse_version(features.version_module("freetype2")) < parse_version("2.5.1")
-        and dir == "ttb"
-    ):
-        # FreeType 2.5.1 README: Miscellaneous Changes:
-        # Improved computation of emulated vertical metrics for TrueType fonts.
-        pytest.skip("FreeType <2.5.1 has incompatible ttb metrics")
-
     path = f"Tests/images/test_combine_{name}.png"
     f = ImageFont.truetype("Tests/fonts/NotoSans-Regular.ttf", 48)

@@ -351,8 +318,7 @@
         if str(ex) == "libraqm 0.7 or greater required for 'ttb' direction":
             pytest.skip("libraqm 0.7 or greater not available")

-    with Image.open(path) as expected:
-        assert_image_similar(im, expected, epsilon)
+    assert_image_similar_tofile(im, path, epsilon)


 @pytest.mark.parametrize(
@@ -384,8 +350,7 @@
     d.rectangle(bbox, outline="red")
     d.multiline_text((200, 200), text, fill="black", anchor=anchor, font=f, align=align)

-    with Image.open(path) as expected:
-        assert_image_similar(im, expected, 0.015)
+    assert_image_similar_tofile(im, path, 0.015)


 def test_anchor_invalid_ttb():
('Tests', 'test_file_hdf5stub.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -46,3 +46,35 @@
             im.save(dummy_filename)
         with pytest.raises(OSError):
             Hdf5StubImagePlugin._save(im, dummy_fp, dummy_filename)
+
+
+def test_handler(tmp_path):
+    class TestHandler:
+        opened = False
+        loaded = False
+        saved = False
+
+        def open(self, im):
+            self.opened = True
+
+        def load(self, im):
+            self.loaded = True
+            return Image.new("RGB", (1, 1))
+
+        def save(self, im, fp, filename):
+            self.saved = True
+
+    handler = TestHandler()
+    Hdf5StubImagePlugin.register_handler(handler)
+    with Image.open(TEST_FILE) as im:
+        assert handler.opened
+        assert not handler.loaded
+
+        im.load()
+        assert handler.loaded
+
+        temp_file = str(tmp_path / "temp.h5")
+        im.save(temp_file)
+        assert handler.saved
+
+    Hdf5StubImagePlugin._handler = None
('Tests', 'test_file_jpeg.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,5 +1,6 @@
 import os
 import re
+import warnings
 from io import BytesIO

 import pytest
@@ -17,13 +18,21 @@
 from .helper import (
     assert_image,
     assert_image_equal,
+    assert_image_equal_tofile,
     assert_image_similar,
+    assert_image_similar_tofile,
     cjpeg_available,
     djpeg_available,
     hopper,
     is_win32,
+    mark_if_feature_version,
     skip_unless_feature,
 )
+
+try:
+    import defusedxml.ElementTree as ElementTree
+except ImportError:
+    ElementTree = None

 TEST_FILE = "Tests/images/hopper.jpg"

@@ -59,6 +68,13 @@
             assert im.format == "JPEG"
             assert im.get_format_mimetype() == "image/jpeg"

+    @pytest.mark.parametrize("size", ((1, 0), (0, 1), (0, 0)))
+    def test_zero(self, size, tmp_path):
+        f = str(tmp_path / "temp.jpg")
+        im = Image.new("RGB", size)
+        with pytest.raises(ValueError):
+            im.save(f)
+
     def test_app(self):
         # Test APP/COM reader (@PIL135)
         with Image.open(TEST_FILE) as im:
@@ -77,26 +93,26 @@
         f = "Tests/images/pil_sample_cmyk.jpg"
         with Image.open(f) as im:
             # the source image has red pixels in the upper left corner.
-            c, m, y, k = [x / 255.0 for x in im.getpixel((0, 0))]
+            c, m, y, k = (x / 255.0 for x in im.getpixel((0, 0)))
             assert c == 0.0
             assert m > 0.8
             assert y > 0.8
             assert k == 0.0
             # the opposite corner is black
-            c, m, y, k = [
+            c, m, y, k = (
                 x / 255.0 for x in im.getpixel((im.size[0] - 1, im.size[1] - 1))
-            ]
+            )
             assert k > 0.9
             # roundtrip, and check again
             im = self.roundtrip(im)
-            c, m, y, k = [x / 255.0 for x in im.getpixel((0, 0))]
+            c, m, y, k = (x / 255.0 for x in im.getpixel((0, 0)))
             assert c == 0.0
             assert m > 0.8
             assert y > 0.8
             assert k == 0.0
-            c, m, y, k = [
+            c, m, y, k = (
                 x / 255.0 for x in im.getpixel((im.size[0] - 1, im.size[1] - 1))
-            ]
+            )
             assert k > 0.9

     @pytest.mark.parametrize(
@@ -114,6 +130,9 @@
         assert test(100, 200) == (100, 200)
         assert test(0) is None  # square pixels

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_icc(self, tmp_path):
         # Test ICC support
         with Image.open("Tests/images/rgb.jpg") as im1:
@@ -153,6 +172,9 @@
         test(ImageFile.MAXBLOCK + 1)  # full buffer block plus one byte
         test(ImageFile.MAXBLOCK * 4 + 3)  # large block

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_large_icc_meta(self, tmp_path):
         # https://github.com/python-pillow/Pillow/issues/148
         # Sometimes the meta data on the icc_profile block is bigger than
@@ -257,14 +279,14 @@
             del exif[0x8769]

             # Assert that it needs to be transposed
-            assert exif[0x0112] == Image.TRANSVERSE
+            assert exif[0x0112] == Image.Transpose.TRANSVERSE

             # Assert that the GPS IFD is present and empty
-            assert exif[0x8825] == {}
+            assert exif.get_ifd(0x8825) == {}

             transposed = ImageOps.exif_transpose(im)
         exif = transposed.getexif()
-        assert exif[0x8825] == {}
+        assert exif.get_ifd(0x8825) == {}

         # Assert that it was transposed
         assert 0x0112 not in exif
@@ -419,6 +441,9 @@
         with Image.open(filename):
             pass

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_truncated_jpeg_should_read_all_the_data(self):
         filename = "Tests/images/truncated_jpeg.jpg"
         ImageFile.LOAD_TRUNCATED_IMAGES = True
@@ -437,6 +462,9 @@
             with pytest.raises(OSError):
                 im.load()

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_qtables(self, tmp_path):
         def _n_qtables_helper(n, test_file):
             with Image.open(test_file) as im:
@@ -446,7 +474,7 @@
                 assert len(im.quantization) == n
                 reloaded = self.roundtrip(im, qtables="keep")
                 assert im.quantization == reloaded.quantization
-                assert reloaded.quantization[0].typecode == "B"
+                assert max(reloaded.quantization[0]) <= 255

         with Image.open("Tests/images/hopper.jpg") as im:
             qtables = im.quantization
@@ -458,7 +486,8 @@

             # valid bounds for baseline qtable
             bounds_qtable = [int(s) for s in ("255 1 " * 32).split(None)]
-            self.roundtrip(im, qtables=[bounds_qtable])
+            im2 = self.roundtrip(im, qtables=[bounds_qtable])
+            assert im2.quantization == {0: bounds_qtable}

             # values from wizard.txt in jpeg9-a src package.
             standard_l_qtable = [
@@ -569,11 +598,17 @@
             assert max(im2.quantization[0]) <= 255
             assert max(im2.quantization[1]) <= 255

+    def test_convert_dict_qtables_deprecation(self):
+        with pytest.warns(DeprecationWarning):
+            qtable = {0: [1, 2, 3, 4]}
+            qtable2 = JpegImagePlugin.convert_dict_qtables(qtable)
+            assert qtable == qtable2
+
     @pytest.mark.skipif(not djpeg_available(), reason="djpeg not available")
     def test_load_djpeg(self):
         with Image.open(TEST_FILE) as img:
             img.load_djpeg()
-            assert_image_similar(img, Image.open(TEST_FILE), 5)
+            assert_image_similar_tofile(img, TEST_FILE, 5)

     @pytest.mark.skipif(not cjpeg_available(), reason="cjpeg not available")
     def test_save_cjpeg(self, tmp_path):
@@ -581,7 +616,7 @@
             tempfile = str(tmp_path / "temp.jpg")
             JpegImagePlugin._save_cjpeg(img, 0, tempfile)
             # Default save quality is 75%, so a tiny bit of difference is alright
-            assert_image_similar(img, Image.open(tempfile), 17)
+            assert_image_similar_tofile(img, tempfile, 17)

     def test_no_duplicate_0x1001_tag(self):
         # Arrange
@@ -603,7 +638,7 @@
             reloaded.save(f, quality="keep", optimize=True)

     def test_bad_mpo_header(self):
-        """ Treat unknown MPO as JPEG """
+        """Treat unknown MPO as JPEG"""
         # Arrange

         # Act
@@ -641,15 +676,6 @@
                 reloaded.load()
                 assert im.info["dpi"] == reloaded.info["dpi"]

-    def test_load_dpi_rounding(self):
-        # Round up
-        with Image.open("Tests/images/iptc_roundUp.jpg") as im:
-            assert im.info["dpi"] == (44, 44)
-
-        # Round down
-        with Image.open("Tests/images/iptc_roundDown.jpg") as im:
-            assert im.info["dpi"] == (2, 2)
-
     def test_save_dpi_rounding(self, tmp_path):
         outfile = str(tmp_path / "temp.jpg")
         with Image.open("Tests/images/hopper.jpg") as im:
@@ -700,6 +726,15 @@
             # This should return the default, and not raise a ZeroDivisionError
             assert im.info.get("dpi") == (72, 72)

+    def test_dpi_exif_string(self):
+        # Arrange
+        # 0x011A tag in this exif contains string '300300\x02'
+        with Image.open("Tests/images/broken_exif_dpi.jpg") as im:
+
+            # Act / Assert
+            # This should return the default
+            assert im.info.get("dpi") == (72, 72)
+
     def test_no_dpi_in_exif(self):
         # Arrange
         # This is photoshop-200dpi.jpg with resolution removed from EXIF:
@@ -720,15 +755,17 @@
             # OSError for unidentified image.
             assert im.info.get("dpi") == (72, 72)

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_exif_x_resolution(self, tmp_path):
         with Image.open("Tests/images/flower.jpg") as im:
             exif = im.getexif()
             assert exif[282] == 180

             out = str(tmp_path / "out.jpg")
-            with pytest.warns(None) as record:
+            with warnings.catch_warnings():
                 im.save(out, exif=exif)
-            assert len(record) == 0

         with Image.open(out) as reloaded:
             assert reloaded.getexif()[282] == 180
@@ -750,6 +787,9 @@
             # Act / Assert
             assert im._getexif()[306] == "2017:03:13 23:03:09"

+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_photoshop(self):
         with Image.open("Tests/images/photoshop-200dpi.jpg") as im:
             assert im.info["photoshop"][0x03ED] == {
@@ -761,8 +801,7 @@

             # Test that the image can still load, even with broken Photoshop data
             # This image had the APP13 length hexedited to be smaller
-            with Image.open("Tests/images/photoshop-200dpi-broken.jpg") as im_broken:
-                assert_image_equal(im_broken, im)
+            assert_image_equal_tofile(im, "Tests/images/photoshop-200dpi-broken.jpg")

         # This image does not contain a Photoshop header string
         with Image.open("Tests/images/app13.jpg") as im:
@@ -775,6 +814,20 @@
             apps_13_lengths = [len(v) for k, v in im.applist if k == "APP13"]
             assert [65504, 24] == apps_13_lengths

+    def test_adobe_transform(self):
+        with Image.open("Tests/images/pil_sample_rgb.jpg") as im:
+            assert im.info["adobe_transform"] == 1
+
+        with Image.open("Tests/images/pil_sample_cmyk.jpg") as im:
+            assert im.info["adobe_transform"] == 2
+
+        # This image has been manually hexedited
+        # so that the APP14 reports its length to be 11,
+        # leaving no room for "adobe_transform"
+        with Image.open("Tests/images/truncated_app14.jpg") as im:
+            assert "adobe" in im.info
+            assert "adobe_transform" not in im.info
+
     def test_icc_after_SOF(self):
         with Image.open("Tests/images/icc-after-SOF.jpg") as im:
             assert im.info["icc_profile"] == b"profile"
@@ -792,10 +845,61 @@

         buffer.read = read
         with pytest.raises(UnidentifiedImageError):
-            Image.open(buffer)
+            with Image.open(buffer):
+                pass

         # Assert the entire file has not been read
         assert 0 < buffer.max_pos < size
+
+    def test_getxmp(self):
+        with Image.open("Tests/images/xmp_test.jpg") as im:
+            if ElementTree is None:
+                with pytest.warns(UserWarning):
+                    assert im.getxmp() == {}
+            else:
+                xmp = im.getxmp()
+
+                description = xmp["xmpmeta"]["RDF"]["Description"]
+                assert description["DerivedFrom"] == {
+                    "documentID": "8367D410E636EA95B7DE7EBA1C43A412",
+                    "originalDocumentID": "8367D410E636EA95B7DE7EBA1C43A412",
+                }
+                assert description["Look"]["Description"]["Group"]["Alt"]["li"] == {
+                    "lang": "x-default",
+                    "text": "Profiles",
+                }
+                assert description["ToneCurve"]["Seq"]["li"] == ["0, 0", "255, 255"]
+
+                # Attribute
+                assert description["Version"] == "10.4"
+
+        if ElementTree is not None:
+            with Image.open("Tests/images/hopper.jpg") as im:
+                assert im.getxmp() == {}
+
+    @pytest.mark.timeout(timeout=1)
+    def test_eof(self):
+        # Even though this decoder never says that it is finished
+        # the image should still end when there is no new data
+        class InfiniteMockPyDecoder(ImageFile.PyDecoder):
+            def decode(self, buffer):
+                return 0, 0
+
+        decoder = InfiniteMockPyDecoder(None)
+
+        def closure(mode, *args):
+            decoder.__init__(mode, *args)
+            return decoder
+
+        Image.register_decoder("INFINITE", closure)
+
+        with Image.open(TEST_FILE) as im:
+            im.tile = [
+                ("INFINITE", (0, 0, 128, 128), 0, ("RGB", 0, 1)),
+            ]
+            ImageFile.LOAD_TRUNCATED_IMAGES = True
+            im.load()
+            ImageFile.LOAD_TRUNCATED_IMAGES = False


 @pytest.mark.skipif(not is_win32(), reason="Windows only")
('.github', 'mergify.yml')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -7,6 +7,7 @@
       - status-success=Test Successful
       - status-success=Docker Test Successful
       - status-success=Windows Test Successful
+      - status-success=MinGW Test Successful
       - status-success=continuous-integration/appveyor/pr
     actions:
       merge:
('.github/workflows', 'lint.yml')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,6 @@
 name: Lint

-on: [push, pull_request]
+on: [push, pull_request, workflow_dispatch]

 jobs:
   build:
@@ -10,15 +10,7 @@
     name: Lint

     steps:
-    - uses: actions/checkout@v2
-
-    - name: pip cache
-      uses: actions/cache@v2
-      with:
-        path: ~/.cache/pip
-        key: lint-pip-${{ hashFiles('**/setup.py') }}
-        restore-keys: |
-          lint-pip-
+    - uses: actions/checkout@v3

     - name: pre-commit cache
       uses: actions/cache@v2
@@ -29,20 +21,21 @@
           lint-pre-commit-

     - name: Set up Python
-      uses: actions/setup-python@v2
+      uses: actions/setup-python@v3
       with:
-        python-version: 3.8
+        python-version: "3.10"
+        cache: pip
+        cache-dependency-path: "setup.py"

     - name: Build system information
-      run: python .github/workflows/system-info.py
+      run: python3 .github/workflows/system-info.py

     - name: Install dependencies
       run: |
-        python -m pip install -U pip
-        python -m pip install -U tox
+        python3 -m pip install -U pip
+        python3 -m pip install -U tox

     - name: Lint
       run: tox -e lint
       env:
         PRE_COMMIT_COLOR: always
-
('.github/workflows', 'test.yml')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,6 @@
 name: Test

-on: [push, pull_request]
+on: [push, pull_request, workflow_dispatch]

 jobs:
   build:
@@ -9,56 +9,44 @@
       fail-fast: false
       matrix:
         os: [
+          "macos-latest",
           "ubuntu-latest",
-          "macOS-latest",
         ]
         python-version: [
+          "pypy-3.8",
           "pypy-3.7",
-          "pypy-3.6",
-          "3.10-dev",
+          "3.10",
           "3.9",
           "3.8",
           "3.7",
-          "3.6",
         ]
         include:
-        - python-version: "3.6"
+        - python-version: "3.7"
           PYTHONOPTIMIZE: 1
-        - python-version: "3.7"
+          REVERSE: "--reverse"
+        - python-version: "3.8"
           PYTHONOPTIMIZE: 2
         # Include new variables for Codecov
         - os: ubuntu-latest
           codecov-flag: GHA_Ubuntu
-        - os: macOS-latest
+        - os: macos-latest
           codecov-flag: GHA_macOS

     runs-on: ${{ matrix.os }}
     name: ${{ matrix.os }} Python ${{ matrix.python-version }}

     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v3

     - name: Set up Python ${{ matrix.python-version }}
-      uses: actions/setup-python@v2
+      uses: actions/setup-python@v3
       with:
         python-version: ${{ matrix.python-version }}
-
-    - name: Get pip cache dir
-      id: pip-cache
-      run: |
-        echo "::set-output name=dir::$(python3 -m pip cache dir)"
-
-    - name: pip cache
-      uses: actions/cache@v2
-      with:
-        path: ${{ steps.pip-cache.outputs.dir }}
-        key:
-          ${{ matrix.os }}-${{ matrix.python-version }}-${{ hashFiles('**/.ci/*.sh') }}
-        restore-keys: |
-          ${{ matrix.os }}-${{ matrix.python-version }}-
+        cache: pip
+        cache-dependency-path: ".ci/*.sh"

     - name: Build system information
-      run: python .github/workflows/system-info.py
+      run: python3 .github/workflows/system-info.py

     - name: Install Linux dependencies
       if: startsWith(matrix.os, 'ubuntu')
@@ -71,8 +59,6 @@
       if: startsWith(matrix.os, 'macOS')
       run: |
         .github/workflows/macos-install.sh
-      env:
-        GHA_PYTHON_VERSION: ${{ matrix.python-version }}

     - name: Build
       run: |
@@ -80,6 +66,9 @@

     - name: Test
       run: |
+        if [ $REVERSE ]; then
+          python3 -m pip install pytest-reverse
+        fi
         if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
           xvfb-run -s '-screen 0 1024x768x24' .ci/test.sh
         else
@@ -87,24 +76,24 @@
         fi
       env:
         PYTHONOPTIMIZE: ${{ matrix.PYTHONOPTIMIZE }}
+        REVERSE: ${{ matrix.REVERSE }}

     - name: Prepare to upload errors
       if: failure()
       run: |
         mkdir -p Tests/errors
-      shell: pwsh

     - name: Upload errors
-      uses: actions/upload-artifact@v2
+      uses: actions/upload-artifact@v3
       if: failure()
       with:
         name: errors
         path: Tests/errors

     - name: Docs
-      if: startsWith(matrix.os, 'ubuntu') && matrix.python-version == 3.9
+      if: startsWith(matrix.os, 'ubuntu') && matrix.python-version == 3.10
       run: |
-        python3 -m pip install sphinx-issues sphinx-removed-in sphinx-rtd-theme
+        python3 -m pip install sphinx-copybutton sphinx-issues sphinx-removed-in sphinx-rtd-theme sphinxext-opengraph
         make doccheck

     - name: After success
('.github/workflows', 'macos-install.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,19 +6,16 @@

 PYTHONOPTIMIZE=0 python3 -m pip install cffi
 python3 -m pip install coverage
+python3 -m pip install defusedxml
 python3 -m pip install olefile
 python3 -m pip install -U pytest
 python3 -m pip install -U pytest-cov
+python3 -m pip install -U pytest-timeout
 python3 -m pip install pyroma
 python3 -m pip install test-image-results

 echo -e "[openblas]\nlibraries = openblas\nlibrary_dirs = /usr/local/opt/openblas/lib" >> ~/.numpy-site.cfg
-# TODO Remove condition when numpy supports 3.10
-if ! [ "$GHA_PYTHON_VERSION" == "3.10-dev" ]; then python3 -m pip install numpy ; fi
-
-# TODO Remove when 3.8 / 3.9 includes setuptools 49.3.2+:
-if [ "$GHA_PYTHON_VERSION" == "3.8" ]; then python3 -m pip install -U "setuptools>=49.3.2" ; fi
-if [ "$GHA_PYTHON_VERSION" == "3.9" ]; then python3 -m pip install -U "setuptools>=49.3.2" ; fi
+python3 -m pip install numpy

 # extra test images
 pushd depends && ./install_extra_test_images.sh && popd
('.github/workflows', 'release-drafter.yml')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,14 +4,15 @@
   push:
     # branches to consider in the event; optional, defaults to all
     branches:
-      - master
+      - main
+  workflow_dispatch:

 jobs:
   update_release_draft:
     if: github.repository == 'python-pillow/Pillow'
     runs-on: ubuntu-latest
     steps:
-      # Drafts your next release notes as pull requests are merged into "master"
+      # Drafts your next release notes as pull requests are merged into "main"
       - uses: release-drafter/release-drafter@v5
         env:
           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
('.github/workflows', 'test-windows.yml')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,78 +1,59 @@
 name: Test Windows

-on: [push, pull_request]
+on: [push, pull_request, workflow_dispatch]

 jobs:
   build:
-    runs-on: windows-2019
+    runs-on: windows-latest
     strategy:
       fail-fast: false
       matrix:
-        python-version: ["pypy-3.6", "pypy-3.7", "3.6", "3.7", "3.8", "3.9", "3.10-dev"]
+        python-version: ["3.7", "3.8", "3.9", "3.10"]
         architecture: ["x86", "x64"]
         include:
-          - architecture: "x86"
-            platform-vcvars: "x86"
-            platform-msbuild: "Win32"
-          - architecture: "x64"
-            platform-vcvars: "x86_amd64"
-            platform-msbuild: "x64"
-        exclude:
-          # PyPy does not support 64-bit on Windows
-          - python-version: "pypy-3.6"
-            architecture: "x64"
+          # PyPy 7.3.4+ only ships 64-bit binaries for Windows
           - python-version: "pypy-3.7"
             architecture: "x64"
+          - python-version: "pypy-3.8"
+            architecture: "x64"
+
     timeout-minutes: 30

     name: Python ${{ matrix.python-version }} ${{ matrix.architecture }}

     steps:
     - name: Checkout Pillow
-      uses: actions/checkout@v2
+      uses: actions/checkout@v3

     - name: Checkout cached dependencies
-      uses: actions/checkout@v2
+      uses: actions/checkout@v3
       with:
         repository: python-pillow/pillow-depends
         path: winbuild\depends

-    - name: Cache pip
-      uses: actions/cache@v2
-      with:
-        path: ~\AppData\Local\pip\Cache
-        key:
-          ${{ runner.os }}-${{ matrix.python-version }}-${{ matrix.architecture }}-${{ hashFiles('**/.github/workflows/test-windows.yml') }}
-        restore-keys: |
-          ${{ runner.os }}-${{ matrix.python-version }}-${{ matrix.architecture }}-
-          ${{ runner.os }}-${{ matrix.python-version }}-
-
     # sets env: pythonLocation
     - name: Set up Python
-      uses: actions/setup-python@v2
+      uses: actions/setup-python@v3
       with:
         python-version: ${{ matrix.python-version }}
         architecture: ${{ matrix.architecture }}
+        cache: pip
+        cache-dependency-path: ".github/workflows/test-windows.yml"

     - name: Print build system information
       run: python .github/workflows/system-info.py

-    - name: python -m pip install wheel pytest pytest-cov
-      run: python -m pip install wheel pytest pytest-cov
-
-    # TODO Remove when 3.8 / 3.9 includes setuptools 49.3.2+:
-    - name: Upgrade setuptools
-      if: "contains(matrix.python-version, '3.8') || contains(matrix.python-version, '3.9')"
-      run: python -m pip install -U "setuptools>=49.3.2"
+    - name: python -m pip install wheel pytest pytest-cov pytest-timeout defusedxml
+      run: python -m pip install wheel pytest pytest-cov pytest-timeout defusedxml

     - name: Install dependencies
       id: install
       run: |
-        7z x winbuild\depends\nasm-2.14.02-win64.zip "-o$env:RUNNER_WORKSPACE\"
-        echo "$env:RUNNER_WORKSPACE\nasm-2.14.02" >> $env:GITHUB_PATH
+        7z x winbuild\depends\nasm-2.15.05-win64.zip "-o$env:RUNNER_WORKSPACE\"
+        echo "$env:RUNNER_WORKSPACE\nasm-2.15.05" >> $env:GITHUB_PATH

-        winbuild\depends\gs9533w32.exe /S
-        echo "C:\Program Files (x86)\gs\gs9.53.3\bin" >> $env:GITHUB_PATH
+        winbuild\depends\gs9550w32.exe /S
+        echo "C:\Program Files (x86)\gs\gs9.55.0\bin" >> $env:GITHUB_PATH

         xcopy /S /Y winbuild\depends\test_images\* Tests\images\

@@ -110,7 +91,7 @@
       if: steps.build-cache.outputs.cache-hit != 'true'
       run: "& winbuild\\build\\build_dep_libwebp.cmd"

-    # for FreeType CBDT font support
+    # for FreeType CBDT/SBIX font support
     - name: Build dependencies / libpng
       if: steps.build-cache.outputs.cache-hit != 'true'
       run: "& winbuild\\build\\build_dep_libpng.cmd"
@@ -137,13 +118,10 @@
       if: steps.build-cache.outputs.cache-hit != 'true'
       run: "& winbuild\\build\\build_dep_harfbuzz.cmd"

+    # Raqm dependencies
     - name: Build dependencies / FriBidi
       if: steps.build-cache.outputs.cache-hit != 'true'
       run: "& winbuild\\build\\build_dep_fribidi.cmd"
-
-    - name: Build dependencies / Raqm
-      if: steps.build-cache.outputs.cache-hit != 'true'
-      run: "& winbuild\\build\\build_dep_libraqm.cmd"

     # trim ~150MB x 9
     - name: Optimize build cache
@@ -154,15 +132,16 @@
     - name: Build Pillow
       run: |
         $FLAGS=""
-        if ('${{ github.event_name }}' -eq 'push') { $FLAGS="--disable-imagequant" }
+        if ('${{ github.event_name }}' -ne 'pull_request') { $FLAGS="--disable-imagequant" }
         & winbuild\build\build_pillow.cmd $FLAGS install
         & $env:pythonLocation\python.exe selftest.py --installed
       shell: pwsh

-    # failing with PyPy3
+    # skip PyPy for speed
     - name: Enable heap verification
       if: "!contains(matrix.python-version, 'pypy')"
-      run: "& 'C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\gflags.exe' /p /enable $env:pythonLocation\\python.exe"
+      run: |
+        & reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\python.exe" /v "GlobalFlag" /t REG_SZ /d "0x02000000" /f

     - name: Test Pillow
       run: |
@@ -174,10 +153,10 @@
       if: failure()
       run: |
         mkdir -p Tests/errors
-      shell: pwsh
+      shell: bash

     - name: Upload errors
-      uses: actions/upload-artifact@v2
+      uses: actions/upload-artifact@v3
       if: failure()
       with:
         name: errors
@@ -197,93 +176,20 @@

     - name: Build wheel
       id: wheel
-      if: "github.event_name == 'push'"
+      if: "github.event_name != 'pull_request'"
       run: |
         for /f "tokens=3 delims=/" %%a in ("${{ github.ref }}") do echo ::set-output name=dist::dist-%%a
         winbuild\\build\\build_pillow.cmd --disable-imagequant bdist_wheel
       shell: cmd

-    - uses: actions/upload-artifact@v2
-      if: "github.event_name == 'push'"
+    - uses: actions/upload-artifact@v3
+      if: "github.event_name != 'pull_request'"
       with:
         name: ${{ steps.wheel.outputs.dist }}
         path: dist\*.whl

-  msys:
-    runs-on: windows-2019
-
-    strategy:
-      fail-fast: false
-      matrix:
-        mingw: ["MINGW32", "MINGW64"]
-        include:
-          - mingw: "MINGW32"
-            name: "MSYS2 MinGW 32-bit"
-            package: "mingw-w64-i686"
-          - mingw: "MINGW64"
-            name: "MSYS2 MinGW 64-bit"
-            package: "mingw-w64-x86_64"
-
-    defaults:
-      run:
-        shell: bash.exe --login -eo pipefail "{0}"
-    env:
-      MSYSTEM: ${{ matrix.mingw }}
-      CHERE_INVOKING: 1
-
-    timeout-minutes: 30
-    name: ${{ matrix.name }}
-
-    steps:
-      - uses: actions/checkout@v2
-
-      - name: Set up shell
-        run: echo "C:\msys64\usr\bin\" >> $env:GITHUB_PATH
-        shell: pwsh
-
-      - name: Install Dependencies
-        run: |
-          pacman -S --noconfirm \
-              ${{ matrix.package }}-python3-cffi \
-              ${{ matrix.package }}-python3-numpy \
-              ${{ matrix.package }}-python3-olefile \
-              ${{ matrix.package }}-python3-pip \
-              ${{ matrix.package }}-python3-pyqt5 \
-              ${{ matrix.package }}-python3-pytest \
-              ${{ matrix.package }}-python3-pytest-cov \
-              ${{ matrix.package }}-python3-setuptools \
-              ${{ matrix.package }}-freetype \
-              ${{ matrix.package }}-ghostscript \
-              ${{ matrix.package }}-lcms2 \
-              ${{ matrix.package }}-libimagequant \
-              ${{ matrix.package }}-libjpeg-turbo \
-              ${{ matrix.package }}-libraqm \
-              ${{ matrix.package }}-libtiff \
-              ${{ matrix.package }}-libwebp \
-              ${{ matrix.package }}-openjpeg2 \
-              subversion
-
-          python3 -m pip install pyroma
-
-          pushd depends && ./install_extra_test_images.sh && popd
-
-      - name: Build Pillow
-        run: CFLAGS="-coverage" python3 setup.py build_ext install
-
-      - name: Test Pillow
-        run: |
-          python3 selftest.py --installed
-          python3 -m pytest -vx --cov PIL --cov Tests --cov-report term --cov-report xml Tests
-
-      - name: Upload coverage
-        run: |
-          python3 -m pip install codecov
-          bash <(curl -s https://codecov.io/bash) -F GHA_Windows
-        env:
-          CODECOV_NAME: ${{ matrix.name }}
-
   success:
-    needs: [build, msys]
+    needs: build
     runs-on: ubuntu-latest
     name: Windows Test Successful
     steps:
('.github/workflows', 'test-docker.yml')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,6 @@
 name: Test Docker

-on: [push, pull_request]
+on: [push, pull_request, workflow_dispatch]

 jobs:
   build:
@@ -19,14 +19,17 @@
           amazon-2-amd64,
           arch,
           centos-7-amd64,
-          centos-8-amd64,
+          centos-stream-8-amd64,
+          centos-stream-9-amd64,
           debian-10-buster-x86,
-          fedora-32-amd64,
-          fedora-33-amd64,
+          debian-11-bullseye-x86,
+          fedora-34-amd64,
+          fedora-35-amd64,
+          gentoo,
           ubuntu-18.04-bionic-amd64,
           ubuntu-20.04-focal-amd64,
         ]
-        dockerTag: [master]
+        dockerTag: [main]
         include:
           - docker: "ubuntu-20.04-focal-arm64v8"
             qemu-arch: "aarch64"
@@ -38,10 +41,10 @@
     name: ${{ matrix.docker }}

     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v3

     - name: Build system information
-      run: python .github/workflows/system-info.py
+      run: python3 .github/workflows/system-info.py

     - name: Set up QEMU
       if: "matrix.qemu-arch"
('depends', 'install_raqm.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,13 +2,13 @@
 # install raqm


-archive=raqm-0.7.1
+archive=libraqm-0.9.0

-./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/master/$archive.tar.gz
+./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/main/$archive.tar.gz

 pushd $archive

-./configure --prefix=/usr && make -j4 && sudo make -j4 install
+meson build --prefix=/usr && sudo ninja -C build install

 popd

('depends', 'install_webp.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,9 +1,9 @@
 #!/bin/bash
 # install webp

-archive=libwebp-1.1.0
+archive=libwebp-1.2.2

-./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/master/$archive.tar.gz
+./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/main/$archive.tar.gz

 pushd $archive

('depends', 'install_openjpeg.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -3,7 +3,7 @@

 archive=openjpeg-2.4.0

-./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/master/$archive.tar.gz
+./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/main/$archive.tar.gz

 pushd $archive

('depends', 'install_raqm_cmake.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,7 @@

 archive=raqm-cmake-99300ff3

-./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/master/$archive.tar.gz
+./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/main/$archive.tar.gz

 pushd $archive

('depends', 'install_imagequant.sh')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,14 +1,15 @@
 #!/bin/bash
 # install libimagequant

-archive=libimagequant-2.13.1
+archive=libimagequant-4.0.0

-./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/master/$archive.tar.gz
+./download-and-extract.sh $archive https://raw.githubusercontent.com/python-pillow/pillow-depends/main/$archive.tar.gz

-pushd $archive
+pushd $archive/imagequant-sys

-make shared
-sudo cp libimagequant.so* /usr/lib/
-sudo cp libimagequant.h /usr/include/
+cargo install cargo-c
+cargo cinstall --prefix=/usr --destdir=.
+sudo cp usr/lib/libimagequant.so* /usr/lib/
+sudo cp usr/include/libimagequant.h /usr/include/

 popd
('src', 'display.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -41,15 +41,13 @@
 #endif

 typedef struct {
-    PyObject_HEAD
-    ImagingDIB dib;
+    PyObject_HEAD ImagingDIB dib;
 } ImagingDisplayObject;

 static PyTypeObject ImagingDisplayType;

-static ImagingDisplayObject*
-_new(const char* mode, int xsize, int ysize)
-{
+static ImagingDisplayObject *
+_new(const char *mode, int xsize, int ysize) {
     ImagingDisplayObject *display;

     if (PyType_Ready(&ImagingDisplayType) < 0) {
@@ -71,17 +69,15 @@
 }

 static void
-_delete(ImagingDisplayObject* display)
-{
+_delete(ImagingDisplayObject *display) {
     if (display->dib) {
         ImagingDeleteDIB(display->dib);
     }
     PyObject_Del(display);
 }

-static PyObject*
-_expose(ImagingDisplayObject* display, PyObject* args)
-{
+static PyObject *
+_expose(ImagingDisplayObject *display, PyObject *args) {
     HDC hdc;
     if (!PyArg_ParseTuple(args, F_HANDLE, &hdc)) {
         return NULL;
@@ -93,15 +89,23 @@
     return Py_None;
 }

-static PyObject*
-_draw(ImagingDisplayObject* display, PyObject* args)
-{
+static PyObject *
+_draw(ImagingDisplayObject *display, PyObject *args) {
     HDC hdc;
     int dst[4];
     int src[4];
-    if (!PyArg_ParseTuple(args, F_HANDLE "(iiii)(iiii)", &hdc,
-                          dst+0, dst+1, dst+2, dst+3,
-                          src+0, src+1, src+2, src+3)) {
+    if (!PyArg_ParseTuple(
+            args,
+            F_HANDLE "(iiii)(iiii)",
+            &hdc,
+            dst + 0,
+            dst + 1,
+            dst + 2,
+            dst + 3,
+            src + 0,
+            src + 1,
+            src + 2,
+            src + 3)) {
         return NULL;
     }

@@ -111,17 +115,17 @@
     return Py_None;
 }

-extern Imaging PyImaging_AsImaging(PyObject *op);
-
-static PyObject*
-_paste(ImagingDisplayObject* display, PyObject* args)
-{
+extern Imaging
+PyImaging_AsImaging(PyObject *op);
+
+static PyObject *
+_paste(ImagingDisplayObject *display, PyObject *args) {
     Imaging im;

-    PyObject* op;
+    PyObject *op;
     int xy[4];
     xy[0] = xy[1] = xy[2] = xy[3] = 0;
-    if (!PyArg_ParseTuple(args, "O|(iiii)", &op, xy+0, xy+1, xy+2, xy+3)) {
+    if (!PyArg_ParseTuple(args, "O|(iiii)", &op, xy + 0, xy + 1, xy + 2, xy + 3)) {
         return NULL;
     }
     im = PyImaging_AsImaging(op);
@@ -142,9 +146,8 @@
     return Py_None;
 }

-static PyObject*
-_query_palette(ImagingDisplayObject* display, PyObject* args)
-{
+static PyObject *
+_query_palette(ImagingDisplayObject *display, PyObject *args) {
     HDC hdc;
     int status;

@@ -157,9 +160,8 @@
     return Py_BuildValue("i", status);
 }

-static PyObject*
-_getdc(ImagingDisplayObject* display, PyObject* args)
-{
+static PyObject *
+_getdc(ImagingDisplayObject *display, PyObject *args) {
     HWND window;
     HDC dc;

@@ -176,9 +178,8 @@
     return Py_BuildValue(F_HANDLE, dc);
 }

-static PyObject*
-_releasedc(ImagingDisplayObject* display, PyObject* args)
-{
+static PyObject *
+_releasedc(ImagingDisplayObject *display, PyObject *args) {
     HWND window;
     HDC dc;

@@ -192,10 +193,9 @@
     return Py_None;
 }

-static PyObject*
-_frombytes(ImagingDisplayObject* display, PyObject* args)
-{
-    char* ptr;
+static PyObject *
+_frombytes(ImagingDisplayObject *display, PyObject *args) {
+    char *ptr;
     Py_ssize_t bytes;

     if (!PyArg_ParseTuple(args, "y#:frombytes", &ptr, &bytes)) {
@@ -213,86 +213,77 @@
     return Py_None;
 }

-static PyObject*
-_tobytes(ImagingDisplayObject* display, PyObject* args)
-{
+static PyObject *
+_tobytes(ImagingDisplayObject *display, PyObject *args) {
     if (!PyArg_ParseTuple(args, ":tobytes")) {
         return NULL;
     }

     return PyBytes_FromStringAndSize(
-        display->dib->bits, display->dib->ysize * display->dib->linesize
-        );
+        display->dib->bits, display->dib->ysize * display->dib->linesize);
 }

 static struct PyMethodDef methods[] = {
-    {"draw", (PyCFunction)_draw, 1},
-    {"expose", (PyCFunction)_expose, 1},
-    {"paste", (PyCFunction)_paste, 1},
-    {"query_palette", (PyCFunction)_query_palette, 1},
-    {"getdc", (PyCFunction)_getdc, 1},
-    {"releasedc", (PyCFunction)_releasedc, 1},
-    {"frombytes", (PyCFunction)_frombytes, 1},
-    {"tobytes", (PyCFunction)_tobytes, 1},
+    {"draw", (PyCFunction)_draw, METH_VARARGS},
+    {"expose", (PyCFunction)_expose, METH_VARARGS},
+    {"paste", (PyCFunction)_paste, METH_VARARGS},
+    {"query_palette", (PyCFunction)_query_palette, METH_VARARGS},
+    {"getdc", (PyCFunction)_getdc, METH_VARARGS},
+    {"releasedc", (PyCFunction)_releasedc, METH_VARARGS},
+    {"frombytes", (PyCFunction)_frombytes, METH_VARARGS},
+    {"tobytes", (PyCFunction)_tobytes, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };

-static PyObject*
-_getattr_mode(ImagingDisplayObject* self, void* closure)
-{
+static PyObject *
+_getattr_mode(ImagingDisplayObject *self, void *closure) {
     return Py_BuildValue("s", self->dib->mode);
 }

-static PyObject*
-_getattr_size(ImagingDisplayObject* self, void* closure)
-{
+static PyObject *
+_getattr_size(ImagingDisplayObject *self, void *closure) {
     return Py_BuildValue("ii", self->dib->xsize, self->dib->ysize);
 }

 static struct PyGetSetDef getsetters[] = {
-    { "mode",   (getter) _getattr_mode },
-    { "size",   (getter) _getattr_size },
-    { NULL }
+    {"mode", (getter)_getattr_mode}, {"size", (getter)_getattr_size}, {NULL}};
+
+static PyTypeObject ImagingDisplayType = {
+    PyVarObject_HEAD_INIT(NULL, 0) "ImagingDisplay", /*tp_name*/
+    sizeof(ImagingDisplayObject),                    /*tp_size*/
+    0,                                               /*tp_itemsize*/
+    /* methods */
+    (destructor)_delete, /*tp_dealloc*/
+    0,                   /*tp_print*/
+    0,                   /*tp_getattr*/
+    0,                   /*tp_setattr*/
+    0,                   /*tp_compare*/
+    0,                   /*tp_repr*/
+    0,                   /*tp_as_number */
+    0,                   /*tp_as_sequence */
+    0,                   /*tp_as_mapping */
+    0,                   /*tp_hash*/
+    0,                   /*tp_call*/
+    0,                   /*tp_str*/
+    0,                   /*tp_getattro*/
+    0,                   /*tp_setattro*/
+    0,                   /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,  /*tp_flags*/
+    0,                   /*tp_doc*/
+    0,                   /*tp_traverse*/
+    0,                   /*tp_clear*/
+    0,                   /*tp_richcompare*/
+    0,                   /*tp_weaklistoffset*/
+    0,                   /*tp_iter*/
+    0,                   /*tp_iternext*/
+    methods,             /*tp_methods*/
+    0,                   /*tp_members*/
+    getsetters,          /*tp_getset*/
 };

-static PyTypeObject ImagingDisplayType = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "ImagingDisplay",            /*tp_name*/
-    sizeof(ImagingDisplayObject),/*tp_size*/
-    0,                           /*tp_itemsize*/
-    /* methods */
-    (destructor)_delete,        /*tp_dealloc*/
-    0,                          /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    methods,                    /*tp_methods*/
-    0,                          /*tp_members*/
-    getsetters,                 /*tp_getset*/
-};
-
-PyObject*
-PyImaging_DisplayWin32(PyObject* self, PyObject* args)
-{
-    ImagingDisplayObject* display;
+PyObject *
+PyImaging_DisplayWin32(PyObject *self, PyObject *args) {
+    ImagingDisplayObject *display;
     char *mode;
     int xsize, ysize;

@@ -305,12 +296,11 @@
         return NULL;
     }

-    return (PyObject*) display;
-}
-
-PyObject*
-PyImaging_DisplayModeWin32(PyObject* self, PyObject* args)
-{
+    return (PyObject *)display;
+}
+
+PyObject *
+PyImaging_DisplayModeWin32(PyObject *self, PyObject *args) {
     char *mode;
     int size[2];

@@ -322,18 +312,17 @@
 /* -------------------------------------------------------------------- */
 /* Windows screen grabber */

-typedef HANDLE(__stdcall* Func_SetThreadDpiAwarenessContext)(HANDLE);
-
-PyObject*
-PyImaging_GrabScreenWin32(PyObject* self, PyObject* args)
-{
+typedef HANDLE(__stdcall *Func_SetThreadDpiAwarenessContext)(HANDLE);
+
+PyObject *
+PyImaging_GrabScreenWin32(PyObject *self, PyObject *args) {
     int x = 0, y = 0, width, height;
     int includeLayeredWindows = 0, all_screens = 0;
     HBITMAP bitmap;
     BITMAPCOREHEADER core;
     HDC screen, screen_copy;
     DWORD rop;
-    PyObject* buffer;
+    PyObject *buffer;
     HANDLE dpiAwareness;
     HMODULE user32;
     Func_SetThreadDpiAwarenessContext SetThreadDpiAwarenessContext_function;
@@ -352,11 +341,11 @@
     // loaded dynamically to avoid link errors
     user32 = LoadLibraryA("User32.dll");
     SetThreadDpiAwarenessContext_function =
-            (Func_SetThreadDpiAwarenessContext)
-            GetProcAddress(user32, "SetThreadDpiAwarenessContext");
+        (Func_SetThreadDpiAwarenessContext)GetProcAddress(
+            user32, "SetThreadDpiAwarenessContext");
     if (SetThreadDpiAwarenessContext_function != NULL) {
         // DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE = ((DPI_CONTEXT_HANDLE)-3)
-        dpiAwareness = SetThreadDpiAwarenessContext_function((HANDLE) -3);
+        dpiAwareness = SetThreadDpiAwarenessContext_function((HANDLE)-3);
     }

     if (all_screens) {
@@ -396,7 +385,7 @@

     /* step 3: extract bits from bitmap */

-    buffer = PyBytes_FromStringAndSize(NULL, height * ((width*3 + 3) & -4));
+    buffer = PyBytes_FromStringAndSize(NULL, height * ((width * 3 + 3) & -4));
     if (!buffer) {
         return NULL;
     }
@@ -406,8 +395,14 @@
     core.bcHeight = height;
     core.bcPlanes = 1;
     core.bcBitCount = 24;
-    if (!GetDIBits(screen_copy, bitmap, 0, height, PyBytes_AS_STRING(buffer),
-                   (BITMAPINFO*) &core, DIB_RGB_COLORS)) {
+    if (!GetDIBits(
+            screen_copy,
+            bitmap,
+            0,
+            height,
+            PyBytes_AS_STRING(buffer),
+            (BITMAPINFO *)&core,
+            DIB_RGB_COLORS)) {
         goto error;
     }

@@ -426,11 +421,11 @@
     return NULL;
 }

-static BOOL CALLBACK list_windows_callback(HWND hwnd, LPARAM lParam)
-{
-    PyObject* window_list = (PyObject*) lParam;
-    PyObject* item;
-    PyObject* title;
+static BOOL CALLBACK
+list_windows_callback(HWND hwnd, LPARAM lParam) {
+    PyObject *window_list = (PyObject *)lParam;
+    PyObject *item;
+    PyObject *title;
     RECT inner, outer;
     int title_size;
     int status;
@@ -440,7 +435,7 @@
     if (title_size > 0) {
         title = PyUnicode_FromStringAndSize(NULL, title_size);
         if (title) {
-            GetWindowTextW(hwnd, PyUnicode_AS_UNICODE(title), title_size+1);
+            GetWindowTextW(hwnd, PyUnicode_AS_UNICODE(title), title_size + 1);
         }
     } else {
         title = PyUnicode_FromString("");
@@ -454,10 +449,17 @@
     GetWindowRect(hwnd, &outer);

     item = Py_BuildValue(
-        F_HANDLE "N(iiii)(iiii)", hwnd, title,
-        inner.left, inner.top, inner.right, inner.bottom,
-        outer.left, outer.top, outer.right, outer.bottom
-        );
+        F_HANDLE "N(iiii)(iiii)",
+        hwnd,
+        title,
+        inner.left,
+        inner.top,
+        inner.right,
+        inner.bottom,
+        outer.left,
+        outer.top,
+        outer.right,
+        outer.bottom);
     if (!item) {
         return 0;
     }
@@ -473,17 +475,16 @@
     return 1;
 }

-PyObject*
-PyImaging_ListWindowsWin32(PyObject* self, PyObject* args)
-{
-    PyObject* window_list;
+PyObject *
+PyImaging_ListWindowsWin32(PyObject *self, PyObject *args) {
+    PyObject *window_list;

     window_list = PyList_New(0);
     if (!window_list) {
         return NULL;
     }

-    EnumWindows(list_windows_callback, (LPARAM) window_list);
+    EnumWindows(list_windows_callback, (LPARAM)window_list);

     if (PyErr_Occurred()) {
         Py_DECREF(window_list);
@@ -496,17 +497,16 @@
 /* -------------------------------------------------------------------- */
 /* Windows clipboard grabber */

-PyObject*
-PyImaging_GrabClipboardWin32(PyObject* self, PyObject* args)
-{
+PyObject *
+PyImaging_GrabClipboardWin32(PyObject *self, PyObject *args) {
     int clip;
     HANDLE handle = NULL;
     int size;
-    void* data;
-    PyObject* result;
+    void *data;
+    PyObject *result;
     UINT format;
-    UINT formats[] = { CF_DIB, CF_DIBV5, CF_HDROP, RegisterClipboardFormatA("PNG"), 0 };
-    LPCSTR format_names[] = { "DIB", "DIB", "file", "png", NULL };
+    UINT formats[] = {CF_DIB, CF_DIBV5, CF_HDROP, RegisterClipboardFormatA("PNG"), 0};
+    LPCSTR format_names[] = {"DIB", "DIB", "file", "png", NULL};

     if (!OpenClipboard(NULL)) {
         PyErr_SetString(PyExc_OSError, "failed to open clipboard");
@@ -551,15 +551,14 @@
 static int mainloop = 0;

 static void
-callback_error(const char* handler)
-{
-    PyObject* sys_stderr;
+callback_error(const char *handler) {
+    PyObject *sys_stderr;

     sys_stderr = PySys_GetObject("stderr");

     if (sys_stderr) {
         PyFile_WriteString("*** ImageWin: error in ", sys_stderr);
-        PyFile_WriteString((char*) handler, sys_stderr);
+        PyFile_WriteString((char *)handler, sys_stderr);
         PyFile_WriteString(":\n", sys_stderr);
     }

@@ -568,109 +567,119 @@
 }

 static LRESULT CALLBACK
-windowCallback(HWND wnd, UINT message, WPARAM wParam, LPARAM lParam)
-{
+windowCallback(HWND wnd, UINT message, WPARAM wParam, LPARAM lParam) {
     PAINTSTRUCT ps;
-    PyObject* callback = NULL;
-    PyObject* result;
-    PyThreadState* threadstate;
-    PyThreadState* current_threadstate;
+    PyObject *callback = NULL;
+    PyObject *result;
+    PyThreadState *threadstate;
+    PyThreadState *current_threadstate;
     HDC dc;
     RECT rect;
     LRESULT status = 0;

     /* set up threadstate for messages that calls back into python */
     switch (message) {
-    case WM_CREATE:
-        mainloop++;
-        break;
-    case WM_DESTROY:
-        mainloop--;
-        /* fall through... */
-    case WM_PAINT:
-    case WM_SIZE:
-        callback = (PyObject*) GetWindowLongPtr(wnd, 0);
-        if (callback) {
-            threadstate = (PyThreadState*)
-                GetWindowLongPtr(wnd, sizeof(PyObject*));
-            current_threadstate = PyThreadState_Swap(NULL);
-            PyEval_RestoreThread(threadstate);
-        } else {
-            return DefWindowProc(wnd, message, wParam, lParam);
-        }
+        case WM_CREATE:
+            mainloop++;
+            break;
+        case WM_DESTROY:
+            mainloop--;
+            /* fall through... */
+        case WM_PAINT:
+        case WM_SIZE:
+            callback = (PyObject *)GetWindowLongPtr(wnd, 0);
+            if (callback) {
+                threadstate =
+                    (PyThreadState *)GetWindowLongPtr(wnd, sizeof(PyObject *));
+                current_threadstate = PyThreadState_Swap(NULL);
+                PyEval_RestoreThread(threadstate);
+            } else {
+                return DefWindowProc(wnd, message, wParam, lParam);
+            }
     }

     /* process message */
     switch (message) {
-
-    case WM_PAINT:
-        /* redraw (part of) window.  this generates a WCK-style
-           damage/clear/repair cascade */
-        BeginPaint(wnd, &ps);
-        dc = GetDC(wnd);
-        GetWindowRect(wnd, &rect); /* in screen coordinates */
-
-        result = PyObject_CallFunction(
-            callback, "siiii", "damage",
-            ps.rcPaint.left, ps.rcPaint.top,
-            ps.rcPaint.right, ps.rcPaint.bottom
-            );
-        if (result) {
-            Py_DECREF(result);
-        } else {
-            callback_error("window damage callback");
-        }
-
-        result = PyObject_CallFunction(
-            callback, "s" F_HANDLE "iiii", "clear", dc,
-            0, 0, rect.right-rect.left, rect.bottom-rect.top
-            );
-        if (result) {
-            Py_DECREF(result);
-        } else {
-            callback_error("window clear callback");
-        }
-
-        result = PyObject_CallFunction(
-            callback, "s" F_HANDLE "iiii", "repair", dc,
-            0, 0, rect.right-rect.left, rect.bottom-rect.top
-            );
-        if (result) {
-            Py_DECREF(result);
-        } else {
-            callback_error("window repair callback");
-        }
-
-        ReleaseDC(wnd, dc);
-        EndPaint(wnd, &ps);
-        break;
-
-    case WM_SIZE:
-        /* resize window */
-        result = PyObject_CallFunction(
-            callback, "sii", "resize", LOWORD(lParam), HIWORD(lParam)
-            );
-        if (result) {
-            InvalidateRect(wnd, NULL, 1);
-            Py_DECREF(result);
-        } else {
-            callback_error("window resize callback");
-        }
-        break;
-
-    case WM_DESTROY:
-        /* destroy window */
-        result = PyObject_CallFunction(callback, "s", "destroy");
-        if (result) {
-            Py_DECREF(result);
-        } else {
-            callback_error("window destroy callback");
-        }
-        Py_DECREF(callback);
-        break;
-
-    default:
-        status = DefWindowProc(wnd, message, wParam, lParam);
+        case WM_PAINT:
+            /* redraw (part of) window.  this generates a WCK-style
+               damage/clear/repair cascade */
+            BeginPaint(wnd, &ps);
+            dc = GetDC(wnd);
+            GetWindowRect(wnd, &rect); /* in screen coordinates */
+
+            result = PyObject_CallFunction(
+                callback,
+                "siiii",
+                "damage",
+                ps.rcPaint.left,
+                ps.rcPaint.top,
+                ps.rcPaint.right,
+                ps.rcPaint.bottom);
+            if (result) {
+                Py_DECREF(result);
+            } else {
+                callback_error("window damage callback");
+            }
+
+            result = PyObject_CallFunction(
+                callback,
+                "s" F_HANDLE "iiii",
+                "clear",
+                dc,
+                0,
+                0,
+                rect.right - rect.left,
+                rect.bottom - rect.top);
+            if (result) {
+                Py_DECREF(result);
+            } else {
+                callback_error("window clear callback");
+            }
+
+            result = PyObject_CallFunction(
+                callback,
+                "s" F_HANDLE "iiii",
+                "repair",
+                dc,
+                0,
+                0,
+                rect.right - rect.left,
+                rect.bottom - rect.top);
+            if (result) {
+                Py_DECREF(result);
+            } else {
+                callback_error("window repair callback");
+            }
+
+            ReleaseDC(wnd, dc);
+            EndPaint(wnd, &ps);
+            break;
+
+        case WM_SIZE:
+            /* resize window */
+            result = PyObject_CallFunction(
+                callback, "sii", "resize", LOWORD(lParam), HIWORD(lParam));
+            if (result) {
+                InvalidateRect(wnd, NULL, 1);
+                Py_DECREF(result);
+            } else {
+                callback_error("window resize callback");
+            }
+            break;
+
+        case WM_DESTROY:
+            /* destroy window */
+            result = PyObject_CallFunction(callback, "s", "destroy");
+            if (result) {
+                Py_DECREF(result);
+            } else {
+                callback_error("window destroy callback");
+            }
+            Py_DECREF(callback);
+            break;
+
+        default:
+            status = DefWindowProc(wnd, message, wParam, lParam);
     }

     if (callback) {
@@ -682,14 +691,13 @@
     return status;
 }

-PyObject*
-PyImaging_CreateWindowWin32(PyObject* self, PyObject* args)
-{
+PyObject *
+PyImaging_CreateWindowWin32(PyObject *self, PyObject *args) {
     HWND wnd;
     WNDCLASS windowClass;

-    char* title;
-    PyObject* callback;
+    char *title;
+    PyObject *callback;
     int width = 0, height = 0;
     if (!PyArg_ParseTuple(args, "sO|ii", &title, &callback, &width, &height)) {
         return NULL;
@@ -705,7 +713,7 @@
     /* register toplevel window class */
     windowClass.style = CS_CLASSDC;
     windowClass.cbClsExtra = 0;
-    windowClass.cbWndExtra = sizeof(PyObject*) + sizeof(PyThreadState*);
+    windowClass.cbWndExtra = sizeof(PyObject *) + sizeof(PyThreadState *);
     windowClass.hInstance = GetModuleHandle(NULL);
     /* windowClass.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1); */
     windowClass.hbrBackground = NULL;
@@ -718,11 +726,18 @@
     RegisterClass(&windowClass); /* FIXME: check return status */

     wnd = CreateWindowEx(
-        0, windowClass.lpszClassName, title,
+        0,
+        windowClass.lpszClassName,
+        title,
         WS_OVERLAPPEDWINDOW,
-        CW_USEDEFAULT, CW_USEDEFAULT, width, height,
-        HWND_DESKTOP, NULL, NULL, NULL
-        );
+        CW_USEDEFAULT,
+        CW_USEDEFAULT,
+        width,
+        height,
+        HWND_DESKTOP,
+        NULL,
+        NULL,
+        NULL);

     if (!wnd) {
         PyErr_SetString(PyExc_OSError, "failed to create window");
@@ -731,76 +746,76 @@

     /* register window callback */
     Py_INCREF(callback);
-    SetWindowLongPtr(wnd, 0, (LONG_PTR) callback);
-    SetWindowLongPtr(wnd, sizeof(callback), (LONG_PTR) PyThreadState_Get());
-
-    Py_BEGIN_ALLOW_THREADS
-    ShowWindow(wnd, SW_SHOWNORMAL);
+    SetWindowLongPtr(wnd, 0, (LONG_PTR)callback);
+    SetWindowLongPtr(wnd, sizeof(callback), (LONG_PTR)PyThreadState_Get());
+
+    Py_BEGIN_ALLOW_THREADS ShowWindow(wnd, SW_SHOWNORMAL);
     SetForegroundWindow(wnd); /* to make sure it's visible */
     Py_END_ALLOW_THREADS

-    return Py_BuildValue(F_HANDLE, wnd);
-}
-
-PyObject*
-PyImaging_EventLoopWin32(PyObject* self, PyObject* args)
-{
+        return Py_BuildValue(F_HANDLE, wnd);
+}
+
+PyObject *
+PyImaging_EventLoopWin32(PyObject *self, PyObject *args) {
     MSG msg;

-    Py_BEGIN_ALLOW_THREADS
-    while (mainloop && GetMessage(&msg, NULL, 0, 0)) {
+    Py_BEGIN_ALLOW_THREADS while (mainloop && GetMessage(&msg, NULL, 0, 0)) {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
     }
     Py_END_ALLOW_THREADS

-    Py_INCREF(Py_None);
+        Py_INCREF(Py_None);
     return Py_None;
 }

 /* -------------------------------------------------------------------- */
 /* windows WMF renderer */

-#define GET32(p,o) ((DWORD*)(p+o))[0]
+#define GET32(p, o) ((DWORD *)(p + o))[0]

 PyObject *
-PyImaging_DrawWmf(PyObject* self, PyObject* args)
-{
+PyImaging_DrawWmf(PyObject *self, PyObject *args) {
     HBITMAP bitmap;
     HENHMETAFILE meta;
     BITMAPCOREHEADER core;
     HDC dc;
     RECT rect;
-    PyObject* buffer = NULL;
-    char* ptr;
-
-    char* data;
+    PyObject *buffer = NULL;
+    char *ptr;
+
+    char *data;
     Py_ssize_t datasize;
     int width, height;
     int x0, y0, x1, y1;
-    if (!PyArg_ParseTuple(args, "y#(ii)(iiii):_load", &data, &datasize,
-                          &width, &height, &x0, &x1, &y0, &y1)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "y#(ii)(iiii):_load",
+            &data,
+            &datasize,
+            &width,
+            &height,
+            &x0,
+            &x1,
+            &y0,
+            &y1)) {
         return NULL;
     }

     /* step 1: copy metafile contents into METAFILE object */

     if (datasize > 22 && GET32(data, 0) == 0x9ac6cdd7) {
-
         /* placeable windows metafile (22-byte aldus header) */
-        meta = SetWinMetaFileBits(datasize-22, data+22, NULL, NULL);
-
-    } else if (datasize > 80 && GET32(data, 0) == 1 &&
-               GET32(data, 40) == 0x464d4520) {
-
+        meta = SetWinMetaFileBits(datasize - 22, data + 22, NULL, NULL);
+
+    } else if (datasize > 80 && GET32(data, 0) == 1 && GET32(data, 40) == 0x464d4520) {
         /* enhanced metafile */
         meta = SetEnhMetaFileBits(datasize, data);

     } else {
-
         /* unknown meta format */
         meta = NULL;
-
     }

     if (!meta) {
@@ -818,9 +833,7 @@

     dc = CreateCompatibleDC(NULL);

-    bitmap = CreateDIBSection(
-        dc, (BITMAPINFO*) &core, DIB_RGB_COLORS, &ptr, NULL, 0
-        );
+    bitmap = CreateDIBSection(dc, (BITMAPINFO *)&core, DIB_RGB_COLORS, &ptr, NULL, 0);

     if (!bitmap) {
         PyErr_SetString(PyExc_OSError, "cannot create bitmap");
@@ -850,7 +863,7 @@

     GdiFlush();

-    buffer = PyBytes_FromStringAndSize(ptr, height * ((width*3 + 3) & -4));
+    buffer = PyBytes_FromStringAndSize(ptr, height * ((width * 3 + 3) & -4));

 error:
     DeleteEnhMetaFile(meta);
@@ -875,18 +888,17 @@
 /* -------------------------------------------------------------------- */
 /* X11 screen grabber */

-PyObject*
-PyImaging_GrabScreenX11(PyObject* self, PyObject* args)
-{
+PyObject *
+PyImaging_GrabScreenX11(PyObject *self, PyObject *args) {
     int width, height;
-    char* display_name;
-    xcb_connection_t* connection;
+    char *display_name;
+    xcb_connection_t *connection;
     int screen_number;
     xcb_screen_iterator_t iter;
-    xcb_screen_t* screen = NULL;
-    xcb_get_image_reply_t* reply;
-    xcb_generic_error_t* error;
-    PyObject* buffer = NULL;
+    xcb_screen_t *screen = NULL;
+    xcb_get_image_reply_t *reply;
+    xcb_generic_error_t *error;
+    PyObject *buffer = NULL;

     if (!PyArg_ParseTuple(args, "|z", &display_name)) {
         return NULL;
@@ -896,7 +908,10 @@

     connection = xcb_connect(display_name, &screen_number);
     if (xcb_connection_has_error(connection)) {
-        PyErr_Format(PyExc_OSError, "X connection failed: error %i", xcb_connection_has_error(connection));
+        PyErr_Format(
+            PyExc_OSError,
+            "X connection failed: error %i",
+            xcb_connection_has_error(connection));
         xcb_disconnect(connection);
         return NULL;
     }
@@ -920,13 +935,26 @@

     /* get image data */

-    reply = xcb_get_image_reply(connection,
-                                xcb_get_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, screen->root,
-                                              0, 0, width, height, 0x00ffffff),
-                                &error);
+    reply = xcb_get_image_reply(
+        connection,
+        xcb_get_image(
+            connection,
+            XCB_IMAGE_FORMAT_Z_PIXMAP,
+            screen->root,
+            0,
+            0,
+            width,
+            height,
+            0x00ffffff),
+        &error);
     if (reply == NULL) {
-        PyErr_Format(PyExc_OSError, "X get_image failed: error %i (%i, %i, %i)",
-                     error->error_code, error->major_code, error->minor_code, error->resource_id);
+        PyErr_Format(
+            PyExc_OSError,
+            "X get_image failed: error %i (%i, %i, %i)",
+            error->error_code,
+            error->major_code,
+            error->minor_code,
+            error->resource_id);
         free(error);
         xcb_disconnect(connection);
         return NULL;
@@ -935,8 +963,8 @@
     /* store data in Python buffer */

     if (reply->depth == 24) {
-        buffer = PyBytes_FromStringAndSize((char*)xcb_get_image_data(reply),
-                                           xcb_get_image_data_length(reply));
+        buffer = PyBytes_FromStringAndSize(
+            (char *)xcb_get_image_data(reply), xcb_get_image_data_length(reply));
     } else {
         PyErr_Format(PyExc_OSError, "unsupported bit depth: %i", reply->depth);
     }
('src', '_imagingft.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -35,12 +35,8 @@

 #define KEEP_PY_UNICODE

-#ifndef _WIN32
-#include <dlfcn.h>
-#endif
-
 #if !defined(FT_LOAD_TARGET_MONO)
-#define FT_LOAD_TARGET_MONO  FT_LOAD_MONOCHROME
+#define FT_LOAD_TARGET_MONO FT_LOAD_MONOCHROME
 #endif

 /* -------------------------------------------------------------------- */
@@ -49,98 +45,62 @@
 #undef FTERRORS_H
 #undef __FTERRORS_H__

-#define FT_ERRORDEF( e, v, s )  { e, s },
-#define FT_ERROR_START_LIST  {
-#define FT_ERROR_END_LIST    { 0, 0 } };
-
-#include "libImaging/raqm.h"
+#define FT_ERRORDEF(e, v, s) {e, s},
+#define FT_ERROR_START_LIST {
+#define FT_ERROR_END_LIST \
+    { 0, 0 }              \
+    }                     \
+    ;
+
+#ifdef HAVE_RAQM
+# ifdef HAVE_RAQM_SYSTEM
+#  include <raqm.h>
+# else
+#  include "thirdparty/raqm/raqm.h"
+#  ifdef HAVE_FRIBIDI_SYSTEM
+#   include <fribidi.h>
+#  else
+#   include "thirdparty/fribidi-shim/fribidi.h"
+#   include <hb.h>
+#  endif
+# endif
+#endif
+
+static int have_raqm = 0;

 #define LAYOUT_FALLBACK 0
 #define LAYOUT_RAQM 1

-typedef struct
-{
-  int index, x_offset, x_advance, y_offset, y_advance;
-  unsigned int cluster;
+typedef struct {
+    int index, x_offset, x_advance, y_offset, y_advance;
+    unsigned int cluster;
 } GlyphInfo;

 struct {
     int code;
-    const char* message;
+    const char *message;
 } ft_errors[] =

 #include FT_ERRORS_H

-/* -------------------------------------------------------------------- */
-/* font objects */
-
-static FT_Library library;
+    /* -------------------------------------------------------------------- */
+    /* font objects */
+
+    static FT_Library library;

 typedef struct {
-    PyObject_HEAD
-    FT_Face face;
+    PyObject_HEAD FT_Face face;
     unsigned char *font_bytes;
     int layout_engine;
 } FontObject;

 static PyTypeObject Font_Type;

-typedef const char* (*t_raqm_version_string) (void);
-typedef bool (*t_raqm_version_atleast)(unsigned int major,
-                                       unsigned int minor,
-                                       unsigned int micro);
-typedef raqm_t* (*t_raqm_create)(void);
-typedef int (*t_raqm_set_text)(raqm_t         *rq,
-                               const uint32_t *text,
-                               size_t          len);
-typedef bool (*t_raqm_set_text_utf8) (raqm_t     *rq,
-                                      const char *text,
-                                      size_t      len);
-typedef bool (*t_raqm_set_par_direction) (raqm_t          *rq,
-                                          raqm_direction_t dir);
-typedef bool (*t_raqm_set_language) (raqm_t     *rq,
-                                     const char *lang,
-                                     size_t      start,
-                                     size_t      len);
-typedef bool (*t_raqm_add_font_feature)  (raqm_t     *rq,
-                                          const char *feature,
-                                          int         len);
-typedef bool (*t_raqm_set_freetype_face) (raqm_t *rq,
-                                          FT_Face face);
-typedef bool (*t_raqm_layout) (raqm_t *rq);
-typedef raqm_glyph_t* (*t_raqm_get_glyphs) (raqm_t *rq,
-                                            size_t *length);
-typedef raqm_glyph_t_01* (*t_raqm_get_glyphs_01) (raqm_t *rq,
-                                            size_t *length);
-typedef void (*t_raqm_destroy) (raqm_t *rq);
-
-typedef struct {
-    void* raqm;
-    int version;
-    t_raqm_version_string version_string;
-    t_raqm_version_atleast version_atleast;
-    t_raqm_create create;
-    t_raqm_set_text set_text;
-    t_raqm_set_text_utf8 set_text_utf8;
-    t_raqm_set_par_direction set_par_direction;
-    t_raqm_set_language set_language;
-    t_raqm_add_font_feature add_font_feature;
-    t_raqm_set_freetype_face set_freetype_face;
-    t_raqm_layout layout;
-    t_raqm_get_glyphs get_glyphs;
-    t_raqm_get_glyphs_01 get_glyphs_01;
-    t_raqm_destroy destroy;
-} p_raqm_func;
-
-static p_raqm_func p_raqm;
-
-
 /* round a 26.6 pixel coordinate to the nearest integer */
-#define PIXEL(x) ((((x)+32) & -64)>>6)
-
-static PyObject*
-geterror(int code)
-{
+#define PIXEL(x) ((((x) + 32) & -64) >> 6)
+
+static PyObject *
+geterror(int code) {
     int i;

     for (i = 0; ft_errors[i].message; i++) {
@@ -154,134 +114,41 @@
     return NULL;
 }

-static int
-setraqm(void)
-{
-    /* set the static function pointers for dynamic raqm linking */
-    p_raqm.raqm = NULL;
-
-    /* Microsoft needs a totally different system */
-#ifndef _WIN32
-    p_raqm.raqm = dlopen("libraqm.so.0", RTLD_LAZY);
-    if (!p_raqm.raqm) {
-        p_raqm.raqm = dlopen("libraqm.dylib", RTLD_LAZY);
-    }
-#else
-    p_raqm.raqm = LoadLibrary("libraqm");
-    /* MSYS */
-    if (!p_raqm.raqm) {
-        p_raqm.raqm = LoadLibrary("libraqm-0");
-    }
-#endif
-
-    if (!p_raqm.raqm) {
-        return 1;
-    }
-
-#ifndef _WIN32
-    p_raqm.version_string = (t_raqm_version_string)dlsym(p_raqm.raqm, "raqm_version_string");
-    p_raqm.version_atleast = (t_raqm_version_atleast)dlsym(p_raqm.raqm, "raqm_version_atleast");
-    p_raqm.create = (t_raqm_create)dlsym(p_raqm.raqm, "raqm_create");
-    p_raqm.set_text = (t_raqm_set_text)dlsym(p_raqm.raqm, "raqm_set_text");
-    p_raqm.set_text_utf8 = (t_raqm_set_text_utf8)dlsym(p_raqm.raqm, "raqm_set_text_utf8");
-    p_raqm.set_par_direction = (t_raqm_set_par_direction)dlsym(p_raqm.raqm, "raqm_set_par_direction");
-    p_raqm.set_language = (t_raqm_set_language)dlsym(p_raqm.raqm, "raqm_set_language");
-    p_raqm.add_font_feature = (t_raqm_add_font_feature)dlsym(p_raqm.raqm, "raqm_add_font_feature");
-    p_raqm.set_freetype_face = (t_raqm_set_freetype_face)dlsym(p_raqm.raqm, "raqm_set_freetype_face");
-    p_raqm.layout = (t_raqm_layout)dlsym(p_raqm.raqm, "raqm_layout");
-    p_raqm.destroy = (t_raqm_destroy)dlsym(p_raqm.raqm, "raqm_destroy");
-    if(dlsym(p_raqm.raqm, "raqm_index_to_position")) {
-        p_raqm.get_glyphs = (t_raqm_get_glyphs)dlsym(p_raqm.raqm, "raqm_get_glyphs");
-        p_raqm.version = 2;
-    } else {
-        p_raqm.version = 1;
-        p_raqm.get_glyphs_01 = (t_raqm_get_glyphs_01)dlsym(p_raqm.raqm, "raqm_get_glyphs");
-    }
-    if (dlerror() ||
-        !(p_raqm.create &&
-          p_raqm.set_text &&
-          p_raqm.set_text_utf8 &&
-          p_raqm.set_par_direction &&
-          p_raqm.set_language &&
-          p_raqm.add_font_feature &&
-          p_raqm.set_freetype_face &&
-          p_raqm.layout &&
-          (p_raqm.get_glyphs || p_raqm.get_glyphs_01) &&
-          p_raqm.destroy)) {
-        dlclose(p_raqm.raqm);
-        p_raqm.raqm = NULL;
-        return 2;
-    }
-#else
-    p_raqm.version_string = (t_raqm_version_string)GetProcAddress(p_raqm.raqm, "raqm_version_string");
-    p_raqm.version_atleast = (t_raqm_version_atleast)GetProcAddress(p_raqm.raqm, "raqm_version_atleast");
-    p_raqm.create = (t_raqm_create)GetProcAddress(p_raqm.raqm, "raqm_create");
-    p_raqm.set_text = (t_raqm_set_text)GetProcAddress(p_raqm.raqm, "raqm_set_text");
-    p_raqm.set_text_utf8 = (t_raqm_set_text_utf8)GetProcAddress(p_raqm.raqm, "raqm_set_text_utf8");
-    p_raqm.set_par_direction = (t_raqm_set_par_direction)GetProcAddress(p_raqm.raqm, "raqm_set_par_direction");
-    p_raqm.set_language = (t_raqm_set_language)GetProcAddress(p_raqm.raqm, "raqm_set_language");
-    p_raqm.add_font_feature = (t_raqm_add_font_feature)GetProcAddress(p_raqm.raqm, "raqm_add_font_feature");
-    p_raqm.set_freetype_face = (t_raqm_set_freetype_face)GetProcAddress(p_raqm.raqm, "raqm_set_freetype_face");
-    p_raqm.layout = (t_raqm_layout)GetProcAddress(p_raqm.raqm, "raqm_layout");
-    p_raqm.destroy = (t_raqm_destroy)GetProcAddress(p_raqm.raqm, "raqm_destroy");
-    if(GetProcAddress(p_raqm.raqm, "raqm_index_to_position")) {
-        p_raqm.get_glyphs = (t_raqm_get_glyphs)GetProcAddress(p_raqm.raqm, "raqm_get_glyphs");
-        p_raqm.version = 2;
-    } else {
-        p_raqm.version = 1;
-        p_raqm.get_glyphs_01 = (t_raqm_get_glyphs_01)GetProcAddress(p_raqm.raqm, "raqm_get_glyphs");
-    }
-    if (!(p_raqm.create &&
-          p_raqm.set_text &&
-          p_raqm.set_text_utf8 &&
-          p_raqm.set_par_direction &&
-          p_raqm.set_language &&
-          p_raqm.add_font_feature &&
-          p_raqm.set_freetype_face &&
-          p_raqm.layout &&
-          (p_raqm.get_glyphs || p_raqm.get_glyphs_01) &&
-          p_raqm.destroy)) {
-        FreeLibrary(p_raqm.raqm);
-        p_raqm.raqm = NULL;
-        return 2;
-    }
-#endif
-
-    return 0;
-}
-
-static PyObject*
-getfont(PyObject* self_, PyObject* args, PyObject* kw)
-{
+static PyObject *
+getfont(PyObject *self_, PyObject *args, PyObject *kw) {
     /* create a font object from a file name and a size (in pixels) */

-    FontObject* self;
+    FontObject *self;
     int error = 0;

-    char* filename = NULL;
+    char *filename = NULL;
     Py_ssize_t size;
     Py_ssize_t index = 0;
     Py_ssize_t layout_engine = 0;
-    unsigned char* encoding;
-    unsigned char* font_bytes;
+    unsigned char *encoding;
+    unsigned char *font_bytes;
     Py_ssize_t font_bytes_size = 0;
-    static char* kwlist[] = {
-        "filename", "size", "index", "encoding", "font_bytes",
-        "layout_engine", NULL
-    };
+    static char *kwlist[] = {
+        "filename", "size", "index", "encoding", "font_bytes", "layout_engine", NULL};

     if (!library) {
-        PyErr_SetString(
-            PyExc_OSError,
-            "failed to initialize FreeType library"
-            );
+        PyErr_SetString(PyExc_OSError, "failed to initialize FreeType library");
         return NULL;
     }

-    if (!PyArg_ParseTupleAndKeywords(args, kw, "etn|nsy#n", kwlist,
-                                     Py_FileSystemDefaultEncoding, &filename,
-                                     &size, &index, &encoding, &font_bytes,
-                                     &font_bytes_size, &layout_engine)) {
+    if (!PyArg_ParseTupleAndKeywords(
+            args,
+            kw,
+            "etn|nsy#n",
+            kwlist,
+            Py_FileSystemDefaultEncoding,
+            &filename,
+            &size,
+            &index,
+            &encoding,
+            &font_bytes,
+            &font_bytes_size,
+            &layout_engine)) {
         return NULL;
     }

@@ -304,12 +171,16 @@
         /* Don't free this before FT_Done_Face */
         self->font_bytes = PyMem_Malloc(font_bytes_size);
         if (!self->font_bytes) {
-            error = 65; // Out of Memory in Freetype.
+            error = 65;  // Out of Memory in Freetype.
         }
         if (!error) {
             memcpy(self->font_bytes, font_bytes, (size_t)font_bytes_size);
-            error = FT_New_Memory_Face(library, (FT_Byte*)self->font_bytes,
-                                       font_bytes_size, index, &self->face);
+            error = FT_New_Memory_Face(
+                library,
+                (FT_Byte *)self->font_bytes,
+                font_bytes_size,
+                index,
+                &self->face);
         }
     }

@@ -317,14 +188,13 @@
         error = FT_Set_Pixel_Sizes(self->face, 0, size);
     }

-    if (!error && encoding && strlen((char*) encoding) == 4) {
-        FT_Encoding encoding_tag = FT_MAKE_TAG(
-            encoding[0], encoding[1], encoding[2], encoding[3]
-            );
+    if (!error && encoding && strlen((char *)encoding) == 4) {
+        FT_Encoding encoding_tag =
+            FT_MAKE_TAG(encoding[0], encoding[1], encoding[2], encoding[3]);
         error = FT_Select_Charmap(self->face, encoding_tag);
     }
     if (filename) {
-      PyMem_Free(filename);
+        PyMem_Free(filename);
     }

     if (error) {
@@ -336,12 +206,11 @@
         return geterror(error);
     }

-    return (PyObject*) self;
+    return (PyObject *)self;
 }

 static int
-font_getchar(PyObject* string, int index, FT_ULong* char_out)
-{
+font_getchar(PyObject *string, int index, FT_ULong *char_out) {
     if (PyUnicode_Check(string)) {
         if (index >= PyUnicode_GET_LENGTH(string)) {
             return 0;
@@ -352,17 +221,24 @@
     return 0;
 }

+#ifdef HAVE_RAQM
+
 static size_t
-text_layout_raqm(PyObject* string, FontObject* self, const char* dir, PyObject *features,
-                 const char* lang, GlyphInfo **glyph_info, int mask, int color)
-{
+text_layout_raqm(
+    PyObject *string,
+    FontObject *self,
+    const char *dir,
+    PyObject *features,
+    const char *lang,
+    GlyphInfo **glyph_info,
+    int mask,
+    int color) {
     size_t i = 0, count = 0, start = 0;
     raqm_t *rq;
     raqm_glyph_t *glyphs = NULL;
-    raqm_glyph_t_01 *glyphs_01 = NULL;
     raqm_direction_t direction;

-    rq = (*p_raqm.create)();
+    rq = raqm_create();
     if (rq == NULL) {
         PyErr_SetString(PyExc_ValueError, "raqm_create() failed.");
         goto failed;
@@ -376,20 +252,19 @@
                and raqm fails with empty strings */
             goto failed;
         }
-        int set_text = (*p_raqm.set_text)(rq, text, size);
+        int set_text = raqm_set_text(rq, text, size);
         PyMem_Free(text);
         if (!set_text) {
             PyErr_SetString(PyExc_ValueError, "raqm_set_text() failed");
             goto failed;
         }
         if (lang) {
-            if (!(*p_raqm.set_language)(rq, lang, start, size)) {
+            if (!raqm_set_language(rq, lang, start, size)) {
                 PyErr_SetString(PyExc_ValueError, "raqm_set_language() failed");
                 goto failed;
             }
         }
-    }
-    else {
+    } else {
         PyErr_SetString(PyExc_TypeError, "expected string");
         goto failed;
     }
@@ -402,17 +277,21 @@
             direction = RAQM_DIRECTION_LTR;
         } else if (strcmp(dir, "ttb") == 0) {
             direction = RAQM_DIRECTION_TTB;
-            if (p_raqm.version_atleast == NULL || !(*p_raqm.version_atleast)(0, 7, 0)) {
-                PyErr_SetString(PyExc_ValueError, "libraqm 0.7 or greater required for 'ttb' direction");
-                goto failed;
-            }
+#if !defined(RAQM_VERSION_ATLEAST)
+            /* RAQM_VERSION_ATLEAST was added in Raqm 0.7.0 */
+            PyErr_SetString(
+                PyExc_ValueError,
+                "libraqm 0.7 or greater required for 'ttb' direction");
+            goto failed;
+#endif
         } else {
-            PyErr_SetString(PyExc_ValueError, "direction must be either 'rtl', 'ltr' or 'ttb'");
+            PyErr_SetString(
+                PyExc_ValueError, "direction must be either 'rtl', 'ltr' or 'ttb'");
             goto failed;
         }
     }

-    if (!(*p_raqm.set_par_direction)(rq, direction)) {
+    if (!raqm_set_par_direction(rq, direction)) {
         PyErr_SetString(PyExc_ValueError, "raqm_set_par_direction() failed");
         goto failed;
     }
@@ -444,37 +323,28 @@
                 feature = PyBytes_AS_STRING(bytes);
                 size = PyBytes_GET_SIZE(bytes);
             }
-            if (!(*p_raqm.add_font_feature)(rq, feature, size)) {
+            if (!raqm_add_font_feature(rq, feature, size)) {
                 PyErr_SetString(PyExc_ValueError, "raqm_add_font_feature() failed");
                 goto failed;
             }
         }
     }

-    if (!(*p_raqm.set_freetype_face)(rq, self->face)) {
+    if (!raqm_set_freetype_face(rq, self->face)) {
         PyErr_SetString(PyExc_RuntimeError, "raqm_set_freetype_face() failed.");
         goto failed;
     }

-    if (!(*p_raqm.layout)(rq)) {
+    if (!raqm_layout(rq)) {
         PyErr_SetString(PyExc_RuntimeError, "raqm_layout() failed.");
         goto failed;
     }

-    if (p_raqm.version == 1) {
-        glyphs_01 = (*p_raqm.get_glyphs_01)(rq, &count);
-        if (glyphs_01 == NULL) {
-            PyErr_SetString(PyExc_ValueError, "raqm_get_glyphs() failed.");
-            count = 0;
-            goto failed;
-        }
-    } else { /* version == 2 */
-        glyphs = (*p_raqm.get_glyphs)(rq, &count);
-        if (glyphs == NULL) {
-            PyErr_SetString(PyExc_ValueError, "raqm_get_glyphs() failed.");
-            count = 0;
-            goto failed;
-        }
+    glyphs = raqm_get_glyphs(rq, &count);
+    if (glyphs == NULL) {
+        PyErr_SetString(PyExc_ValueError, "raqm_get_glyphs() failed.");
+        count = 0;
+        goto failed;
     }

     (*glyph_info) = PyMem_New(GlyphInfo, count);
@@ -484,35 +354,32 @@
         goto failed;
     }

-    if (p_raqm.version == 1) {
-        for (i = 0; i < count; i++) {
-            (*glyph_info)[i].index = glyphs_01[i].index;
-            (*glyph_info)[i].x_offset = glyphs_01[i].x_offset;
-            (*glyph_info)[i].x_advance = glyphs_01[i].x_advance;
-            (*glyph_info)[i].y_offset = glyphs_01[i].y_offset;
-            (*glyph_info)[i].y_advance = glyphs_01[i].y_advance;
-            (*glyph_info)[i].cluster = glyphs_01[i].cluster;
-        }
-    } else {
-        for (i = 0; i < count; i++) {
-            (*glyph_info)[i].index = glyphs[i].index;
-            (*glyph_info)[i].x_offset = glyphs[i].x_offset;
-            (*glyph_info)[i].x_advance = glyphs[i].x_advance;
-            (*glyph_info)[i].y_offset = glyphs[i].y_offset;
-            (*glyph_info)[i].y_advance = glyphs[i].y_advance;
-            (*glyph_info)[i].cluster = glyphs[i].cluster;
-        }
+    for (i = 0; i < count; i++) {
+        (*glyph_info)[i].index = glyphs[i].index;
+        (*glyph_info)[i].x_offset = glyphs[i].x_offset;
+        (*glyph_info)[i].x_advance = glyphs[i].x_advance;
+        (*glyph_info)[i].y_offset = glyphs[i].y_offset;
+        (*glyph_info)[i].y_advance = glyphs[i].y_advance;
+        (*glyph_info)[i].cluster = glyphs[i].cluster;
     }

 failed:
-    (*p_raqm.destroy)(rq);
+    raqm_destroy(rq);
     return count;
 }

+#endif
+
 static size_t
-text_layout_fallback(PyObject* string, FontObject* self, const char* dir, PyObject *features,
-                     const char* lang, GlyphInfo **glyph_info, int mask, int color)
-{
+text_layout_fallback(
+    PyObject *string,
+    FontObject *self,
+    const char *dir,
+    PyObject *features,
+    const char *lang,
+    GlyphInfo **glyph_info,
+    int mask,
+    int color) {
     int error, load_flags;
     FT_ULong ch;
     Py_ssize_t count;
@@ -522,7 +389,10 @@
     int i;

     if (features != Py_None || dir != NULL || lang != NULL) {
-      PyErr_SetString(PyExc_KeyError, "setting text direction, language or font features is not supported without libraqm");
+        PyErr_SetString(
+            PyExc_KeyError,
+            "setting text direction, language or font features is not supported "
+            "without libraqm");
     }
     if (!PyUnicode_Check(string)) {
         PyErr_SetString(PyExc_TypeError, "expected string");
@@ -531,7 +401,7 @@

     count = 0;
     while (font_getchar(string, count, &ch)) {
-       count++;
+        count++;
     }
     if (count == 0) {
         return 0;
@@ -560,14 +430,18 @@
             return 0;
         }
         glyph = self->face->glyph;
-        (*glyph_info)[i].x_offset=0;
-        (*glyph_info)[i].y_offset=0;
+        (*glyph_info)[i].x_offset = 0;
+        (*glyph_info)[i].y_offset = 0;
         if (kerning && last_index && (*glyph_info)[i].index) {
             FT_Vector delta;
-            if (FT_Get_Kerning(self->face, last_index, (*glyph_info)[i].index,
-                           ft_kerning_default,&delta) == 0) {
-                (*glyph_info)[i-1].x_advance += PIXEL(delta.x);
-                (*glyph_info)[i-1].y_advance += PIXEL(delta.y);
+            if (FT_Get_Kerning(
+                    self->face,
+                    last_index,
+                    (*glyph_info)[i].index,
+                    ft_kerning_default,
+                    &delta) == 0) {
+                (*glyph_info)[i - 1].x_advance += PIXEL(delta.x);
+                (*glyph_info)[i - 1].y_advance += PIXEL(delta.y);
             }
         }

@@ -581,28 +455,37 @@
 }

 static size_t
-text_layout(PyObject* string, FontObject* self, const char* dir, PyObject *features,
-            const char* lang, GlyphInfo **glyph_info, int mask, int color)
-{
+text_layout(
+    PyObject *string,
+    FontObject *self,
+    const char *dir,
+    PyObject *features,
+    const char *lang,
+    GlyphInfo **glyph_info,
+    int mask,
+    int color) {
     size_t count;
-
-    if (p_raqm.raqm && self->layout_engine == LAYOUT_RAQM) {
-        count = text_layout_raqm(string, self, dir, features, lang, glyph_info,  mask, color);
-    } else {
-        count = text_layout_fallback(string, self, dir, features, lang, glyph_info, mask, color);
+#ifdef HAVE_RAQM
+    if (have_raqm && self->layout_engine == LAYOUT_RAQM) {
+        count = text_layout_raqm(
+            string, self, dir, features, lang, glyph_info,  mask, color);
+    } else
+#endif
+    {
+        count = text_layout_fallback(
+            string, self, dir, features, lang, glyph_info, mask, color);
     }
     return count;
 }

-static PyObject*
-font_getlength(FontObject* self, PyObject* args)
-{
-    int length; /* length along primary axis, in 26.6 precision */
+static PyObject *
+font_getlength(FontObject *self, PyObject *args) {
+    int length;                   /* length along primary axis, in 26.6 precision */
     GlyphInfo *glyph_info = NULL; /* computed text layout */
-    size_t i, count; /* glyph_info index and length */
-    int horizontal_dir; /* is primary axis horizontal? */
-    int mask = 0; /* is FT_LOAD_TARGET_MONO enabled? */
-    int color = 0; /* is FT_LOAD_COLOR enabled? */
+    size_t i, count;              /* glyph_info index and length */
+    int horizontal_dir;           /* is primary axis horizontal? */
+    int mask = 0;                 /* is FT_LOAD_TARGET_MONO enabled? */
+    int color = 0;                /* is FT_LOAD_COLOR enabled? */
     const char *mode = NULL;
     const char *dir = NULL;
     const char *lang = NULL;
@@ -611,7 +494,8 @@

     /* calculate size and bearing for a given string */

-    if (!PyArg_ParseTuple(args, "O|zzOz:getlength", &string, &mode, &dir, &features, &lang)) {
+    if (!PyArg_ParseTuple(
+            args, "O|zzOz:getlength", &string, &mode, &dir, &features, &lang)) {
         return NULL;
     }

@@ -642,24 +526,23 @@
     return PyLong_FromLong(length);
 }

-static PyObject*
-font_getsize(FontObject* self, PyObject* args)
-{
+static PyObject *
+font_getsize(FontObject *self, PyObject *args) {
     int position; /* pen position along primary axis, in 26.6 precision */
     int advanced; /* pen position along primary axis, in pixels */
-    int px, py; /* position of current glyph, in pixels */
+    int px, py;   /* position of current glyph, in pixels */
     int x_min, x_max, y_min, y_max; /* text bounding box, in pixels */
-    int x_anchor, y_anchor; /* offset of point drawn at (0, 0), in pixels */
-    int load_flags; /* FreeType load_flags parameter */
+    int x_anchor, y_anchor;         /* offset of point drawn at (0, 0), in pixels */
+    int load_flags;                 /* FreeType load_flags parameter */
     int error;
     FT_Face face;
     FT_Glyph glyph;
-    FT_BBox bbox; /* glyph bounding box */
+    FT_BBox bbox;                 /* glyph bounding box */
     GlyphInfo *glyph_info = NULL; /* computed text layout */
-    size_t i, count; /* glyph_info index and length */
-    int horizontal_dir; /* is primary axis horizontal? */
-    int mask = 0; /* is FT_LOAD_TARGET_MONO enabled? */
-    int color = 0; /* is FT_LOAD_COLOR enabled? */
+    size_t i, count;              /* glyph_info index and length */
+    int horizontal_dir;           /* is primary axis horizontal? */
+    int mask = 0;                 /* is FT_LOAD_TARGET_MONO enabled? */
+    int color = 0;                /* is FT_LOAD_COLOR enabled? */
     const char *mode = NULL;
     const char *dir = NULL;
     const char *lang = NULL;
@@ -669,7 +552,8 @@

     /* calculate size and bearing for a given string */

-    if (!PyArg_ParseTuple(args, "O|zzOzz:getsize", &string, &mode, &dir, &features, &lang, &anchor)) {
+    if (!PyArg_ParseTuple(
+            args, "O|zzOzz:getsize", &string, &mode, &dir, &features, &lang, &anchor)) {
         return NULL;
     }

@@ -771,95 +655,98 @@
     if (face) {
         if (horizontal_dir) {
             switch (anchor[0]) {
-            case 'l':  // left
-                x_anchor = 0;
-                break;
-            case 'm':  // middle (left + right) / 2
-                x_anchor = PIXEL(position / 2);
-                break;
-            case 'r':  // right
-                x_anchor = PIXEL(position);
-                break;
-            case 's':  // vertical baseline
-            default:
-                goto bad_anchor;
+                case 'l':  // left
+                    x_anchor = 0;
+                    break;
+                case 'm':  // middle (left + right) / 2
+                    x_anchor = PIXEL(position / 2);
+                    break;
+                case 'r':  // right
+                    x_anchor = PIXEL(position);
+                    break;
+                case 's':  // vertical baseline
+                default:
+                    goto bad_anchor;
             }
             switch (anchor[1]) {
-            case 'a':  // ascender
-                y_anchor = PIXEL(self->face->size->metrics.ascender);
-                break;
-            case 't':  // top
-                y_anchor = y_max;
-                break;
-            case 'm':  // middle (ascender + descender) / 2
-                y_anchor = PIXEL((self->face->size->metrics.ascender + self->face->size->metrics.descender) / 2);
-                break;
-            case 's':  // horizontal baseline
-                y_anchor = 0;
-                break;
-            case 'b':  // bottom
-                y_anchor = y_min;
-                break;
-            case 'd':  // descender
-                y_anchor = PIXEL(self->face->size->metrics.descender);
-                break;
-            default:
-                goto bad_anchor;
+                case 'a':  // ascender
+                    y_anchor = PIXEL(self->face->size->metrics.ascender);
+                    break;
+                case 't':  // top
+                    y_anchor = y_max;
+                    break;
+                case 'm':  // middle (ascender + descender) / 2
+                    y_anchor = PIXEL(
+                        (self->face->size->metrics.ascender +
+                         self->face->size->metrics.descender) /
+                        2);
+                    break;
+                case 's':  // horizontal baseline
+                    y_anchor = 0;
+                    break;
+                case 'b':  // bottom
+                    y_anchor = y_min;
+                    break;
+                case 'd':  // descender
+                    y_anchor = PIXEL(self->face->size->metrics.descender);
+                    break;
+                default:
+                    goto bad_anchor;
             }
         } else {
             switch (anchor[0]) {
-            case 'l':  // left
-                x_anchor = x_min;
-                break;
-            case 'm':  // middle (left + right) / 2
-                x_anchor = (x_min + x_max) / 2;
-                break;
-            case 'r':  // right
-                x_anchor = x_max;
-                break;
-            case 's':  // vertical baseline
-                x_anchor = 0;
-                break;
-            default:
-                goto bad_anchor;
+                case 'l':  // left
+                    x_anchor = x_min;
+                    break;
+                case 'm':  // middle (left + right) / 2
+                    x_anchor = (x_min + x_max) / 2;
+                    break;
+                case 'r':  // right
+                    x_anchor = x_max;
+                    break;
+                case 's':  // vertical baseline
+                    x_anchor = 0;
+                    break;
+                default:
+                    goto bad_anchor;
             }
             switch (anchor[1]) {
-            case 't':  // top
-                y_anchor = 0;
-                break;
-            case 'm':  // middle (top + bottom) / 2
-                y_anchor = PIXEL(position / 2);
-                break;
-            case 'b':  // bottom
-                y_anchor = PIXEL(position);
-                break;
-            case 'a':  // ascender
-            case 's':  // horizontal baseline
-            case 'd':  // descender
-            default:
-                goto bad_anchor;
+                case 't':  // top
+                    y_anchor = 0;
+                    break;
+                case 'm':  // middle (top + bottom) / 2
+                    y_anchor = PIXEL(position / 2);
+                    break;
+                case 'b':  // bottom
+                    y_anchor = PIXEL(position);
+                    break;
+                case 'a':  // ascender
+                case 's':  // horizontal baseline
+                case 'd':  // descender
+                default:
+                    goto bad_anchor;
             }
         }
     }

     return Py_BuildValue(
         "(ii)(ii)",
-        (x_max - x_min), (y_max - y_min),
-        (-x_anchor + x_min), -(-y_anchor + y_max)
-    );
+        (x_max - x_min),
+        (y_max - y_min),
+        (-x_anchor + x_min),
+        -(-y_anchor + y_max));

 bad_anchor:
     PyErr_Format(PyExc_ValueError, "bad anchor specified: %s", anchor);
     return NULL;
 }

-static PyObject*
-font_render(FontObject* self, PyObject* args)
-{
-    int x, y; /* pen position, in 26.6 precision */
-    int px, py; /* position of current glyph, in pixels */
+static PyObject *
+font_render(FontObject *self, PyObject *args) {
+    int x, y;         /* pen position, in 26.6 precision */
+    int px, py;       /* position of current glyph, in pixels */
     int x_min, y_max; /* text offset in 26.6 precision */
-    int load_flags; /* FreeType load_flags parameter */
+    int load_flags;   /* FreeType load_flags parameter */
     int error;
     FT_Glyph glyph;
     FT_GlyphSlot glyph_slot;
@@ -868,16 +755,16 @@
     FT_BitmapGlyph bitmap_glyph;
     FT_Stroker stroker = NULL;
     int bitmap_converted_ready = 0; /* has bitmap_converted been initialized */
-    GlyphInfo *glyph_info = NULL; /* computed text layout */
-    size_t i, count; /* glyph_info index and length */
-    int xx, yy; /* pixel offset of current glyph bitmap */
-    int x0, x1; /* horizontal bounds of glyph bitmap to copy */
-    unsigned int bitmap_y; /* glyph bitmap y index */
-    unsigned char *source; /* glyph bitmap source buffer */
-    unsigned char convert_scale; /* scale factor for non-8bpp bitmaps */
+    GlyphInfo *glyph_info = NULL;   /* computed text layout */
+    size_t i, count;                /* glyph_info index and length */
+    int xx, yy;                     /* pixel offset of current glyph bitmap */
+    int x0, x1;                     /* horizontal bounds of glyph bitmap to copy */
+    unsigned int bitmap_y;          /* glyph bitmap y index */
+    unsigned char *source;          /* glyph bitmap source buffer */
+    unsigned char convert_scale;    /* scale factor for non-8bpp bitmaps */
     Imaging im;
     Py_ssize_t id;
-    int mask = 0; /* is FT_LOAD_TARGET_MONO enabled? */
+    int mask = 0;  /* is FT_LOAD_TARGET_MONO enabled? */
     int color = 0; /* is FT_LOAD_COLOR enabled? */
     int stroke_width = 0;
     PY_LONG_LONG foreground_ink_long = 0;
@@ -886,13 +773,22 @@
     const char *dir = NULL;
     const char *lang = NULL;
     PyObject *features = Py_None;
-    PyObject* string;
+    PyObject *string;

     /* render string into given buffer (the buffer *must* have
        the right size, or this will crash) */

-    if (!PyArg_ParseTuple(args, "On|zzOziL:render", &string,  &id, &mode, &dir, &features, &lang,
-                                                   &stroke_width, &foreground_ink_long)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "On|zzOziL:render",
+            &string,
+            &id,
+            &mode,
+            &dir,
+            &features,
+            &lang,
+            &stroke_width,
+            &foreground_ink_long)) {
         return NULL;
     }

@@ -904,11 +800,12 @@
 #ifdef FT_COLOR_H
     if (color) {
         FT_Color foreground_color;
-        FT_Byte* ink = (FT_Byte*)&foreground_ink;
+        FT_Byte *ink = (FT_Byte *)&foreground_ink;
         foreground_color.red = ink[0];
         foreground_color.green = ink[1];
         foreground_color.blue = ink[2];
-        foreground_color.alpha = (FT_Byte) 255; /* ink alpha is handled in ImageDraw.text */
+        foreground_color.alpha =
+            (FT_Byte)255; /* ink alpha is handled in ImageDraw.text */
         FT_Palette_Set_Foreground_Color(self->face, foreground_color);
     }
 #endif
@@ -927,11 +824,16 @@
             return geterror(error);
         }

-        FT_Stroker_Set(stroker, (FT_Fixed)stroke_width*64, FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);
-    }
-
-    im = (Imaging) id;
-    load_flags = FT_LOAD_DEFAULT;
+        FT_Stroker_Set(
+            stroker,
+            (FT_Fixed)stroke_width * 64,
+            FT_STROKER_LINECAP_ROUND,
+            FT_STROKER_LINEJOIN_ROUND,
+            0);
+    }
+
+    im = (Imaging)id;
+    load_flags = stroke_width ? FT_LOAD_NO_BITMAP : FT_LOAD_DEFAULT;
     if (mask) {
         load_flags |= FT_LOAD_TARGET_MONO;
     }
@@ -950,7 +852,8 @@
         px = PIXEL(x + glyph_info[i].x_offset);
         py = PIXEL(y + glyph_info[i].y_offset);

-        error = FT_Load_Glyph(self->face, glyph_info[i].index, load_flags | FT_LOAD_RENDER);
+        error =
+            FT_Load_Glyph(self->face, glyph_info[i].index, load_flags | FT_LOAD_RENDER);
         if (error) {
             return geterror(error);
         }
@@ -1030,13 +933,7 @@
             case FT_PIXEL_MODE_GRAY2:
             case FT_PIXEL_MODE_GRAY4:
                 if (!bitmap_converted_ready) {
-
-#if FREETYPE_MAJOR > 2 ||\
-    (FREETYPE_MAJOR == 2 && FREETYPE_MINOR > 6)
                     FT_Bitmap_Init(&bitmap_converted);
-#else
-                    FT_Bitmap_New(&bitmap_converted);
-#endif
                     bitmap_converted_ready = 1;
                 }
                 error = FT_Bitmap_Convert(library, &bitmap, &bitmap_converted, 1);
@@ -1070,18 +967,18 @@
             x1 = im->xsize - xx;
         }

-        source = (unsigned char*) bitmap.buffer;
+        source = (unsigned char *)bitmap.buffer;
         for (bitmap_y = 0; bitmap_y < bitmap.rows; bitmap_y++, yy++) {
             /* clip glyph bitmap height to target image bounds */
             if (yy >= 0 && yy < im->ysize) {
                 /* blend this glyph into the buffer */
                 int k;
                 unsigned char v;
-                unsigned char* target;
+                unsigned char *target;
                 if (color) {
                     /* target[RGB] returns the color, target[A] returns the mask */
                     /* target bands get split again in ImageDraw.text */
-                    target = (unsigned char*)im->image[yy] + xx * 4;
+                    target = (unsigned char *)im->image[yy] + xx * 4;
                 } else {
                     target = im->image8[yy] + xx;
                 }
@@ -1091,17 +988,20 @@
                     for (k = x0; k < x1; k++) {
                         if (target[k * 4 + 3] < source[k * 4 + 3]) {
                             /* unpremultiply BGRa to RGBA */
-                            target[k * 4 + 0] = CLIP8((255 * (int)source[k * 4 + 2]) / source[k * 4 + 3]);
-                            target[k * 4 + 1] = CLIP8((255 * (int)source[k * 4 + 1]) / source[k * 4 + 3]);
-                            target[k * 4 + 2] = CLIP8((255 * (int)source[k * 4 + 0]) / source[k * 4 + 3]);
+                            target[k * 4 + 0] = CLIP8(
+                                (255 * (int)source[k * 4 + 2]) / source[k * 4 + 3]);
+                            target[k * 4 + 1] = CLIP8(
+                                (255 * (int)source[k * 4 + 1]) / source[k * 4 + 3]);
+                            target[k * 4 + 2] = CLIP8(
+                                (255 * (int)source[k * 4 + 0]) / source[k * 4 + 3]);
                             target[k * 4 + 3] = source[k * 4 + 3];
                         }
                     }
                 } else
 #endif
-                if (bitmap.pixel_mode == FT_PIXEL_MODE_GRAY) {
+                    if (bitmap.pixel_mode == FT_PIXEL_MODE_GRAY) {
                     if (color) {
-                        unsigned char* ink = (unsigned char*)&foreground_ink;
+                        unsigned char *ink = (unsigned char *)&foreground_ink;
                         for (k = x0; k < x1; k++) {
                             v = source[k] * convert_scale;
                             if (target[k * 4 + 3] < v) {
@@ -1152,173 +1052,166 @@
     return NULL;
 }

-#if FREETYPE_MAJOR > 2 ||\
-    (FREETYPE_MAJOR == 2 && FREETYPE_MINOR > 9) ||\
+#if FREETYPE_MAJOR > 2 || (FREETYPE_MAJOR == 2 && FREETYPE_MINOR > 9) || \
     (FREETYPE_MAJOR == 2 && FREETYPE_MINOR == 9 && FREETYPE_PATCH == 1)
-    static PyObject*
-    font_getvarnames(FontObject* self)
-    {
-        int error;
-        FT_UInt i, j, num_namedstyles, name_count;
-        FT_MM_Var *master;
-        FT_SfntName name;
-        PyObject *list_names, *list_name;
-
-        error = FT_Get_MM_Var(self->face, &master);
+static PyObject *
+font_getvarnames(FontObject *self) {
+    int error;
+    FT_UInt i, j, num_namedstyles, name_count;
+    FT_MM_Var *master;
+    FT_SfntName name;
+    PyObject *list_names, *list_name;
+
+    error = FT_Get_MM_Var(self->face, &master);
+    if (error) {
+        return geterror(error);
+    }
+
+    num_namedstyles = master->num_namedstyles;
+    list_names = PyList_New(num_namedstyles);
+
+    name_count = FT_Get_Sfnt_Name_Count(self->face);
+    for (i = 0; i < name_count; i++) {
+        error = FT_Get_Sfnt_Name(self->face, i, &name);
         if (error) {
             return geterror(error);
         }

-        num_namedstyles = master->num_namedstyles;
-        list_names = PyList_New(num_namedstyles);
-
-        name_count = FT_Get_Sfnt_Name_Count(self->face);
-        for (i = 0; i < name_count; i++) {
-            error = FT_Get_Sfnt_Name(self->face, i, &name);
+        for (j = 0; j < num_namedstyles; j++) {
+            if (PyList_GetItem(list_names, j) != NULL) {
+                continue;
+            }
+
+            if (master->namedstyle[j].strid == name.name_id) {
+                list_name = Py_BuildValue("y#", name.string, name.string_len);
+                PyList_SetItem(list_names, j, list_name);
+                break;
+            }
+        }
+    }
+
+    FT_Done_MM_Var(library, master);
+
+    return list_names;
+}
+
+static PyObject *
+font_getvaraxes(FontObject *self) {
+    int error;
+    FT_UInt i, j, num_axis, name_count;
+    FT_MM_Var *master;
+    FT_Var_Axis axis;
+    FT_SfntName name;
+    PyObject *list_axes, *list_axis, *axis_name;
+    error = FT_Get_MM_Var(self->face, &master);
+    if (error) {
+        return geterror(error);
+    }
+
+    num_axis = master->num_axis;
+    name_count = FT_Get_Sfnt_Name_Count(self->face);
+
+    list_axes = PyList_New(num_axis);
+    for (i = 0; i < num_axis; i++) {
+        axis = master->axis[i];
+
+        list_axis = PyDict_New();
+        PyDict_SetItemString(
+            list_axis, "minimum", PyLong_FromLong(axis.minimum / 65536));
+        PyDict_SetItemString(list_axis, "default", PyLong_FromLong(axis.def / 65536));
+        PyDict_SetItemString(
+            list_axis, "maximum", PyLong_FromLong(axis.maximum / 65536));
+
+        for (j = 0; j < name_count; j++) {
+            error = FT_Get_Sfnt_Name(self->face, j, &name);
             if (error) {
                 return geterror(error);
             }

-            for (j = 0; j < num_namedstyles; j++) {
-                if (PyList_GetItem(list_names, j) != NULL) {
-                    continue;
-                }
-
-                if (master->namedstyle[j].strid == name.name_id) {
-                    list_name = Py_BuildValue("y#", name.string, name.string_len);
-                    PyList_SetItem(list_names, j, list_name);
-                    break;
-                }
-            }
-        }
-
-        FT_Done_MM_Var(library, master);
-
-        return list_names;
-    }
-
-    static PyObject*
-    font_getvaraxes(FontObject* self)
-    {
-        int error;
-        FT_UInt i, j, num_axis, name_count;
-        FT_MM_Var* master;
-        FT_Var_Axis axis;
-        FT_SfntName name;
-        PyObject *list_axes, *list_axis, *axis_name;
-        error = FT_Get_MM_Var(self->face, &master);
-        if (error) {
-            return geterror(error);
-        }
-
-        num_axis = master->num_axis;
-        name_count = FT_Get_Sfnt_Name_Count(self->face);
-
-        list_axes = PyList_New(num_axis);
-        for (i = 0; i < num_axis; i++) {
-            axis = master->axis[i];
-
-            list_axis = PyDict_New();
-            PyDict_SetItemString(list_axis, "minimum",
-                                 PyLong_FromLong(axis.minimum / 65536));
-            PyDict_SetItemString(list_axis, "default",
-                                 PyLong_FromLong(axis.def / 65536));
-            PyDict_SetItemString(list_axis, "maximum",
-                                 PyLong_FromLong(axis.maximum / 65536));
-
-            for (j = 0; j < name_count; j++) {
-                error = FT_Get_Sfnt_Name(self->face, j, &name);
-                if (error) {
-                    return geterror(error);
-                }
-
-                if (name.name_id == axis.strid) {
-                    axis_name = Py_BuildValue("y#", name.string, name.string_len);
-                    PyDict_SetItemString(list_axis, "name", axis_name);
-                    break;
-                }
-            }
-
-            PyList_SetItem(list_axes, i, list_axis);
-        }
-
-        FT_Done_MM_Var(library, master);
-
-        return list_axes;
-    }
-
-    static PyObject*
-    font_setvarname(FontObject* self, PyObject* args)
-    {
-        int error;
-
-        int instance_index;
-        if (!PyArg_ParseTuple(args, "i", &instance_index)) {
+            if (name.name_id == axis.strid) {
+                axis_name = Py_BuildValue("y#", name.string, name.string_len);
+                PyDict_SetItemString(list_axis, "name", axis_name);
+                break;
+            }
+        }
+
+        PyList_SetItem(list_axes, i, list_axis);
+    }
+
+    FT_Done_MM_Var(library, master);
+
+    return list_axes;
+}
+
+static PyObject *
+font_setvarname(FontObject *self, PyObject *args) {
+    int error;
+
+    int instance_index;
+    if (!PyArg_ParseTuple(args, "i", &instance_index)) {
+        return NULL;
+    }
+
+    error = FT_Set_Named_Instance(self->face, instance_index);
+    if (error) {
+        return geterror(error);
+    }
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+static PyObject *
+font_setvaraxes(FontObject *self, PyObject *args) {
+    int error;
+
+    PyObject *axes, *item;
+    Py_ssize_t i, num_coords;
+    FT_Fixed *coords;
+    FT_Fixed coord;
+    if (!PyArg_ParseTuple(args, "O", &axes)) {
+        return NULL;
+    }
+
+    if (!PyList_Check(axes)) {
+        PyErr_SetString(PyExc_TypeError, "argument must be a list");
+        return NULL;
+    }
+
+    num_coords = PyObject_Length(axes);
+    coords = malloc(2 * sizeof(coords));
+    if (coords == NULL) {
+        return PyErr_NoMemory();
+    }
+    for (i = 0; i < num_coords; i++) {
+        item = PyList_GET_ITEM(axes, i);
+        if (PyFloat_Check(item)) {
+            coord = PyFloat_AS_DOUBLE(item);
+        } else if (PyLong_Check(item)) {
+            coord = (float)PyLong_AS_LONG(item);
+        } else if (PyNumber_Check(item)) {
+            coord = PyFloat_AsDouble(item);
+        } else {
+            free(coords);
+            PyErr_SetString(PyExc_TypeError, "list must contain numbers");
             return NULL;
         }
-
-        error = FT_Set_Named_Instance(self->face, instance_index);
-        if (error) {
-            return geterror(error);
-        }
-
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-
-    static PyObject*
-    font_setvaraxes(FontObject* self, PyObject* args)
-    {
-        int error;
-
-        PyObject *axes, *item;
-        Py_ssize_t i, num_coords;
-        FT_Fixed *coords;
-        FT_Fixed coord;
-        if (!PyArg_ParseTuple(args, "O", &axes)) {
-            return NULL;
-        }
-
-        if (!PyList_Check(axes)) {
-            PyErr_SetString(PyExc_TypeError, "argument must be a list");
-            return NULL;
-        }
-
-        num_coords = PyObject_Length(axes);
-        coords = malloc(2 * sizeof(coords));
-        if (coords == NULL) {
-            return PyErr_NoMemory();
-        }
-        for (i = 0; i < num_coords; i++) {
-            item = PyList_GET_ITEM(axes, i);
-            if (PyFloat_Check(item)) {
-                coord = PyFloat_AS_DOUBLE(item);
-            } else if (PyLong_Check(item)) {
-                coord = (float) PyLong_AS_LONG(item);
-            } else if (PyNumber_Check(item)) {
-                coord = PyFloat_AsDouble(item);
-            } else {
-                free(coords);
-                PyErr_SetString(PyExc_TypeError, "list must contain numbers");
-                return NULL;
-            }
-            coords[i] = coord * 65536;
-        }
-
-        error = FT_Set_Var_Design_Coordinates(self->face, num_coords, coords);
-        free(coords);
-        if (error) {
-            return geterror(error);
-        }
-
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
+        coords[i] = coord * 65536;
+    }
+
+    error = FT_Set_Var_Design_Coordinates(self->face, num_coords, coords);
+    free(coords);
+    if (error) {
+        return geterror(error);
+    }
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
 #endif

 static void
-font_dealloc(FontObject* self)
-{
+font_dealloc(FontObject *self) {
     if (self->face) {
         FT_Done_Face(self->face);
     }
@@ -1329,128 +1222,115 @@
 }

 static PyMethodDef font_methods[] = {
-    {"render", (PyCFunction) font_render, METH_VARARGS},
-    {"getsize", (PyCFunction) font_getsize, METH_VARARGS},
-    {"getlength", (PyCFunction) font_getlength, METH_VARARGS},
-#if FREETYPE_MAJOR > 2 ||\
-    (FREETYPE_MAJOR == 2 && FREETYPE_MINOR > 9) ||\
+    {"render", (PyCFunction)font_render, METH_VARARGS},
+    {"getsize", (PyCFunction)font_getsize, METH_VARARGS},
+    {"getlength", (PyCFunction)font_getlength, METH_VARARGS},
+#if FREETYPE_MAJOR > 2 || (FREETYPE_MAJOR == 2 && FREETYPE_MINOR > 9) || \
     (FREETYPE_MAJOR == 2 && FREETYPE_MINOR == 9 && FREETYPE_PATCH == 1)
-    {"getvarnames", (PyCFunction) font_getvarnames, METH_NOARGS },
-    {"getvaraxes", (PyCFunction) font_getvaraxes, METH_NOARGS },
-    {"setvarname", (PyCFunction) font_setvarname, METH_VARARGS},
-    {"setvaraxes", (PyCFunction) font_setvaraxes, METH_VARARGS},
-#endif
-    {NULL, NULL}
-};
-
-static PyObject*
-font_getattr_family(FontObject* self, void* closure)
-{
+    {"getvarnames", (PyCFunction)font_getvarnames, METH_NOARGS},
+    {"getvaraxes", (PyCFunction)font_getvaraxes, METH_NOARGS},
+    {"setvarname", (PyCFunction)font_setvarname, METH_VARARGS},
+    {"setvaraxes", (PyCFunction)font_setvaraxes, METH_VARARGS},
+#endif
+    {NULL, NULL}};
+
+static PyObject *
+font_getattr_family(FontObject *self, void *closure) {
     if (self->face->family_name) {
         return PyUnicode_FromString(self->face->family_name);
     }
     Py_RETURN_NONE;
 }

-static PyObject*
-font_getattr_style(FontObject* self, void* closure)
-{
+static PyObject *
+font_getattr_style(FontObject *self, void *closure) {
     if (self->face->style_name) {
         return PyUnicode_FromString(self->face->style_name);
     }
     Py_RETURN_NONE;
 }

-static PyObject*
-font_getattr_ascent(FontObject* self, void* closure)
-{
+static PyObject *
+font_getattr_ascent(FontObject *self, void *closure) {
     return PyLong_FromLong(PIXEL(self->face->size->metrics.ascender));
 }

-static PyObject*
-font_getattr_descent(FontObject* self, void* closure)
-{
+static PyObject *
+font_getattr_descent(FontObject *self, void *closure) {
     return PyLong_FromLong(-PIXEL(self->face->size->metrics.descender));
 }

-static PyObject*
-font_getattr_height(FontObject* self, void* closure)
-{
+static PyObject *
+font_getattr_height(FontObject *self, void *closure) {
     return PyLong_FromLong(PIXEL(self->face->size->metrics.height));
 }

-static PyObject*
-font_getattr_x_ppem(FontObject* self, void* closure)
-{
+static PyObject *
+font_getattr_x_ppem(FontObject *self, void *closure) {
     return PyLong_FromLong(self->face->size->metrics.x_ppem);
 }

-static PyObject*
-font_getattr_y_ppem(FontObject* self, void* closure)
-{
+static PyObject *
+font_getattr_y_ppem(FontObject *self, void *closure) {
     return PyLong_FromLong(self->face->size->metrics.y_ppem);
 }

-
-static PyObject*
-font_getattr_glyphs(FontObject* self, void* closure)
-{
+static PyObject *
+font_getattr_glyphs(FontObject *self, void *closure) {
     return PyLong_FromLong(self->face->num_glyphs);
 }

 static struct PyGetSetDef font_getsetters[] = {
-    { "family",     (getter) font_getattr_family },
-    { "style",      (getter) font_getattr_style },
-    { "ascent",     (getter) font_getattr_ascent },
-    { "descent",    (getter) font_getattr_descent },
-    { "height",     (getter) font_getattr_height },
-    { "x_ppem",     (getter) font_getattr_x_ppem },
-    { "y_ppem",     (getter) font_getattr_y_ppem },
-    { "glyphs",     (getter) font_getattr_glyphs },
-    { NULL }
-};
+    {"family", (getter)font_getattr_family},
+    {"style", (getter)font_getattr_style},
+    {"ascent", (getter)font_getattr_ascent},
+    {"descent", (getter)font_getattr_descent},
+    {"height", (getter)font_getattr_height},
+    {"x_ppem", (getter)font_getattr_x_ppem},
+    {"y_ppem", (getter)font_getattr_y_ppem},
+    {"glyphs", (getter)font_getattr_glyphs},
+    {NULL}};

 static PyTypeObject Font_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "Font", sizeof(FontObject), 0,
+    PyVarObject_HEAD_INIT(NULL, 0) "Font",
+    sizeof(FontObject),
+    0,
     /* methods */
     (destructor)font_dealloc, /* tp_dealloc */
-    0, /* tp_print */
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    font_methods,               /*tp_methods*/
-    0,                          /*tp_members*/
-    font_getsetters,            /*tp_getset*/
+    0,                        /* tp_print */
+    0,                        /*tp_getattr*/
+    0,                        /*tp_setattr*/
+    0,                        /*tp_compare*/
+    0,                        /*tp_repr*/
+    0,                        /*tp_as_number */
+    0,                        /*tp_as_sequence */
+    0,                        /*tp_as_mapping */
+    0,                        /*tp_hash*/
+    0,                        /*tp_call*/
+    0,                        /*tp_str*/
+    0,                        /*tp_getattro*/
+    0,                        /*tp_setattro*/
+    0,                        /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,       /*tp_flags*/
+    0,                        /*tp_doc*/
+    0,                        /*tp_traverse*/
+    0,                        /*tp_clear*/
+    0,                        /*tp_richcompare*/
+    0,                        /*tp_weaklistoffset*/
+    0,                        /*tp_iter*/
+    0,                        /*tp_iternext*/
+    font_methods,             /*tp_methods*/
+    0,                        /*tp_members*/
+    font_getsetters,          /*tp_getset*/
 };

 static PyMethodDef _functions[] = {
-    {"getfont", (PyCFunction) getfont, METH_VARARGS|METH_KEYWORDS},
-    {NULL, NULL}
-};
+    {"getfont", (PyCFunction)getfont, METH_VARARGS | METH_KEYWORDS}, {NULL, NULL}};

 static int
-setup_module(PyObject* m) {
-    PyObject* d;
-    PyObject* v;
+setup_module(PyObject *m) {
+    PyObject *d;
+    PyObject *v;
     int major, minor, patch;

     d = PyModule_GetDict(m);
@@ -1467,12 +1347,51 @@
     v = PyUnicode_FromFormat("%d.%d.%d", major, minor, patch);
     PyDict_SetItemString(d, "freetype2_version", v);

-
-    setraqm();
-    v = PyBool_FromLong(!!p_raqm.raqm);
+#ifdef HAVE_RAQM
+#if defined(HAVE_RAQM_SYSTEM) || defined(HAVE_FRIBIDI_SYSTEM)
+    have_raqm = 1;
+#else
+    load_fribidi();
+    have_raqm = !!p_fribidi;
+#endif
+#else
+    have_raqm = 0;
+#endif
+
+    /* if we have Raqm, we have all three (but possibly no version info) */
+    v = PyBool_FromLong(have_raqm);
     PyDict_SetItemString(d, "HAVE_RAQM", v);
-    if (p_raqm.version_string) {
-        PyDict_SetItemString(d, "raqm_version", PyUnicode_FromString(p_raqm.version_string()));
+    PyDict_SetItemString(d, "HAVE_FRIBIDI", v);
+    PyDict_SetItemString(d, "HAVE_HARFBUZZ", v);
+    if (have_raqm) {
+#ifdef RAQM_VERSION_MAJOR
+        v = PyUnicode_FromString(raqm_version_string());
+#else
+        v = Py_None;
+#endif
+        PyDict_SetItemString(d, "raqm_version", v);
+
+#ifdef FRIBIDI_MAJOR_VERSION
+        {
+            const char *a = strchr(fribidi_version_info, ')');
+            const char *b = strchr(fribidi_version_info, '\n');
+            if (a && b && a + 2 < b) {
+                v = PyUnicode_FromStringAndSize(a + 2, b - (a + 2));
+            } else {
+                v = Py_None;
+            }
+        }
+#else
+        v = Py_None;
+#endif
+        PyDict_SetItemString(d, "fribidi_version", v);
+
+#ifdef HB_VERSION_STRING
+        v = PyUnicode_FromString(hb_version_string());
+#else
+        v = Py_None;
+#endif
+        PyDict_SetItemString(d, "harfbuzz_version", v);
     }

     return 0;
@@ -1480,14 +1399,14 @@

 PyMODINIT_FUNC
 PyInit__imagingft(void) {
-    PyObject* m;
+    PyObject *m;

     static PyModuleDef module_def = {
         PyModuleDef_HEAD_INIT,
-        "_imagingft",       /* m_name */
-        NULL,               /* m_doc */
-        -1,                 /* m_size */
-        _functions,         /* m_methods */
+        "_imagingft", /* m_name */
+        NULL,         /* m_doc */
+        -1,           /* m_size */
+        _functions,   /* m_methods */
     };

     m = PyModule_Create(&module_def);
('src', '_webp.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,12 +21,14 @@

 #endif

-void ImagingSectionEnter(ImagingSectionCookie* cookie) {
-    *cookie = (PyThreadState *) PyEval_SaveThread();
-}
-
-void ImagingSectionLeave(ImagingSectionCookie* cookie) {
-    PyEval_RestoreThread((PyThreadState*) *cookie);
+void
+ImagingSectionEnter(ImagingSectionCookie *cookie) {
+    *cookie = (PyThreadState *)PyEval_SaveThread();
+}
+
+void
+ImagingSectionLeave(ImagingSectionCookie *cookie) {
+    PyEval_RestoreThread((PyThreadState *)*cookie);
 }

 /* -------------------------------------------------------------------- */
@@ -35,12 +37,15 @@

 #ifdef HAVE_WEBPMUX

-static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
-    "WEBP_MUX_NOT_FOUND", "WEBP_MUX_INVALID_ARGUMENT", "WEBP_MUX_BAD_DATA",
-    "WEBP_MUX_MEMORY_ERROR", "WEBP_MUX_NOT_ENOUGH_DATA"
-};
-
-PyObject* HandleMuxError(WebPMuxError err, char* chunk) {
+static const char *const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
+    "WEBP_MUX_NOT_FOUND",
+    "WEBP_MUX_INVALID_ARGUMENT",
+    "WEBP_MUX_BAD_DATA",
+    "WEBP_MUX_MEMORY_ERROR",
+    "WEBP_MUX_NOT_ENOUGH_DATA"};
+
+PyObject *
+HandleMuxError(WebPMuxError err, char *chunk) {
     char message[100];
     int message_len;
     assert(err <= WEBP_MUX_NOT_FOUND && err >= WEBP_MUX_NOT_ENOUGH_DATA);
@@ -52,9 +57,11 @@

     // Create the error message
     if (chunk == NULL) {
-        message_len = sprintf(message, "could not assemble chunks: %s", kErrorMessages[-err]);
+        message_len =
+            sprintf(message, "could not assemble chunks: %s", kErrorMessages[-err]);
     } else {
-        message_len = sprintf(message, "could not set %.4s chunk: %s", chunk, kErrorMessages[-err]);
+        message_len = sprintf(
+            message, "could not set %.4s chunk: %s", chunk, kErrorMessages[-err]);
     }
     if (message_len < 0) {
         PyErr_SetString(PyExc_RuntimeError, "failed to construct error message");
@@ -90,8 +97,7 @@

 // Encoder type
 typedef struct {
-    PyObject_HEAD
-    WebPAnimEncoder* enc;
+    PyObject_HEAD WebPAnimEncoder *enc;
     WebPPicture frame;
 } WebPAnimEncoderObject;

@@ -99,18 +105,17 @@

 // Decoder type
 typedef struct {
-    PyObject_HEAD
-    WebPAnimDecoder* dec;
+    PyObject_HEAD WebPAnimDecoder *dec;
     WebPAnimInfo info;
     WebPData data;
-    char* mode;
+    char *mode;
 } WebPAnimDecoderObject;

 static PyTypeObject WebPAnimDecoder_Type;

 // Encoder functions
-PyObject* _anim_encoder_new(PyObject* self, PyObject* args)
-{
+PyObject *
+_anim_encoder_new(PyObject *self, PyObject *args) {
     int width, height;
     uint32_t bgcolor;
     int loop_count;
@@ -119,12 +124,21 @@
     int allow_mixed;
     int verbose;
     WebPAnimEncoderOptions enc_options;
-    WebPAnimEncoderObject* encp = NULL;
-    WebPAnimEncoder* enc = NULL;
-
-    if (!PyArg_ParseTuple(args, "iiIiiiiii",
-        &width, &height, &bgcolor, &loop_count, &minimize_size,
-        &kmin, &kmax, &allow_mixed, &verbose)) {
+    WebPAnimEncoderObject *encp = NULL;
+    WebPAnimEncoder *enc = NULL;
+
+    if (!PyArg_ParseTuple(
+            args,
+            "iiIiiiiii",
+            &width,
+            &height,
+            &bgcolor,
+            &loop_count,
+            &minimize_size,
+            &kmin,
+            &kmax,
+            &allow_mixed,
+            &verbose)) {
         return NULL;
     }

@@ -154,7 +168,7 @@
             enc = WebPAnimEncoderNew(width, height, &enc_options);
             if (enc) {
                 encp->enc = enc;
-                return (PyObject*) encp;
+                return (PyObject *)encp;
             }
             WebPPictureFree(&(encp->frame));
         }
@@ -164,33 +178,42 @@
     return NULL;
 }

-PyObject* _anim_encoder_dealloc(PyObject* self)
-{
-    WebPAnimEncoderObject* encp = (WebPAnimEncoderObject*)self;
+PyObject *
+_anim_encoder_dealloc(PyObject *self) {
+    WebPAnimEncoderObject *encp = (WebPAnimEncoderObject *)self;
     WebPPictureFree(&(encp->frame));
     WebPAnimEncoderDelete(encp->enc);
     Py_RETURN_NONE;
 }

-PyObject* _anim_encoder_add(PyObject* self, PyObject* args)
-{
-    uint8_t* rgb;
+PyObject *
+_anim_encoder_add(PyObject *self, PyObject *args) {
+    uint8_t *rgb;
     Py_ssize_t size;
     int timestamp;
     int width;
     int height;
-    char* mode;
+    char *mode;
     int lossless;
     float quality_factor;
     int method;
     WebPConfig config;
-    WebPAnimEncoderObject* encp = (WebPAnimEncoderObject*)self;
-    WebPAnimEncoder* enc = encp->enc;
-    WebPPicture* frame = &(encp->frame);
-
-    if (!PyArg_ParseTuple(args, "z#iiisifi",
-        (char**)&rgb, &size, &timestamp, &width, &height, &mode,
-        &lossless, &quality_factor, &method)) {
+    WebPAnimEncoderObject *encp = (WebPAnimEncoderObject *)self;
+    WebPAnimEncoder *enc = encp->enc;
+    WebPPicture *frame = &(encp->frame);
+
+    if (!PyArg_ParseTuple(
+            args,
+            "z#iiisifi",
+            (char **)&rgb,
+            &size,
+            &timestamp,
+            &width,
+            &height,
+            &mode,
+            &lossless,
+            &quality_factor,
+            &method)) {
         return NULL;
     }

@@ -218,10 +241,10 @@
     // Populate the frame with raw bytes passed to us
     frame->width = width;
     frame->height = height;
-    frame->use_argb = 1; // Don't convert RGB pixels to YUV
-    if (strcmp(mode, "RGBA")==0) {
+    frame->use_argb = 1;  // Don't convert RGB pixels to YUV
+    if (strcmp(mode, "RGBA") == 0) {
         WebPPictureImportRGBA(frame, rgb, 4 * width);
-    } else if (strcmp(mode, "RGBX")==0) {
+    } else if (strcmp(mode, "RGBX") == 0) {
         WebPPictureImportRGBX(frame, rgb, 4 * width);
     } else {
         WebPPictureImportRGB(frame, rgb, 3 * width);
@@ -236,22 +259,29 @@
     Py_RETURN_NONE;
 }

-PyObject* _anim_encoder_assemble(PyObject* self, PyObject* args)
-{
-    uint8_t* icc_bytes;
-    uint8_t* exif_bytes;
-    uint8_t* xmp_bytes;
+PyObject *
+_anim_encoder_assemble(PyObject *self, PyObject *args) {
+    uint8_t *icc_bytes;
+    uint8_t *exif_bytes;
+    uint8_t *xmp_bytes;
     Py_ssize_t icc_size;
     Py_ssize_t exif_size;
     Py_ssize_t xmp_size;
     WebPData webp_data;
-    WebPAnimEncoderObject* encp = (WebPAnimEncoderObject*)self;
-    WebPAnimEncoder* enc = encp->enc;
-    WebPMux* mux = NULL;
-    PyObject* ret = NULL;
-
-    if (!PyArg_ParseTuple(args, "s#s#s#",
-    &icc_bytes, &icc_size, &exif_bytes, &exif_size, &xmp_bytes, &xmp_size)) {
+    WebPAnimEncoderObject *encp = (WebPAnimEncoderObject *)self;
+    WebPAnimEncoder *enc = encp->enc;
+    WebPMux *mux = NULL;
+    PyObject *ret = NULL;
+
+    if (!PyArg_ParseTuple(
+            args,
+            "s#s#s#",
+            &icc_bytes,
+            &icc_size,
+            &exif_bytes,
+            &exif_size,
+            &xmp_bytes,
+            &xmp_size)) {
         return NULL;
     }

@@ -270,9 +300,9 @@
         int i_icc_size = (int)icc_size;
         int i_exif_size = (int)exif_size;
         int i_xmp_size = (int)xmp_size;
-        WebPData icc_profile = { icc_bytes, i_icc_size };
-        WebPData exif = { exif_bytes, i_exif_size };
-        WebPData xmp = { xmp_bytes, i_xmp_size };
+        WebPData icc_profile = {icc_bytes, i_icc_size};
+        WebPData exif = {exif_bytes, i_exif_size};
+        WebPData xmp = {xmp_bytes, i_xmp_size};

         mux = WebPMuxCreate(&webp_data, 1);
         if (mux == NULL) {
@@ -312,7 +342,7 @@
     }

     // Convert to Python bytes
-    ret = PyBytes_FromStringAndSize((char*)webp_data.bytes, webp_data.size);
+    ret = PyBytes_FromStringAndSize((char *)webp_data.bytes, webp_data.size);
     WebPDataClear(&webp_data);

     // If we had to re-mux, we should free it now that we're done with it
@@ -324,21 +354,21 @@
 }

 // Decoder functions
-PyObject* _anim_decoder_new(PyObject* self, PyObject* args)
-{
+PyObject *
+_anim_decoder_new(PyObject *self, PyObject *args) {
     PyBytesObject *webp_string;
     const uint8_t *webp;
     Py_ssize_t size;
     WebPData webp_src;
-    char* mode;
+    char *mode;
     WebPDecoderConfig config;
-    WebPAnimDecoderObject* decp = NULL;
-    WebPAnimDecoder* dec = NULL;
+    WebPAnimDecoderObject *decp = NULL;
+    WebPAnimDecoder *dec = NULL;

     if (!PyArg_ParseTuple(args, "S", &webp_string)) {
         return NULL;
     }
-    PyBytes_AsStringAndSize((PyObject *)webp_string, (char**)&webp, &size);
+    PyBytes_AsStringAndSize((PyObject *)webp_string, (char **)&webp, &size);
     webp_src.bytes = webp;
     webp_src.size = size;

@@ -359,43 +389,45 @@
             if (dec) {
                 if (WebPAnimDecoderGetInfo(dec, &(decp->info))) {
                     decp->dec = dec;
-                    return (PyObject*)decp;
+                    return (PyObject *)decp;
                 }
             }
+            WebPDataClear(&(decp->data));
         }
         PyObject_Del(decp);
     }
-    PyErr_SetString(PyExc_RuntimeError, "could not create decoder object");
+    PyErr_SetString(PyExc_OSError, "could not create decoder object");
     return NULL;
 }

-PyObject* _anim_decoder_dealloc(PyObject* self)
-{
-    WebPAnimDecoderObject* decp = (WebPAnimDecoderObject *)self;
+PyObject *
+_anim_decoder_dealloc(PyObject *self) {
+    WebPAnimDecoderObject *decp = (WebPAnimDecoderObject *)self;
     WebPDataClear(&(decp->data));
     WebPAnimDecoderDelete(decp->dec);
     Py_RETURN_NONE;
 }

-PyObject* _anim_decoder_get_info(PyObject* self)
-{
-    WebPAnimDecoderObject* decp = (WebPAnimDecoderObject *)self;
-    WebPAnimInfo* info = &(decp->info);
-
-    return Py_BuildValue("IIIIIs",
-        info->canvas_width, info->canvas_height,
+PyObject *
+_anim_decoder_get_info(PyObject *self) {
+    WebPAnimDecoderObject *decp = (WebPAnimDecoderObject *)self;
+    WebPAnimInfo *info = &(decp->info);
+
+    return Py_BuildValue(
+        "IIIIIs",
+        info->canvas_width,
+        info->canvas_height,
         info->loop_count,
         info->bgcolor,
         info->frame_count,
-        decp->mode
-    );
-}
-
-PyObject* _anim_decoder_get_chunk(PyObject* self, PyObject* args)
-{
-    char* mode;
-    WebPAnimDecoderObject* decp = (WebPAnimDecoderObject *)self;
-    const WebPDemuxer* demux;
+        decp->mode);
+}
+
+PyObject *
+_anim_decoder_get_chunk(PyObject *self, PyObject *args) {
+    char *mode;
+    WebPAnimDecoderObject *decp = (WebPAnimDecoderObject *)self;
+    const WebPDemuxer *demux;
     WebPChunkIterator iter;
     PyObject *ret;

@@ -408,27 +440,27 @@
         Py_RETURN_NONE;
     }

-    ret = PyBytes_FromStringAndSize((const char*)iter.chunk.bytes, iter.chunk.size);
+    ret = PyBytes_FromStringAndSize((const char *)iter.chunk.bytes, iter.chunk.size);
     WebPDemuxReleaseChunkIterator(&iter);

     return ret;
 }

-PyObject* _anim_decoder_get_next(PyObject* self)
-{
-    uint8_t* buf;
+PyObject *
+_anim_decoder_get_next(PyObject *self) {
+    uint8_t *buf;
     int timestamp;
-    PyObject* bytes;
-    PyObject* ret;
-    WebPAnimDecoderObject* decp = (WebPAnimDecoderObject*)self;
+    PyObject *bytes;
+    PyObject *ret;
+    WebPAnimDecoderObject *decp = (WebPAnimDecoderObject *)self;

     if (!WebPAnimDecoderGetNext(decp->dec, &buf, &timestamp)) {
         PyErr_SetString(PyExc_OSError, "failed to read next frame");
         return NULL;
     }

-    bytes = PyBytes_FromStringAndSize((char *)buf,
-        decp->info.canvas_width * 4 * decp->info.canvas_height);
+    bytes = PyBytes_FromStringAndSize(
+        (char *)buf, decp->info.canvas_width * 4 * decp->info.canvas_height);

     ret = Py_BuildValue("Si", bytes, timestamp);

@@ -436,9 +468,9 @@
     return ret;
 }

-PyObject* _anim_decoder_reset(PyObject* self)
-{
-    WebPAnimDecoderObject* decp = (WebPAnimDecoderObject *)self;
+PyObject *
+_anim_decoder_reset(PyObject *self) {
+    WebPAnimDecoderObject *decp = (WebPAnimDecoderObject *)self;
     WebPAnimDecoderReset(decp->dec);
     Py_RETURN_NONE;
 }
@@ -454,39 +486,38 @@
     {NULL, NULL} /* sentinel */
 };

-// WebPAnimDecoder type definition
+// WebPAnimEncoder type definition
 static PyTypeObject WebPAnimEncoder_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "WebPAnimEncoder",          /*tp_name */
-    sizeof(WebPAnimEncoderObject),   /*tp_size */
-    0,                          /*tp_itemsize */
+    PyVarObject_HEAD_INIT(NULL, 0) "WebPAnimEncoder", /*tp_name */
+    sizeof(WebPAnimEncoderObject),                    /*tp_size */
+    0,                                                /*tp_itemsize */
     /* methods */
     (destructor)_anim_encoder_dealloc, /*tp_dealloc*/
-    0,                          /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    _anim_encoder_methods,      /*tp_methods*/
-    0,                          /*tp_members*/
-    0,     /*tp_getset*/
+    0,                                 /*tp_print*/
+    0,                                 /*tp_getattr*/
+    0,                                 /*tp_setattr*/
+    0,                                 /*tp_compare*/
+    0,                                 /*tp_repr*/
+    0,                                 /*tp_as_number */
+    0,                                 /*tp_as_sequence */
+    0,                                 /*tp_as_mapping */
+    0,                                 /*tp_hash*/
+    0,                                 /*tp_call*/
+    0,                                 /*tp_str*/
+    0,                                 /*tp_getattro*/
+    0,                                 /*tp_setattro*/
+    0,                                 /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,                /*tp_flags*/
+    0,                                 /*tp_doc*/
+    0,                                 /*tp_traverse*/
+    0,                                 /*tp_clear*/
+    0,                                 /*tp_richcompare*/
+    0,                                 /*tp_weaklistoffset*/
+    0,                                 /*tp_iter*/
+    0,                                 /*tp_iternext*/
+    _anim_encoder_methods,             /*tp_methods*/
+    0,                                 /*tp_members*/
+    0,                                 /*tp_getset*/
 };

 // WebPAnimDecoder methods
@@ -500,37 +531,36 @@

 // WebPAnimDecoder type definition
 static PyTypeObject WebPAnimDecoder_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "WebPAnimDecoder",          /*tp_name */
-    sizeof(WebPAnimDecoderObject),   /*tp_size */
-    0,                          /*tp_itemsize */
+    PyVarObject_HEAD_INIT(NULL, 0) "WebPAnimDecoder", /*tp_name */
+    sizeof(WebPAnimDecoderObject),                    /*tp_size */
+    0,                                                /*tp_itemsize */
     /* methods */
     (destructor)_anim_decoder_dealloc, /*tp_dealloc*/
-    0,                          /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    _anim_decoder_methods,      /*tp_methods*/
-    0,                          /*tp_members*/
-    0,     /*tp_getset*/
+    0,                                 /*tp_print*/
+    0,                                 /*tp_getattr*/
+    0,                                 /*tp_setattr*/
+    0,                                 /*tp_compare*/
+    0,                                 /*tp_repr*/
+    0,                                 /*tp_as_number */
+    0,                                 /*tp_as_sequence */
+    0,                                 /*tp_as_mapping */
+    0,                                 /*tp_hash*/
+    0,                                 /*tp_call*/
+    0,                                 /*tp_str*/
+    0,                                 /*tp_getattro*/
+    0,                                 /*tp_setattro*/
+    0,                                 /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,                /*tp_flags*/
+    0,                                 /*tp_doc*/
+    0,                                 /*tp_traverse*/
+    0,                                 /*tp_clear*/
+    0,                                 /*tp_richcompare*/
+    0,                                 /*tp_weaklistoffset*/
+    0,                                 /*tp_iter*/
+    0,                                 /*tp_iternext*/
+    _anim_decoder_methods,             /*tp_methods*/
+    0,                                 /*tp_members*/
+    0,                                 /*tp_getset*/
 };

 #endif
@@ -539,19 +569,19 @@
 /* Legacy WebP Support                                                  */
 /* -------------------------------------------------------------------- */

-PyObject* WebPEncode_wrapper(PyObject* self, PyObject* args)
-{
+PyObject *
+WebPEncode_wrapper(PyObject *self, PyObject *args) {
     int width;
     int height;
     int lossless;
     float quality_factor;
     int method;
-    uint8_t* rgb;
-    uint8_t* icc_bytes;
-    uint8_t* exif_bytes;
-    uint8_t* xmp_bytes;
-    uint8_t* output;
-    char* mode;
+    uint8_t *rgb;
+    uint8_t *icc_bytes;
+    uint8_t *exif_bytes;
+    uint8_t *xmp_bytes;
+    uint8_t *output;
+    char *mode;
     Py_ssize_t size;
     Py_ssize_t icc_size;
     Py_ssize_t exif_size;
@@ -565,9 +595,23 @@
     WebPMemoryWriter writer;
     WebPPicture pic;

-    if (!PyArg_ParseTuple(args, "y#iiifss#is#s#",
-                (char**)&rgb, &size, &width, &height, &lossless, &quality_factor, &mode,
-                &icc_bytes, &icc_size, &method, &exif_bytes, &exif_size, &xmp_bytes, &xmp_size)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "y#iiifss#is#s#",
+            (char **)&rgb,
+            &size,
+            &width,
+            &height,
+            &lossless,
+            &quality_factor,
+            &mode,
+            &icc_bytes,
+            &icc_size,
+            &method,
+            &exif_bytes,
+            &exif_size,
+            &xmp_bytes,
+            &xmp_size)) {
         return NULL;
     }

@@ -602,7 +646,7 @@
     }
     pic.width = width;
     pic.height = height;
-    pic.use_argb = 1; // Don't convert RGB pixels to YUV
+    pic.use_argb = 1;  // Don't convert RGB pixels to YUV

     if (rgba_mode) {
         WebPPictureImportRGBA(&pic, rgb, channels * width);
@@ -620,7 +664,7 @@

     WebPPictureFree(&pic);
     if (!ok) {
-        PyErr_SetString(PyExc_ValueError, "encoding error");
+        PyErr_Format(PyExc_ValueError, "encoding error %d", (&pic)->error_code);
         return NULL;
     }
     output = writer.mem;
@@ -628,98 +672,100 @@

 #ifndef HAVE_WEBPMUX
     if (ret_size > 0) {
-        PyObject *ret = PyBytes_FromStringAndSize((char*)output, ret_size);
+        PyObject *ret = PyBytes_FromStringAndSize((char *)output, ret_size);
         free(output);
         return ret;
     }
 #else
     {
-    /* I want to truncate the *_size items that get passed into WebP
-       data. Pypy2.1.0 had some issues where the Py_ssize_t items had
-       data in the upper byte. (Not sure why, it shouldn't have been there)
-    */
-    int i_icc_size = (int)icc_size;
-    int i_exif_size = (int)exif_size;
-    int i_xmp_size = (int)xmp_size;
-    WebPData output_data = {0};
-    WebPData image = { output, ret_size };
-    WebPData icc_profile = { icc_bytes, i_icc_size };
-    WebPData exif = { exif_bytes, i_exif_size };
-    WebPData xmp = { xmp_bytes, i_xmp_size };
-    WebPMuxError err;
-    int dbg = 0;
-
-    int copy_data = 0;  // value 1 indicates given data WILL be copied to the mux
-                        // and value 0 indicates data will NOT be copied.
-
-    WebPMux* mux = WebPMuxNew();
-    WebPMuxSetImage(mux, &image, copy_data);
-
-    if (dbg) {
-        /* was getting %ld icc_size == 0, icc_size>0 was true */
-        fprintf(stderr, "icc size %d, %d \n", i_icc_size, i_icc_size > 0);
-    }
-
-    if (i_icc_size > 0) {
+        /* I want to truncate the *_size items that get passed into WebP
+           data. Pypy2.1.0 had some issues where the Py_ssize_t items had
+           data in the upper byte. (Not sure why, it shouldn't have been there)
+        */
+        int i_icc_size = (int)icc_size;
+        int i_exif_size = (int)exif_size;
+        int i_xmp_size = (int)xmp_size;
+        WebPData output_data = {0};
+        WebPData image = {output, ret_size};
+        WebPData icc_profile = {icc_bytes, i_icc_size};
+        WebPData exif = {exif_bytes, i_exif_size};
+        WebPData xmp = {xmp_bytes, i_xmp_size};
+        WebPMuxError err;
+        int dbg = 0;
+
+        int copy_data = 0;  // value 1 indicates given data WILL be copied to the mux
+                            // and value 0 indicates data will NOT be copied.
+
+        WebPMux *mux = WebPMuxNew();
+        WebPMuxSetImage(mux, &image, copy_data);
+
         if (dbg) {
-            fprintf(stderr, "Adding ICC Profile\n");
-        }
-        err = WebPMuxSetChunk(mux, "ICCP", &icc_profile, copy_data);
-        if (err != WEBP_MUX_OK) {
-            return HandleMuxError(err, "ICCP");
-        }
-    }
-
-    if (dbg) {
-        fprintf(stderr, "exif size %d \n", i_exif_size);
-    }
-    if (i_exif_size > 0) {
+            /* was getting %ld icc_size == 0, icc_size>0 was true */
+            fprintf(stderr, "icc size %d, %d \n", i_icc_size, i_icc_size > 0);
+        }
+
+        if (i_icc_size > 0) {
+            if (dbg) {
+                fprintf(stderr, "Adding ICC Profile\n");
+            }
+            err = WebPMuxSetChunk(mux, "ICCP", &icc_profile, copy_data);
+            if (err != WEBP_MUX_OK) {
+                return HandleMuxError(err, "ICCP");
+            }
+        }
+
         if (dbg) {
-            fprintf(stderr, "Adding Exif Data\n");
-        }
-        err = WebPMuxSetChunk(mux, "EXIF", &exif, copy_data);
-        if (err != WEBP_MUX_OK) {
-            return HandleMuxError(err, "EXIF");
-        }
-    }
-
-    if (dbg) {
-        fprintf(stderr, "xmp size %d \n", i_xmp_size);
-    }
-    if (i_xmp_size > 0) {
-        if (dbg){
-            fprintf(stderr, "Adding XMP Data\n");
-        }
-        err = WebPMuxSetChunk(mux, "XMP ", &xmp, copy_data);
-        if (err != WEBP_MUX_OK) {
-            return HandleMuxError(err, "XMP ");
-        }
-    }
-
-    WebPMuxAssemble(mux, &output_data);
-    WebPMuxDelete(mux);
-    free(output);
-
-    ret_size = output_data.size;
-    if (ret_size > 0) {
-        PyObject *ret = PyBytes_FromStringAndSize((char*)output_data.bytes, ret_size);
-        WebPDataClear(&output_data);
-        return ret;
-    }
+            fprintf(stderr, "exif size %d \n", i_exif_size);
+        }
+        if (i_exif_size > 0) {
+            if (dbg) {
+                fprintf(stderr, "Adding Exif Data\n");
+            }
+            err = WebPMuxSetChunk(mux, "EXIF", &exif, copy_data);
+            if (err != WEBP_MUX_OK) {
+                return HandleMuxError(err, "EXIF");
+            }
+        }
+
+        if (dbg) {
+            fprintf(stderr, "xmp size %d \n", i_xmp_size);
+        }
+        if (i_xmp_size > 0) {
+            if (dbg) {
+                fprintf(stderr, "Adding XMP Data\n");
+            }
+            err = WebPMuxSetChunk(mux, "XMP ", &xmp, copy_data);
+            if (err != WEBP_MUX_OK) {
+                return HandleMuxError(err, "XMP ");
+            }
+        }
+
+        WebPMuxAssemble(mux, &output_data);
+        WebPMuxDelete(mux);
+        free(output);
+
+        ret_size = output_data.size;
+        if (ret_size > 0) {
+            PyObject *ret =
+                PyBytes_FromStringAndSize((char *)output_data.bytes, ret_size);
+            WebPDataClear(&output_data);
+            return ret;
+        }
     }
 #endif
     Py_RETURN_NONE;
 }

-PyObject* WebPDecode_wrapper(PyObject* self, PyObject* args)
-{
-    PyBytesObject* webp_string;
-    const uint8_t* webp;
+PyObject *
+WebPDecode_wrapper(PyObject *self, PyObject *args) {
+    PyBytesObject *webp_string;
+    const uint8_t *webp;
     Py_ssize_t size;
-    PyObject *ret = Py_None, *bytes = NULL, *pymode = NULL, *icc_profile = NULL, *exif = NULL;
+    PyObject *ret = Py_None, *bytes = NULL, *pymode = NULL, *icc_profile = NULL,
+             *exif = NULL;
     WebPDecoderConfig config;
     VP8StatusCode vp8_status_code = VP8_STATUS_OK;
-    char* mode = "RGB";
+    char *mode = "RGB";

     if (!PyArg_ParseTuple(args, "S", &webp_string)) {
         return NULL;
@@ -729,7 +775,7 @@
         Py_RETURN_NONE;
     }

-    PyBytes_AsStringAndSize((PyObject*) webp_string, (char**)&webp, &size);
+    PyBytes_AsStringAndSize((PyObject *)webp_string, (char **)&webp, &size);

     vp8_status_code = WebPGetFeatures(webp, size, &config.input);
     if (vp8_status_code == VP8_STATUS_OK) {
@@ -743,39 +789,40 @@
 #ifndef HAVE_WEBPMUX
         vp8_status_code = WebPDecode(webp, size, &config);
 #else
-       {
-        int copy_data = 0;
-        WebPData data = { webp, size };
-        WebPMuxFrameInfo image;
-        WebPData icc_profile_data = {0};
-        WebPData exif_data = {0};
-
-        WebPMux* mux = WebPMuxCreate(&data, copy_data);
-        if (NULL == mux) {
-            goto end;
-        }
-
-        if (WEBP_MUX_OK != WebPMuxGetFrame(mux, 1, &image))
         {
+            int copy_data = 0;
+            WebPData data = {webp, size};
+            WebPMuxFrameInfo image;
+            WebPData icc_profile_data = {0};
+            WebPData exif_data = {0};
+
+            WebPMux *mux = WebPMuxCreate(&data, copy_data);
+            if (NULL == mux) {
+                goto end;
+            }
+
+            if (WEBP_MUX_OK != WebPMuxGetFrame(mux, 1, &image)) {
+                WebPMuxDelete(mux);
+                goto end;
+            }
+
+            webp = image.bitstream.bytes;
+            size = image.bitstream.size;
+
+            vp8_status_code = WebPDecode(webp, size, &config);
+
+            if (WEBP_MUX_OK == WebPMuxGetChunk(mux, "ICCP", &icc_profile_data)) {
+                icc_profile = PyBytes_FromStringAndSize(
+                    (const char *)icc_profile_data.bytes, icc_profile_data.size);
+            }
+
+            if (WEBP_MUX_OK == WebPMuxGetChunk(mux, "EXIF", &exif_data)) {
+                exif = PyBytes_FromStringAndSize(
+                    (const char *)exif_data.bytes, exif_data.size);
+            }
+
+            WebPDataClear(&image.bitstream);
             WebPMuxDelete(mux);
-            goto end;
-        }
-
-        webp = image.bitstream.bytes;
-        size = image.bitstream.size;
-
-        vp8_status_code = WebPDecode(webp, size, &config);
-
-        if (WEBP_MUX_OK == WebPMuxGetChunk(mux, "ICCP", &icc_profile_data)) {
-            icc_profile = PyBytes_FromStringAndSize((const char*)icc_profile_data.bytes, icc_profile_data.size);
-        }
-
-        if (WEBP_MUX_OK == WebPMuxGetChunk(mux, "EXIF", &exif_data)) {
-            exif = PyBytes_FromStringAndSize((const char*)exif_data.bytes, exif_data.size);
-        }
-
-        WebPDataClear(&image.bitstream);
-        WebPMuxDelete(mux);
         }
 #endif
     }
@@ -785,20 +832,24 @@
     }

     if (config.output.colorspace < MODE_YUV) {
-        bytes = PyBytes_FromStringAndSize((char*)config.output.u.RGBA.rgba,
-                                          config.output.u.RGBA.size);
+        bytes = PyBytes_FromStringAndSize(
+            (char *)config.output.u.RGBA.rgba, config.output.u.RGBA.size);
     } else {
         // Skipping YUV for now. Need Test Images.
         // UNDONE -- unclear if we'll ever get here if we set mode_rgb*
-        bytes = PyBytes_FromStringAndSize((char*)config.output.u.YUVA.y,
-                                          config.output.u.YUVA.y_size);
+        bytes = PyBytes_FromStringAndSize(
+            (char *)config.output.u.YUVA.y, config.output.u.YUVA.y_size);
     }

     pymode = PyUnicode_FromString(mode);
-    ret = Py_BuildValue("SiiSSS", bytes, config.output.width,
-                        config.output.height, pymode,
-                        NULL == icc_profile ? Py_None : icc_profile,
-                        NULL == exif ? Py_None : exif);
+    ret = Py_BuildValue(
+        "SiiSSS",
+        bytes,
+        config.output.width,
+        config.output.height,
+        pymode,
+        NULL == icc_profile ? Py_None : icc_profile,
+        NULL == exif ? Py_None : exif);

 end:
     WebPFreeDecBuffer(&config.output);
@@ -817,17 +868,22 @@

 // Return the decoder's version number, packed in hexadecimal using 8bits for
 // each of major/minor/revision. E.g: v2.5.7 is 0x020507.
-PyObject* WebPDecoderVersion_wrapper() {
+PyObject *
+WebPDecoderVersion_wrapper() {
     return Py_BuildValue("i", WebPGetDecoderVersion());
 }

 // Version as string
-const char*
-WebPDecoderVersion_str(void)
-{
+const char *
+WebPDecoderVersion_str(void) {
     static char version[20];
     int version_number = WebPGetDecoderVersion();
-    sprintf(version, "%d.%d.%d", version_number >> 16, (version_number >> 8) % 0x100, version_number % 0x100);
+    sprintf(
+        version,
+        "%d.%d.%d",
+        version_number >> 16,
+        (version_number >> 8) % 0x100,
+        version_number % 0x100);
     return version;
 }

@@ -835,11 +891,13 @@
  * The version of webp that ships with (0.1.3) Ubuntu 12.04 doesn't handle alpha well.
  * Files that are valid with 0.3 are reported as being invalid.
  */
-int WebPDecoderBuggyAlpha(void) {
-    return WebPGetDecoderVersion()==0x0103;
-}
-
-PyObject* WebPDecoderBuggyAlpha_wrapper() {
+int
+WebPDecoderBuggyAlpha(void) {
+    return WebPGetDecoderVersion() == 0x0103;
+}
+
+PyObject *
+WebPDecoderBuggyAlpha_wrapper() {
     return Py_BuildValue("i", WebPDecoderBuggyAlpha());
 }

@@ -847,8 +905,7 @@
 /* Module Setup                                                         */
 /* -------------------------------------------------------------------- */

-static PyMethodDef webpMethods[] =
-{
+static PyMethodDef webpMethods[] = {
 #ifdef HAVE_WEBPANIM
     {"WebPAnimDecoder", _anim_decoder_new, METH_VARARGS, "WebPAnimDecoder"},
     {"WebPAnimEncoder", _anim_encoder_new, METH_VARARGS, "WebPAnimEncoder"},
@@ -856,38 +913,51 @@
     {"WebPEncode", WebPEncode_wrapper, METH_VARARGS, "WebPEncode"},
     {"WebPDecode", WebPDecode_wrapper, METH_VARARGS, "WebPDecode"},
     {"WebPDecoderVersion", WebPDecoderVersion_wrapper, METH_NOARGS, "WebPVersion"},
-    {"WebPDecoderBuggyAlpha", WebPDecoderBuggyAlpha_wrapper, METH_NOARGS, "WebPDecoderBuggyAlpha"},
-    {NULL, NULL}
-};
-
-void addMuxFlagToModule(PyObject* m) {
+    {"WebPDecoderBuggyAlpha",
+     WebPDecoderBuggyAlpha_wrapper,
+     METH_NOARGS,
+     "WebPDecoderBuggyAlpha"},
+    {NULL, NULL}};
+
+void
+addMuxFlagToModule(PyObject *m) {
+    PyObject *have_webpmux;
 #ifdef HAVE_WEBPMUX
-    PyModule_AddObject(m, "HAVE_WEBPMUX", Py_True);
+    have_webpmux = Py_True;
 #else
-    PyModule_AddObject(m, "HAVE_WEBPMUX", Py_False);
+    have_webpmux = Py_False;
 #endif
-}
-
-void addAnimFlagToModule(PyObject* m) {
+    Py_INCREF(have_webpmux);
+    PyModule_AddObject(m, "HAVE_WEBPMUX", have_webpmux);
+}
+
+void
+addAnimFlagToModule(PyObject *m) {
+    PyObject *have_webpanim;
 #ifdef HAVE_WEBPANIM
-    PyModule_AddObject(m, "HAVE_WEBPANIM", Py_True);
+    have_webpanim = Py_True;
 #else
-    PyModule_AddObject(m, "HAVE_WEBPANIM", Py_False);
+    have_webpanim = Py_False;
 #endif
-}
-
-void addTransparencyFlagToModule(PyObject* m) {
-    PyModule_AddObject(m, "HAVE_TRANSPARENCY",
-               PyBool_FromLong(!WebPDecoderBuggyAlpha()));
-}
-
-static int setup_module(PyObject* m) {
-    PyObject* d = PyModule_GetDict(m);
+    Py_INCREF(have_webpanim);
+    PyModule_AddObject(m, "HAVE_WEBPANIM", have_webpanim);
+}
+
+void
+addTransparencyFlagToModule(PyObject *m) {
+    PyModule_AddObject(
+        m, "HAVE_TRANSPARENCY", PyBool_FromLong(!WebPDecoderBuggyAlpha()));
+}
+
+static int
+setup_module(PyObject *m) {
+    PyObject *d = PyModule_GetDict(m);
     addMuxFlagToModule(m);
     addAnimFlagToModule(m);
     addTransparencyFlagToModule(m);

-    PyDict_SetItemString(d, "webpdecoder_version", PyUnicode_FromString(WebPDecoderVersion_str()));
+    PyDict_SetItemString(
+        d, "webpdecoder_version", PyUnicode_FromString(WebPDecoderVersion_str()));

 #ifdef HAVE_WEBPANIM
     /* Ready object types */
@@ -901,14 +971,14 @@

 PyMODINIT_FUNC
 PyInit__webp(void) {
-    PyObject* m;
+    PyObject *m;

     static PyModuleDef module_def = {
         PyModuleDef_HEAD_INIT,
-        "_webp",            /* m_name */
-        NULL,               /* m_doc */
-        -1,                 /* m_size */
-        webpMethods,        /* m_methods */
+        "_webp",     /* m_name */
+        NULL,        /* m_doc */
+        -1,          /* m_size */
+        webpMethods, /* m_methods */
     };

     m = PyModule_Create(&module_def);
('src', '_imagingmath.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,50 +23,51 @@
 #define MAX_INT32 2147483647.0
 #define MIN_INT32 -2147483648.0

-#define UNOP(name, op, type)\
-void name(Imaging out, Imaging im1)\
-{\
-    int x, y;\
-    for (y = 0; y < out->ysize; y++) {\
-        type* p0 = (type*) out->image[y];\
-        type* p1 = (type*) im1->image[y];\
-        for (x = 0; x < out->xsize; x++) {\
-            *p0 = op(type, *p1);\
-            p0++; p1++;\
-        }\
-    }\
-}
-
-#define BINOP(name, op, type)\
-void name(Imaging out, Imaging im1, Imaging im2)\
-{\
-    int x, y;\
-    for (y = 0; y < out->ysize; y++) {\
-        type* p0 = (type*) out->image[y];\
-        type* p1 = (type*) im1->image[y];\
-        type* p2 = (type*) im2->image[y];\
-        for (x = 0; x < out->xsize; x++) {\
-            *p0 = op(type, *p1, *p2);\
-            p0++; p1++; p2++;\
-        }\
-    }\
-}
+#define UNOP(name, op, type)                   \
+    void name(Imaging out, Imaging im1) {      \
+        int x, y;                              \
+        for (y = 0; y < out->ysize; y++) {     \
+            type *p0 = (type *)out->image[y];  \
+            type *p1 = (type *)im1->image[y];  \
+            for (x = 0; x < out->xsize; x++) { \
+                *p0 = op(type, *p1);           \
+                p0++;                          \
+                p1++;                          \
+            }                                  \
+        }                                      \
+    }
+
+#define BINOP(name, op, type)                          \
+    void name(Imaging out, Imaging im1, Imaging im2) { \
+        int x, y;                                      \
+        for (y = 0; y < out->ysize; y++) {             \
+            type *p0 = (type *)out->image[y];          \
+            type *p1 = (type *)im1->image[y];          \
+            type *p2 = (type *)im2->image[y];          \
+            for (x = 0; x < out->xsize; x++) {         \
+                *p0 = op(type, *p1, *p2);              \
+                p0++;                                  \
+                p1++;                                  \
+                p2++;                                  \
+            }                                          \
+        }                                              \
+    }

 #define NEG(type, v1) -(v1)
 #define INVERT(type, v1) ~(v1)

-#define ADD(type, v1, v2) (v1)+(v2)
-#define SUB(type, v1, v2) (v1)-(v2)
-#define MUL(type, v1, v2) (v1)*(v2)
-
-#define MIN(type, v1, v2) ((v1)<(v2))?(v1):(v2)
-#define MAX(type, v1, v2) ((v1)>(v2))?(v1):(v2)
-
-#define AND(type, v1, v2) (v1)&(v2)
-#define OR(type, v1, v2) (v1)|(v2)
-#define XOR(type, v1, v2) (v1)^(v2)
-#define LSHIFT(type, v1, v2) (v1)<<(v2)
-#define RSHIFT(type, v1, v2) (v1)>>(v2)
+#define ADD(type, v1, v2) (v1) + (v2)
+#define SUB(type, v1, v2) (v1) - (v2)
+#define MUL(type, v1, v2) (v1) * (v2)
+
+#define MIN(type, v1, v2) ((v1) < (v2)) ? (v1) : (v2)
+#define MAX(type, v1, v2) ((v1) > (v2)) ? (v1) : (v2)
+
+#define AND(type, v1, v2) (v1) & (v2)
+#define OR(type, v1, v2) (v1) | (v2)
+#define XOR(type, v1, v2) (v1) ^ (v2)
+#define LSHIFT(type, v1, v2) (v1) << (v2)
+#define RSHIFT(type, v1, v2) (v1) >> (v2)

 #define ABS_I(type, v1) abs((v1))
 #define ABS_F(type, v1) fabs((v1))
@@ -79,14 +80,14 @@
  * PyFPE_END_PROTECT(result)
  */

-#define DIV_I(type, v1, v2) ((v2)!=0)?(v1)/(v2):0
-#define DIV_F(type, v1, v2) ((v2)!=0.0F)?(v1)/(v2):0.0F
-
-#define MOD_I(type, v1, v2) ((v2)!=0)?(v1)%(v2):0
-#define MOD_F(type, v1, v2) ((v2)!=0.0F)?fmod((v1),(v2)):0.0F
-
-static int powi(int x, int y)
-{
+#define DIV_I(type, v1, v2) ((v2) != 0) ? (v1) / (v2) : 0
+#define DIV_F(type, v1, v2) ((v2) != 0.0F) ? (v1) / (v2) : 0.0F
+
+#define MOD_I(type, v1, v2) ((v2) != 0) ? (v1) % (v2) : 0
+#define MOD_F(type, v1, v2) ((v2) != 0.0F) ? fmod((v1), (v2)) : 0.0F
+
+static int
+powi(int x, int y) {
     double v = pow(x, y) + 0.5;
     if (errno == EDOM) {
         return 0;
@@ -96,21 +97,21 @@
     } else if (v > MAX_INT32) {
         v = MAX_INT32;
     }
-    return (int) v;
+    return (int)v;
 }

 #define POW_I(type, v1, v2) powi(v1, v2)
 #define POW_F(type, v1, v2) powf(v1, v2) /* FIXME: EDOM handling */

-#define DIFF_I(type, v1, v2) abs((v1)-(v2))
-#define DIFF_F(type, v1, v2) fabs((v1)-(v2))
-
-#define EQ(type, v1, v2) (v1)==(v2)
-#define NE(type, v1, v2) (v1)!=(v2)
-#define LT(type, v1, v2) (v1)<(v2)
-#define LE(type, v1, v2) (v1)<=(v2)
-#define GT(type, v1, v2) (v1)>(v2)
-#define GE(type, v1, v2) (v1)>=(v2)
+#define DIFF_I(type, v1, v2) abs((v1) - (v2))
+#define DIFF_F(type, v1, v2) fabs((v1) - (v2))
+
+#define EQ(type, v1, v2) (v1) == (v2)
+#define NE(type, v1, v2) (v1) != (v2)
+#define LT(type, v1, v2) (v1) < (v2)
+#define LE(type, v1, v2) (v1) <= (v2)
+#define GT(type, v1, v2) (v1) > (v2)
+#define GE(type, v1, v2) (v1) >= (v2)

 UNOP(abs_I, ABS_I, INT32)
 UNOP(neg_I, NEG, INT32)
@@ -162,8 +163,7 @@
 BINOP(ge_F, GE, FLOAT32)

 static PyObject *
-_unop(PyObject* self, PyObject* args)
-{
+_unop(PyObject *self, PyObject *args) {
     Imaging out;
     Imaging im1;
     void (*unop)(Imaging, Imaging);
@@ -173,10 +173,10 @@
         return NULL;
     }

-    out = (Imaging) i0;
-    im1 = (Imaging) i1;
-
-    unop = (void*) op;
+    out = (Imaging)i0;
+    im1 = (Imaging)i1;
+
+    unop = (void *)op;

     unop(out, im1);

@@ -185,8 +185,7 @@
 }

 static PyObject *
-_binop(PyObject* self, PyObject* args)
-{
+_binop(PyObject *self, PyObject *args) {
     Imaging out;
     Imaging im1;
     Imaging im2;
@@ -197,11 +196,11 @@
         return NULL;
     }

-    out = (Imaging) i0;
-    im1 = (Imaging) i1;
-    im2 = (Imaging) i2;
-
-    binop = (void*) op;
+    out = (Imaging)i0;
+    im1 = (Imaging)i1;
+    im2 = (Imaging)i2;
+
+    binop = (void *)op;

     binop(out, im1, im2);

@@ -210,15 +209,11 @@
 }

 static PyMethodDef _functions[] = {
-    {"unop", _unop, 1},
-    {"binop", _binop, 1},
-    {NULL, NULL}
-};
+    {"unop", _unop, 1}, {"binop", _binop, 1}, {NULL, NULL}};

 static void
-install(PyObject *d, char* name, void* value)
-{
-    PyObject *v = PyLong_FromSsize_t((Py_ssize_t) value);
+install(PyObject *d, char *name, void *value) {
+    PyObject *v = PyLong_FromSsize_t((Py_ssize_t)value);
     if (!v || PyDict_SetItemString(d, name, v)) {
         PyErr_Clear();
     }
@@ -226,8 +221,8 @@
 }

 static int
-setup_module(PyObject* m) {
-    PyObject* d = PyModule_GetDict(m);
+setup_module(PyObject *m) {
+    PyObject *d = PyModule_GetDict(m);

     install(d, "abs_I", abs_I);
     install(d, "neg_I", neg_I);
@@ -279,14 +274,14 @@

 PyMODINIT_FUNC
 PyInit__imagingmath(void) {
-    PyObject* m;
+    PyObject *m;

     static PyModuleDef module_def = {
         PyModuleDef_HEAD_INIT,
-        "_imagingmath",     /* m_name */
-        NULL,               /* m_doc */
-        -1,                 /* m_size */
-        _functions,         /* m_methods */
+        "_imagingmath", /* m_name */
+        NULL,           /* m_doc */
+        -1,             /* m_size */
+        _functions,     /* m_methods */
     };

     m = PyModule_Create(&module_def);
('src', 'decode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -34,36 +34,34 @@

 #include "libImaging/Imaging.h"

+#include "libImaging/Bit.h"
+#include "libImaging/Bcn.h"
 #include "libImaging/Gif.h"
 #include "libImaging/Raw.h"
-#include "libImaging/Bit.h"
 #include "libImaging/Sgi.h"

-
 /* -------------------------------------------------------------------- */
 /* Common                                                               */
 /* -------------------------------------------------------------------- */

 typedef struct {
-    PyObject_HEAD
-    int (*decode)(Imaging im, ImagingCodecState state,
-                  UINT8* buffer, Py_ssize_t bytes);
+    PyObject_HEAD int (*decode)(
+        Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
     int (*cleanup)(ImagingCodecState state);
     struct ImagingCodecStateInstance state;
     Imaging im;
-    PyObject* lock;
+    PyObject *lock;
     int pulls_fd;
 } ImagingDecoderObject;

 static PyTypeObject ImagingDecoderType;

-static ImagingDecoderObject*
-PyImaging_DecoderNew(int contextsize)
-{
+static ImagingDecoderObject *
+PyImaging_DecoderNew(int contextsize) {
     ImagingDecoderObject *decoder;
     void *context;

-    if(PyType_Ready(&ImagingDecoderType) < 0) {
+    if (PyType_Ready(&ImagingDecoderType) < 0) {
         return NULL;
     }

@@ -77,10 +75,10 @@

     /* Allocate decoder context */
     if (contextsize > 0) {
-        context = (void*) calloc(1, contextsize);
+        context = (void *)calloc(1, contextsize);
         if (!context) {
             Py_DECREF(decoder);
-            (void) ImagingError_MemoryError();
+            (void)ImagingError_MemoryError();
             return NULL;
         }
     } else {
@@ -105,8 +103,7 @@
 }

 static void
-_dealloc(ImagingDecoderObject* decoder)
-{
+_dealloc(ImagingDecoderObject *decoder) {
     if (decoder->cleanup) {
         decoder->cleanup(&decoder->state);
     }
@@ -117,10 +114,9 @@
     PyObject_Del(decoder);
 }

-static PyObject*
-_decode(ImagingDecoderObject* decoder, PyObject* args)
-{
-    UINT8* buffer;
+static PyObject *
+_decode(ImagingDecoderObject *decoder, PyObject *args) {
+    UINT8 *buffer;
     Py_ssize_t bufsize;
     int status;
     ImagingSectionCookie cookie;
@@ -142,26 +138,23 @@
     return Py_BuildValue("ii", status, decoder->state.errcode);
 }

-static PyObject*
-_decode_cleanup(ImagingDecoderObject* decoder, PyObject* args)
-{
+static PyObject *
+_decode_cleanup(ImagingDecoderObject *decoder, PyObject *args) {
     int status = 0;

-    if (decoder->cleanup){
+    if (decoder->cleanup) {
         status = decoder->cleanup(&decoder->state);
     }

     return Py_BuildValue("i", status);
 }

-
-
-extern Imaging PyImaging_AsImaging(PyObject *op);
-
-static PyObject*
-_setimage(ImagingDecoderObject* decoder, PyObject* args)
-{
-    PyObject* op;
+extern Imaging
+PyImaging_AsImaging(PyObject *op);
+
+static PyObject *
+_setimage(ImagingDecoderObject *decoder, PyObject *args) {
+    PyObject *op;
     Imaging im;
     ImagingCodecState state;
     int x0, y0, x1, y1;
@@ -192,10 +185,8 @@
         state->ysize = y1 - y0;
     }

-    if (state->xsize <= 0 ||
-        state->xsize + state->xoff > (int) im->xsize ||
-        state->ysize <= 0 ||
-        state->ysize + state->yoff > (int) im->ysize) {
+    if (state->xsize <= 0 || state->xsize + state->xoff > (int)im->xsize ||
+        state->ysize <= 0 || state->ysize + state->yoff > (int)im->ysize) {
         PyErr_SetString(PyExc_ValueError, "tile cannot extend outside image");
         return NULL;
     }
@@ -203,13 +194,13 @@
     /* Allocate memory buffer (if bits field is set) */
     if (state->bits > 0) {
         if (!state->bytes) {
-            if (state->xsize > ((INT_MAX / state->bits)-7)){
+            if (state->xsize > ((INT_MAX / state->bits) - 7)) {
                 return ImagingError_MemoryError();
             }
-            state->bytes = (state->bits * state->xsize+7)/8;
+            state->bytes = (state->bits * state->xsize + 7) / 8;
         }
         /* malloc check ok, overflow checked above */
-        state->buffer = (UINT8*) malloc(state->bytes);
+        state->buffer = (UINT8 *)calloc(1, state->bytes);
         if (!state->buffer) {
             return ImagingError_MemoryError();
         }
@@ -225,10 +216,9 @@
     return Py_None;
 }

-static PyObject*
-_setfd(ImagingDecoderObject* decoder, PyObject* args)
-{
-    PyObject* fd;
+static PyObject *
+_setfd(ImagingDecoderObject *decoder, PyObject *args) {
+    PyObject *fd;
     ImagingCodecState state;

     if (!PyArg_ParseTuple(args, "O", &fd)) {
@@ -244,75 +234,72 @@
     return Py_None;
 }

-
 static PyObject *
-_get_pulls_fd(ImagingDecoderObject *decoder)
-{
+_get_pulls_fd(ImagingDecoderObject *decoder, void *closure) {
     return PyBool_FromLong(decoder->pulls_fd);
 }

 static struct PyMethodDef methods[] = {
-    {"decode", (PyCFunction)_decode, 1},
-    {"cleanup", (PyCFunction)_decode_cleanup, 1},
-    {"setimage", (PyCFunction)_setimage, 1},
-    {"setfd", (PyCFunction)_setfd, 1},
+    {"decode", (PyCFunction)_decode, METH_VARARGS},
+    {"cleanup", (PyCFunction)_decode_cleanup, METH_VARARGS},
+    {"setimage", (PyCFunction)_setimage, METH_VARARGS},
+    {"setfd", (PyCFunction)_setfd, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };

 static struct PyGetSetDef getseters[] = {
-   {"pulls_fd", (getter)_get_pulls_fd, NULL,
+    {"pulls_fd",
+     (getter)_get_pulls_fd,
+     NULL,
      "True if this decoder expects to pull from self.fd itself.",
      NULL},
     {NULL, NULL, NULL, NULL, NULL} /* sentinel */
 };

 static PyTypeObject ImagingDecoderType = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "ImagingDecoder",               /*tp_name*/
-    sizeof(ImagingDecoderObject),   /*tp_size*/
-    0,                              /*tp_itemsize*/
+    PyVarObject_HEAD_INIT(NULL, 0) "ImagingDecoder", /*tp_name*/
+    sizeof(ImagingDecoderObject),                    /*tp_size*/
+    0,                                               /*tp_itemsize*/
     /* methods */
-    (destructor)_dealloc,           /*tp_dealloc*/
-    0,                              /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    methods,                    /*tp_methods*/
-    0,                          /*tp_members*/
-    getseters,                  /*tp_getset*/
+    (destructor)_dealloc, /*tp_dealloc*/
+    0,                    /*tp_print*/
+    0,                    /*tp_getattr*/
+    0,                    /*tp_setattr*/
+    0,                    /*tp_compare*/
+    0,                    /*tp_repr*/
+    0,                    /*tp_as_number */
+    0,                    /*tp_as_sequence */
+    0,                    /*tp_as_mapping */
+    0,                    /*tp_hash*/
+    0,                    /*tp_call*/
+    0,                    /*tp_str*/
+    0,                    /*tp_getattro*/
+    0,                    /*tp_setattro*/
+    0,                    /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,   /*tp_flags*/
+    0,                    /*tp_doc*/
+    0,                    /*tp_traverse*/
+    0,                    /*tp_clear*/
+    0,                    /*tp_richcompare*/
+    0,                    /*tp_weaklistoffset*/
+    0,                    /*tp_iter*/
+    0,                    /*tp_iternext*/
+    methods,              /*tp_methods*/
+    0,                    /*tp_members*/
+    getseters,            /*tp_getset*/
 };

 /* -------------------------------------------------------------------- */

 int
-get_unpacker(ImagingDecoderObject* decoder, const char* mode,
-             const char* rawmode)
-{
+get_unpacker(ImagingDecoderObject *decoder, const char *mode, const char *rawmode) {
     int bits;
     ImagingShuffler unpack;

     unpack = ImagingFindUnpacker(mode, rawmode, &bits);
     if (!unpack) {
         Py_DECREF(decoder);
-        PyErr_SetString(PyExc_ValueError, "unknown raw mode");
+        PyErr_SetString(PyExc_ValueError, "unknown raw mode for given image mode");
         return -1;
     }

@@ -322,24 +309,21 @@
     return 0;
 }

-
 /* -------------------------------------------------------------------- */
 /* BIT (packed fields)                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_BitDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    int bits  = 8;
-    int pad   = 8;
-    int fill  = 0;
-    int sign  = 0;
+PyObject *
+PyImaging_BitDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    int bits = 8;
+    int pad = 8;
+    int fill = 0;
+    int sign = 0;
     int ystep = 1;
-    if (!PyArg_ParseTuple(args, "s|iiiii", &mode, &bits, &pad, &fill,
-                          &sign, &ystep)) {
+    if (!PyArg_ParseTuple(args, "s|iiiii", &mode, &bits, &pad, &fill, &sign, &ystep)) {
         return NULL;
     }

@@ -357,47 +341,50 @@

     decoder->state.ystep = ystep;

-    ((BITSTATE*)decoder->state.context)->bits = bits;
-    ((BITSTATE*)decoder->state.context)->pad  = pad;
-    ((BITSTATE*)decoder->state.context)->fill = fill;
-    ((BITSTATE*)decoder->state.context)->sign = sign;
-
-    return (PyObject*) decoder;
-}
-
+    ((BITSTATE *)decoder->state.context)->bits = bits;
+    ((BITSTATE *)decoder->state.context)->pad = pad;
+    ((BITSTATE *)decoder->state.context)->fill = fill;
+    ((BITSTATE *)decoder->state.context)->sign = sign;
+
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* BCn: GPU block-compressed texture formats                            */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_BcnDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* actual;
+PyObject *
+PyImaging_BcnDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *actual;
     int n = 0;
-    int ystep = 1;
-    if (!PyArg_ParseTuple(args, "s|ii", &mode, &n, &ystep)) {
+    char *pixel_format = "";
+    if (!PyArg_ParseTuple(args, "si|s", &mode, &n, &pixel_format)) {
         return NULL;
     }

     switch (n) {
-    case 1: /* BC1: 565 color, 1-bit alpha */
-    case 2: /* BC2: 565 color, 4-bit alpha */
-    case 3: /* BC3: 565 color, 2-endpoint 8-bit interpolated alpha */
-    case 5: /* BC5: 2-channel 8-bit via 2 BC3 alpha blocks */
-    case 7: /* BC7: 4-channel 8-bit via everything */
-        actual = "RGBA"; break;
-    case 4: /* BC4: 1-channel 8-bit via 1 BC3 alpha block */
-        actual = "L"; break;
-    case 6: /* BC6: 3-channel 16-bit float */
-        /* TODO: support 4-channel floating point images */
-        actual = "RGBAF"; break;
-    default:
-        PyErr_SetString(PyExc_ValueError, "block compression type unknown");
-        return NULL;
+        case 1: /* BC1: 565 color, 1-bit alpha */
+        case 2: /* BC2: 565 color, 4-bit alpha */
+        case 3: /* BC3: 565 color, 2-endpoint 8-bit interpolated alpha */
+        case 7: /* BC7: 4-channel 8-bit via everything */
+            actual = "RGBA";
+            break;
+        case 4: /* BC4: 1-channel 8-bit via 1 BC3 alpha block */
+            actual = "L";
+            break;
+        case 5: /* BC5: 2-channel 8-bit via 2 BC3 alpha blocks */
+            actual = "RGB";
+            break;
+        case 6: /* BC6: 3-channel 16-bit float */
+            /* TODO: support 4-channel floating point images */
+            actual = "RGBAF";
+            break;
+        default:
+            PyErr_SetString(PyExc_ValueError, "block compression type unknown");
+            return NULL;
     }

     if (strcmp(mode, actual) != 0) {
@@ -405,27 +392,25 @@
         return NULL;
     }

-    decoder = PyImaging_DecoderNew(0);
+    decoder = PyImaging_DecoderNew(sizeof(char *));
     if (decoder == NULL) {
         return NULL;
     }

     decoder->decode = ImagingBcnDecode;
     decoder->state.state = n;
-    decoder->state.ystep = ystep;
-
-    return (PyObject*) decoder;
-}
-
+    ((BCNSTATE *)decoder->state.context)->pixel_format = pixel_format;
+
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* FLI                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_FliDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
+PyObject *
+PyImaging_FliDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;

     decoder = PyImaging_DecoderNew(0);
     if (decoder == NULL) {
@@ -434,23 +419,22 @@

     decoder->decode = ImagingFliDecode;

-    return (PyObject*) decoder;
-}
-
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* GIF                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_GifDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
+PyObject *
+PyImaging_GifDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
     int bits = 8;
     int interlace = 0;
-    if (!PyArg_ParseTuple(args, "s|ii", &mode, &bits, &interlace)) {
+    int transparency = -1;
+    if (!PyArg_ParseTuple(args, "s|iii", &mode, &bits, &interlace, &transparency)) {
         return NULL;
     }

@@ -466,24 +450,23 @@

     decoder->decode = ImagingGifDecode;

-    ((GIFDECODERSTATE*)decoder->state.context)->bits = bits;
-    ((GIFDECODERSTATE*)decoder->state.context)->interlace = interlace;
-
-    return (PyObject*) decoder;
-}
-
+    ((GIFDECODERSTATE *)decoder->state.context)->bits = bits;
+    ((GIFDECODERSTATE *)decoder->state.context)->interlace = interlace;
+    ((GIFDECODERSTATE *)decoder->state.context)->transparency = transparency;
+
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* HEX                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_HexDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_HexDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;
     if (!PyArg_ParseTuple(args, "ss", &mode, &rawmode)) {
         return NULL;
     }
@@ -499,9 +482,8 @@

     decoder->decode = ImagingHexDecode;

-    return (PyObject*) decoder;
-}
-
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* LibTiff                                                              */
@@ -513,17 +495,16 @@

 #include <string.h>

-PyObject*
-PyImaging_LibTiffDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-    char* mode;
-    char* rawmode;
-    char* compname;
+PyObject *
+PyImaging_LibTiffDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+    char *mode;
+    char *rawmode;
+    char *compname;
     int fp;
-    uint32 ifdoffset;
-
-    if (! PyArg_ParseTuple(args, "sssiI", &mode, &rawmode, &compname, &fp, &ifdoffset)) {
+    uint32_t ifdoffset;
+
+    if (!PyArg_ParseTuple(args, "sssiI", &mode, &rawmode, &compname, &fp, &ifdoffset)) {
         return NULL;
     }

@@ -538,31 +519,29 @@
         return NULL;
     }

-    if (! ImagingLibTiffInit(&decoder->state, fp, ifdoffset)) {
+    if (!ImagingLibTiffInit(&decoder->state, fp, ifdoffset)) {
         Py_DECREF(decoder);
         PyErr_SetString(PyExc_RuntimeError, "tiff codec initialization failed");
         return NULL;
     }

-    decoder->decode  = ImagingLibTiffDecode;
-
-    return (PyObject*) decoder;
+    decoder->decode = ImagingLibTiffDecode;
+
+    return (PyObject *)decoder;
 }

 #endif

-
 /* -------------------------------------------------------------------- */
 /* PackBits                                                             */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_PackbitsDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_PackbitsDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;
     if (!PyArg_ParseTuple(args, "ss", &mode, &rawmode)) {
         return NULL;
     }
@@ -578,18 +557,16 @@

     decoder->decode = ImagingPackbitsDecode;

-    return (PyObject*) decoder;
-}
-
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* PCD                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_PcdDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
+PyObject *
+PyImaging_PcdDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;

     decoder = PyImaging_DecoderNew(0);
     if (decoder == NULL) {
@@ -603,21 +580,19 @@

     decoder->decode = ImagingPcdDecode;

-    return (PyObject*) decoder;
-}
-
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* PCX                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_PcxDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_PcxDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;
     int stride;
     if (!PyArg_ParseTuple(args, "ssi", &mode, &rawmode, &stride)) {
         return NULL;
@@ -636,23 +611,21 @@

     decoder->decode = ImagingPcxDecode;

-    return (PyObject*) decoder;
-}
-
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* RAW                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_RawDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_RawDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;
     int stride = 0;
-    int ystep  = 1;
+    int ystep = 1;
     if (!PyArg_ParseTuple(args, "ss|ii", &mode, &rawmode, &stride, &ystep)) {
         return NULL;
     }
@@ -670,23 +643,21 @@

     decoder->state.ystep = ystep;

-    ((RAWSTATE*)decoder->state.context)->stride = stride;
-
-    return (PyObject*) decoder;
-}
-
+    ((RAWSTATE *)decoder->state.context)->stride = stride;
+
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* SGI RLE                                                              */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_SgiRleDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_SgiRleDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;
     int ystep = 1;
     int bpc = 1;
     if (!PyArg_ParseTuple(args, "ss|ii", &mode, &rawmode, &ystep, &bpc)) {
@@ -706,23 +677,21 @@
     decoder->decode = ImagingSgiRleDecode;
     decoder->state.ystep = ystep;

-    ((SGISTATE*)decoder->state.context)->bpc = bpc;
-
-    return (PyObject*) decoder;
-}
-
+    ((SGISTATE *)decoder->state.context)->bpc = bpc;
+
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* SUN RLE                                                              */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_SunRleDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_SunRleDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;
     if (!PyArg_ParseTuple(args, "ss", &mode, &rawmode)) {
         return NULL;
     }
@@ -738,21 +707,19 @@

     decoder->decode = ImagingSunRleDecode;

-    return (PyObject*) decoder;
-}
-
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* TGA RLE                                                              */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_TgaRleDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_TgaRleDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;
     int ystep = 1;
     int depth = 8;
     if (!PyArg_ParseTuple(args, "ss|ii", &mode, &rawmode, &ystep, &depth)) {
@@ -773,18 +740,16 @@
     decoder->state.ystep = ystep;
     decoder->state.count = depth / 8;

-    return (PyObject*) decoder;
-}
-
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* XBM                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_XbmDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
+PyObject *
+PyImaging_XbmDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;

     decoder = PyImaging_DecoderNew(0);
     if (decoder == NULL) {
@@ -797,9 +762,8 @@

     decoder->decode = ImagingXbmDecode;

-    return (PyObject*) decoder;
-}
-
+    return (PyObject *)decoder;
+}

 /* -------------------------------------------------------------------- */
 /* ZIP                                                                  */
@@ -809,13 +773,12 @@

 #include "libImaging/ZipCodecs.h"

-PyObject*
-PyImaging_ZipDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_ZipDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;
     int interlaced = 0;
     if (!PyArg_ParseTuple(args, "ss|i", &mode, &rawmode, &interlaced)) {
         return NULL;
@@ -833,12 +796,11 @@
     decoder->decode = ImagingZipDecode;
     decoder->cleanup = ImagingZipDecodeCleanup;

-    ((ZIPSTATE*)decoder->state.context)->interlaced = interlaced;
-
-    return (PyObject*) decoder;
+    ((ZIPSTATE *)decoder->state.context)->interlaced = interlaced;
+
+    return (PyObject *)decoder;
 }
 #endif
-

 /* -------------------------------------------------------------------- */
 /* JPEG                                                                 */
@@ -849,31 +811,29 @@
 /* We better define this decoder last in this file, so the following
    undef's won't mess things up for the Imaging library proper. */

-#undef  HAVE_PROTOTYPES
-#undef  HAVE_STDDEF_H
-#undef  HAVE_STDLIB_H
-#undef  UINT8
-#undef  UINT16
-#undef  UINT32
-#undef  INT8
-#undef  INT16
-#undef  INT32
+#undef HAVE_PROTOTYPES
+#undef HAVE_STDDEF_H
+#undef HAVE_STDLIB_H
+#undef UINT8
+#undef UINT16
+#undef UINT32
+#undef INT8
+#undef INT16
+#undef INT32

 #include "libImaging/Jpeg.h"

-PyObject*
-PyImaging_JpegDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
-
-    char* mode;
-    char* rawmode; /* what we want from the decoder */
-    char* jpegmode; /* what's in the file */
+PyObject *
+PyImaging_JpegDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
+
+    char *mode;
+    char *rawmode;  /* what we want from the decoder */
+    char *jpegmode; /* what's in the file */
     int scale = 1;
     int draft = 0;

-    if (!PyArg_ParseTuple(args, "ssz|ii", &mode, &rawmode, &jpegmode,
-                          &scale, &draft)) {
+    if (!PyArg_ParseTuple(args, "ssz|ii", &mode, &rawmode, &jpegmode, &scale, &draft)) {
         return NULL;
     }

@@ -900,13 +860,13 @@
     decoder->decode = ImagingJpegDecode;
     decoder->cleanup = ImagingJpegDecodeCleanup;

-    strncpy(((JPEGSTATE*)decoder->state.context)->rawmode, rawmode, 8);
-    strncpy(((JPEGSTATE*)decoder->state.context)->jpegmode, jpegmode, 8);
-
-    ((JPEGSTATE*)decoder->state.context)->scale = scale;
-    ((JPEGSTATE*)decoder->state.context)->draft = draft;
-
-    return (PyObject*) decoder;
+    strncpy(((JPEGSTATE *)decoder->state.context)->rawmode, rawmode, 8);
+    strncpy(((JPEGSTATE *)decoder->state.context)->jpegmode, jpegmode, 8);
+
+    ((JPEGSTATE *)decoder->state.context)->scale = scale;
+    ((JPEGSTATE *)decoder->state.context)->draft = draft;
+
+    return (PyObject *)decoder;
 }
 #endif

@@ -918,22 +878,21 @@

 #include "libImaging/Jpeg2K.h"

-PyObject*
-PyImaging_Jpeg2KDecoderNew(PyObject* self, PyObject* args)
-{
-    ImagingDecoderObject* decoder;
+PyObject *
+PyImaging_Jpeg2KDecoderNew(PyObject *self, PyObject *args) {
+    ImagingDecoderObject *decoder;
     JPEG2KDECODESTATE *context;

-    char* mode;
-    char* format;
+    char *mode;
+    char *format;
     OPJ_CODEC_FORMAT codec_format;
     int reduce = 0;
     int layers = 0;
     int fd = -1;
     PY_LONG_LONG length = -1;

-    if (!PyArg_ParseTuple(args, "ss|iiiL", &mode, &format,
-                          &reduce, &layers, &fd, &length)) {
+    if (!PyArg_ParseTuple(
+            args, "ss|iiiL", &mode, &format, &reduce, &layers, &fd, &length)) {
         return NULL;
     }

@@ -964,7 +923,6 @@
     context->reduce = reduce;
     context->layers = layers;

-    return (PyObject*) decoder;
+    return (PyObject *)decoder;
 }
 #endif /* HAVE_OPENJPEG */
-
('src', 'encode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -37,25 +37,23 @@
 /* -------------------------------------------------------------------- */

 typedef struct {
-    PyObject_HEAD
-    int (*encode)(Imaging im, ImagingCodecState state,
-                  UINT8* buffer, int bytes);
+    PyObject_HEAD int (*encode)(
+        Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
     int (*cleanup)(ImagingCodecState state);
     struct ImagingCodecStateInstance state;
     Imaging im;
-    PyObject* lock;
+    PyObject *lock;
     int pushes_fd;
 } ImagingEncoderObject;

 static PyTypeObject ImagingEncoderType;

-static ImagingEncoderObject*
-PyImaging_EncoderNew(int contextsize)
-{
+static ImagingEncoderObject *
+PyImaging_EncoderNew(int contextsize) {
     ImagingEncoderObject *encoder;
     void *context;

-    if(PyType_Ready(&ImagingEncoderType) < 0) {
+    if (PyType_Ready(&ImagingEncoderType) < 0) {
         return NULL;
     }

@@ -69,10 +67,10 @@

     /* Allocate encoder context */
     if (contextsize > 0) {
-        context = (void*) calloc(1, contextsize);
+        context = (void *)calloc(1, contextsize);
         if (!context) {
             Py_DECREF(encoder);
-            (void) ImagingError_MemoryError();
+            (void)ImagingError_MemoryError();
             return NULL;
         }
     } else {
@@ -94,8 +92,7 @@
 }

 static void
-_dealloc(ImagingEncoderObject* encoder)
-{
+_dealloc(ImagingEncoderObject *encoder) {
     if (encoder->cleanup) {
         encoder->cleanup(&encoder->state);
     }
@@ -106,23 +103,21 @@
     PyObject_Del(encoder);
 }

-static PyObject*
-_encode_cleanup(ImagingEncoderObject* encoder, PyObject* args)
-{
+static PyObject *
+_encode_cleanup(ImagingEncoderObject *encoder, PyObject *args) {
     int status = 0;

-    if (encoder->cleanup){
+    if (encoder->cleanup) {
         status = encoder->cleanup(&encoder->state);
     }

     return Py_BuildValue("i", status);
 }

-static PyObject*
-_encode(ImagingEncoderObject* encoder, PyObject* args)
-{
-    PyObject* buf;
-    PyObject* result;
+static PyObject *
+_encode(ImagingEncoderObject *encoder, PyObject *args) {
+    PyObject *buf;
+    PyObject *result;
     int status;

     /* Encode to a Python string (allocated by this method) */
@@ -138,8 +133,8 @@
         return NULL;
     }

-    status = encoder->encode(encoder->im, &encoder->state,
-                             (UINT8*) PyBytes_AsString(buf), bufsize);
+    status = encoder->encode(
+        encoder->im, &encoder->state, (UINT8 *)PyBytes_AsString(buf), bufsize);

     /* adjust string length to avoid slicing in encoder */
     if (_PyBytes_Resize(&buf, (status > 0) ? status : 0) < 0) {
@@ -153,31 +148,27 @@
     return result;
 }

-static PyObject*
-_encode_to_pyfd(ImagingEncoderObject* encoder, PyObject* args)
-{
-
+static PyObject *
+_encode_to_pyfd(ImagingEncoderObject *encoder) {
     PyObject *result;
     int status;

     if (!encoder->pushes_fd) {
         // UNDONE, appropriate errcode???
-        result = Py_BuildValue("ii", 0, IMAGING_CODEC_CONFIG);;
+        result = Py_BuildValue("ii", 0, IMAGING_CODEC_CONFIG);
         return result;
     }

-    status = encoder->encode(encoder->im, &encoder->state,
-                             (UINT8*) NULL, 0);
+    status = encoder->encode(encoder->im, &encoder->state, (UINT8 *)NULL, 0);

     result = Py_BuildValue("ii", status, encoder->state.errcode);

     return result;
 }

-static PyObject*
-_encode_to_file(ImagingEncoderObject* encoder, PyObject* args)
-{
-    UINT8* buf;
+static PyObject *
+_encode_to_file(ImagingEncoderObject *encoder, PyObject *args) {
+    UINT8 *buf;
     int status;
     ImagingSectionCookie cookie;

@@ -192,7 +183,7 @@

     /* Allocate an encoder buffer */
     /* malloc check ok, either constant int, or checked by PyArg_ParseTuple */
-    buf = (UINT8*) malloc(bufsize);
+    buf = (UINT8 *)malloc(bufsize);
     if (!buf) {
         return ImagingError_MemoryError();
     }
@@ -200,7 +191,6 @@
     ImagingSectionEnter(&cookie);

     do {
-
         /* This replaces the inner loop in the ImageFile _save
            function. */

@@ -223,12 +213,12 @@
     return Py_BuildValue("i", encoder->state.errcode);
 }

-extern Imaging PyImaging_AsImaging(PyObject *op);
-
-static PyObject*
-_setimage(ImagingEncoderObject* encoder, PyObject* args)
-{
-    PyObject* op;
+extern Imaging
+PyImaging_AsImaging(PyObject *op);
+
+static PyObject *
+_setimage(ImagingEncoderObject *encoder, PyObject *args) {
+    PyObject *op;
     Imaging im;
     ImagingCodecState state;
     Py_ssize_t x0, y0, x1, y1;
@@ -260,22 +250,20 @@
         state->ysize = y1 - y0;
     }

-    if (state->xsize <= 0 ||
-        state->xsize + state->xoff > im->xsize ||
-        state->ysize <= 0 ||
-        state->ysize + state->yoff > im->ysize) {
+    if (state->xsize <= 0 || state->xsize + state->xoff > im->xsize ||
+        state->ysize <= 0 || state->ysize + state->yoff > im->ysize) {
         PyErr_SetString(PyExc_SystemError, "tile cannot extend outside image");
         return NULL;
     }

     /* Allocate memory buffer (if bits field is set) */
     if (state->bits > 0) {
-        if (state->xsize > ((INT_MAX / state->bits)-7)) {
+        if (state->xsize > ((INT_MAX / state->bits) - 7)) {
             return ImagingError_MemoryError();
         }
-        state->bytes = (state->bits * state->xsize+7)/8;
+        state->bytes = (state->bits * state->xsize + 7) / 8;
         /* malloc check ok, overflow checked above */
-        state->buffer = (UINT8*) malloc(state->bytes);
+        state->buffer = (UINT8 *)calloc(1, state->bytes);
         if (!state->buffer) {
             return ImagingError_MemoryError();
         }
@@ -291,10 +279,9 @@
     return Py_None;
 }

-static PyObject*
-_setfd(ImagingEncoderObject* encoder, PyObject* args)
-{
-    PyObject* fd;
+static PyObject *
+_setfd(ImagingEncoderObject *encoder, PyObject *args) {
+    PyObject *fd;
     ImagingCodecState state;

     if (!PyArg_ParseTuple(args, "O", &fd)) {
@@ -311,68 +298,66 @@
 }

 static PyObject *
-_get_pushes_fd(ImagingEncoderObject *encoder)
-{
+_get_pushes_fd(ImagingEncoderObject *encoder, void *closure) {
     return PyBool_FromLong(encoder->pushes_fd);
 }

 static struct PyMethodDef methods[] = {
-    {"encode", (PyCFunction)_encode, 1},
-    {"cleanup", (PyCFunction)_encode_cleanup, 1},
-    {"encode_to_file", (PyCFunction)_encode_to_file, 1},
-    {"encode_to_pyfd", (PyCFunction)_encode_to_pyfd, 1},
-    {"setimage", (PyCFunction)_setimage, 1},
-    {"setfd", (PyCFunction)_setfd, 1},
+    {"encode", (PyCFunction)_encode, METH_VARARGS},
+    {"cleanup", (PyCFunction)_encode_cleanup, METH_VARARGS},
+    {"encode_to_file", (PyCFunction)_encode_to_file, METH_VARARGS},
+    {"encode_to_pyfd", (PyCFunction)_encode_to_pyfd, METH_NOARGS},
+    {"setimage", (PyCFunction)_setimage, METH_VARARGS},
+    {"setfd", (PyCFunction)_setfd, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };

 static struct PyGetSetDef getseters[] = {
-   {"pushes_fd", (getter)_get_pushes_fd, NULL,
+    {"pushes_fd",
+     (getter)_get_pushes_fd,
+     NULL,
      "True if this decoder expects to push directly to self.fd",
      NULL},
     {NULL, NULL, NULL, NULL, NULL} /* sentinel */
 };

 static PyTypeObject ImagingEncoderType = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "ImagingEncoder",               /*tp_name*/
-    sizeof(ImagingEncoderObject),   /*tp_size*/
-    0,                              /*tp_itemsize*/
+    PyVarObject_HEAD_INIT(NULL, 0) "ImagingEncoder", /*tp_name*/
+    sizeof(ImagingEncoderObject),                    /*tp_size*/
+    0,                                               /*tp_itemsize*/
     /* methods */
-    (destructor)_dealloc,           /*tp_dealloc*/
-    0,                              /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    methods,                    /*tp_methods*/
-    0,                          /*tp_members*/
-    getseters,                  /*tp_getset*/
+    (destructor)_dealloc, /*tp_dealloc*/
+    0,                    /*tp_print*/
+    0,                    /*tp_getattr*/
+    0,                    /*tp_setattr*/
+    0,                    /*tp_compare*/
+    0,                    /*tp_repr*/
+    0,                    /*tp_as_number */
+    0,                    /*tp_as_sequence */
+    0,                    /*tp_as_mapping */
+    0,                    /*tp_hash*/
+    0,                    /*tp_call*/
+    0,                    /*tp_str*/
+    0,                    /*tp_getattro*/
+    0,                    /*tp_setattro*/
+    0,                    /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,   /*tp_flags*/
+    0,                    /*tp_doc*/
+    0,                    /*tp_traverse*/
+    0,                    /*tp_clear*/
+    0,                    /*tp_richcompare*/
+    0,                    /*tp_weaklistoffset*/
+    0,                    /*tp_iter*/
+    0,                    /*tp_iternext*/
+    methods,              /*tp_methods*/
+    0,                    /*tp_members*/
+    getseters,            /*tp_getset*/
 };

 /* -------------------------------------------------------------------- */

 int
-get_packer(ImagingEncoderObject* encoder, const char* mode,
-           const char* rawmode)
-{
+get_packer(ImagingEncoderObject *encoder, const char *mode, const char *rawmode) {
     int bits;
     ImagingShuffler pack;

@@ -389,15 +374,13 @@
     return 0;
 }

-
 /* -------------------------------------------------------------------- */
 /* EPS                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_EpsEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
+PyObject *
+PyImaging_EpsEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;

     encoder = PyImaging_EncoderNew(0);
     if (encoder == NULL) {
@@ -406,18 +389,16 @@

     encoder->encode = ImagingEpsEncode;

-    return (PyObject*) encoder;
-}
-
+    return (PyObject *)encoder;
+}

 /* -------------------------------------------------------------------- */
 /* GIF                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_GifEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
+PyObject *
+PyImaging_GifEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;

     char *mode;
     char *rawmode;
@@ -438,21 +419,19 @@

     encoder->encode = ImagingGifEncode;

-    ((GIFENCODERSTATE*)encoder->state.context)->bits = bits;
-    ((GIFENCODERSTATE*)encoder->state.context)->interlace = interlace;
-
-    return (PyObject*) encoder;
-}
-
+    ((GIFENCODERSTATE *)encoder->state.context)->bits = bits;
+    ((GIFENCODERSTATE *)encoder->state.context)->interlace = interlace;
+
+    return (PyObject *)encoder;
+}

 /* -------------------------------------------------------------------- */
 /* PCX                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_PcxEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
+PyObject *
+PyImaging_PcxEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;

     char *mode;
     char *rawmode;
@@ -473,18 +452,16 @@

     encoder->encode = ImagingPcxEncode;

-    return (PyObject*) encoder;
-}
-
+    return (PyObject *)encoder;
+}

 /* -------------------------------------------------------------------- */
 /* RAW                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_RawEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
+PyObject *
+PyImaging_RawEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;

     char *mode;
     char *rawmode;
@@ -509,18 +486,16 @@
     encoder->state.ystep = ystep;
     encoder->state.count = stride;

-    return (PyObject*) encoder;
-}
-
+    return (PyObject *)encoder;
+}

 /* -------------------------------------------------------------------- */
 /* TGA                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_TgaRleEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
+PyObject *
+PyImaging_TgaRleEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;

     char *mode;
     char *rawmode;
@@ -543,19 +518,16 @@

     encoder->state.ystep = ystep;

-    return (PyObject*) encoder;
-}
-
-
+    return (PyObject *)encoder;
+}

 /* -------------------------------------------------------------------- */
 /* XBM                                                                  */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyImaging_XbmEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
+PyObject *
+PyImaging_XbmEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;

     encoder = PyImaging_EncoderNew(0);
     if (encoder == NULL) {
@@ -568,9 +540,8 @@

     encoder->encode = ImagingXbmEncode;

-    return (PyObject*) encoder;
-}
-
+    return (PyObject *)encoder;
+}

 /* -------------------------------------------------------------------- */
 /* ZIP                                                                  */
@@ -580,29 +551,34 @@

 #include "libImaging/ZipCodecs.h"

-PyObject*
-PyImaging_ZipEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
-
-    char* mode;
-    char* rawmode;
+PyObject *
+PyImaging_ZipEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;
+
+    char *mode;
+    char *rawmode;
     Py_ssize_t optimize = 0;
     Py_ssize_t compress_level = -1;
     Py_ssize_t compress_type = -1;
-    char* dictionary = NULL;
+    char *dictionary = NULL;
     Py_ssize_t dictionary_size = 0;
-    if (!PyArg_ParseTuple(args, "ss|nnny#", &mode, &rawmode,
-                          &optimize,
-                          &compress_level, &compress_type,
-                          &dictionary, &dictionary_size)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "ss|nnny#",
+            &mode,
+            &rawmode,
+            &optimize,
+            &compress_level,
+            &compress_type,
+            &dictionary,
+            &dictionary_size)) {
         return NULL;
     }

     /* Copy to avoid referencing Python's memory */
     if (dictionary && dictionary_size > 0) {
         /* malloc check ok, size comes from PyArg_ParseTuple */
-        char* p = malloc(dictionary_size);
+        char *p = malloc(dictionary_size);
         if (!p) {
             return ImagingError_MemoryError();
         }
@@ -628,20 +604,19 @@

     if (rawmode[0] == 'P') {
         /* disable filtering */
-        ((ZIPSTATE*)encoder->state.context)->mode = ZIP_PNG_PALETTE;
-    }
-
-    ((ZIPSTATE*)encoder->state.context)->optimize = optimize;
-    ((ZIPSTATE*)encoder->state.context)->compress_level = compress_level;
-    ((ZIPSTATE*)encoder->state.context)->compress_type = compress_type;
-    ((ZIPSTATE*)encoder->state.context)->dictionary = dictionary;
-    ((ZIPSTATE*)encoder->state.context)->dictionary_size = dictionary_size;
-
-    return (PyObject*) encoder;
+        ((ZIPSTATE *)encoder->state.context)->mode = ZIP_PNG_PALETTE;
+    }
+
+    ((ZIPSTATE *)encoder->state.context)->optimize = optimize;
+    ((ZIPSTATE *)encoder->state.context)->compress_level = compress_level;
+    ((ZIPSTATE *)encoder->state.context)->compress_type = compress_type;
+    ((ZIPSTATE *)encoder->state.context)->dictionary = dictionary;
+    ((ZIPSTATE *)encoder->state.context)->dictionary_size = dictionary_size;
+
+    return (PyObject *)encoder;
 }
 #endif

-
 /* -------------------------------------------------------------------- */
 /* LibTiff                                                              */
 /* -------------------------------------------------------------------- */
@@ -652,15 +627,14 @@

 #include <string.h>

-PyObject*
-PyImaging_LibTiffEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
-
-    char* mode;
-    char* rawmode;
-    char* compname;
-    char* filename;
+PyObject *
+PyImaging_LibTiffEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;
+
+    char *mode;
+    char *rawmode;
+    char *compname;
+    char *filename;
     Py_ssize_t fp;

     PyObject *tags, *types;
@@ -669,16 +643,24 @@
     int key_int, status, is_core_tag, is_var_length, num_core_tags, i;
     TIFFDataType type = TIFF_NOTYPE;
     // This list also exists in TiffTags.py
-    const int core_tags[] = {
-        256, 257, 258, 259, 262, 263, 266, 269, 274, 277, 278, 280, 281, 340,
-        341, 282, 283, 284, 286, 287, 296, 297, 320, 321, 338, 32995, 32998, 32996,
-        339, 32997, 330, 531, 530, 65537
-    };
+    const int core_tags[] = {256,   257, 258,   259, 262, 263, 266,   269,   274,
+                             277,   278, 280,   281, 340, 341, 282,   283,   284,
+                             286,   287, 296,   297, 320, 321, 338,   32995, 32998,
+                             32996, 339, 32997, 330, 531, 530, 65537, 301,   532};

     Py_ssize_t tags_size;
     PyObject *item;

-    if (! PyArg_ParseTuple(args, "sssnsOO", &mode, &rawmode, &compname, &fp, &filename, &tags, &types)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "sssnsOO",
+            &mode,
+            &rawmode,
+            &compname,
+            &fp,
+            &filename,
+            &tags,
+            &types)) {
         return NULL;
     }

@@ -688,11 +670,11 @@
     } else {
         tags_size = PyList_Size(tags);
         TRACE(("tags size: %d\n", (int)tags_size));
-        for (pos=0;pos<tags_size;pos++){
+        for (pos = 0; pos < tags_size; pos++) {
             item = PyList_GetItem(tags, pos);
             if (!PyTuple_Check(item) || PyTuple_Size(item) != 2) {
-               PyErr_SetString(PyExc_ValueError, "Invalid tags list");
-               return NULL;
+                PyErr_SetString(PyExc_ValueError, "Invalid tags list");
+                return NULL;
             }
         }
         pos = 0;
@@ -713,7 +695,7 @@
         return NULL;
     }

-    if (! ImagingLibTiffEncodeInit(&encoder->state, filename, fp)) {
+    if (!ImagingLibTiffEncodeInit(&encoder->state, filename, fp)) {
         Py_DECREF(encoder);
         PyErr_SetString(PyExc_RuntimeError, "tiff codec initialization failed");
         return NULL;
@@ -731,7 +713,7 @@
         is_var_length = 0;
         type = TIFF_NOTYPE;

-        for (i=0; i<num_core_tags; i++) {
+        for (i = 0; i < num_core_tags; i++) {
             if (core_tags[i] == key_int) {
                 is_core_tag = 1;
                 break;
@@ -747,7 +729,6 @@
                 }
             }
         }
-

         if (type == TIFF_NOTYPE) {
             // Autodetect type. Types should not be changed for backwards
@@ -774,9 +755,9 @@
             if (type == TIFF_NOTYPE) {
                 // Autodetect type based on first item. Types should not be
                 // changed for backwards compatibility.
-                if (PyLong_Check(PyTuple_GetItem(value,0))) {
+                if (PyLong_Check(PyTuple_GetItem(value, 0))) {
                     type = TIFF_LONG;
-                } else if (PyFloat_Check(PyTuple_GetItem(value,0))) {
+                } else if (PyFloat_Check(PyTuple_GetItem(value, 0))) {
                     type = TIFF_FLOAT;
                 }
             }
@@ -787,48 +768,61 @@
             if (type == TIFF_BYTE) {
                 is_var_length = 1;
             }
-            if (ImagingLibTiffMergeFieldInfo(&encoder->state, type, key_int, is_var_length)) {
+            if (ImagingLibTiffMergeFieldInfo(
+                    &encoder->state, type, key_int, is_var_length)) {
                 continue;
             }
         }

         if (type == TIFF_BYTE || type == TIFF_UNDEFINED) {
-            status = ImagingLibTiffSetField(&encoder->state,
-                    (ttag_t) key_int,
-                    PyBytes_Size(value), PyBytes_AsString(value));
+            status = ImagingLibTiffSetField(
+                &encoder->state,
+                (ttag_t)key_int,
+                PyBytes_Size(value),
+                PyBytes_AsString(value));
         } else if (is_var_length) {
-            Py_ssize_t len,i;
+            Py_ssize_t len, i;
             TRACE(("Setting from Tuple: %d \n", key_int));
             len = PyTuple_Size(value);

             if (key_int == TIFFTAG_COLORMAP) {
                 int stride = 256;
                 if (len != 768) {
-                    PyErr_SetString(PyExc_ValueError, "Requiring 768 items for for Colormap");
+                    PyErr_SetString(
+                        PyExc_ValueError, "Requiring 768 items for Colormap");
                     return NULL;
                 }
                 UINT16 *av;
                 /* malloc check ok, calloc checks for overflow */
                 av = calloc(len, sizeof(UINT16));
                 if (av) {
-                    for (i=0;i<len;i++) {
-                        av[i] = (UINT16)PyLong_AsLong(PyTuple_GetItem(value,i));
+                    for (i = 0; i < len; i++) {
+                        av[i] = (UINT16)PyLong_AsLong(PyTuple_GetItem(value, i));
                     }
-                    status = ImagingLibTiffSetField(&encoder->state, (ttag_t) key_int,
-                                                    av,
-                                                    av + stride,
-                                                    av + stride * 2);
+                    status = ImagingLibTiffSetField(
+                        &encoder->state,
+                        (ttag_t)key_int,
+                        av,
+                        av + stride,
+                        av + stride * 2);
                     free(av);
                 }
+            } else if (key_int == TIFFTAG_YCBCRSUBSAMPLING) {
+                status = ImagingLibTiffSetField(
+                    &encoder->state,
+                    (ttag_t)key_int,
+                    (UINT16)PyLong_AsLong(PyTuple_GetItem(value, 0)),
+                    (UINT16)PyLong_AsLong(PyTuple_GetItem(value, 1)));
             } else if (type == TIFF_SHORT) {
                 UINT16 *av;
                 /* malloc check ok, calloc checks for overflow */
                 av = calloc(len, sizeof(UINT16));
                 if (av) {
-                    for (i=0;i<len;i++) {
-                        av[i] = (UINT16)PyLong_AsLong(PyTuple_GetItem(value,i));
+                    for (i = 0; i < len; i++) {
+                        av[i] = (UINT16)PyLong_AsLong(PyTuple_GetItem(value, i));
                     }
-                    status = ImagingLibTiffSetField(&encoder->state, (ttag_t) key_int, len, av);
+                    status = ImagingLibTiffSetField(
+                        &encoder->state, (ttag_t)key_int, len, av);
                     free(av);
                 }
             } else if (type == TIFF_LONG) {
@@ -836,10 +830,11 @@
                 /* malloc check ok, calloc checks for overflow */
                 av = calloc(len, sizeof(UINT32));
                 if (av) {
-                    for (i=0;i<len;i++) {
-                        av[i] = (UINT32)PyLong_AsLong(PyTuple_GetItem(value,i));
+                    for (i = 0; i < len; i++) {
+                        av[i] = (UINT32)PyLong_AsLong(PyTuple_GetItem(value, i));
                     }
-                    status = ImagingLibTiffSetField(&encoder->state, (ttag_t) key_int, len, av);
+                    status = ImagingLibTiffSetField(
+                        &encoder->state, (ttag_t)key_int, len, av);
                     free(av);
                 }
             } else if (type == TIFF_SBYTE) {
@@ -847,10 +842,11 @@
                 /* malloc check ok, calloc checks for overflow */
                 av = calloc(len, sizeof(INT8));
                 if (av) {
-                    for (i=0;i<len;i++) {
-                        av[i] = (INT8)PyLong_AsLong(PyTuple_GetItem(value,i));
+                    for (i = 0; i < len; i++) {
+                        av[i] = (INT8)PyLong_AsLong(PyTuple_GetItem(value, i));
                     }
-                    status = ImagingLibTiffSetField(&encoder->state, (ttag_t) key_int, len, av);
+                    status = ImagingLibTiffSetField(
+                        &encoder->state, (ttag_t)key_int, len, av);
                     free(av);
                 }
             } else if (type == TIFF_SSHORT) {
@@ -858,10 +854,11 @@
                 /* malloc check ok, calloc checks for overflow */
                 av = calloc(len, sizeof(INT16));
                 if (av) {
-                    for (i=0;i<len;i++) {
-                        av[i] = (INT16)PyLong_AsLong(PyTuple_GetItem(value,i));
+                    for (i = 0; i < len; i++) {
+                        av[i] = (INT16)PyLong_AsLong(PyTuple_GetItem(value, i));
                     }
-                    status = ImagingLibTiffSetField(&encoder->state, (ttag_t) key_int, len, av);
+                    status = ImagingLibTiffSetField(
+                        &encoder->state, (ttag_t)key_int, len, av);
                     free(av);
                 }
             } else if (type == TIFF_SLONG) {
@@ -869,10 +866,11 @@
                 /* malloc check ok, calloc checks for overflow */
                 av = calloc(len, sizeof(INT32));
                 if (av) {
-                    for (i=0;i<len;i++) {
-                        av[i] = (INT32)PyLong_AsLong(PyTuple_GetItem(value,i));
+                    for (i = 0; i < len; i++) {
+                        av[i] = (INT32)PyLong_AsLong(PyTuple_GetItem(value, i));
                     }
-                    status = ImagingLibTiffSetField(&encoder->state, (ttag_t) key_int, len, av);
+                    status = ImagingLibTiffSetField(
+                        &encoder->state, (ttag_t)key_int, len, av);
                     free(av);
                 }
             } else if (type == TIFF_FLOAT) {
@@ -880,10 +878,11 @@
                 /* malloc check ok, calloc checks for overflow */
                 av = calloc(len, sizeof(FLOAT32));
                 if (av) {
-                    for (i=0;i<len;i++) {
-                        av[i] = (FLOAT32)PyFloat_AsDouble(PyTuple_GetItem(value,i));
+                    for (i = 0; i < len; i++) {
+                        av[i] = (FLOAT32)PyFloat_AsDouble(PyTuple_GetItem(value, i));
                     }
-                    status = ImagingLibTiffSetField(&encoder->state, (ttag_t) key_int, len, av);
+                    status = ImagingLibTiffSetField(
+                        &encoder->state, (ttag_t)key_int, len, av);
                     free(av);
                 }
             } else if (type == TIFF_DOUBLE) {
@@ -891,54 +890,47 @@
                 /* malloc check ok, calloc checks for overflow */
                 av = calloc(len, sizeof(FLOAT64));
                 if (av) {
-                    for (i=0;i<len;i++) {
-                        av[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
+                    for (i = 0; i < len; i++) {
+                        av[i] = PyFloat_AsDouble(PyTuple_GetItem(value, i));
                     }
-                    status = ImagingLibTiffSetField(&encoder->state, (ttag_t) key_int, len, av);
+                    status = ImagingLibTiffSetField(
+                        &encoder->state, (ttag_t)key_int, len, av);
                     free(av);
                 }
             }
         } else {
             if (type == TIFF_SHORT) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        (UINT16)PyLong_AsLong(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, (UINT16)PyLong_AsLong(value));
             } else if (type == TIFF_LONG) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        (UINT32)PyLong_AsLong(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, (UINT32)PyLong_AsLong(value));
             } else if (type == TIFF_SSHORT) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        (INT16)PyLong_AsLong(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, (INT16)PyLong_AsLong(value));
             } else if (type == TIFF_SLONG) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        (INT32)PyLong_AsLong(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, (INT32)PyLong_AsLong(value));
             } else if (type == TIFF_FLOAT) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        (FLOAT32)PyFloat_AsDouble(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, (FLOAT32)PyFloat_AsDouble(value));
             } else if (type == TIFF_DOUBLE) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        (FLOAT64)PyFloat_AsDouble(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, (FLOAT64)PyFloat_AsDouble(value));
             } else if (type == TIFF_SBYTE) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        (INT8)PyLong_AsLong(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, (INT8)PyLong_AsLong(value));
             } else if (type == TIFF_ASCII) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        PyBytes_AsString(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, PyBytes_AsString(value));
             } else if (type == TIFF_RATIONAL) {
-                status = ImagingLibTiffSetField(&encoder->state,
-                        (ttag_t) key_int,
-                        (FLOAT64)PyFloat_AsDouble(value));
+                status = ImagingLibTiffSetField(
+                    &encoder->state, (ttag_t)key_int, (FLOAT64)PyFloat_AsDouble(value));
             } else {
-                TRACE(("Unhandled type for key %d : %s \n",
-                            key_int,
-                            PyBytes_AsString(PyObject_Str(value))));
+                TRACE(
+                    ("Unhandled type for key %d : %s \n",
+                     key_int,
+                     PyBytes_AsString(PyObject_Str(value))));
             }
         }
         if (!status) {
@@ -949,9 +941,9 @@
         }
     }

-    encoder->encode  = ImagingLibTiffEncode;
-
-    return (PyObject*) encoder;
+    encoder->encode = ImagingLibTiffEncode;
+
+    return (PyObject *)encoder;
 }

 #endif
@@ -965,26 +957,27 @@
 /* We better define this encoder last in this file, so the following
    undef's won't mess things up for the Imaging library proper. */

-#undef  HAVE_PROTOTYPES
-#undef  HAVE_STDDEF_H
-#undef  HAVE_STDLIB_H
-#undef  UINT8
-#undef  UINT16
-#undef  UINT32
-#undef  INT8
-#undef  INT16
-#undef  INT32
+#undef HAVE_PROTOTYPES
+#undef HAVE_STDDEF_H
+#undef HAVE_STDLIB_H
+#undef UINT8
+#undef UINT16
+#undef UINT32
+#undef INT8
+#undef INT16
+#undef INT32

 #include "libImaging/Jpeg.h"

-static unsigned int* get_qtables_arrays(PyObject* qtables, int* qtablesLen) {
-    PyObject* tables;
-    PyObject* table;
-    PyObject* table_data;
+static unsigned int *
+get_qtables_arrays(PyObject *qtables, int *qtablesLen) {
+    PyObject *tables;
+    PyObject *table;
+    PyObject *table_data;
     int i, j, num_tables;
     unsigned int *qarrays;

-    if ((qtables ==  NULL) || (qtables == Py_None)) {
+    if ((qtables == NULL) || (qtables == Py_None)) {
         return NULL;
     }

@@ -996,13 +989,14 @@
     tables = PySequence_Fast(qtables, "expected a sequence");
     num_tables = PySequence_Size(qtables);
     if (num_tables < 1 || num_tables > NUM_QUANT_TBLS) {
-        PyErr_SetString(PyExc_ValueError,
+        PyErr_SetString(
+            PyExc_ValueError,
             "Not a valid number of quantization tables. Should be between 1 and 4.");
         Py_DECREF(tables);
         return NULL;
     }
     /* malloc check ok, num_tables <4, DCTSIZE2 == 64 from jpeglib.h */
-    qarrays = (unsigned int*) malloc(num_tables * DCTSIZE2 * sizeof(unsigned int));
+    qarrays = (unsigned int *)malloc(num_tables * DCTSIZE2 * sizeof(unsigned int));
     if (!qarrays) {
         Py_DECREF(tables);
         return ImagingError_MemoryError();
@@ -1019,7 +1013,8 @@
         }
         table_data = PySequence_Fast(table, "expected a sequence");
         for (j = 0; j < DCTSIZE2; j++) {
-            qarrays[i * DCTSIZE2 + j] = PyLong_AS_LONG(PySequence_Fast_GET_ITEM(table_data, j));
+            qarrays[i * DCTSIZE2 + j] =
+                PyLong_AS_LONG(PySequence_Fast_GET_ITEM(table_data, j));
         }
         Py_DECREF(table_data);
     }
@@ -1037,10 +1032,9 @@
     return qarrays;
 }

-PyObject*
-PyImaging_JpegEncoderNew(PyObject* self, PyObject* args)
-{
-    ImagingEncoderObject* encoder;
+PyObject *
+PyImaging_JpegEncoderNew(PyObject *self, PyObject *args) {
+    ImagingEncoderObject *encoder;

     char *mode;
     char *rawmode;
@@ -1051,19 +1045,32 @@
     Py_ssize_t streamtype = 0; /* 0=interchange, 1=tables only, 2=image only */
     Py_ssize_t xdpi = 0, ydpi = 0;
     Py_ssize_t subsampling = -1; /* -1=default, 0=none, 1=medium, 2=high */
-    PyObject* qtables=NULL;
+    PyObject *qtables = NULL;
     unsigned int *qarrays = NULL;
     int qtablesLen = 0;
-    char* extra = NULL;
+    char *extra = NULL;
     Py_ssize_t extra_size;
-    char* rawExif = NULL;
+    char *rawExif = NULL;
     Py_ssize_t rawExifLen = 0;

-    if (!PyArg_ParseTuple(args, "ss|nnnnnnnnOy#y#",
-                          &mode, &rawmode, &quality,
-                          &progressive, &smooth, &optimize, &streamtype,
-                          &xdpi, &ydpi, &subsampling, &qtables, &extra, &extra_size,
-                          &rawExif, &rawExifLen)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "ss|nnnnnnnnOy#y#",
+            &mode,
+            &rawmode,
+            &quality,
+            &progressive,
+            &smooth,
+            &optimize,
+            &streamtype,
+            &xdpi,
+            &ydpi,
+            &subsampling,
+            &qtables,
+            &extra,
+            &extra_size,
+            &rawExif,
+            &rawExifLen)) {
         return NULL;
     }

@@ -1088,7 +1095,7 @@

     if (extra && extra_size > 0) {
         /* malloc check ok, length is from python parsearg */
-        char* p = malloc(extra_size); // Freed in JpegEncode, Case 5
+        char *p = malloc(extra_size);  // Freed in JpegEncode, Case 5
         if (!p) {
             return ImagingError_MemoryError();
         }
@@ -1100,7 +1107,7 @@

     if (rawExif && rawExifLen > 0) {
         /* malloc check ok, length is from python parsearg */
-        char* pp = malloc(rawExifLen); // Freed in JpegEncode, Case 5
+        char *pp = malloc(rawExifLen);  // Freed in JpegEncode, Case 5
         if (!pp) {
             if (extra) {
                 free(extra);
@@ -1115,29 +1122,28 @@

     encoder->encode = ImagingJpegEncode;

-    strncpy(((JPEGENCODERSTATE*)encoder->state.context)->rawmode, rawmode, 8);
-
-    ((JPEGENCODERSTATE*)encoder->state.context)->quality = quality;
-    ((JPEGENCODERSTATE*)encoder->state.context)->qtables = qarrays;
-    ((JPEGENCODERSTATE*)encoder->state.context)->qtablesLen = qtablesLen;
-    ((JPEGENCODERSTATE*)encoder->state.context)->subsampling = subsampling;
-    ((JPEGENCODERSTATE*)encoder->state.context)->progressive = progressive;
-    ((JPEGENCODERSTATE*)encoder->state.context)->smooth = smooth;
-    ((JPEGENCODERSTATE*)encoder->state.context)->optimize = optimize;
-    ((JPEGENCODERSTATE*)encoder->state.context)->streamtype = streamtype;
-    ((JPEGENCODERSTATE*)encoder->state.context)->xdpi = xdpi;
-    ((JPEGENCODERSTATE*)encoder->state.context)->ydpi = ydpi;
-    ((JPEGENCODERSTATE*)encoder->state.context)->extra = extra;
-    ((JPEGENCODERSTATE*)encoder->state.context)->extra_size = extra_size;
-    ((JPEGENCODERSTATE*)encoder->state.context)->rawExif = rawExif;
-    ((JPEGENCODERSTATE*)encoder->state.context)->rawExifLen = rawExifLen;
-
-    return (PyObject*) encoder;
+    strncpy(((JPEGENCODERSTATE *)encoder->state.context)->rawmode, rawmode, 8);
+
+    ((JPEGENCODERSTATE *)encoder->state.context)->quality = quality;
+    ((JPEGENCODERSTATE *)encoder->state.context)->qtables = qarrays;
+    ((JPEGENCODERSTATE *)encoder->state.context)->qtablesLen = qtablesLen;
+    ((JPEGENCODERSTATE *)encoder->state.context)->subsampling = subsampling;
+    ((JPEGENCODERSTATE *)encoder->state.context)->progressive = progressive;
+    ((JPEGENCODERSTATE *)encoder->state.context)->smooth = smooth;
+    ((JPEGENCODERSTATE *)encoder->state.context)->optimize = optimize;
+    ((JPEGENCODERSTATE *)encoder->state.context)->streamtype = streamtype;
+    ((JPEGENCODERSTATE *)encoder->state.context)->xdpi = xdpi;
+    ((JPEGENCODERSTATE *)encoder->state.context)->ydpi = ydpi;
+    ((JPEGENCODERSTATE *)encoder->state.context)->extra = extra;
+    ((JPEGENCODERSTATE *)encoder->state.context)->extra_size = extra_size;
+    ((JPEGENCODERSTATE *)encoder->state.context)->rawExif = rawExif;
+    ((JPEGENCODERSTATE *)encoder->state.context)->rawExifLen = rawExifLen;
+
+    return (PyObject *)encoder;
 }

 #endif

-
 /* -------------------------------------------------------------------- */
 /* JPEG 2000                                                            */
 /* -------------------------------------------------------------------- */
@@ -1147,8 +1153,7 @@
 #include "libImaging/Jpeg2K.h"

 static void
-j2k_decode_coord_tuple(PyObject *tuple, int *x, int *y)
-{
+j2k_decode_coord_tuple(PyObject *tuple, int *x, int *y) {
     *x = *y = 0;

     if (tuple && PyTuple_Check(tuple) && PyTuple_GET_SIZE(tuple) == 2) {
@@ -1164,9 +1169,8 @@
     }
 }

-PyObject*
-PyImaging_Jpeg2KEncoderNew(PyObject *self, PyObject *args)
-{
+PyObject *
+PyImaging_Jpeg2KEncoderNew(PyObject *self, PyObject *args) {
     ImagingEncoderObject *encoder;
     JPEG2KENCODESTATE *context;

@@ -1183,22 +1187,35 @@
     OPJ_PROG_ORDER prog_order;
     char *cinema_mode = "no";
     OPJ_CINEMA_MODE cine_mode;
+    char mct = 0;
     Py_ssize_t fd = -1;

-    if (!PyArg_ParseTuple(args, "ss|OOOsOnOOOssn", &mode, &format,
-                          &offset, &tile_offset, &tile_size,
-                          &quality_mode, &quality_layers, &num_resolutions,
-                          &cblk_size, &precinct_size,
-                          &irreversible, &progression, &cinema_mode,
-                          &fd)) {
-        return NULL;
-    }
-
-    if (strcmp (format, "j2k") == 0) {
+    if (!PyArg_ParseTuple(
+            args,
+            "ss|OOOsOnOOOssbn",
+            &mode,
+            &format,
+            &offset,
+            &tile_offset,
+            &tile_size,
+            &quality_mode,
+            &quality_layers,
+            &num_resolutions,
+            &cblk_size,
+            &precinct_size,
+            &irreversible,
+            &progression,
+            &cinema_mode,
+            &mct,
+            &fd)) {
+        return NULL;
+    }
+
+    if (strcmp(format, "j2k") == 0) {
         codec_format = OPJ_CODEC_J2K;
-    } else if (strcmp (format, "jpt") == 0) {
+    } else if (strcmp(format, "jpt") == 0) {
         codec_format = OPJ_CODEC_JPT;
-    } else if (strcmp (format, "jp2") == 0) {
+    } else if (strcmp(format, "jp2") == 0) {
         codec_format = OPJ_CODEC_JP2;
     } else {
         return NULL;
@@ -1245,53 +1262,49 @@
     context->format = codec_format;
     context->offset_x = context->offset_y = 0;

-
     j2k_decode_coord_tuple(offset, &context->offset_x, &context->offset_y);
-    j2k_decode_coord_tuple(tile_offset,
-                           &context->tile_offset_x,
-                           &context->tile_offset_y);
-    j2k_decode_coord_tuple(tile_size,
-                           &context->tile_size_x,
-                           &context->tile_size_y);
+    j2k_decode_coord_tuple(
+        tile_offset, &context->tile_offset_x, &context->tile_offset_y);
+    j2k_decode_coord_tuple(tile_size, &context->tile_size_x, &context->tile_size_y);

     /* Error on illegal tile offsets */
     if (context->tile_size_x && context->tile_size_y) {
-        if (context->tile_offset_x <= context->offset_x - context->tile_size_x
-            || context->tile_offset_y <= context->offset_y - context->tile_size_y) {
-            PyErr_SetString(PyExc_ValueError,
-                            "JPEG 2000 tile offset too small; top left tile must "
-                            "intersect image area");
+        if (context->tile_offset_x <= context->offset_x - context->tile_size_x ||
+            context->tile_offset_y <= context->offset_y - context->tile_size_y) {
+            PyErr_SetString(
+                PyExc_ValueError,
+                "JPEG 2000 tile offset too small; top left tile must "
+                "intersect image area");
             Py_DECREF(encoder);
             return NULL;
         }

-        if (context->tile_offset_x > context->offset_x
-            || context->tile_offset_y > context->offset_y) {
-            PyErr_SetString(PyExc_ValueError,
-                            "JPEG 2000 tile offset too large to cover image area");
+        if (context->tile_offset_x > context->offset_x ||
+            context->tile_offset_y > context->offset_y) {
+            PyErr_SetString(
+                PyExc_ValueError,
+                "JPEG 2000 tile offset too large to cover image area");
             Py_DECREF(encoder);
             return NULL;
         }
     }

     if (quality_layers && PySequence_Check(quality_layers)) {
-        context->quality_is_in_db = strcmp (quality_mode, "dB") == 0;
+        context->quality_is_in_db = strcmp(quality_mode, "dB") == 0;
         context->quality_layers = quality_layers;
         Py_INCREF(quality_layers);
     }

     context->num_resolutions = num_resolutions;

-    j2k_decode_coord_tuple(cblk_size,
-                           &context->cblk_width,
-                           &context->cblk_height);
-    j2k_decode_coord_tuple(precinct_size,
-                           &context->precinct_width,
-                           &context->precinct_height);
+    j2k_decode_coord_tuple(cblk_size, &context->cblk_width, &context->cblk_height);
+    j2k_decode_coord_tuple(
+        precinct_size, &context->precinct_width, &context->precinct_height);

     context->irreversible = PyObject_IsTrue(irreversible);
     context->progression = prog_order;
     context->cinema_mode = cine_mode;
+    context->mct = mct;

     return (PyObject *)encoder;
 }
('src', '_imagingtk.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -12,43 +12,42 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Python.h"
 #include "libImaging/Imaging.h"

 #include "Tk/_tkmini.h"

 /* must link with Tk/tkImaging.c */
-extern void TkImaging_Init(Tcl_Interp* interp);
-extern int load_tkinter_funcs(void);
+extern void
+TkImaging_Init(Tcl_Interp *interp);
+extern int
+load_tkinter_funcs(void);

 /* copied from _tkinter.c (this isn't as bad as it may seem: for new
    versions, we use _tkinter's interpaddr hook instead, and all older
    versions use this structure layout) */

 typedef struct {
-    PyObject_HEAD
-    Tcl_Interp* interp;
+    PyObject_HEAD Tcl_Interp *interp;
 } TkappObject;

-static PyObject*
-_tkinit(PyObject* self, PyObject* args)
-{
-    Tcl_Interp* interp;
+static PyObject *
+_tkinit(PyObject *self, PyObject *args) {
+    Tcl_Interp *interp;

-    PyObject* arg;
+    PyObject *arg;
     int is_interp;
     if (!PyArg_ParseTuple(args, "Oi", &arg, &is_interp)) {
         return NULL;
     }

     if (is_interp) {
-        interp = (Tcl_Interp*)PyLong_AsVoidPtr(arg);
+        interp = (Tcl_Interp *)PyLong_AsVoidPtr(arg);
     } else {
-        TkappObject* app;
+        TkappObject *app;
         /* Do it the hard way.  This will break if the TkappObject
         layout changes */
-        app = (TkappObject*)PyLong_AsVoidPtr(arg);
+        app = (TkappObject *)PyLong_AsVoidPtr(arg);
         interp = app->interp;
     }

@@ -69,10 +68,10 @@
 PyInit__imagingtk(void) {
     static PyModuleDef module_def = {
         PyModuleDef_HEAD_INIT,
-        "_imagingtk",       /* m_name */
-        NULL,               /* m_doc */
-        -1,                 /* m_size */
-        functions,          /* m_methods */
+        "_imagingtk", /* m_name */
+        NULL,         /* m_doc */
+        -1,           /* m_size */
+        functions,    /* m_methods */
     };
     PyObject *m;
     m = PyModule_Create(&module_def);
('src', 'path.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -25,54 +25,52 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Python.h"
 #include "libImaging/Imaging.h"

 #include <math.h>

 /* compatibility wrappers (defined in _imaging.c) */
-extern int PyImaging_CheckBuffer(PyObject* buffer);
-extern int PyImaging_GetBuffer(PyObject* buffer, Py_buffer *view);
+extern int
+PyImaging_CheckBuffer(PyObject *buffer);
+extern int
+PyImaging_GetBuffer(PyObject *buffer, Py_buffer *view);

 /* -------------------------------------------------------------------- */
 /* Class                                                                */
 /* -------------------------------------------------------------------- */

 typedef struct {
-    PyObject_HEAD
-    Py_ssize_t count;
+    PyObject_HEAD Py_ssize_t count;
     double *xy;
     int index; /* temporary use, e.g. in decimate */
 } PyPathObject;

 static PyTypeObject PyPathType;

-static double*
-alloc_array(Py_ssize_t count)
-{
-    double* xy;
+static double *
+alloc_array(Py_ssize_t count) {
+    double *xy;
     if (count < 0) {
         return ImagingError_MemoryError();
     }
-    if ((unsigned long long)count > (SIZE_MAX / (2 * sizeof(double))) - 1 ) {
+    if ((unsigned long long)count > (SIZE_MAX / (2 * sizeof(double))) - 1) {
         return ImagingError_MemoryError();
     }
-    xy = malloc(2 * count * sizeof(double) + 1);
+    xy = calloc(2 * count + 1, sizeof(double));
     if (!xy) {
         ImagingError_MemoryError();
     }
     return xy;
 }

-static PyPathObject*
-path_new(Py_ssize_t count, double* xy, int duplicate)
-{
+static PyPathObject *
+path_new(Py_ssize_t count, double *xy, int duplicate) {
     PyPathObject *path;

     if (duplicate) {
         /* duplicate path */
-        double* p = alloc_array(count);
+        double *p = alloc_array(count);
         if (!p) {
             return NULL;
         }
@@ -98,8 +96,7 @@
 }

 static void
-path_dealloc(PyPathObject* path)
-{
+path_dealloc(PyPathObject *path) {
     free(path->xy);
     PyObject_Del(path);
 }
@@ -111,14 +108,13 @@
 #define PyPath_Check(op) (Py_TYPE(op) == &PyPathType)

 Py_ssize_t
-PyPath_Flatten(PyObject* data, double **pxy)
-{
+PyPath_Flatten(PyObject *data, double **pxy) {
     Py_ssize_t i, j, n;
     double *xy;

     if (PyPath_Check(data)) {
         /* This was another path object. */
-        PyPathObject *path = (PyPathObject*) data;
+        PyPathObject *path = (PyPathObject *)data;
         xy = alloc_array(path->count);
         if (!xy) {
             return -1;
@@ -132,13 +128,13 @@
         /* Assume the buffer contains floats */
         Py_buffer buffer;
         if (PyImaging_GetBuffer(data, &buffer) == 0) {
-            float *ptr = (float*) buffer.buf;
+            float *ptr = (float *)buffer.buf;
             n = buffer.len / (2 * sizeof(float));
             xy = alloc_array(n);
             if (!xy) {
                 return -1;
             }
-            for (i = 0; i < n+n; i++) {
+            for (i = 0; i < n + n; i++) {
                 xy[i] = ptr[i];
             }
             *pxy = xy;
@@ -166,42 +162,37 @@
         return -1;
     }

+#define assign_item_to_array(op, decref) \
+if (PyFloat_Check(op)) { \
+    xy[j++] = PyFloat_AS_DOUBLE(op); \
+} else if (PyLong_Check(op)) { \
+    xy[j++] = (float)PyLong_AS_LONG(op); \
+} else if (PyNumber_Check(op)) { \
+    xy[j++] = PyFloat_AsDouble(op); \
+} else if (PyArg_ParseTuple(op, "dd", &x, &y)) { \
+    xy[j++] = x; \
+    xy[j++] = y; \
+} else { \
+    PyErr_SetString(PyExc_ValueError, "incorrect coordinate type"); \
+    if (decref) { \
+        Py_DECREF(op); \
+    } \
+    free(xy); \
+    return -1; \
+}
+
     /* Copy table to path array */
     if (PyList_Check(data)) {
         for (i = 0; i < n; i++) {
             double x, y;
             PyObject *op = PyList_GET_ITEM(data, i);
-            if (PyFloat_Check(op)) {
-                xy[j++] = PyFloat_AS_DOUBLE(op);
-            } else if (PyLong_Check(op)) {
-                xy[j++] = (float) PyLong_AS_LONG(op);
-            } else if (PyNumber_Check(op)) {
-                xy[j++] = PyFloat_AsDouble(op);
-            } else if (PyArg_ParseTuple(op, "dd", &x, &y)) {
-                xy[j++] = x;
-                xy[j++] = y;
-            } else {
-                free(xy);
-                return -1;
-            }
+            assign_item_to_array(op, 0);
         }
     } else if (PyTuple_Check(data)) {
         for (i = 0; i < n; i++) {
             double x, y;
             PyObject *op = PyTuple_GET_ITEM(data, i);
-            if (PyFloat_Check(op)) {
-                xy[j++] = PyFloat_AS_DOUBLE(op);
-            } else if (PyLong_Check(op)) {
-                xy[j++] = (float) PyLong_AS_LONG(op);
-            } else if (PyNumber_Check(op)) {
-                xy[j++] = PyFloat_AsDouble(op);
-            } else if (PyArg_ParseTuple(op, "dd", &x, &y)) {
-                xy[j++] = x;
-                xy[j++] = y;
-            } else {
-                free(xy);
-                return -1;
-            }
+            assign_item_to_array(op, 0);
         }
     } else {
         for (i = 0; i < n; i++) {
@@ -209,8 +200,7 @@
             PyObject *op = PySequence_GetItem(data, i);
             if (!op) {
                 /* treat IndexError as end of sequence */
-                if (PyErr_Occurred() &&
-                    PyErr_ExceptionMatches(PyExc_IndexError)) {
+                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_IndexError)) {
                     PyErr_Clear();
                     break;
                 } else {
@@ -218,20 +208,7 @@
                     return -1;
                 }
             }
-            if (PyFloat_Check(op)) {
-                xy[j++] = PyFloat_AS_DOUBLE(op);
-            } else if (PyLong_Check(op)) {
-                xy[j++] = (float) PyLong_AS_LONG(op);
-            } else if (PyNumber_Check(op)) {
-                xy[j++] = PyFloat_AsDouble(op);
-            } else if (PyArg_ParseTuple(op, "dd", &x, &y)) {
-                xy[j++] = x;
-                xy[j++] = y;
-            } else {
-                Py_DECREF(op);
-                free(xy);
-                return -1;
-            }
+            assign_item_to_array(op, 1);
             Py_DECREF(op);
         }
     }
@@ -243,23 +220,20 @@
     }

     *pxy = xy;
-    return j/2;
-}
-
+    return j / 2;
+}

 /* -------------------------------------------------------------------- */
 /* Factories                                                            */
 /* -------------------------------------------------------------------- */

-PyObject*
-PyPath_Create(PyObject* self, PyObject* args)
-{
-    PyObject* data;
+PyObject *
+PyPath_Create(PyObject *self, PyObject *args) {
+    PyObject *data;
     Py_ssize_t count;
     double *xy;

     if (PyArg_ParseTuple(args, "n:Path", &count)) {
-
         /* number of vertices */
         xy = alloc_array(count);
         if (!xy) {
@@ -267,7 +241,6 @@
         }

     } else {
-
         /* sequence or other path */
         PyErr_Clear();
         if (!PyArg_ParseTuple(args, "O", &data)) {
@@ -280,17 +253,15 @@
         }
     }

-    return (PyObject*) path_new(count, xy, 0);
-}
-
+    return (PyObject *)path_new(count, xy, 0);
+}

 /* -------------------------------------------------------------------- */
 /* Methods                                                              */
 /* -------------------------------------------------------------------- */

-static PyObject*
-path_compact(PyPathObject* self, PyObject* args)
-{
+static PyObject *
+path_compact(PyPathObject *self, PyObject *args) {
     /* Simple-minded method to shorten path.  A point is removed if
        the city block distance to the previous point is less than the
        given distance */
@@ -307,9 +278,10 @@

     /* remove bogus vertices */
     for (i = j = 1; i < self->count; i++) {
-        if (fabs(xy[j+j-2]-xy[i+i]) + fabs(xy[j+j-1]-xy[i+i+1]) >= cityblock) {
-            xy[j+j] = xy[i+i];
-            xy[j+j+1] = xy[i+i+1];
+        if (fabs(xy[j + j - 2] - xy[i + i]) + fabs(xy[j + j - 1] - xy[i + i + 1]) >=
+            cityblock) {
+            xy[j + j] = xy[i + i];
+            xy[j + j + 1] = xy[i + i + 1];
             j++;
         }
     }
@@ -324,9 +296,8 @@
     return Py_BuildValue("i", i); /* number of removed vertices */
 }

-static PyObject*
-path_getbbox(PyPathObject* self, PyObject* args)
-{
+static PyObject *
+path_getbbox(PyPathObject *self, PyObject *args) {
     /* Find bounding box */
     Py_ssize_t i;
     double *xy;
@@ -338,30 +309,34 @@

     xy = self->xy;

-    x0 = x1 = xy[0];
-    y0 = y1 = xy[1];
-
-    for (i = 1; i < self->count; i++) {
-        if (xy[i+i] < x0) {
-            x0 = xy[i+i];
-        }
-        if (xy[i+i] > x1) {
-            x1 = xy[i+i];
-        }
-        if (xy[i+i+1] < y0) {
-            y0 = xy[i+i+1];
-        }
-        if (xy[i+i+1] > y1) {
-            y1 = xy[i+i+1];
+    if (self->count == 0) {
+        x0 = x1 = 0;
+        y0 = y1 = 0;
+    } else {
+        x0 = x1 = xy[0];
+        y0 = y1 = xy[1];
+
+        for (i = 1; i < self->count; i++) {
+            if (xy[i + i] < x0) {
+                x0 = xy[i + i];
+            }
+            if (xy[i + i] > x1) {
+                x1 = xy[i + i];
+            }
+            if (xy[i + i + 1] < y0) {
+                y0 = xy[i + i + 1];
+            }
+            if (xy[i + i + 1] > y1) {
+                y1 = xy[i + i + 1];
+            }
         }
     }

     return Py_BuildValue("dddd", x0, y0, x1, y1);
 }

-static PyObject*
-path_getitem(PyPathObject* self, Py_ssize_t i)
-{
+static PyObject *
+path_getitem(PyPathObject *self, Py_ssize_t i) {
     if (i < 0) {
         i = self->count + i;
     }
@@ -370,12 +345,11 @@
         return NULL;
     }

-    return Py_BuildValue("dd", self->xy[i+i], self->xy[i+i+1]);
-}
-
-static PyObject*
-path_getslice(PyPathObject* self, Py_ssize_t ilow, Py_ssize_t ihigh)
-{
+    return Py_BuildValue("dd", self->xy[i + i], self->xy[i + i + 1]);
+}
+
+static PyObject *
+path_getslice(PyPathObject *self, Py_ssize_t ilow, Py_ssize_t ihigh) {
     /* adjust arguments */
     if (ilow < 0) {
         ilow = 0;
@@ -391,22 +365,20 @@
         ihigh = self->count;
     }

-    return (PyObject*) path_new(ihigh - ilow, self->xy + ilow * 2, 1);
+    return (PyObject *)path_new(ihigh - ilow, self->xy + ilow * 2, 1);
 }

 static Py_ssize_t
-path_len(PyPathObject* self)
-{
+path_len(PyPathObject *self) {
     return self->count;
 }

-static PyObject*
-path_map(PyPathObject* self, PyObject* args)
-{
+static PyObject *
+path_map(PyPathObject *self, PyObject *args) {
     /* Map coordinate set through function */
     Py_ssize_t i;
     double *xy;
-    PyObject* function;
+    PyObject *function;

     if (!PyArg_ParseTuple(args, "O:map", &function)) {
         return NULL;
@@ -416,15 +388,15 @@

     /* apply function to coordinate set */
     for (i = 0; i < self->count; i++) {
-        double x = xy[i+i];
-        double y = xy[i+i+1];
-        PyObject* item = PyObject_CallFunction(function, "dd", x, y);
+        double x = xy[i + i];
+        double y = xy[i + i + 1];
+        PyObject *item = PyObject_CallFunction(function, "dd", x, y);
         if (!item || !PyArg_ParseTuple(item, "dd", &x, &y)) {
             Py_XDECREF(item);
             return NULL;
         }
-        xy[i+i] = x;
-        xy[i+i+1] = y;
+        xy[i + i] = x;
+        xy[i + i + 1] = y;
         Py_DECREF(item);
     }

@@ -433,23 +405,20 @@
 }

 static int
-path_setitem(PyPathObject* self, Py_ssize_t i, PyObject* op)
-{
-    double* xy;
+path_setitem(PyPathObject *self, Py_ssize_t i, PyObject *op) {
+    double *xy;

     if (i < 0 || i >= self->count) {
-        PyErr_SetString(PyExc_IndexError,
-                        "path assignment index out of range");
+        PyErr_SetString(PyExc_IndexError, "path assignment index out of range");
         return -1;
     }

     if (op == NULL) {
-        PyErr_SetString(PyExc_TypeError,
-                        "cannot delete from path");
+        PyErr_SetString(PyExc_TypeError, "cannot delete from path");
         return -1;
     }

-    xy = &self->xy[i+i];
+    xy = &self->xy[i + i];

     if (!PyArg_ParseTuple(op, "dd", &xy[0], &xy[1])) {
         return -1;
@@ -458,9 +427,8 @@
     return 0;
 }

-static PyObject*
-path_tolist(PyPathObject* self, PyObject* args)
-{
+static PyObject *
+path_tolist(PyPathObject *self, PyObject *args) {
     PyObject *list;
     Py_ssize_t i;

@@ -470,9 +438,9 @@
     }

     if (flat) {
-        list = PyList_New(self->count*2);
-        for (i = 0; i < self->count*2; i++) {
-            PyObject* item;
+        list = PyList_New(self->count * 2);
+        for (i = 0; i < self->count * 2; i++) {
+            PyObject *item;
             item = PyFloat_FromDouble(self->xy[i]);
             if (!item) {
                 goto error;
@@ -482,8 +450,8 @@
     } else {
         list = PyList_New(self->count);
         for (i = 0; i < self->count; i++) {
-            PyObject* item;
-            item = Py_BuildValue("dd", self->xy[i+i], self->xy[i+i+1]);
+            PyObject *item;
+            item = Py_BuildValue("dd", self->xy[i + i], self->xy[i + i + 1]);
             if (!item) {
                 goto error;
             }
@@ -498,9 +466,8 @@
     return NULL;
 }

-static PyObject*
-path_transform(PyPathObject* self, PyObject* args)
-{
+static PyObject *
+path_transform(PyPathObject *self, PyObject *args) {
     /* Apply affine transform to coordinate set */
     Py_ssize_t i;
     double *xy;
@@ -508,9 +475,8 @@

     double wrap = 0.0;

-    if (!PyArg_ParseTuple(args, "(dddddd)|d:transform",
-                          &a, &b, &c, &d, &e, &f,
-                          &wrap)) {
+    if (!PyArg_ParseTuple(
+            args, "(dddddd)|d:transform", &a, &b, &c, &d, &e, &f, &wrap)) {
         return NULL;
     }

@@ -520,23 +486,23 @@
     if (b == 0.0 && d == 0.0) {
         /* scaling */
         for (i = 0; i < self->count; i++) {
-            xy[i+i]   = a*xy[i+i]+c;
-            xy[i+i+1] = e*xy[i+i+1]+f;
+            xy[i + i] = a * xy[i + i] + c;
+            xy[i + i + 1] = e * xy[i + i + 1] + f;
         }
     } else {
         /* affine transform */
         for (i = 0; i < self->count; i++) {
-            double x = xy[i+i];
-            double y = xy[i+i+1];
-            xy[i+i]   = a*x+b*y+c;
-            xy[i+i+1] = d*x+e*y+f;
+            double x = xy[i + i];
+            double y = xy[i + i + 1];
+            xy[i + i] = a * x + b * y + c;
+            xy[i + i + 1] = d * x + e * y + f;
         }
     }

     /* special treatment of geographical map data */
     if (wrap != 0.0) {
         for (i = 0; i < self->count; i++) {
-            xy[i+i] = fmod(xy[i+i], wrap);
+            xy[i + i] = fmod(xy[i + i], wrap);
         }
     }

@@ -545,27 +511,23 @@
 }

 static struct PyMethodDef methods[] = {
-    {"getbbox", (PyCFunction)path_getbbox, 1},
-    {"tolist", (PyCFunction)path_tolist, 1},
-    {"compact", (PyCFunction)path_compact, 1},
-    {"map", (PyCFunction)path_map, 1},
-    {"transform", (PyCFunction)path_transform, 1},
+    {"getbbox", (PyCFunction)path_getbbox, METH_VARARGS},
+    {"tolist", (PyCFunction)path_tolist, METH_VARARGS},
+    {"compact", (PyCFunction)path_compact, METH_VARARGS},
+    {"map", (PyCFunction)path_map, METH_VARARGS},
+    {"transform", (PyCFunction)path_transform, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };

-static PyObject*
-path_getattr_id(PyPathObject* self, void* closure)
-{
-        return Py_BuildValue("n", (Py_ssize_t) self->xy);
-}
-
-static struct PyGetSetDef getsetters[] = {
-    { "id", (getter) path_getattr_id },
-    { NULL }
-};
-
-static PyObject*
-path_subscript(PyPathObject* self, PyObject* item) {
+static PyObject *
+path_getattr_id(PyPathObject *self, void *closure) {
+    return Py_BuildValue("n", (Py_ssize_t)self->xy);
+}
+
+static struct PyGetSetDef getsetters[] = {{"id", (getter)path_getattr_id}, {NULL}};
+
+static PyObject *
+path_subscript(PyPathObject *self, PyObject *item) {
     if (PyIndex_Check(item)) {
         Py_ssize_t i;
         i = PyNumber_AsSsize_t(item, PyExc_IndexError);
@@ -584,71 +546,64 @@

         if (slicelength <= 0) {
             double *xy = alloc_array(0);
-            return (PyObject*) path_new(0, xy, 0);
-        }
-        else if (step == 1) {
+            return (PyObject *)path_new(0, xy, 0);
+        } else if (step == 1) {
             return path_getslice(self, start, stop);
-        }
-        else {
+        } else {
             PyErr_SetString(PyExc_TypeError, "slice steps not supported");
             return NULL;
         }
-    }
-    else {
-        PyErr_Format(PyExc_TypeError,
-                     "Path indices must be integers, not %.200s",
-                     Py_TYPE(item)->tp_name);
+    } else {
+        PyErr_Format(
+            PyExc_TypeError,
+            "Path indices must be integers, not %.200s",
+            Py_TYPE(item)->tp_name);
         return NULL;
     }
 }

 static PySequenceMethods path_as_sequence = {
-        (lenfunc)path_len, /*sq_length*/
-        (binaryfunc)0, /*sq_concat*/
-        (ssizeargfunc)0, /*sq_repeat*/
-        (ssizeargfunc)path_getitem, /*sq_item*/
-        (ssizessizeargfunc)path_getslice, /*sq_slice*/
-        (ssizeobjargproc)path_setitem, /*sq_ass_item*/
-        (ssizessizeobjargproc)0, /*sq_ass_slice*/
+    (lenfunc)path_len,                /*sq_length*/
+    (binaryfunc)0,                    /*sq_concat*/
+    (ssizeargfunc)0,                  /*sq_repeat*/
+    (ssizeargfunc)path_getitem,       /*sq_item*/
+    (ssizessizeargfunc)path_getslice, /*sq_slice*/
+    (ssizeobjargproc)path_setitem,    /*sq_ass_item*/
+    (ssizessizeobjargproc)0,          /*sq_ass_slice*/
 };

 static PyMappingMethods path_as_mapping = {
-    (lenfunc)path_len,
-    (binaryfunc)path_subscript,
-    NULL
+    (lenfunc)path_len, (binaryfunc)path_subscript, NULL};
+
+static PyTypeObject PyPathType = {
+    PyVarObject_HEAD_INIT(NULL, 0) "Path", /*tp_name*/
+    sizeof(PyPathObject),                  /*tp_size*/
+    0,                                     /*tp_itemsize*/
+    /* methods */
+    (destructor)path_dealloc, /*tp_dealloc*/
+    0,                        /*tp_print*/
+    0,                        /*tp_getattr*/
+    0,                        /*tp_setattr*/
+    0,                        /*tp_compare*/
+    0,                        /*tp_repr*/
+    0,                        /*tp_as_number */
+    &path_as_sequence,        /*tp_as_sequence */
+    &path_as_mapping,         /*tp_as_mapping */
+    0,                        /*tp_hash*/
+    0,                        /*tp_call*/
+    0,                        /*tp_str*/
+    0,                        /*tp_getattro*/
+    0,                        /*tp_setattro*/
+    0,                        /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,       /*tp_flags*/
+    0,                        /*tp_doc*/
+    0,                        /*tp_traverse*/
+    0,                        /*tp_clear*/
+    0,                        /*tp_richcompare*/
+    0,                        /*tp_weaklistoffset*/
+    0,                        /*tp_iter*/
+    0,                        /*tp_iternext*/
+    methods,                  /*tp_methods*/
+    0,                        /*tp_members*/
+    getsetters,               /*tp_getset*/
 };
-
-static PyTypeObject PyPathType = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "Path",                         /*tp_name*/
-    sizeof(PyPathObject),           /*tp_size*/
-    0,                              /*tp_itemsize*/
-    /* methods */
-    (destructor)path_dealloc,       /*tp_dealloc*/
-    0,                              /*tp_print*/
-    0,                                  /*tp_getattr*/
-    0,                              /*tp_setattr*/
-    0,                              /*tp_compare*/
-    0,                              /*tp_repr*/
-    0,                              /*tp_as_number */
-    &path_as_sequence,              /*tp_as_sequence */
-    &path_as_mapping,           /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    methods,                    /*tp_methods*/
-    0,                          /*tp_members*/
-    getsetters,                 /*tp_getset*/
-};
-
('src', 'outline.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,22 +21,19 @@

 #include "libImaging/Imaging.h"

-
 /* -------------------------------------------------------------------- */
 /* Class                                                                */

 typedef struct {
-    PyObject_HEAD
-    ImagingOutline outline;
+    PyObject_HEAD ImagingOutline outline;
 } OutlineObject;

 static PyTypeObject OutlineType;

 #define PyOutline_Check(op) (Py_TYPE(op) == &OutlineType)

-static OutlineObject*
-_outline_new(void)
-{
+static OutlineObject *
+_outline_new(void) {
     OutlineObject *self;

     if (PyType_Ready(&OutlineType) < 0) {
@@ -54,43 +51,37 @@
 }

 static void
-_outline_dealloc(OutlineObject* self)
-{
+_outline_dealloc(OutlineObject *self) {
     ImagingOutlineDelete(self->outline);
     PyObject_Del(self);
 }

 ImagingOutline
-PyOutline_AsOutline(PyObject* outline)
-{
+PyOutline_AsOutline(PyObject *outline) {
     if (PyOutline_Check(outline)) {
-        return ((OutlineObject*) outline)->outline;
+        return ((OutlineObject *)outline)->outline;
     }

     return NULL;
 }

-
 /* -------------------------------------------------------------------- */
 /* Factories                                                            */

-PyObject*
-PyOutline_Create(PyObject* self, PyObject* args)
-{
+PyObject *
+PyOutline_Create(PyObject *self, PyObject *args) {
     if (!PyArg_ParseTuple(args, ":outline")) {
         return NULL;
     }

-    return (PyObject*) _outline_new();
+    return (PyObject *)_outline_new();
 }
-

 /* -------------------------------------------------------------------- */
 /* Methods                                                              */

-static PyObject*
-_outline_move(OutlineObject* self, PyObject* args)
-{
+static PyObject *
+_outline_move(OutlineObject *self, PyObject *args) {
     float x0, y0;
     if (!PyArg_ParseTuple(args, "ff", &x0, &y0)) {
         return NULL;
@@ -102,9 +93,8 @@
     return Py_None;
 }

-static PyObject*
-_outline_line(OutlineObject* self, PyObject* args)
-{
+static PyObject *
+_outline_line(OutlineObject *self, PyObject *args) {
     float x1, y1;
     if (!PyArg_ParseTuple(args, "ff", &x1, &y1)) {
         return NULL;
@@ -116,9 +106,8 @@
     return Py_None;
 }

-static PyObject*
-_outline_curve(OutlineObject* self, PyObject* args)
-{
+static PyObject *
+_outline_curve(OutlineObject *self, PyObject *args) {
     float x1, y1, x2, y2, x3, y3;
     if (!PyArg_ParseTuple(args, "ffffff", &x1, &y1, &x2, &y2, &x3, &y3)) {
         return NULL;
@@ -130,9 +119,8 @@
     return Py_None;
 }

-static PyObject*
-_outline_close(OutlineObject* self, PyObject* args)
-{
+static PyObject *
+_outline_close(OutlineObject *self, PyObject *args) {
     if (!PyArg_ParseTuple(args, ":close")) {
         return NULL;
     }
@@ -143,11 +131,10 @@
     return Py_None;
 }

-static PyObject*
-_outline_transform(OutlineObject* self, PyObject* args)
-{
+static PyObject *
+_outline_transform(OutlineObject *self, PyObject *args) {
     double a[6];
-    if (!PyArg_ParseTuple(args, "(dddddd)", a+0, a+1, a+2, a+3, a+4, a+5)) {
+    if (!PyArg_ParseTuple(args, "(dddddd)", a + 0, a + 1, a + 2, a + 3, a + 4, a + 5)) {
         return NULL;
     }

@@ -158,44 +145,43 @@
 }

 static struct PyMethodDef _outline_methods[] = {
-    {"line", (PyCFunction)_outline_line, 1},
-    {"curve", (PyCFunction)_outline_curve, 1},
-    {"move", (PyCFunction)_outline_move, 1},
-    {"close", (PyCFunction)_outline_close, 1},
-    {"transform", (PyCFunction)_outline_transform, 1},
+    {"line", (PyCFunction)_outline_line, METH_VARARGS},
+    {"curve", (PyCFunction)_outline_curve, METH_VARARGS},
+    {"move", (PyCFunction)_outline_move, METH_VARARGS},
+    {"close", (PyCFunction)_outline_close, METH_VARARGS},
+    {"transform", (PyCFunction)_outline_transform, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };

 static PyTypeObject OutlineType = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "Outline",                   /*tp_name*/
-    sizeof(OutlineObject),       /*tp_size*/
-    0,                           /*tp_itemsize*/
+    PyVarObject_HEAD_INIT(NULL, 0) "Outline", /*tp_name*/
+    sizeof(OutlineObject),                    /*tp_size*/
+    0,                                        /*tp_itemsize*/
     /* methods */
-    (destructor)_outline_dealloc,/*tp_dealloc*/
-    0,                           /*tp_print*/
-    0,                           /*tp_getattr*/
-    0,                           /*tp_setattr*/
-    0,                           /*tp_compare*/
-    0,                           /*tp_repr*/
-    0,                           /*tp_as_number */
-    0,                           /*tp_as_sequence */
-    0,                           /*tp_as_mapping */
-    0,                           /*tp_hash*/
-    0,                           /*tp_call*/
-    0,                           /*tp_str*/
-    0,                           /*tp_getattro*/
-    0,                           /*tp_setattro*/
-    0,                           /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,          /*tp_flags*/
-    0,                           /*tp_doc*/
-    0,                           /*tp_traverse*/
-    0,                           /*tp_clear*/
-    0,                           /*tp_richcompare*/
-    0,                           /*tp_weaklistoffset*/
-    0,                           /*tp_iter*/
-    0,                           /*tp_iternext*/
-    _outline_methods,            /*tp_methods*/
-    0,                           /*tp_members*/
-    0,                           /*tp_getset*/
+    (destructor)_outline_dealloc, /*tp_dealloc*/
+    0,                            /*tp_print*/
+    0,                            /*tp_getattr*/
+    0,                            /*tp_setattr*/
+    0,                            /*tp_compare*/
+    0,                            /*tp_repr*/
+    0,                            /*tp_as_number */
+    0,                            /*tp_as_sequence */
+    0,                            /*tp_as_mapping */
+    0,                            /*tp_hash*/
+    0,                            /*tp_call*/
+    0,                            /*tp_str*/
+    0,                            /*tp_getattro*/
+    0,                            /*tp_setattro*/
+    0,                            /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,           /*tp_flags*/
+    0,                            /*tp_doc*/
+    0,                            /*tp_traverse*/
+    0,                            /*tp_clear*/
+    0,                            /*tp_richcompare*/
+    0,                            /*tp_weaklistoffset*/
+    0,                            /*tp_iter*/
+    0,                            /*tp_iternext*/
+    _outline_methods,             /*tp_methods*/
+    0,                            /*tp_members*/
+    0,                            /*tp_getset*/
 };
('src', 'map.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,320 +23,56 @@
 #include "libImaging/Imaging.h"

 /* compatibility wrappers (defined in _imaging.c) */
-extern int PyImaging_CheckBuffer(PyObject* buffer);
-extern int PyImaging_GetBuffer(PyObject* buffer, Py_buffer *view);
+extern int
+PyImaging_CheckBuffer(PyObject *buffer);
+extern int
+PyImaging_GetBuffer(PyObject *buffer, Py_buffer *view);

-/* -------------------------------------------------------------------- */
-/* Standard mapper */
-
-typedef struct {
-    PyObject_HEAD
-    char* base;
-    int   size;
-    int   offset;
-#ifdef _WIN32
-    HANDLE hFile;
-    HANDLE hMap;
-#endif
-} ImagingMapperObject;
-
-static PyTypeObject ImagingMapperType;
-
-ImagingMapperObject*
-PyImaging_MapperNew(const char* filename, int readonly)
-{
-    ImagingMapperObject *mapper;
-
-    if (PyType_Ready(&ImagingMapperType) < 0) {
-        return NULL;
-    }
-
-    mapper = PyObject_New(ImagingMapperObject, &ImagingMapperType);
-    if (mapper == NULL) {
-        return NULL;
-    }
-
-    mapper->base = NULL;
-    mapper->size = mapper->offset = 0;
-
-#ifdef _WIN32
-    mapper->hFile = (HANDLE)-1;
-    mapper->hMap  = (HANDLE)-1;
-
-    /* FIXME: currently supports readonly mappings only */
-    mapper->hFile = CreateFile(
-        filename,
-        GENERIC_READ,
-        FILE_SHARE_READ,
-        NULL, OPEN_EXISTING,
-        FILE_ATTRIBUTE_NORMAL,
-        NULL);
-    if (mapper->hFile == (HANDLE)-1) {
-        PyErr_SetString(PyExc_OSError, "cannot open file");
-        Py_DECREF(mapper);
-        return NULL;
-    }
-
-    mapper->hMap = CreateFileMapping(
-        mapper->hFile, NULL,
-        PAGE_READONLY,
-        0, 0, NULL);
-    if (mapper->hMap == (HANDLE)-1) {
-        CloseHandle(mapper->hFile);
-        PyErr_SetString(PyExc_OSError, "cannot map file");
-        Py_DECREF(mapper);
-        return NULL;
-    }
-
-    mapper->base = (char*) MapViewOfFile(
-        mapper->hMap,
-        FILE_MAP_READ,
-        0, 0, 0);
-
-    mapper->size = GetFileSize(mapper->hFile, 0);
-#endif
-
-    return mapper;
-}
-
-static void
-mapping_dealloc(ImagingMapperObject* mapper)
-{
-#ifdef _WIN32
-    if (mapper->base != 0) {
-        UnmapViewOfFile(mapper->base);
-    }
-    if (mapper->hMap != (HANDLE)-1) {
-        CloseHandle(mapper->hMap);
-    }
-    if (mapper->hFile != (HANDLE)-1) {
-        CloseHandle(mapper->hFile);
-    }
-    mapper->base = 0;
-    mapper->hMap = mapper->hFile = (HANDLE)-1;
-#endif
-    PyObject_Del(mapper);
-}
-
-/* -------------------------------------------------------------------- */
-/* standard file operations */
-
-static PyObject*
-mapping_read(ImagingMapperObject* mapper, PyObject* args)
-{
-    PyObject* buf;
-
-    int size = -1;
-    if (!PyArg_ParseTuple(args, "|i", &size)) {
-        return NULL;
-    }
-
-    /* check size */
-    if (size < 0 || mapper->offset + size > mapper->size) {
-        size = mapper->size - mapper->offset;
-    }
-    if (size < 0) {
-        size = 0;
-    }
-
-    buf = PyBytes_FromStringAndSize(NULL, size);
-    if (!buf) {
-        return NULL;
-    }
-
-    if (size > 0) {
-        memcpy(PyBytes_AsString(buf), mapper->base + mapper->offset, size);
-        mapper->offset += size;
-    }
-
-    return buf;
-}
-
-static PyObject*
-mapping_seek(ImagingMapperObject* mapper, PyObject* args)
-{
-    int offset;
-    int whence = 0;
-    if (!PyArg_ParseTuple(args, "i|i", &offset, &whence)) {
-        return NULL;
-    }
-
-    switch (whence) {
-        case 0: /* SEEK_SET */
-            mapper->offset = offset;
-            break;
-        case 1: /* SEEK_CUR */
-            mapper->offset += offset;
-            break;
-        case 2: /* SEEK_END */
-            mapper->offset = mapper->size + offset;
-            break;
-        default:
-            /* FIXME: raise ValueError? */
-            break;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-/* -------------------------------------------------------------------- */
-/* map entire image */
-
-extern PyObject*PyImagingNew(Imaging im);
-
-static void
-ImagingDestroyMap(Imaging im)
-{
-    return; /* nothing to do! */
-}
-
-static PyObject*
-mapping_readimage(ImagingMapperObject* mapper, PyObject* args)
-{
-    int y, size;
-    Imaging im;
-
-    char* mode;
-    int xsize;
-    int ysize;
-    int stride;
-    int orientation;
-    if (!PyArg_ParseTuple(args, "s(ii)ii", &mode, &xsize, &ysize,
-                          &stride, &orientation)) {
-        return NULL;
-    }
-
-    if (stride <= 0) {
-        /* FIXME: maybe we should call ImagingNewPrologue instead */
-        if (!strcmp(mode, "L") || !strcmp(mode, "P")) {
-            stride = xsize;
-        } else if (!strcmp(mode, "I;16") || !strcmp(mode, "I;16B")) {
-            stride = xsize * 2;
-        } else {
-            stride = xsize * 4;
-        }
-    }
-
-    size = ysize * stride;
-
-    if (mapper->offset + size > mapper->size) {
-        PyErr_SetString(PyExc_OSError, "image file truncated");
-        return NULL;
-    }
-
-    im = ImagingNewPrologue(mode, xsize, ysize);
-    if (!im) {
-        return NULL;
-    }
-
-    /* setup file pointers */
-    if (orientation > 0) {
-        for (y = 0; y < ysize; y++) {
-            im->image[y] = mapper->base + mapper->offset + y * stride;
-        }
-    } else {
-        for (y = 0; y < ysize; y++) {
-            im->image[ysize-y-1] = mapper->base + mapper->offset + y * stride;
-        }
-    }
-
-    im->destroy = ImagingDestroyMap;
-
-    mapper->offset += size;
-
-    return PyImagingNew(im);
-}
-
-static struct PyMethodDef methods[] = {
-    /* standard file interface */
-    {"read", (PyCFunction)mapping_read, 1},
-    {"seek", (PyCFunction)mapping_seek, 1},
-    /* extensions */
-    {"readimage", (PyCFunction)mapping_readimage, 1},
-    {NULL, NULL} /* sentinel */
-};
-
-static PyTypeObject ImagingMapperType = {
-        PyVarObject_HEAD_INIT(NULL, 0)
-        "ImagingMapper",                /*tp_name*/
-        sizeof(ImagingMapperObject),    /*tp_size*/
-        0,                              /*tp_itemsize*/
-        /* methods */
-        (destructor)mapping_dealloc,    /*tp_dealloc*/
-        0,                              /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    methods,                    /*tp_methods*/
-    0,                          /*tp_members*/
-    0,                          /*tp_getset*/
-};
-
-PyObject*
-PyImaging_Mapper(PyObject* self, PyObject* args)
-{
-    char* filename;
-    if (!PyArg_ParseTuple(args, "s", &filename)) {
-        return NULL;
-    }
-
-    return (PyObject*) PyImaging_MapperNew(filename, 1);
-}
+extern PyObject *
+PyImagingNew(Imaging im);

 /* -------------------------------------------------------------------- */
 /* Buffer mapper */

 typedef struct ImagingBufferInstance {
     struct ImagingMemoryInstance im;
-    PyObject* target;
+    PyObject *target;
     Py_buffer view;
 } ImagingBufferInstance;

 static void
-mapping_destroy_buffer(Imaging im)
-{
-    ImagingBufferInstance* buffer = (ImagingBufferInstance*) im;
+mapping_destroy_buffer(Imaging im) {
+    ImagingBufferInstance *buffer = (ImagingBufferInstance *)im;

     PyBuffer_Release(&buffer->view);
     Py_XDECREF(buffer->target);
 }

-PyObject*
-PyImaging_MapBuffer(PyObject* self, PyObject* args)
-{
+PyObject *
+PyImaging_MapBuffer(PyObject *self, PyObject *args) {
     Py_ssize_t y, size;
     Imaging im;

-    PyObject* target;
+    PyObject *target;
     Py_buffer view;
-    char* mode;
-    char* codec;
+    char *mode;
+    char *codec;
     Py_ssize_t offset;
     int xsize, ysize;
     int stride;
     int ystep;

-    if (!PyArg_ParseTuple(args, "O(ii)sn(sii)", &target, &xsize, &ysize,
-                          &codec, &offset, &mode, &stride, &ystep)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "O(ii)sn(sii)",
+            &target,
+            &xsize,
+            &ysize,
+            &codec,
+            &offset,
+            &mode,
+            &stride,
+            &ystep)) {
         return NULL;
     }

@@ -360,7 +96,7 @@
         return NULL;
     }

-    size = (Py_ssize_t) ysize * stride;
+    size = (Py_ssize_t)ysize * stride;

     if (offset > PY_SSIZE_T_MAX - size) {
         PyErr_SetString(PyExc_MemoryError, "Integer overflow in offset");
@@ -383,8 +119,7 @@
         return NULL;
     }

-    im = ImagingNewPrologueSubtype(
-        mode, xsize, ysize, sizeof(ImagingBufferInstance));
+    im = ImagingNewPrologueSubtype(mode, xsize, ysize, sizeof(ImagingBufferInstance));
     if (!im) {
         PyBuffer_Release(&view);
         return NULL;
@@ -393,20 +128,19 @@
     /* setup file pointers */
     if (ystep > 0) {
         for (y = 0; y < ysize; y++) {
-            im->image[y] = (char*)view.buf + offset + y * stride;
+            im->image[y] = (char *)view.buf + offset + y * stride;
         }
     } else {
         for (y = 0; y < ysize; y++) {
-            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;
+            im->image[ysize - y - 1] = (char *)view.buf + offset + y * stride;
         }
     }

     im->destroy = mapping_destroy_buffer;

     Py_INCREF(target);
-    ((ImagingBufferInstance*) im)->target = target;
-    ((ImagingBufferInstance*) im)->view = view;
+    ((ImagingBufferInstance *)im)->target = target;
+    ((ImagingBufferInstance *)im)->view = view;

     return PyImagingNew(im);
 }
-
('src', '_imagingmorph.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,7 +14,7 @@
 #include "Python.h"
 #include "libImaging/Imaging.h"

-#define LUT_SIZE (1<<9)
+#define LUT_SIZE (1 << 9)

 /* Apply a morphologic LUT to a binary image. Outputs a
    a new binary image.
@@ -27,9 +27,8 @@

    Returns number of changed pixels.
 */
-static PyObject*
-apply(PyObject *self, PyObject* args)
-{
+static PyObject *
+apply(PyObject *self, PyObject *args) {
     const char *lut;
     PyObject *py_lut;
     Py_ssize_t lut_len, i0, i1;
@@ -58,18 +57,16 @@

     lut = PyBytes_AsString(py_lut);

-    imgin = (Imaging) i0;
-    imgout = (Imaging) i1;
+    imgin = (Imaging)i0;
+    imgout = (Imaging)i1;
     width = imgin->xsize;
     height = imgin->ysize;

-    if (imgin->type != IMAGING_TYPE_UINT8 ||
-        imgin->bands != 1) {
+    if (imgin->type != IMAGING_TYPE_UINT8 || imgin->bands != 1) {
         PyErr_SetString(PyExc_RuntimeError, "Unsupported image type");
         return NULL;
     }
-    if (imgout->type != IMAGING_TYPE_UINT8 ||
-        imgout->bands != 1) {
+    if (imgout->type != IMAGING_TYPE_UINT8 || imgout->bands != 1) {
         PyErr_SetString(PyExc_RuntimeError, "Unsupported image type");
         return NULL;
     }
@@ -77,52 +74,46 @@
     inrows = imgin->image8;
     outrows = imgout->image8;

-    for (row_idx=0; row_idx < height; row_idx++) {
+    for (row_idx = 0; row_idx < height; row_idx++) {
         UINT8 *outrow = outrows[row_idx];
         UINT8 *inrow = inrows[row_idx];
         UINT8 *prow, *nrow; /* Previous and next row */

         /* zero boundary conditions. TBD support other modes */
-        outrow[0] = outrow[width-1] = 0;
-        if (row_idx==0 || row_idx == height-1) {
-            for(col_idx=0; col_idx<width; col_idx++) {
+        outrow[0] = outrow[width - 1] = 0;
+        if (row_idx == 0 || row_idx == height - 1) {
+            for (col_idx = 0; col_idx < width; col_idx++) {
                 outrow[col_idx] = 0;
             }
             continue;
         }

-        prow = inrows[row_idx-1];
-        nrow = inrows[row_idx+1];
-
-        for (col_idx=1; col_idx<width-1; col_idx++) {
-            int cim = col_idx-1;
-            int cip = col_idx+1;
-            unsigned char b0 = prow[cim] &1;
-            unsigned char b1 = prow[col_idx]&1;
-            unsigned char b2 = prow[cip]&1;
-
-            unsigned char b3 = inrow[cim]&1;
-            unsigned char b4 = inrow[col_idx]&1;
-            unsigned char b5 = inrow[cip]&1;
-
-            unsigned char b6 = nrow[cim]&1;
-            unsigned char b7 = nrow[col_idx]&1;
-            unsigned char b8 = nrow[cip]&1;
-
-            int lut_idx = (b0
-                           |(b1 << 1)
-                           |(b2 << 2)
-                           |(b3 << 3)
-                           |(b4 << 4)
-                           |(b5 << 5)
-                           |(b6 << 6)
-                           |(b7 << 7)
-                           |(b8 << 8));
-            outrow[col_idx] = 255*(lut[lut_idx]&1);
-            num_changed_pixels += ((b4&1)!=(outrow[col_idx]&1));
-        }
-    }
-    return Py_BuildValue("i",num_changed_pixels);
+        prow = inrows[row_idx - 1];
+        nrow = inrows[row_idx + 1];
+
+        for (col_idx = 1; col_idx < width - 1; col_idx++) {
+            int cim = col_idx - 1;
+            int cip = col_idx + 1;
+            unsigned char b0 = prow[cim] & 1;
+            unsigned char b1 = prow[col_idx] & 1;
+            unsigned char b2 = prow[cip] & 1;
+
+            unsigned char b3 = inrow[cim] & 1;
+            unsigned char b4 = inrow[col_idx] & 1;
+            unsigned char b5 = inrow[cip] & 1;
+
+            unsigned char b6 = nrow[cim] & 1;
+            unsigned char b7 = nrow[col_idx] & 1;
+            unsigned char b8 = nrow[cip] & 1;
+
+            int lut_idx =
+                (b0 | (b1 << 1) | (b2 << 2) | (b3 << 3) | (b4 << 4) | (b5 << 5) |
+                 (b6 << 6) | (b7 << 7) | (b8 << 8));
+            outrow[col_idx] = 255 * (lut[lut_idx] & 1);
+            num_changed_pixels += ((b4 & 1) != (outrow[col_idx] & 1));
+        }
+    }
+    return Py_BuildValue("i", num_changed_pixels);
 }

 /* Match a morphologic LUT to a binary image and return a list
@@ -135,9 +126,8 @@

    Returns list of matching pixels.
 */
-static PyObject*
-match(PyObject *self, PyObject* args)
-{
+static PyObject *
+match(PyObject *self, PyObject *args) {
     const char *lut;
     PyObject *py_lut;
     Py_ssize_t lut_len, i0;
@@ -165,10 +155,9 @@
     }

     lut = PyBytes_AsString(py_lut);
-    imgin = (Imaging) i0;
-
-    if (imgin->type != IMAGING_TYPE_UINT8 ||
-        imgin->bands != 1) {
+    imgin = (Imaging)i0;
+
+    if (imgin->type != IMAGING_TYPE_UINT8 || imgin->bands != 1) {
         PyErr_SetString(PyExc_RuntimeError, "Unsupported image type");
         return NULL;
     }
@@ -177,39 +166,33 @@
     width = imgin->xsize;
     height = imgin->ysize;

-    for (row_idx=1; row_idx < height-1; row_idx++) {
+    for (row_idx = 1; row_idx < height - 1; row_idx++) {
         UINT8 *inrow = inrows[row_idx];
         UINT8 *prow, *nrow;

-        prow = inrows[row_idx-1];
-        nrow = inrows[row_idx+1];
-
-        for (col_idx=1; col_idx<width-1; col_idx++) {
-            int cim = col_idx-1;
-            int cip = col_idx+1;
-            unsigned char b0 = prow[cim] &1;
-            unsigned char b1 = prow[col_idx]&1;
-            unsigned char b2 = prow[cip]&1;
-
-            unsigned char b3 = inrow[cim]&1;
-            unsigned char b4 = inrow[col_idx]&1;
-            unsigned char b5 = inrow[cip]&1;
-
-            unsigned char b6 = nrow[cim]&1;
-            unsigned char b7 = nrow[col_idx]&1;
-            unsigned char b8 = nrow[cip]&1;
-
-            int lut_idx = (b0
-                           |(b1 << 1)
-                           |(b2 << 2)
-                           |(b3 << 3)
-                           |(b4 << 4)
-                           |(b5 << 5)
-                           |(b6 << 6)
-                           |(b7 << 7)
-                           |(b8 << 8));
+        prow = inrows[row_idx - 1];
+        nrow = inrows[row_idx + 1];
+
+        for (col_idx = 1; col_idx < width - 1; col_idx++) {
+            int cim = col_idx - 1;
+            int cip = col_idx + 1;
+            unsigned char b0 = prow[cim] & 1;
+            unsigned char b1 = prow[col_idx] & 1;
+            unsigned char b2 = prow[cip] & 1;
+
+            unsigned char b3 = inrow[cim] & 1;
+            unsigned char b4 = inrow[col_idx] & 1;
+            unsigned char b5 = inrow[cip] & 1;
+
+            unsigned char b6 = nrow[cim] & 1;
+            unsigned char b7 = nrow[col_idx] & 1;
+            unsigned char b8 = nrow[cip] & 1;
+
+            int lut_idx =
+                (b0 | (b1 << 1) | (b2 << 2) | (b3 << 3) | (b4 << 4) | (b5 << 5) |
+                 (b6 << 6) | (b7 << 7) | (b8 << 8));
             if (lut[lut_idx]) {
-                PyObject *coordObj = Py_BuildValue("(nn)",col_idx,row_idx);
+                PyObject *coordObj = Py_BuildValue("(nn)", col_idx, row_idx);
                 PyList_Append(ret, coordObj);
             }
         }
@@ -222,9 +205,8 @@
    May be used to extract features after a sequence of MorphOps were applied.
    This is faster than match as only 1x1 lookup is made.
 */
-static PyObject*
-get_on_pixels(PyObject *self, PyObject* args)
-{
+static PyObject *
+get_on_pixels(PyObject *self, PyObject *args) {
     Py_ssize_t i0;
     Imaging img;
     UINT8 **rows;
@@ -237,16 +219,16 @@

         return NULL;
     }
-    img = (Imaging) i0;
+    img = (Imaging)i0;
     rows = img->image8;
     width = img->xsize;
     height = img->ysize;

-    for (row_idx=0; row_idx < height; row_idx++) {
+    for (row_idx = 0; row_idx < height; row_idx++) {
         UINT8 *row = rows[row_idx];
-        for (col_idx=0; col_idx<width; col_idx++) {
+        for (col_idx = 0; col_idx < width; col_idx++) {
             if (row[col_idx]) {
-                PyObject *coordObj = Py_BuildValue("(nn)",col_idx,row_idx);
+                PyObject *coordObj = Py_BuildValue("(nn)", col_idx, row_idx);
                 PyList_Append(ret, coordObj);
             }
         }
@@ -254,11 +236,9 @@
     return ret;
 }

-
 static int
-setup_module(PyObject* m)
-{
-    PyObject* d = PyModule_GetDict(m);
+setup_module(PyObject *m) {
+    PyObject *d = PyModule_GetDict(m);

     PyDict_SetItemString(d, "__version", PyUnicode_FromString("0.1"));

@@ -270,19 +250,18 @@
     {"apply", (PyCFunction)apply, METH_VARARGS, NULL},
     {"get_on_pixels", (PyCFunction)get_on_pixels, METH_VARARGS, NULL},
     {"match", (PyCFunction)match, METH_VARARGS, NULL},
-    {NULL, NULL, 0, NULL}
-};
+    {NULL, NULL, 0, NULL}};

 PyMODINIT_FUNC
 PyInit__imagingmorph(void) {
-    PyObject* m;
+    PyObject *m;

     static PyModuleDef module_def = {
         PyModuleDef_HEAD_INIT,
-        "_imagingmorph",         /* m_name */
-        "A module for doing image morphology",               /* m_doc */
-        -1,                 /* m_size */
-        functions,          /* m_methods */
+        "_imagingmorph",                       /* m_name */
+        "A module for doing image morphology", /* m_doc */
+        -1,                                    /* m_size */
+        functions,                             /* m_methods */
     };

     m = PyModule_Create(&module_def);
('src', '_imaging.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -94,31 +94,30 @@
 #include <math.h>

 /* Configuration stuff. Feel free to undef things you don't need. */
-#define WITH_IMAGECHOPS /* ImageChops support */
-#define WITH_IMAGEDRAW /* ImageDraw support */
-#define WITH_MAPPING /* use memory mapping to read some file formats */
-#define WITH_IMAGEPATH /* ImagePath stuff */
-#define WITH_ARROW /* arrow graphics stuff (experimental) */
-#define WITH_EFFECTS /* special effects */
-#define WITH_QUANTIZE /* quantization support */
-#define WITH_RANKFILTER /* rank filter */
-#define WITH_MODEFILTER /* mode filter */
-#define WITH_THREADING /* "friendly" threading support */
+#define WITH_IMAGECHOPS  /* ImageChops support */
+#define WITH_IMAGEDRAW   /* ImageDraw support */
+#define WITH_MAPPING     /* use memory mapping to read some file formats */
+#define WITH_IMAGEPATH   /* ImagePath stuff */
+#define WITH_ARROW       /* arrow graphics stuff (experimental) */
+#define WITH_EFFECTS     /* special effects */
+#define WITH_QUANTIZE    /* quantization support */
+#define WITH_RANKFILTER  /* rank filter */
+#define WITH_MODEFILTER  /* mode filter */
+#define WITH_THREADING   /* "friendly" threading support */
 #define WITH_UNSHARPMASK /* Kevin Cazabon's unsharpmask module */

-#undef    VERBOSE
-
-#define B16(p, i) ((((int)p[(i)]) << 8) + p[(i)+1])
-#define L16(p, i) ((((int)p[(i)+1]) << 8) + p[(i)])
-#define S16(v) ((v) < 32768 ? (v) : ((v) - 65536))
+#undef VERBOSE
+
+#define B16(p, i) ((((int)p[(i)]) << 8) + p[(i) + 1])
+#define L16(p, i) ((((int)p[(i) + 1]) << 8) + p[(i)])
+#define S16(v) ((v) < 32768 ? (v) : ((v)-65536))

 /* -------------------------------------------------------------------- */
 /* OBJECT ADMINISTRATION                        */
 /* -------------------------------------------------------------------- */

 typedef struct {
-    PyObject_HEAD
-    Imaging image;
+    PyObject_HEAD Imaging image;
     ImagingAccess access;
 } ImagingObject;

@@ -126,8 +125,7 @@

 #ifdef WITH_IMAGEDRAW

-typedef struct
-{
+typedef struct {
     /* to write a character, cut out sxy from glyph data, place
        at current position plus dxy, and advance by (dx, dy) */
     int dx, dy;
@@ -136,8 +134,7 @@
 } Glyph;

 typedef struct {
-    PyObject_HEAD
-    ImagingObject* ref;
+    PyObject_HEAD ImagingObject *ref;
     Imaging bitmap;
     int ysize;
     int baseline;
@@ -147,8 +144,7 @@
 static PyTypeObject ImagingFont_Type;

 typedef struct {
-    PyObject_HEAD
-    ImagingObject* image;
+    PyObject_HEAD ImagingObject *image;
     UINT8 ink[4];
     int blend;
 } ImagingDrawObject;
@@ -158,17 +154,15 @@
 #endif

 typedef struct {
-    PyObject_HEAD
-    ImagingObject* image;
+    PyObject_HEAD ImagingObject *image;
     int readonly;
 } PixelAccessObject;

 static PyTypeObject PixelAccess_Type;

-PyObject*
-PyImagingNew(Imaging imOut)
-{
-    ImagingObject* imagep;
+PyObject *
+PyImagingNew(Imaging imOut) {
+    ImagingObject *imagep;

     if (!imOut) {
         return NULL;
@@ -187,13 +181,11 @@
     imagep->image = imOut;
     imagep->access = ImagingAccessNew(imOut);

-    return (PyObject*) imagep;
+    return (PyObject *)imagep;
 }

 static void
-_dealloc(ImagingObject* imagep)
-{
-
+_dealloc(ImagingObject *imagep) {
 #ifdef VERBOSE
     printf("imaging %p deleted\n", imagep);
 #endif
@@ -207,8 +199,8 @@

 #define PyImaging_Check(op) (Py_TYPE(op) == &Imaging_Type)

-Imaging PyImaging_AsImaging(PyObject *op)
-{
+Imaging
+PyImaging_AsImaging(PyObject *op) {
     if (!PyImaging_Check(op)) {
         PyErr_BadInternalCall();
         return NULL;
@@ -216,23 +208,22 @@

     return ((ImagingObject *)op)->image;
 }
-

 /* -------------------------------------------------------------------- */
 /* THREAD HANDLING                                                      */
 /* -------------------------------------------------------------------- */

-void ImagingSectionEnter(ImagingSectionCookie* cookie)
-{
+void
+ImagingSectionEnter(ImagingSectionCookie *cookie) {
 #ifdef WITH_THREADING
-    *cookie = (PyThreadState *) PyEval_SaveThread();
-#endif
-}
-
-void ImagingSectionLeave(ImagingSectionCookie* cookie)
-{
+    *cookie = (PyThreadState *)PyEval_SaveThread();
+#endif
+}
+
+void
+ImagingSectionLeave(ImagingSectionCookie *cookie) {
 #ifdef WITH_THREADING
-    PyEval_RestoreThread((PyThreadState*) *cookie);
+    PyEval_RestoreThread((PyThreadState *)*cookie);
 #endif
 }

@@ -241,13 +232,13 @@
 /* -------------------------------------------------------------------- */
 /* Python compatibility API */

-int PyImaging_CheckBuffer(PyObject* buffer)
-{
+int
+PyImaging_CheckBuffer(PyObject *buffer) {
     return PyObject_CheckBuffer(buffer);
 }

-int PyImaging_GetBuffer(PyObject* buffer, Py_buffer *view)
-{
+int
+PyImaging_GetBuffer(PyObject *buffer, Py_buffer *view) {
     /* must call check_buffer first! */
     return PyObject_GetBuffer(buffer, view, PyBUF_SIMPLE);
 }
@@ -257,58 +248,50 @@
 /* -------------------------------------------------------------------- */

 /* error messages */
-static const char* must_be_sequence = "argument must be a sequence";
-static const char* must_be_two_coordinates =
-                     "coordinate list must contain exactly 2 coordinates";
-static const char* wrong_mode = "unrecognized image mode";
-static const char* wrong_raw_mode = "unrecognized raw mode";
-static const char* outside_image = "image index out of range";
-static const char* outside_palette = "palette index out of range";
-static const char* wrong_palette_size = "invalid palette size";
-static const char* no_palette = "image has no palette";
-static const char* readonly = "image is readonly";
+static const char *must_be_sequence = "argument must be a sequence";
+static const char *must_be_two_coordinates =
+    "coordinate list must contain exactly 2 coordinates";
+static const char *wrong_mode = "unrecognized image mode";
+static const char *wrong_raw_mode = "unrecognized raw mode";
+static const char *outside_image = "image index out of range";
+static const char *outside_palette = "palette index out of range";
+static const char *wrong_palette_size = "invalid palette size";
+static const char *no_palette = "image has no palette";
+static const char *readonly = "image is readonly";
 /* static const char* no_content = "image has no content"; */

 void *
-ImagingError_OSError(void)
-{
+ImagingError_OSError(void) {
     PyErr_SetString(PyExc_OSError, "error when accessing file");
     return NULL;
 }

 void *
-ImagingError_MemoryError(void)
-{
+ImagingError_MemoryError(void) {
     return PyErr_NoMemory();
 }

 void *
-ImagingError_Mismatch(void)
-{
+ImagingError_Mismatch(void) {
     PyErr_SetString(PyExc_ValueError, "images do not match");
     return NULL;
 }

 void *
-ImagingError_ModeError(void)
-{
+ImagingError_ModeError(void) {
     PyErr_SetString(PyExc_ValueError, "image has wrong mode");
     return NULL;
 }

 void *
-ImagingError_ValueError(const char *message)
-{
+ImagingError_ValueError(const char *message) {
     PyErr_SetString(
-        PyExc_ValueError,
-        (message) ? (char*) message : "unrecognized argument value"
-        );
+        PyExc_ValueError, (message) ? (char *)message : "unrecognized argument value");
     return NULL;
 }

 void
-ImagingError_Clear(void)
-{
+ImagingError_Clear(void) {
     PyErr_Clear();
 }

@@ -317,8 +300,7 @@
 /* -------------------------------------------------------------------- */

 static int
-getbands(const char* mode)
-{
+getbands(const char *mode) {
     Imaging im;
     int bands;

@@ -335,15 +317,14 @@
     return bands;
 }

-#define TYPE_UINT8 (0x100|sizeof(UINT8))
-#define TYPE_INT32 (0x200|sizeof(INT32))
-#define TYPE_FLOAT16 (0x500|sizeof(FLOAT16))
-#define TYPE_FLOAT32 (0x300|sizeof(FLOAT32))
-#define TYPE_DOUBLE (0x400|sizeof(double))
-
-static void*
-getlist(PyObject* arg, Py_ssize_t* length, const char* wrong_length, int type)
-{
+#define TYPE_UINT8 (0x100 | sizeof(UINT8))
+#define TYPE_INT32 (0x200 | sizeof(INT32))
+#define TYPE_FLOAT16 (0x500 | sizeof(FLOAT16))
+#define TYPE_FLOAT32 (0x300 | sizeof(FLOAT32))
+#define TYPE_DOUBLE (0x400 | sizeof(double))
+
+static void *
+getlist(PyObject *arg, Py_ssize_t *length, const char *wrong_length, int type) {
     /* - allocates and returns a c array of the items in the
           python sequence arg.
        - the size of the returned array is in length
@@ -358,11 +339,11 @@
     int itemp;
     double dtemp;
     FLOAT32 ftemp;
-    UINT8* list;
-    PyObject* seq;
-    PyObject* op;
-
-    if ( ! PySequence_Check(arg)) {
+    UINT8 *list;
+    PyObject *seq;
+    PyObject *op;
+
+    if (!PySequence_Check(arg)) {
         PyErr_SetString(PyExc_TypeError, must_be_sequence);
         return NULL;
     }
@@ -376,12 +357,12 @@
     /* malloc check ok, type & ff is just a sizeof(something)
        calloc checks for overflow */
     list = calloc(n, type & 0xff);
-    if ( ! list) {
+    if (!list) {
         return ImagingError_MemoryError();
     }

     seq = PySequence_Fast(arg, must_be_sequence);
-    if ( ! seq) {
+    if (!seq) {
         free(list);
         return NULL;
     }
@@ -391,22 +372,22 @@
         // DRY, branch prediction is going to work _really_ well
         // on this switch. And 3 fewer loops to copy/paste.
         switch (type) {
-        case TYPE_UINT8:
-            itemp = PyLong_AsLong(op);
-            list[i] = CLIP8(itemp);
-            break;
-        case TYPE_INT32:
-            itemp = PyLong_AsLong(op);
-            memcpy(list + i * sizeof(INT32), &itemp, sizeof(itemp));
-            break;
-        case TYPE_FLOAT32:
-            ftemp = (FLOAT32)PyFloat_AsDouble(op);
-            memcpy(list + i * sizeof(ftemp), &ftemp, sizeof(ftemp));
-            break;
-        case TYPE_DOUBLE:
-            dtemp = PyFloat_AsDouble(op);
-            memcpy(list + i * sizeof(dtemp), &dtemp, sizeof(dtemp));
-            break;
+            case TYPE_UINT8:
+                itemp = PyLong_AsLong(op);
+                list[i] = CLIP8(itemp);
+                break;
+            case TYPE_INT32:
+                itemp = PyLong_AsLong(op);
+                memcpy(list + i * sizeof(INT32), &itemp, sizeof(itemp));
+                break;
+            case TYPE_FLOAT32:
+                ftemp = (FLOAT32)PyFloat_AsDouble(op);
+                memcpy(list + i * sizeof(ftemp), &ftemp, sizeof(ftemp));
+                break;
+            case TYPE_DOUBLE:
+                dtemp = PyFloat_AsDouble(op);
+                memcpy(list + i * sizeof(dtemp), &dtemp, sizeof(dtemp));
+                break;
         }
     }

@@ -431,31 +412,30 @@
     UINT32 t3;
     FLOAT32 out[1] = {0};

-    t1 = in & 0x7fff;                       // Non-sign bits
-    t2 = in & 0x8000;                       // Sign bit
-    t3 = in & 0x7c00;                       // Exponent
-
-    t1 <<= 13;                              // Align mantissa on MSB
-    t2 <<= 16;                              // Shift sign bit into position
-
-    t1 += 0x38000000;                       // Adjust bias
-
-    t1 = (t3 == 0 ? 0 : t1);                // Denormals-as-zero
-
-    t1 |= t2;                               // Re-insert sign bit
+    t1 = in & 0x7fff;  // Non-sign bits
+    t2 = in & 0x8000;  // Sign bit
+    t3 = in & 0x7c00;  // Exponent
+
+    t1 <<= 13;  // Align mantissa on MSB
+    t2 <<= 16;  // Shift sign bit into position
+
+    t1 += 0x38000000;  // Adjust bias
+
+    t1 = (t3 == 0 ? 0 : t1);  // Denormals-as-zero
+
+    t1 |= t2;  // Re-insert sign bit

     memcpy(out, &t1, 4);
     return out[0];
 }

-static inline PyObject*
-getpixel(Imaging im, ImagingAccess access, int x, int y)
-{
+static inline PyObject *
+getpixel(Imaging im, ImagingAccess access, int x, int y) {
     union {
-      UINT8 b[4];
-      UINT16 h;
-      INT32 i;
-      FLOAT32 f;
+        UINT8 b[4];
+        UINT16 h;
+        INT32 i;
+        FLOAT32 f;
     } pixel;

     if (x < 0) {
@@ -473,27 +453,28 @@
     access->get_pixel(im, x, y, &pixel);

     switch (im->type) {
-    case IMAGING_TYPE_UINT8:
-        switch (im->bands) {
-        case 1:
-            return PyLong_FromLong(pixel.b[0]);
-        case 2:
-            return Py_BuildValue("BB", pixel.b[0], pixel.b[1]);
-        case 3:
-            return Py_BuildValue("BBB", pixel.b[0], pixel.b[1], pixel.b[2]);
-        case 4:
-            return Py_BuildValue("BBBB", pixel.b[0], pixel.b[1], pixel.b[2], pixel.b[3]);
-        }
-        break;
-    case IMAGING_TYPE_INT32:
-        return PyLong_FromLong(pixel.i);
-    case IMAGING_TYPE_FLOAT32:
-        return PyFloat_FromDouble(pixel.f);
-    case IMAGING_TYPE_SPECIAL:
-        if (strncmp(im->mode, "I;16", 4) == 0) {
-            return PyLong_FromLong(pixel.h);
-        }
-        break;
+        case IMAGING_TYPE_UINT8:
+            switch (im->bands) {
+                case 1:
+                    return PyLong_FromLong(pixel.b[0]);
+                case 2:
+                    return Py_BuildValue("BB", pixel.b[0], pixel.b[1]);
+                case 3:
+                    return Py_BuildValue("BBB", pixel.b[0], pixel.b[1], pixel.b[2]);
+                case 4:
+                    return Py_BuildValue(
+                        "BBBB", pixel.b[0], pixel.b[1], pixel.b[2], pixel.b[3]);
+            }
+            break;
+        case IMAGING_TYPE_INT32:
+            return PyLong_FromLong(pixel.i);
+        case IMAGING_TYPE_FLOAT32:
+            return PyFloat_FromDouble(pixel.f);
+        case IMAGING_TYPE_SPECIAL:
+            if (strncmp(im->mode, "I;16", 4) == 0) {
+                return PyLong_FromLong(pixel.h);
+            }
+            break;
     }

     /* unknown type */
@@ -501,11 +482,10 @@
     return Py_None;
 }

-static char*
-getink(PyObject* color, Imaging im, char* ink)
-{
-    int g=0, b=0, a=0;
-    double f=0;
+static char *
+getink(PyObject *color, Imaging im, char *ink) {
+    int g = 0, b = 0, a = 0;
+    double f = 0;
     /* Windows 64 bit longs are 32 bits, and 0xFFFFFFFF (white) is a
        python long (not int) that raises an overflow error when trying
        to return it into a 32 bit C long
@@ -518,11 +498,10 @@
        be cast to either UINT8 or INT32 */

     int rIsInt = 0;
-    if (PyTuple_Check(color) && PyTuple_Size(color) == 1) {
+    if (PyTuple_Check(color) && PyTuple_GET_SIZE(color) == 1) {
         color = PyTuple_GetItem(color, 0);
     }
-    if (im->type == IMAGING_TYPE_UINT8 ||
-        im->type == IMAGING_TYPE_INT32 ||
+    if (im->type == IMAGING_TYPE_UINT8 || im->type == IMAGING_TYPE_INT32 ||
         im->type == IMAGING_TYPE_SPECIAL) {
         if (PyLong_Check(color)) {
             r = PyLong_AsLongLong(color);
@@ -536,70 +515,81 @@
                 return NULL;
             }
         } else {
-            PyErr_SetString(PyExc_TypeError, "color must be int or single-element tuple");
+            PyErr_SetString(
+                PyExc_TypeError, "color must be int or single-element tuple");
             return NULL;
         }
     }

     switch (im->type) {
-    case IMAGING_TYPE_UINT8:
-        /* unsigned integer */
-        if (im->bands == 1) {
-            /* unsigned integer, single layer */
-            if (rIsInt != 1) {
-                if (!PyArg_ParseTuple(color, "L", &r)) {
-                    return NULL;
-                }
-            }
-            ink[0] = (char) CLIP8(r);
-            ink[1] = ink[2] = ink[3] = 0;
-        } else {
-            a = 255;
-            if (rIsInt) {
-                /* compatibility: ABGR */
-                a = (UINT8) (r >> 24);
-                b = (UINT8) (r >> 16);
-                g = (UINT8) (r >> 8);
-                r = (UINT8) r;
-            } else {
-                if (im->bands == 2) {
-                    if (!PyArg_ParseTuple(color, "L|i", &r, &a)) {
+        case IMAGING_TYPE_UINT8:
+            /* unsigned integer */
+            if (im->bands == 1) {
+                /* unsigned integer, single layer */
+                if (rIsInt != 1) {
+                    if (PyTuple_GET_SIZE(color) != 1) {
+                        PyErr_SetString(PyExc_TypeError, "color must be int or single-element tuple");
                         return NULL;
-                    }
-                    g = b = r;
-                } else {
-                    if (!PyArg_ParseTuple(color, "Lii|i", &r, &g, &b, &a)) {
+                    } else if (!PyArg_ParseTuple(color, "L", &r)) {
                         return NULL;
                     }
                 }
+                ink[0] = (char)CLIP8(r);
+                ink[1] = ink[2] = ink[3] = 0;
+            } else {
+                a = 255;
+                if (rIsInt) {
+                    /* compatibility: ABGR */
+                    a = (UINT8)(r >> 24);
+                    b = (UINT8)(r >> 16);
+                    g = (UINT8)(r >> 8);
+                    r = (UINT8)r;
+                } else {
+                    int tupleSize = PyTuple_GET_SIZE(color);
+                    if (im->bands == 2) {
+                        if (tupleSize != 1 && tupleSize != 2) {
+                            PyErr_SetString(PyExc_TypeError, "color must be int, or tuple of one or two elements");
+                            return NULL;
+                        } else if (!PyArg_ParseTuple(color, "L|i", &r, &a)) {
+                            return NULL;
+                        }
+                        g = b = r;
+                    } else {
+                        if (tupleSize != 3 && tupleSize != 4) {
+                            PyErr_SetString(PyExc_TypeError, "color must be int, or tuple of one, three or four elements");
+                            return NULL;
+                        } else if (!PyArg_ParseTuple(color, "Lii|i", &r, &g, &b, &a)) {
+                            return NULL;
+                        }
+                    }
+                }
+                ink[0] = (char)CLIP8(r);
+                ink[1] = (char)CLIP8(g);
+                ink[2] = (char)CLIP8(b);
+                ink[3] = (char)CLIP8(a);
             }
-            ink[0] = (char) CLIP8(r);
-            ink[1] = (char) CLIP8(g);
-            ink[2] = (char) CLIP8(b);
-            ink[3] = (char) CLIP8(a);
-        }
-        return ink;
-    case IMAGING_TYPE_INT32:
-        /* signed integer */
-        itmp = r;
-        memcpy(ink, &itmp, sizeof(itmp));
-        return ink;
-    case IMAGING_TYPE_FLOAT32:
-        /* floating point */
-        f = PyFloat_AsDouble(color);
-        if (f == -1.0 && PyErr_Occurred()) {
-            return NULL;
-        }
-        ftmp = f;
-        memcpy(ink, &ftmp, sizeof(ftmp));
-        return ink;
-    case IMAGING_TYPE_SPECIAL:
-        if (strncmp(im->mode, "I;16", 4) == 0) {
-            ink[0] = (UINT8) r;
-            ink[1] = (UINT8) (r >> 8);
-            ink[2] = ink[3] = 0;
             return ink;
-        }
+        case IMAGING_TYPE_INT32:
+            /* signed integer */
+            itmp = r;
+            memcpy(ink, &itmp, sizeof(itmp));
+            return ink;
+        case IMAGING_TYPE_FLOAT32:
+            /* floating point */
+            f = PyFloat_AsDouble(color);
+            if (f == -1.0 && PyErr_Occurred()) {
+                return NULL;
+            }
+            ftmp = f;
+            memcpy(ink, &ftmp, sizeof(ftmp));
+            return ink;
+        case IMAGING_TYPE_SPECIAL:
+            if (strncmp(im->mode, "I;16", 4) == 0) {
+                ink[0] = (UINT8)r;
+                ink[1] = (UINT8)(r >> 8);
+                ink[2] = ink[3] = 0;
+                return ink;
+            }
     }

     PyErr_SetString(PyExc_ValueError, wrong_mode);
@@ -610,12 +600,11 @@
 /* FACTORIES                                */
 /* -------------------------------------------------------------------- */

-static PyObject*
-_fill(PyObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_fill(PyObject *self, PyObject *args) {
+    char *mode;
     int xsize, ysize;
-    PyObject* color;
+    PyObject *color;
     char buffer[4];
     Imaging im;

@@ -639,16 +628,14 @@
         }
     }

-
-    (void) ImagingFill(im, buffer);
+    (void)ImagingFill(im, buffer);

     return PyImagingNew(im);
 }

-static PyObject*
-_new(PyObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_new(PyObject *self, PyObject *args) {
+    char *mode;
     int xsize, ysize;

     if (!PyArg_ParseTuple(args, "s(ii)", &mode, &xsize, &ysize)) {
@@ -658,10 +645,9 @@
     return PyImagingNew(ImagingNew(mode, xsize, ysize));
 }

-static PyObject*
-_new_block(PyObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_new_block(PyObject *self, PyObject *args) {
+    char *mode;
     int xsize, ysize;

     if (!PyArg_ParseTuple(args, "s(ii)", &mode, &xsize, &ysize)) {
@@ -671,10 +657,9 @@
     return PyImagingNew(ImagingNewBlock(mode, xsize, ysize));
 }

-static PyObject*
-_linear_gradient(PyObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_linear_gradient(PyObject *self, PyObject *args) {
+    char *mode;

     if (!PyArg_ParseTuple(args, "s", &mode)) {
         return NULL;
@@ -683,10 +668,9 @@
     return PyImagingNew(ImagingFillLinearGradient(mode));
 }

-static PyObject*
-_radial_gradient(PyObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_radial_gradient(PyObject *self, PyObject *args) {
+    char *mode;

     if (!PyArg_ParseTuple(args, "s", &mode)) {
         return NULL;
@@ -695,64 +679,57 @@
     return PyImagingNew(ImagingFillRadialGradient(mode));
 }

-static PyObject*
-_alpha_composite(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep1;
-    ImagingObject* imagep2;
-
-    if (!PyArg_ParseTuple(args, "O!O!",
-              &Imaging_Type, &imagep1,
-              &Imaging_Type, &imagep2)) {
+static PyObject *
+_alpha_composite(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep1;
+    ImagingObject *imagep2;
+
+    if (!PyArg_ParseTuple(
+            args, "O!O!", &Imaging_Type, &imagep1, &Imaging_Type, &imagep2)) {
         return NULL;
     }

     return PyImagingNew(ImagingAlphaComposite(imagep1->image, imagep2->image));
 }

-static PyObject*
-_blend(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep1;
-    ImagingObject* imagep2;
+static PyObject *
+_blend(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep1;
+    ImagingObject *imagep2;
     double alpha;

     alpha = 0.5;
-    if (!PyArg_ParseTuple(args, "O!O!|d",
-                          &Imaging_Type, &imagep1,
-                          &Imaging_Type, &imagep2,
-                          &alpha)) {
-        return NULL;
-    }
-
-    return PyImagingNew(ImagingBlend(imagep1->image, imagep2->image,
-                     (float) alpha));
+    if (!PyArg_ParseTuple(
+            args, "O!O!|d", &Imaging_Type, &imagep1, &Imaging_Type, &imagep2, &alpha)) {
+        return NULL;
+    }
+
+    return PyImagingNew(ImagingBlend(imagep1->image, imagep2->image, (float)alpha));
 }

 /* -------------------------------------------------------------------- */
 /* METHODS                                                              */
 /* -------------------------------------------------------------------- */

-static INT16*
-_prepare_lut_table(PyObject* table, Py_ssize_t table_size)
-{
+static INT16 *
+_prepare_lut_table(PyObject *table, Py_ssize_t table_size) {
     int i;
     Py_buffer buffer_info;
     INT32 data_type = TYPE_FLOAT32;
     float item = 0;
-    void* table_data = NULL;
-    int   free_table_data = 0;
-    INT16* prepared;
-
-    /* NOTE: This value should be the same as in ColorLUT.c */
-    #define PRECISION_BITS (16 - 8 - 2)
-
-    const char* wrong_size = ("The table should have table_channels * "
-                              "size1D * size2D * size3D float items.");
+    void *table_data = NULL;
+    int free_table_data = 0;
+    INT16 *prepared;
+
+/* NOTE: This value should be the same as in ColorLUT.c */
+#define PRECISION_BITS (16 - 8 - 2)
+
+    const char *wrong_size =
+        ("The table should have table_channels * "
+         "size1D * size2D * size3D float items.");

     if (PyObject_CheckBuffer(table)) {
-        if ( ! PyObject_GetBuffer(table, &buffer_info,
-                                  PyBUF_CONTIG_RO | PyBUF_FORMAT)) {
+        if (!PyObject_GetBuffer(table, &buffer_info, PyBUF_CONTIG_RO | PyBUF_FORMAT)) {
             if (buffer_info.ndim == 1 && buffer_info.shape[0] == table_size) {
                 if (strlen(buffer_info.format) == 1) {
                     switch (buffer_info.format[0]) {
@@ -775,21 +752,21 @@
         }
     }

-    if ( ! table_data) {
+    if (!table_data) {
         free_table_data = 1;
         table_data = getlist(table, &table_size, wrong_size, TYPE_FLOAT32);
-        if ( ! table_data) {
+        if (!table_data) {
             return NULL;
         }
     }

     /* malloc check ok, max is 2 * 4 * 65**3 = 2197000 */
-    prepared = (INT16*) malloc(sizeof(INT16) * table_size);
-    if ( ! prepared) {
+    prepared = (INT16 *)malloc(sizeof(INT16) * table_size);
+    if (!prepared) {
         if (free_table_data) {
             free(table_data);
         }
-        return (INT16*) ImagingError_MemoryError();
+        return (INT16 *)ImagingError_MemoryError();
     }

     for (i = 0; i < table_size; i++) {
@@ -797,15 +774,16 @@
         double dtmp;
         switch (data_type) {
             case TYPE_FLOAT16:
-                memcpy(&htmp, ((char*) table_data) + i * sizeof(htmp), sizeof(htmp));
+                memcpy(&htmp, ((char *)table_data) + i * sizeof(htmp), sizeof(htmp));
                 item = float16tofloat32(htmp);
                 break;
             case TYPE_FLOAT32:
-                memcpy(&item, ((char*) table_data) + i * sizeof(FLOAT32), sizeof(FLOAT32));
+                memcpy(
+                    &item, ((char *)table_data) + i * sizeof(FLOAT32), sizeof(FLOAT32));
                 break;
             case TYPE_DOUBLE:
-                memcpy(&dtmp, ((char*) table_data) + i * sizeof(dtmp), sizeof(dtmp));
-                item = (FLOAT32) dtmp;
+                memcpy(&dtmp, ((char *)table_data) + i * sizeof(dtmp), sizeof(dtmp));
+                item = (FLOAT32)dtmp;
                 break;
         }
         /* Max value for INT16 */
@@ -825,69 +803,75 @@
         }
     }

-    #undef PRECISION_BITS
+#undef PRECISION_BITS
     if (free_table_data) {
         free(table_data);
     }
     return prepared;
 }

-
-static PyObject*
-_color_lut_3d(ImagingObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_color_lut_3d(ImagingObject *self, PyObject *args) {
+    char *mode;
     int filter;
     int table_channels;
     int size1D, size2D, size3D;
-    PyObject* table;
-
-    INT16* prepared_table;
+    PyObject *table;
+
+    INT16 *prepared_table;
     Imaging imOut;

-    if ( ! PyArg_ParseTuple(args, "siiiiiO:color_lut_3d", &mode, &filter,
-                            &table_channels, &size1D, &size2D, &size3D,
-                            &table)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "siiiiiO:color_lut_3d",
+            &mode,
+            &filter,
+            &table_channels,
+            &size1D,
+            &size2D,
+            &size3D,
+            &table)) {
         return NULL;
     }

     /* actually, it is trilinear */
     if (filter != IMAGING_TRANSFORM_BILINEAR) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Only LINEAR filter is supported.");
+        PyErr_SetString(PyExc_ValueError, "Only LINEAR filter is supported.");
         return NULL;
     }

     if (1 > table_channels || table_channels > 4) {
-        PyErr_SetString(PyExc_ValueError,
-                        "table_channels should be from 1 to 4");
-        return NULL;
-    }
-
-    if (2 > size1D || size1D > 65 ||
-        2 > size2D || size2D > 65 ||
-        2 > size3D || size3D > 65
-    ) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Table size in any dimension should be from 2 to 65");
-        return NULL;
-    }
-
-    prepared_table = _prepare_lut_table(
-        table, table_channels * size1D * size2D * size3D);
-    if ( ! prepared_table) {
+        PyErr_SetString(PyExc_ValueError, "table_channels should be from 1 to 4");
+        return NULL;
+    }
+
+    if (2 > size1D || size1D > 65 || 2 > size2D || size2D > 65 || 2 > size3D ||
+        size3D > 65) {
+        PyErr_SetString(
+            PyExc_ValueError, "Table size in any dimension should be from 2 to 65");
+        return NULL;
+    }
+
+    prepared_table =
+        _prepare_lut_table(table, table_channels * size1D * size2D * size3D);
+    if (!prepared_table) {
         return NULL;
     }

     imOut = ImagingNewDirty(mode, self->image->xsize, self->image->ysize);
-    if ( ! imOut) {
+    if (!imOut) {
         free(prepared_table);
         return NULL;
     }

-    if ( ! ImagingColorLUT3D_linear(imOut, self->image,
-                                    table_channels, size1D, size2D, size3D,
-                                    prepared_table)) {
+    if (!ImagingColorLUT3D_linear(
+            imOut,
+            self->image,
+            table_channels,
+            size1D,
+            size2D,
+            size3D,
+            prepared_table)) {
         free(prepared_table);
         ImagingDelete(imOut);
         return NULL;
@@ -898,10 +882,9 @@
     return PyImagingNew(imOut);
 }

-static PyObject*
-_convert(ImagingObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_convert(ImagingObject *self, PyObject *args) {
+    char *mode;
     int dither = 0;
     ImagingObject *paletteimage = NULL;

@@ -911,7 +894,8 @@
     if (paletteimage != NULL) {
         if (!PyImaging_Check(paletteimage)) {
             PyObject_Print((PyObject *)paletteimage, stderr, 0);
-            PyErr_SetString(PyExc_ValueError, "palette argument must be image with mode 'P'");
+            PyErr_SetString(
+                PyExc_ValueError, "palette argument must be image with mode 'P'");
             return NULL;
         }
         if (paletteimage->image->palette == NULL) {
@@ -920,17 +904,16 @@
         }
     }

-    return PyImagingNew(ImagingConvert(self->image, mode, paletteimage ? paletteimage->image->palette : NULL, dither));
-}
-
-static PyObject*
-_convert2(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep1;
-    ImagingObject* imagep2;
-    if (!PyArg_ParseTuple(args, "O!O!",
-                          &Imaging_Type, &imagep1,
-                          &Imaging_Type, &imagep2)) {
+    return PyImagingNew(ImagingConvert(
+        self->image, mode, paletteimage ? paletteimage->image->palette : NULL, dither));
+}
+
+static PyObject *
+_convert2(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep1;
+    ImagingObject *imagep2;
+    if (!PyArg_ParseTuple(
+            args, "O!O!", &Imaging_Type, &imagep1, &Imaging_Type, &imagep2)) {
         return NULL;
     }

@@ -942,17 +925,28 @@
     return Py_None;
 }

-static PyObject*
-_convert_matrix(ImagingObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_convert_matrix(ImagingObject *self, PyObject *args) {
+    char *mode;
     float m[12];
-    if (!PyArg_ParseTuple(args, "s(ffff)", &mode, m+0, m+1, m+2, m+3)) {
+    if (!PyArg_ParseTuple(args, "s(ffff)", &mode, m + 0, m + 1, m + 2, m + 3)) {
         PyErr_Clear();
-        if (!PyArg_ParseTuple(args, "s(ffffffffffff)", &mode,
-                              m+0, m+1, m+2, m+3,
-                              m+4, m+5, m+6, m+7,
-                              m+8, m+9, m+10, m+11)){
+        if (!PyArg_ParseTuple(
+                args,
+                "s(ffffffffffff)",
+                &mode,
+                m + 0,
+                m + 1,
+                m + 2,
+                m + 3,
+                m + 4,
+                m + 5,
+                m + 6,
+                m + 7,
+                m + 8,
+                m + 9,
+                m + 10,
+                m + 11)) {
             return NULL;
         }
     }
@@ -960,11 +954,10 @@
     return PyImagingNew(ImagingConvertMatrix(self->image, mode, m));
 }

-static PyObject*
-_convert_transparent(ImagingObject* self, PyObject* args)
-{
-    char* mode;
-    int r,g,b;
+static PyObject *
+_convert_transparent(ImagingObject *self, PyObject *args) {
+    char *mode;
+    int r, g, b;
     if (PyArg_ParseTuple(args, "s(iii)", &mode, &r, &g, &b)) {
         return PyImagingNew(ImagingConvertTransparent(self->image, mode, r, g, b));
     }
@@ -975,9 +968,8 @@
     return NULL;
 }

-static PyObject*
-_copy(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_copy(ImagingObject *self, PyObject *args) {
     if (!PyArg_ParseTuple(args, "")) {
         return NULL;
     }
@@ -985,9 +977,8 @@
     return PyImagingNew(ImagingCopy(self->image));
 }

-static PyObject*
-_crop(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_crop(ImagingObject *self, PyObject *args) {
     int x0, y0, x1, y1;
     if (!PyArg_ParseTuple(args, "(iiii)", &x0, &y0, &x1, &y1)) {
         return NULL;
@@ -996,9 +987,8 @@
     return PyImagingNew(ImagingCrop(self->image, x0, y0, x1, y1));
 }

-static PyObject*
-_expand_image(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_expand_image(ImagingObject *self, PyObject *args) {
     int x, y;
     int mode = 0;
     if (!PyArg_ParseTuple(args, "ii|i", &x, &y, &mode)) {
@@ -1008,18 +998,17 @@
     return PyImagingNew(ImagingExpand(self->image, x, y, mode));
 }

-static PyObject*
-_filter(ImagingObject* self, PyObject* args)
-{
-    PyObject* imOut;
+static PyObject *
+_filter(ImagingObject *self, PyObject *args) {
+    PyObject *imOut;
     Py_ssize_t kernelsize;
-    FLOAT32* kerneldata;
+    FLOAT32 *kerneldata;

     int xsize, ysize, i;
     float divisor, offset;
-    PyObject* kernel = NULL;
-    if (!PyArg_ParseTuple(args, "(ii)ffO", &xsize, &ysize,
-                          &divisor, &offset, &kernel)) {
+    PyObject *kernel = NULL;
+    if (!PyArg_ParseTuple(
+            args, "(ii)ffO", &xsize, &ysize, &divisor, &offset, &kernel)) {
         return NULL;
     }

@@ -1028,7 +1017,7 @@
     if (!kerneldata) {
         return NULL;
     }
-    if (kernelsize != (Py_ssize_t) xsize * (Py_ssize_t) ysize) {
+    if (kernelsize != (Py_ssize_t)xsize * (Py_ssize_t)ysize) {
         free(kerneldata);
         return ImagingError_ValueError("bad kernel size");
     }
@@ -1037,9 +1026,7 @@
         kerneldata[i] /= divisor;
     }

-    imOut = PyImagingNew(
-        ImagingFilter(self->image, xsize, ysize, kerneldata, offset)
-        );
+    imOut = PyImagingNew(ImagingFilter(self->image, xsize, ysize, kerneldata, offset));

     free(kerneldata);

@@ -1047,9 +1034,8 @@
 }

 #ifdef WITH_UNSHARPMASK
-static PyObject*
-_gaussian_blur(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_gaussian_blur(ImagingObject *self, PyObject *args) {
     Imaging imIn;
     Imaging imOut;

@@ -1074,16 +1060,15 @@
 }
 #endif

-static PyObject*
-_getpalette(ImagingObject* self, PyObject* args)
-{
-    PyObject* palette;
-    int palettesize = 256;
+static PyObject *
+_getpalette(ImagingObject *self, PyObject *args) {
+    PyObject *palette;
+    int palettesize;
     int bits;
     ImagingShuffler pack;

-    char* mode = "RGB";
-    char* rawmode = "RGB";
+    char *mode = "RGB";
+    char *rawmode = "RGB";
     if (!PyArg_ParseTuple(args, "|ss", &mode, &rawmode)) {
         return NULL;
     }
@@ -1099,32 +1084,31 @@
         return NULL;
     }

+    palettesize = self->image->palette->size;
     palette = PyBytes_FromStringAndSize(NULL, palettesize * bits / 8);
     if (!palette) {
         return NULL;
     }

-    pack((UINT8*) PyBytes_AsString(palette),
-         self->image->palette->palette, palettesize);
+    pack(
+        (UINT8 *)PyBytes_AsString(palette), self->image->palette->palette, palettesize);

     return palette;
 }

-static PyObject*
-_getpalettemode(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_getpalettemode(ImagingObject *self) {
     if (!self->image->palette) {
-    PyErr_SetString(PyExc_ValueError, no_palette);
-    return NULL;
+        PyErr_SetString(PyExc_ValueError, no_palette);
+        return NULL;
     }

     return PyUnicode_FromString(self->image->palette->mode);
 }

 static inline int
-_getxy(PyObject* xy, int* x, int *y)
-{
-    PyObject* value;
+_getxy(PyObject *xy, int *x, int *y) {
+    PyObject *value;

     if (!PyTuple_Check(xy) || PyTuple_GET_SIZE(xy) != 2) {
         goto badarg;
@@ -1134,48 +1118,48 @@
     if (PyLong_Check(value)) {
         *x = PyLong_AS_LONG(value);
     } else if (PyFloat_Check(value)) {
-        *x = (int) PyFloat_AS_DOUBLE(value);
+        *x = (int)PyFloat_AS_DOUBLE(value);
     } else {
-        goto badval;
+        PyObject *int_value = PyObject_CallMethod(value, "__int__", NULL);
+        if (int_value != NULL && PyLong_Check(int_value)) {
+            *x = PyLong_AS_LONG(int_value);
+        } else {
+            goto badval;
+        }
     }

     value = PyTuple_GET_ITEM(xy, 1);
     if (PyLong_Check(value)) {
         *y = PyLong_AS_LONG(value);
     } else if (PyFloat_Check(value)) {
-        *y = (int) PyFloat_AS_DOUBLE(value);
+        *y = (int)PyFloat_AS_DOUBLE(value);
     } else {
-        goto badval;
+        PyObject *int_value = PyObject_CallMethod(value, "__int__", NULL);
+        if (int_value != NULL && PyLong_Check(int_value)) {
+            *y = PyLong_AS_LONG(int_value);
+        } else {
+            goto badval;
+        }
     }

     return 0;

-  badarg:
-    PyErr_SetString(
-        PyExc_TypeError,
-        "argument must be sequence of length 2"
-        );
+badarg:
+    PyErr_SetString(PyExc_TypeError, "argument must be sequence of length 2");
     return -1;

-  badval:
-    PyErr_SetString(
-        PyExc_TypeError,
-        "an integer is required"
-        );
+badval:
+    PyErr_SetString(PyExc_TypeError, "an integer is required");
     return -1;
 }

-static PyObject*
-_getpixel(ImagingObject* self, PyObject* args)
-{
-    PyObject* xy;
+static PyObject *
+_getpixel(ImagingObject *self, PyObject *args) {
+    PyObject *xy;
     int x, y;

     if (PyTuple_GET_SIZE(args) != 1) {
-        PyErr_SetString(
-            PyExc_TypeError,
-            "argument 1 must be sequence of length 2"
-            );
+        PyErr_SetString(PyExc_TypeError, "argument 1 must be sequence of length 2");
         return NULL;
     }

@@ -1199,38 +1183,37 @@
     FLOAT32 f[2];
 };

-static union hist_extrema*
-parse_histogram_extremap(ImagingObject* self, PyObject* extremap,
-                         union hist_extrema* ep)
-{
+static union hist_extrema *
+parse_histogram_extremap(
+    ImagingObject *self, PyObject *extremap, union hist_extrema *ep) {
     int i0, i1;
     double f0, f1;

     if (extremap) {
         switch (self->image->type) {
-        case IMAGING_TYPE_UINT8:
-            if (!PyArg_ParseTuple(extremap, "ii", &i0, &i1)) {
+            case IMAGING_TYPE_UINT8:
+                if (!PyArg_ParseTuple(extremap, "ii", &i0, &i1)) {
+                    return NULL;
+                }
+                ep->u[0] = CLIP8(i0);
+                ep->u[1] = CLIP8(i1);
+                break;
+            case IMAGING_TYPE_INT32:
+                if (!PyArg_ParseTuple(extremap, "ii", &i0, &i1)) {
+                    return NULL;
+                }
+                ep->i[0] = i0;
+                ep->i[1] = i1;
+                break;
+            case IMAGING_TYPE_FLOAT32:
+                if (!PyArg_ParseTuple(extremap, "dd", &f0, &f1)) {
+                    return NULL;
+                }
+                ep->f[0] = (FLOAT32)f0;
+                ep->f[1] = (FLOAT32)f1;
+                break;
+            default:
                 return NULL;
-            }
-            ep->u[0] = CLIP8(i0);
-            ep->u[1] = CLIP8(i1);
-            break;
-        case IMAGING_TYPE_INT32:
-            if (!PyArg_ParseTuple(extremap, "ii", &i0, &i1)) {
-                return NULL;
-            }
-            ep->i[0] = i0;
-            ep->i[1] = i1;
-            break;
-        case IMAGING_TYPE_FLOAT32:
-            if (!PyArg_ParseTuple(extremap, "dd", &f0, &f1)) {
-                return NULL;
-            }
-            ep->f[0] = (FLOAT32) f0;
-            ep->f[1] = (FLOAT32) f1;
-            break;
-        default:
-            return NULL;
         }
     } else {
         return NULL;
@@ -1238,17 +1221,16 @@
     return ep;
 }

-static PyObject*
-_histogram(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_histogram(ImagingObject *self, PyObject *args) {
     ImagingHistogram h;
-    PyObject* list;
+    PyObject *list;
     int i;
     union hist_extrema extrema;
-    union hist_extrema* ep;
-
-    PyObject* extremap = NULL;
-    ImagingObject* maskp = NULL;
+    union hist_extrema *ep;
+
+    PyObject *extremap = NULL;
+    ImagingObject *maskp = NULL;
     if (!PyArg_ParseTuple(args, "|OO!", &extremap, &Imaging_Type, &maskp)) {
         return NULL;
     }
@@ -1264,7 +1246,7 @@
     /* Build an integer list containing the histogram */
     list = PyList_New(h->bands * 256);
     for (i = 0; i < h->bands * 256; i++) {
-        PyObject* item;
+        PyObject *item;
         item = PyLong_FromLong(h->histogram[i]);
         if (item == NULL) {
             Py_DECREF(list);
@@ -1280,18 +1262,17 @@
     return list;
 }

-static PyObject*
-_entropy(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_entropy(ImagingObject *self, PyObject *args) {
     ImagingHistogram h;
     int idx, length;
     long sum;
     double entropy, fsum, p;
     union hist_extrema extrema;
-    union hist_extrema* ep;
-
-    PyObject* extremap = NULL;
-    ImagingObject* maskp = NULL;
+    union hist_extrema *ep;
+
+    PyObject *extremap = NULL;
+    ImagingObject *maskp = NULL;
     if (!PyArg_ParseTuple(args, "|OO!", &extremap, &Imaging_Type, &maskp)) {
         return NULL;
     }
@@ -1330,9 +1311,8 @@
 }

 #ifdef WITH_MODEFILTER
-static PyObject*
-_modefilter(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_modefilter(ImagingObject *self, PyObject *args) {
     int size;
     if (!PyArg_ParseTuple(args, "i", &size)) {
         return NULL;
@@ -1342,9 +1322,8 @@
 }
 #endif

-static PyObject*
-_offset(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_offset(ImagingObject *self, PyObject *args) {
     int xoffset, yoffset;
     if (!PyArg_ParseTuple(args, "ii", &xoffset, &yoffset)) {
         return NULL;
@@ -1353,38 +1332,35 @@
     return PyImagingNew(ImagingOffset(self->image, xoffset, yoffset));
 }

-static PyObject*
-_paste(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_paste(ImagingObject *self, PyObject *args) {
     int status;
     char ink[4];

-    PyObject* source;
+    PyObject *source;
     int x0, y0, x1, y1;
-    ImagingObject* maskp = NULL;
-    if (!PyArg_ParseTuple(args, "O(iiii)|O!",
-              &source,
-              &x0, &y0, &x1, &y1,
-              &Imaging_Type, &maskp)) {
+    ImagingObject *maskp = NULL;
+    if (!PyArg_ParseTuple(
+            args, "O(iiii)|O!", &source, &x0, &y0, &x1, &y1, &Imaging_Type, &maskp)) {
         return NULL;
     }

     if (PyImaging_Check(source)) {
         status = ImagingPaste(
-            self->image, PyImaging_AsImaging(source),
+            self->image,
+            PyImaging_AsImaging(source),
             (maskp) ? maskp->image : NULL,
-            x0, y0, x1, y1
-            );
+            x0,
+            y0,
+            x1,
+            y1);

     } else {
         if (!getink(source, self->image, ink)) {
             return NULL;
         }
         status = ImagingFill2(
-            self->image, ink,
-            (maskp) ? maskp->image : NULL,
-            x0, y0, x1, y1
-            );
+            self->image, ink, (maskp) ? maskp->image : NULL, x0, y0, x1, y1);
     }

     if (status < 0) {
@@ -1395,23 +1371,22 @@
     return Py_None;
 }

-static PyObject*
-_point(ImagingObject* self, PyObject* args)
-{
-    static const char* wrong_number = "wrong number of lut entries";
+static PyObject *
+_point(ImagingObject *self, PyObject *args) {
+    static const char *wrong_number = "wrong number of lut entries";

     Py_ssize_t n;
     int i, bands;
     Imaging im;

-    PyObject* list;
-    char* mode;
+    PyObject *list;
+    char *mode;
     if (!PyArg_ParseTuple(args, "Oz", &list, &mode)) {
         return NULL;
     }

     if (mode && !strcmp(mode, "F")) {
-        FLOAT32* data;
+        FLOAT32 *data;

         /* map from 8-bit data to floating point */
         n = 256;
@@ -1419,11 +1394,11 @@
         if (!data) {
             return NULL;
         }
-        im = ImagingPoint(self->image, mode, (void*) data);
+        im = ImagingPoint(self->image, mode, (void *)data);
         free(data);

     } else if (!strcmp(self->image->mode, "I") && mode && !strcmp(mode, "L")) {
-        UINT8* data;
+        UINT8 *data;

         /* map from 16-bit subset of 32-bit data to 8-bit */
         /* FIXME: support arbitrary number of entries (requires API change) */
@@ -1432,11 +1407,11 @@
         if (!data) {
             return NULL;
         }
-        im = ImagingPoint(self->image, mode, (void*) data);
+        im = ImagingPoint(self->image, mode, (void *)data);
         free(data);

     } else {
-        INT32* data;
+        INT32 *data;
         UINT8 lut[1024];

         if (mode) {
@@ -1456,23 +1431,23 @@
         }

         if (mode && !strcmp(mode, "I")) {
-            im = ImagingPoint(self->image, mode, (void*) data);
+            im = ImagingPoint(self->image, mode, (void *)data);
         } else if (mode && bands > 1) {
             for (i = 0; i < 256; i++) {
-                lut[i*4] = CLIP8(data[i]);
-                lut[i*4+1] = CLIP8(data[i+256]);
-                lut[i*4+2] = CLIP8(data[i+512]);
+                lut[i * 4] = CLIP8(data[i]);
+                lut[i * 4 + 1] = CLIP8(data[i + 256]);
+                lut[i * 4 + 2] = CLIP8(data[i + 512]);
                 if (n > 768) {
-                    lut[i*4+3] = CLIP8(data[i+768]);
+                    lut[i * 4 + 3] = CLIP8(data[i + 768]);
                 }
             }
-            im = ImagingPoint(self->image, mode, (void*) lut);
+            im = ImagingPoint(self->image, mode, (void *)lut);
         } else {
             /* map individual bands */
             for (i = 0; i < n; i++) {
                 lut[i] = CLIP8(data[i]);
             }
-            im = ImagingPoint(self->image, mode, (void*) lut);
+            im = ImagingPoint(self->image, mode, (void *)lut);
         }
         free(data);
     }
@@ -1480,9 +1455,8 @@
     return PyImagingNew(im);
 }

-static PyObject*
-_point_transform(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_point_transform(ImagingObject *self, PyObject *args) {
     double scale = 1.0;
     double offset = 0.0;
     if (!PyArg_ParseTuple(args, "|dd", &scale, &offset)) {
@@ -1492,16 +1466,15 @@
     return PyImagingNew(ImagingPointTransform(self->image, scale, offset));
 }

-static PyObject*
-_putdata(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_putdata(ImagingObject *self, PyObject *args) {
     Imaging image;
     // i & n are # pixels, require py_ssize_t. x can be as large as n. y, just because.
     Py_ssize_t n, i, x, y;

-    PyObject* data;
-    PyObject* seq = NULL;
-    PyObject* op;
+    PyObject *data;
+    PyObject *seq = NULL;
+    PyObject *op;
     double scale = 1.0;
     double offset = 0.0;

@@ -1522,56 +1495,64 @@
         return NULL;
     }

+#define set_value_to_item(seq, i) \
+op = PySequence_Fast_GET_ITEM(seq, i); \
+if (PySequence_Check(op)) { \
+    PyErr_SetString(PyExc_TypeError, "sequence must be flattened"); \
+    return NULL; \
+} else { \
+    value = PyFloat_AsDouble(op); \
+}
     if (image->image8) {
         if (PyBytes_Check(data)) {
-            unsigned char* p;
-            p = (unsigned char*) PyBytes_AS_STRING(data);
+            unsigned char *p;
+            p = (unsigned char *)PyBytes_AS_STRING(data);
             if (scale == 1.0 && offset == 0.0) {
                 /* Plain string data */
                 for (i = y = 0; i < n; i += image->xsize, y++) {
                     x = n - i;
-                    if (x > (int) image->xsize) {
+                    if (x > (int)image->xsize) {
                         x = image->xsize;
                     }
-                    memcpy(image->image8[y], p+i, x);
+                    memcpy(image->image8[y], p + i, x);
                 }
             } else {
                 /* Scaled and clipped string data */
                 for (i = x = y = 0; i < n; i++) {
-                    image->image8[y][x] = CLIP8((int) (p[i] * scale + offset));
-                    if (++x >= (int) image->xsize) {
+                    image->image8[y][x] = CLIP8((int)(p[i] * scale + offset));
+                    if (++x >= (int)image->xsize) {
                         x = 0, y++;
                     }
                 }
             }
         } else {
-           seq = PySequence_Fast(data, must_be_sequence);
-           if (!seq) {
-               PyErr_SetString(PyExc_TypeError, must_be_sequence);
-               return NULL;
-           }
-           if (scale == 1.0 && offset == 0.0) {
-               /* Clipped data */
-               for (i = x = y = 0; i < n; i++) {
-                   op = PySequence_Fast_GET_ITEM(seq, i);
-                   image->image8[y][x] = (UINT8) CLIP8(PyLong_AsLong(op));
-                   if (++x >= (int) image->xsize){
-                       x = 0, y++;
-                   }
-               }
+            seq = PySequence_Fast(data, must_be_sequence);
+            if (!seq) {
+                PyErr_SetString(PyExc_TypeError, must_be_sequence);
+                return NULL;
+            }
+            double value;
+            if (scale == 1.0 && offset == 0.0) {
+                /* Clipped data */
+                for (i = x = y = 0; i < n; i++) {
+                    set_value_to_item(seq, i);
+                    image->image8[y][x] = (UINT8)CLIP8(value);
+                    if (++x >= (int)image->xsize) {
+                        x = 0, y++;
+                    }
+                }

             } else {
-               /* Scaled and clipped data */
-               for (i = x = y = 0; i < n; i++) {
-                   PyObject *op = PySequence_Fast_GET_ITEM(seq, i);
-                   image->image8[y][x] = CLIP8(
-                       (int) (PyFloat_AsDouble(op) * scale + offset));
-                   if (++x >= (int) image->xsize){
-                       x = 0, y++;
-                   }
-               }
-           }
-           PyErr_Clear(); /* Avoid weird exceptions */
+                /* Scaled and clipped data */
+                for (i = x = y = 0; i < n; i++) {
+                    set_value_to_item(seq, i);
+                    image->image8[y][x] = CLIP8(value * scale + offset);
+                    if (++x >= (int)image->xsize) {
+                        x = 0, y++;
+                    }
+                }
+            }
+            PyErr_Clear(); /* Avoid weird exceptions */
         }
     } else {
         /* 32-bit images */
@@ -1581,50 +1562,52 @@
             return NULL;
         }
         switch (image->type) {
-        case IMAGING_TYPE_INT32:
-            for (i = x = y = 0; i < n; i++) {
-                op = PySequence_Fast_GET_ITEM(seq, i);
-                IMAGING_PIXEL_INT32(image, x, y) =
-                    (INT32) (PyFloat_AsDouble(op) * scale + offset);
-                if (++x >= (int) image->xsize){
-                    x = 0, y++;
+            case IMAGING_TYPE_INT32:
+                for (i = x = y = 0; i < n; i++) {
+                    double value;
+                    set_value_to_item(seq, i);
+                    IMAGING_PIXEL_INT32(image, x, y) =
+                        (INT32)(value * scale + offset);
+                    if (++x >= (int)image->xsize) {
+                        x = 0, y++;
+                    }
                 }
-            }
-            PyErr_Clear(); /* Avoid weird exceptions */
-            break;
-        case IMAGING_TYPE_FLOAT32:
-            for (i = x = y = 0; i < n; i++) {
-                op = PySequence_Fast_GET_ITEM(seq, i);
-                IMAGING_PIXEL_FLOAT32(image, x, y) =
-                    (FLOAT32) (PyFloat_AsDouble(op) * scale + offset);
-                if (++x >= (int) image->xsize){
-                    x = 0, y++;
+                PyErr_Clear(); /* Avoid weird exceptions */
+                break;
+            case IMAGING_TYPE_FLOAT32:
+                for (i = x = y = 0; i < n; i++) {
+                    double value;
+                    set_value_to_item(seq, i);
+                    IMAGING_PIXEL_FLOAT32(image, x, y) =
+                        (FLOAT32)(value * scale + offset);
+                    if (++x >= (int)image->xsize) {
+                        x = 0, y++;
+                    }
                 }
-            }
-            PyErr_Clear(); /* Avoid weird exceptions */
-            break;
-        default:
-            for (i = x = y = 0; i < n; i++) {
-                union {
-                    char ink[4];
-                    INT32 inkint;
-                } u;
-
-                u.inkint = 0;
-
-                op = PySequence_Fast_GET_ITEM(seq, i);
-                if (!op || !getink(op, image, u.ink)) {
-                    Py_DECREF(seq);
-                    return NULL;
+                PyErr_Clear(); /* Avoid weird exceptions */
+                break;
+            default:
+                for (i = x = y = 0; i < n; i++) {
+                    union {
+                        char ink[4];
+                        INT32 inkint;
+                    } u;
+
+                    u.inkint = 0;
+
+                    op = PySequence_Fast_GET_ITEM(seq, i);
+                    if (!op || !getink(op, image, u.ink)) {
+                        Py_DECREF(seq);
+                        return NULL;
+                    }
+                    /* FIXME: what about scale and offset? */
+                    image->image32[y][x] = u.inkint;
+                    if (++x >= (int)image->xsize) {
+                        x = 0, y++;
+                    }
                 }
-                /* FIXME: what about scale and offset? */
-                image->image32[y][x] = u.inkint;
-                if (++x >= (int) image->xsize){
-                    x = 0, y++;
-                }
-            }
-            PyErr_Clear(); /* Avoid weird exceptions */
-            break;
+                PyErr_Clear(); /* Avoid weird exceptions */
+                break;
         }
     }

@@ -1636,9 +1619,8 @@

 #ifdef WITH_QUANTIZE

-static PyObject*
-_quantize(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_quantize(ImagingObject *self, PyObject *args) {
     int colours = 256;
     int method = 0;
     int kmeans = 0;
@@ -1648,23 +1630,20 @@

     if (!self->image->xsize || !self->image->ysize) {
         /* no content; return an empty image */
-        return PyImagingNew(
-            ImagingNew("P", self->image->xsize, self->image->ysize)
-            );
+        return PyImagingNew(ImagingNew("P", self->image->xsize, self->image->ysize));
     }

     return PyImagingNew(ImagingQuantize(self->image, colours, method, kmeans));
 }
 #endif

-static PyObject*
-_putpalette(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_putpalette(ImagingObject *self, PyObject *args) {
     ImagingShuffler unpack;
     int bits;

-    char* rawmode;
-    UINT8* palette;
+    char *rawmode, *palette_mode;
+    UINT8 *palette;
     Py_ssize_t palettesize;
     if (!PyArg_ParseTuple(args, "sy#", &rawmode, &palette, &palettesize)) {
         return NULL;
@@ -1676,13 +1655,14 @@
         return NULL;
     }

-    unpack = ImagingFindUnpacker("RGB", rawmode, &bits);
+    palette_mode = strncmp("RGBA", rawmode, 4) == 0 ? "RGBA" : "RGB";
+    unpack = ImagingFindUnpacker(palette_mode, rawmode, &bits);
     if (!unpack) {
         PyErr_SetString(PyExc_ValueError, wrong_raw_mode);
         return NULL;
     }

-    if ( palettesize * 8 / bits > 256) {
+    if (palettesize * 8 / bits > 256) {
         PyErr_SetString(PyExc_ValueError, wrong_palette_size);
         return NULL;
     }
@@ -1691,17 +1671,17 @@

     strcpy(self->image->mode, strlen(self->image->mode) == 2 ? "PA" : "P");

-    self->image->palette = ImagingPaletteNew("RGB");
-
-    unpack(self->image->palette->palette, palette, palettesize * 8 / bits);
+    self->image->palette = ImagingPaletteNew(palette_mode);
+
+    self->image->palette->size = palettesize * 8 / bits;
+    unpack(self->image->palette->palette, palette, self->image->palette->size);

     Py_INCREF(Py_None);
     return Py_None;
 }

-static PyObject*
-_putpalettealpha(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_putpalettealpha(ImagingObject *self, PyObject *args) {
     int index;
     int alpha = 0;
     if (!PyArg_ParseTuple(args, "i|i", &index, &alpha)) {
@@ -1719,15 +1699,14 @@
     }

     strcpy(self->image->palette->mode, "RGBA");
-    self->image->palette->palette[index*4+3] = (UINT8) alpha;
+    self->image->palette->palette[index * 4 + 3] = (UINT8)alpha;

     Py_INCREF(Py_None);
     return Py_None;
 }

-static PyObject*
-_putpalettealphas(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_putpalettealphas(ImagingObject *self, PyObject *args) {
     int i;
     UINT8 *values;
     Py_ssize_t length;
@@ -1740,28 +1719,27 @@
         return NULL;
     }

-    if (length  > 256) {
+    if (length > 256) {
         PyErr_SetString(PyExc_ValueError, outside_palette);
         return NULL;
     }

     strcpy(self->image->palette->mode, "RGBA");
-    for (i=0; i<length; i++) {
-        self->image->palette->palette[i*4+3] = (UINT8) values[i];
+    for (i = 0; i < length; i++) {
+        self->image->palette->palette[i * 4 + 3] = (UINT8)values[i];
     }

     Py_INCREF(Py_None);
     return Py_None;
 }

-static PyObject*
-_putpixel(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_putpixel(ImagingObject *self, PyObject *args) {
     Imaging im;
     char ink[4];

     int x, y;
-    PyObject* color;
+    PyObject *color;
     if (!PyArg_ParseTuple(args, "(ii)O", &x, &y, &color)) {
         return NULL;
     }
@@ -1793,9 +1771,8 @@
 }

 #ifdef WITH_RANKFILTER
-static PyObject*
-_rankfilter(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_rankfilter(ImagingObject *self, PyObject *args) {
     int size, rank;
     if (!PyArg_ParseTuple(args, "ii", &size, &rank)) {
         return NULL;
@@ -1805,9 +1782,8 @@
 }
 #endif

-static PyObject*
-_resize(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_resize(ImagingObject *self, PyObject *args) {
     Imaging imIn;
     Imaging imOut;

@@ -1819,8 +1795,16 @@
     box[2] = imIn->xsize;
     box[3] = imIn->ysize;

-    if (!PyArg_ParseTuple(args, "(ii)|i(ffff)", &xsize, &ysize, &filter,
-                          &box[0], &box[1], &box[2], &box[3])) {
+    if (!PyArg_ParseTuple(
+            args,
+            "(ii)|i(ffff)",
+            &xsize,
+            &ysize,
+            &filter,
+            &box[0],
+            &box[1],
+            &box[2],
+            &box[3])) {
         return NULL;
     }

@@ -1841,36 +1825,31 @@
     }

     // If box's coordinates are int and box size matches requested size
-    if (box[0] - (int) box[0] == 0 && box[2] - box[0] == xsize
-            && box[1] - (int) box[1] == 0 && box[3] - box[1] == ysize) {
+    if (box[0] - (int)box[0] == 0 && box[2] - box[0] == xsize &&
+        box[1] - (int)box[1] == 0 && box[3] - box[1] == ysize) {
         imOut = ImagingCrop(imIn, box[0], box[1], box[2], box[3]);
-    }
-    else if (filter == IMAGING_TRANSFORM_NEAREST) {
+    } else if (filter == IMAGING_TRANSFORM_NEAREST) {
         double a[6];

         memset(a, 0, sizeof a);
-        a[0] = (double) (box[2] - box[0]) / xsize;
-        a[4] = (double) (box[3] - box[1]) / ysize;
+        a[0] = (double)(box[2] - box[0]) / xsize;
+        a[4] = (double)(box[3] - box[1]) / ysize;
         a[2] = box[0];
         a[5] = box[1];

         imOut = ImagingNewDirty(imIn->mode, xsize, ysize);

         imOut = ImagingTransform(
-            imOut, imIn, IMAGING_TRANSFORM_AFFINE,
-            0, 0, xsize, ysize,
-            a, filter, 1);
-    }
-    else {
+            imOut, imIn, IMAGING_TRANSFORM_AFFINE, 0, 0, xsize, ysize, a, filter, 1);
+    } else {
         imOut = ImagingResample(imIn, xsize, ysize, filter, box);
     }

     return PyImagingNew(imOut);
 }

-static PyObject*
-_reduce(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_reduce(ImagingObject *self, PyObject *args) {
     Imaging imIn;
     Imaging imOut;

@@ -1881,8 +1860,15 @@
     box[2] = imIn->xsize;
     box[3] = imIn->ysize;

-    if (!PyArg_ParseTuple(args, "(ii)|(iiii)", &xscale, &yscale,
-                          &box[0], &box[1], &box[2], &box[3])) {
+    if (!PyArg_ParseTuple(
+            args,
+            "(ii)|(iiii)",
+            &xscale,
+            &yscale,
+            &box[0],
+            &box[1],
+            &box[2],
+            &box[3])) {
         return NULL;
     }

@@ -1914,18 +1900,16 @@
     return PyImagingNew(imOut);
 }

-
-#define IS_RGB(mode)\
+#define IS_RGB(mode) \
     (!strcmp(mode, "RGB") || !strcmp(mode, "RGBA") || !strcmp(mode, "RGBX"))

-static PyObject*
-im_setmode(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+im_setmode(ImagingObject *self, PyObject *args) {
     /* attempt to modify the mode of an image in place */

     Imaging im;

-    char* mode;
+    char *mode;
     Py_ssize_t modelen;
     if (!PyArg_ParseTuple(args, "s#:setmode", &mode, &modelen)) {
         return NULL;
@@ -1942,7 +1926,7 @@
         strcpy(im->mode, mode);
         im->bands = modelen;
         if (!strcmp(mode, "RGBA")) {
-            (void) ImagingFillBand(im, 3, 255);
+            (void)ImagingFillBand(im, 3, 255);
         }
     } else {
         /* trying doing an in-place conversion */
@@ -1960,42 +1944,48 @@
     return Py_None;
 }

-
-static PyObject*
-_transform2(ImagingObject* self, PyObject* args)
-{
-    static const char* wrong_number = "wrong number of matrix entries";
+static PyObject *
+_transform2(ImagingObject *self, PyObject *args) {
+    static const char *wrong_number = "wrong number of matrix entries";

     Imaging imOut;
     Py_ssize_t n;
     double *a;

-    ImagingObject* imagep;
+    ImagingObject *imagep;
     int x0, y0, x1, y1;
     int method;
-    PyObject* data;
+    PyObject *data;
     int filter = IMAGING_TRANSFORM_NEAREST;
     int fill = 1;
-    if (!PyArg_ParseTuple(args, "(iiii)O!iO|ii",
-                          &x0, &y0, &x1, &y1,
-                          &Imaging_Type, &imagep,
-                          &method, &data,
-                          &filter, &fill)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "(iiii)O!iO|ii",
+            &x0,
+            &y0,
+            &x1,
+            &y1,
+            &Imaging_Type,
+            &imagep,
+            &method,
+            &data,
+            &filter,
+            &fill)) {
         return NULL;
     }

     switch (method) {
-    case IMAGING_TRANSFORM_AFFINE:
-        n = 6;
-        break;
-    case IMAGING_TRANSFORM_PERSPECTIVE:
-        n = 8;
-        break;
-    case IMAGING_TRANSFORM_QUAD:
-        n = 8;
-        break;
-    default:
-        n = -1; /* force error */
+        case IMAGING_TRANSFORM_AFFINE:
+            n = 6;
+            break;
+        case IMAGING_TRANSFORM_PERSPECTIVE:
+            n = 8;
+            break;
+        case IMAGING_TRANSFORM_QUAD:
+            n = 8;
+            break;
+        default:
+            n = -1; /* force error */
     }

     a = getlist(data, &n, wrong_number, TYPE_DOUBLE);
@@ -2004,8 +1994,7 @@
     }

     imOut = ImagingTransform(
-        self->image, imagep->image, method,
-        x0, y0, x1, y1, a, filter, fill);
+        self->image, imagep->image, method, x0, y0, x1, y1, a, filter, fill);

     free(a);

@@ -2017,9 +2006,8 @@
     return Py_None;
 }

-static PyObject*
-_transpose(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_transpose(ImagingObject *self, PyObject *args) {
     Imaging imIn;
     Imaging imOut;

@@ -2031,45 +2019,45 @@
     imIn = self->image;

     switch (op) {
-    case 0: /* flip left right */
-    case 1: /* flip top bottom */
-    case 3: /* rotate 180 */
-        imOut = ImagingNewDirty(imIn->mode, imIn->xsize, imIn->ysize);
-        break;
-    case 2: /* rotate 90 */
-    case 4: /* rotate 270 */
-    case 5: /* transpose */
-    case 6: /* transverse */
-        imOut = ImagingNewDirty(imIn->mode, imIn->ysize, imIn->xsize);
-        break;
-    default:
-        PyErr_SetString(PyExc_ValueError, "No such transpose operation");
-        return NULL;
+        case 0: /* flip left right */
+        case 1: /* flip top bottom */
+        case 3: /* rotate 180 */
+            imOut = ImagingNewDirty(imIn->mode, imIn->xsize, imIn->ysize);
+            break;
+        case 2: /* rotate 90 */
+        case 4: /* rotate 270 */
+        case 5: /* transpose */
+        case 6: /* transverse */
+            imOut = ImagingNewDirty(imIn->mode, imIn->ysize, imIn->xsize);
+            break;
+        default:
+            PyErr_SetString(PyExc_ValueError, "No such transpose operation");
+            return NULL;
     }

     if (imOut) {
         switch (op) {
-        case 0:
-            (void) ImagingFlipLeftRight(imOut, imIn);
-            break;
-        case 1:
-            (void) ImagingFlipTopBottom(imOut, imIn);
-            break;
-        case 2:
-            (void) ImagingRotate90(imOut, imIn);
-            break;
-        case 3:
-            (void) ImagingRotate180(imOut, imIn);
-            break;
-        case 4:
-            (void) ImagingRotate270(imOut, imIn);
-            break;
-        case 5:
-            (void) ImagingTranspose(imOut, imIn);
-            break;
-        case 6:
-            (void) ImagingTransverse(imOut, imIn);
-            break;
+            case 0:
+                (void)ImagingFlipLeftRight(imOut, imIn);
+                break;
+            case 1:
+                (void)ImagingFlipTopBottom(imOut, imIn);
+                break;
+            case 2:
+                (void)ImagingRotate90(imOut, imIn);
+                break;
+            case 3:
+                (void)ImagingRotate180(imOut, imIn);
+                break;
+            case 4:
+                (void)ImagingRotate270(imOut, imIn);
+                break;
+            case 5:
+                (void)ImagingTranspose(imOut, imIn);
+                break;
+            case 6:
+                (void)ImagingTransverse(imOut, imIn);
+                break;
         }
     }

@@ -2077,9 +2065,8 @@
 }

 #ifdef WITH_UNSHARPMASK
-static PyObject*
-_unsharp_mask(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_unsharp_mask(ImagingObject *self, PyObject *args) {
     Imaging imIn;
     Imaging imOut;

@@ -2103,9 +2090,8 @@
 }
 #endif

-static PyObject*
-_box_blur(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_box_blur(ImagingObject *self, PyObject *args) {
     Imaging imIn;
     Imaging imOut;

@@ -2131,15 +2117,13 @@

 /* -------------------------------------------------------------------- */

-static PyObject*
-_isblock(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_isblock(ImagingObject *self) {
     return PyBool_FromLong(self->image->block != NULL);
 }

-static PyObject*
-_getbbox(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_getbbox(ImagingObject *self) {
     int bbox[4];
     if (!ImagingGetBBox(self->image, bbox)) {
         Py_INCREF(Py_None);
@@ -2149,12 +2133,11 @@
     return Py_BuildValue("iiii", bbox[0], bbox[1], bbox[2], bbox[3]);
 }

-static PyObject*
-_getcolors(ImagingObject* self, PyObject* args)
-{
-    ImagingColorItem* items;
+static PyObject *
+_getcolors(ImagingObject *self, PyObject *args) {
+    ImagingColorItem *items;
     int i, colors;
-    PyObject* out;
+    PyObject *out;

     int maxcolors = 256;
     if (!PyArg_ParseTuple(args, "i:getcolors", &maxcolors)) {
@@ -2172,10 +2155,9 @@
     } else {
         out = PyList_New(colors);
         for (i = 0; i < colors; i++) {
-            ImagingColorItem* v = &items[i];
-            PyObject* item = Py_BuildValue(
-                "iN", v->count, getpixel(self->image, self->access, v->x, v->y)
-                );
+            ImagingColorItem *v = &items[i];
+            PyObject *item = Py_BuildValue(
+                "iN", v->count, getpixel(self->image, self->access, v->x, v->y));
             PyList_SetItem(out, i, item);
         }
     }
@@ -2185,9 +2167,8 @@
     return out;
 }

-static PyObject*
-_getextrema(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_getextrema(ImagingObject *self) {
     union {
         UINT8 u[2];
         INT32 i[2];
@@ -2203,16 +2184,16 @@

     if (status) {
         switch (self->image->type) {
-        case IMAGING_TYPE_UINT8:
-            return Py_BuildValue("BB", extrema.u[0], extrema.u[1]);
-        case IMAGING_TYPE_INT32:
-            return Py_BuildValue("ii", extrema.i[0], extrema.i[1]);
-        case IMAGING_TYPE_FLOAT32:
-            return Py_BuildValue("dd", extrema.f[0], extrema.f[1]);
-        case IMAGING_TYPE_SPECIAL:
-            if (strcmp(self->image->mode, "I;16") == 0) {
-                return Py_BuildValue("HH", extrema.s[0], extrema.s[1]);
-            }
+            case IMAGING_TYPE_UINT8:
+                return Py_BuildValue("BB", extrema.u[0], extrema.u[1]);
+            case IMAGING_TYPE_INT32:
+                return Py_BuildValue("ii", extrema.i[0], extrema.i[1]);
+            case IMAGING_TYPE_FLOAT32:
+                return Py_BuildValue("dd", extrema.f[0], extrema.f[1]);
+            case IMAGING_TYPE_SPECIAL:
+                if (strcmp(self->image->mode, "I;16") == 0) {
+                    return Py_BuildValue("HH", extrema.s[0], extrema.s[1]);
+                }
         }
     }

@@ -2220,12 +2201,11 @@
     return Py_None;
 }

-static PyObject*
-_getprojection(ImagingObject* self, PyObject* args)
-{
-    unsigned char* xprofile;
-    unsigned char* yprofile;
-    PyObject* result;
+static PyObject *
+_getprojection(ImagingObject *self) {
+    unsigned char *xprofile;
+    unsigned char *yprofile;
+    PyObject *result;

     /* malloc check ok */
     xprofile = malloc(self->image->xsize);
@@ -2237,11 +2217,15 @@
         return ImagingError_MemoryError();
     }

-    ImagingGetProjection(self->image, (unsigned char *)xprofile, (unsigned char *)yprofile);
-
-    result = Py_BuildValue("y#y#",
-                           xprofile, (Py_ssize_t)self->image->xsize,
-                           yprofile, (Py_ssize_t)self->image->ysize);
+    ImagingGetProjection(
+        self->image, (unsigned char *)xprofile, (unsigned char *)yprofile);
+
+    result = Py_BuildValue(
+        "y#y#",
+        xprofile,
+        (Py_ssize_t)self->image->xsize,
+        yprofile,
+        (Py_ssize_t)self->image->ysize);

     free(xprofile);
     free(yprofile);
@@ -2251,9 +2235,8 @@

 /* -------------------------------------------------------------------- */

-static PyObject*
-_getband(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_getband(ImagingObject *self, PyObject *args) {
     int band;

     if (!PyArg_ParseTuple(args, "i", &band)) {
@@ -2263,9 +2246,8 @@
     return PyImagingNew(ImagingGetBand(self->image, band));
 }

-static PyObject*
-_fillband(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_fillband(ImagingObject *self, PyObject *args) {
     int band;
     int color;

@@ -2281,14 +2263,11 @@
     return Py_None;
 }

-static PyObject*
-_putband(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_putband(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;
     int band;
-    if (!PyArg_ParseTuple(args, "O!i",
-                          &Imaging_Type, &imagep,
-                          &band)) {
+    if (!PyArg_ParseTuple(args, "O!i", &Imaging_Type, &imagep, &band)) {
         return NULL;
     }

@@ -2300,19 +2279,27 @@
     return Py_None;
 }

-static PyObject*
-_merge(PyObject* self, PyObject* args)
-{
-    char* mode;
+static PyObject *
+_merge(PyObject *self, PyObject *args) {
+    char *mode;
     ImagingObject *band0 = NULL;
     ImagingObject *band1 = NULL;
     ImagingObject *band2 = NULL;
     ImagingObject *band3 = NULL;
     Imaging bands[4] = {NULL, NULL, NULL, NULL};

-    if (!PyArg_ParseTuple(args, "sO!|O!O!O!", &mode,
-                          &Imaging_Type, &band0, &Imaging_Type, &band1,
-                          &Imaging_Type, &band2, &Imaging_Type, &band3)) {
+    if (!PyArg_ParseTuple(
+            args,
+            "sO!|O!O!O!",
+            &mode,
+            &Imaging_Type,
+            &band0,
+            &Imaging_Type,
+            &band1,
+            &Imaging_Type,
+            &band2,
+            &Imaging_Type,
+            &band3)) {
         return NULL;
     }

@@ -2332,23 +2319,22 @@
     return PyImagingNew(ImagingMerge(mode, bands));
 }

-static PyObject*
-_split(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_split(ImagingObject *self) {
     int fails = 0;
     Py_ssize_t i;
-    PyObject* list;
-    PyObject* imaging_object;
+    PyObject *list;
+    PyObject *imaging_object;
     Imaging bands[4] = {NULL, NULL, NULL, NULL};

-    if ( ! ImagingSplit(self->image, bands)) {
+    if (!ImagingSplit(self->image, bands)) {
         return NULL;
     }

     list = PyTuple_New(self->image->bands);
     for (i = 0; i < self->image->bands; i++) {
         imaging_object = PyImagingNew(bands[i]);
-        if ( ! imaging_object) {
+        if (!imaging_object) {
             fails += 1;
         }
         PyTuple_SET_ITEM(list, i, imaging_object);
@@ -2364,16 +2350,14 @@

 #ifdef WITH_IMAGECHOPS

-static PyObject*
-_chop_invert(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_chop_invert(ImagingObject *self) {
     return PyImagingNew(ImagingNegative(self->image));
 }

-static PyObject*
-_chop_lighter(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_lighter(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2382,10 +2366,9 @@
     return PyImagingNew(ImagingChopLighter(self->image, imagep->image));
 }

-static PyObject*
-_chop_darker(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_darker(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2394,10 +2377,9 @@
     return PyImagingNew(ImagingChopDarker(self->image, imagep->image));
 }

-static PyObject*
-_chop_difference(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_difference(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2406,10 +2388,9 @@
     return PyImagingNew(ImagingChopDifference(self->image, imagep->image));
 }

-static PyObject*
-_chop_multiply(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_multiply(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2418,10 +2399,9 @@
     return PyImagingNew(ImagingChopMultiply(self->image, imagep->image));
 }

-static PyObject*
-_chop_screen(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_screen(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2430,48 +2410,41 @@
     return PyImagingNew(ImagingChopScreen(self->image, imagep->image));
 }

-static PyObject*
-_chop_add(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_add(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;
     float scale;
     int offset;

     scale = 1.0;
     offset = 0;

-    if (!PyArg_ParseTuple(args, "O!|fi", &Imaging_Type, &imagep,
-                          &scale, &offset)) {
-        return NULL;
-    }
-
-    return PyImagingNew(ImagingChopAdd(self->image, imagep->image,
-                       scale, offset));
-}
-
-static PyObject*
-_chop_subtract(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+    if (!PyArg_ParseTuple(args, "O!|fi", &Imaging_Type, &imagep, &scale, &offset)) {
+        return NULL;
+    }
+
+    return PyImagingNew(ImagingChopAdd(self->image, imagep->image, scale, offset));
+}
+
+static PyObject *
+_chop_subtract(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;
     float scale;
     int offset;

     scale = 1.0;
     offset = 0;

-    if (!PyArg_ParseTuple(args, "O!|fi", &Imaging_Type, &imagep,
-                          &scale, &offset)) {
-        return NULL;
-    }
-
-    return PyImagingNew(ImagingChopSubtract(self->image, imagep->image,
-                        scale, offset));
-}
-
-static PyObject*
-_chop_and(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+    if (!PyArg_ParseTuple(args, "O!|fi", &Imaging_Type, &imagep, &scale, &offset)) {
+        return NULL;
+    }
+
+    return PyImagingNew(ImagingChopSubtract(self->image, imagep->image, scale, offset));
+}
+
+static PyObject *
+_chop_and(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2480,10 +2453,9 @@
     return PyImagingNew(ImagingChopAnd(self->image, imagep->image));
 }

-static PyObject*
-_chop_or(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_or(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2492,10 +2464,9 @@
     return PyImagingNew(ImagingChopOr(self->image, imagep->image));
 }

-static PyObject*
-_chop_xor(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_xor(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2504,10 +2475,9 @@
     return PyImagingNew(ImagingChopXor(self->image, imagep->image));
 }

-static PyObject*
-_chop_add_modulo(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_add_modulo(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2516,10 +2486,9 @@
     return PyImagingNew(ImagingChopAddModulo(self->image, imagep->image));
 }

-static PyObject*
-_chop_subtract_modulo(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_subtract_modulo(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2528,10 +2497,9 @@
     return PyImagingNew(ImagingChopSubtractModulo(self->image, imagep->image));
 }

-static PyObject*
-_chop_soft_light(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_soft_light(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2540,10 +2508,9 @@
     return PyImagingNew(ImagingChopSoftLight(self->image, imagep->image));
 }

-static PyObject*
-_chop_hard_light(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_hard_light(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2552,10 +2519,9 @@
     return PyImagingNew(ImagingChopHardLight(self->image, imagep->image));
 }

-static PyObject*
-_chop_overlay(ImagingObject* self, PyObject* args)
-{
-    ImagingObject* imagep;
+static PyObject *
+_chop_overlay(ImagingObject *self, PyObject *args) {
+    ImagingObject *imagep;

     if (!PyArg_ParseTuple(args, "O!", &Imaging_Type, &imagep)) {
         return NULL;
@@ -2565,24 +2531,21 @@
 }
 #endif

-
 /* -------------------------------------------------------------------- */

 #ifdef WITH_IMAGEDRAW

-static PyObject*
-_font_new(PyObject* self_, PyObject* args)
-{
+static PyObject *
+_font_new(PyObject *self_, PyObject *args) {
     ImagingFontObject *self;
     int i, y0, y1;
-    static const char* wrong_length = "descriptor table has wrong size";
-
-    ImagingObject* imagep;
-    unsigned char* glyphdata;
+    static const char *wrong_length = "descriptor table has wrong size";
+
+    ImagingObject *imagep;
+    unsigned char *glyphdata;
     Py_ssize_t glyphdata_length;
-    if (!PyArg_ParseTuple(args, "O!y#",
-                          &Imaging_Type, &imagep,
-                          &glyphdata, &glyphdata_length)) {
+    if (!PyArg_ParseTuple(
+            args, "O!y#", &Imaging_Type, &imagep, &glyphdata, &glyphdata_length)) {
         return NULL;
     }

@@ -2629,19 +2592,17 @@
     Py_INCREF(imagep);
     self->ref = imagep;

-    return (PyObject*) self;
+    return (PyObject *)self;
 }

 static void
-_font_dealloc(ImagingFontObject* self)
-{
+_font_dealloc(ImagingFontObject *self) {
     Py_XDECREF(self->ref);
     PyObject_Del(self);
 }

 static inline int
-textwidth(ImagingFontObject* self, const unsigned char* text)
-{
+textwidth(ImagingFontObject *self, const unsigned char *text) {
     int xsize;

     for (xsize = 0; *text; text++) {
@@ -2651,16 +2612,17 @@
     return xsize;
 }

-void _font_text_asBytes(PyObject* encoded_string, unsigned char** text){
+void
+_font_text_asBytes(PyObject *encoded_string, unsigned char **text) {
     /* Allocates *text, returns a 'new reference'. Caller is required to free */

-    PyObject* bytes = NULL;
+    PyObject *bytes = NULL;
     Py_ssize_t len = 0;
     char *buffer;

     *text = NULL;

-    if (PyUnicode_CheckExact(encoded_string)){
+    if (PyUnicode_CheckExact(encoded_string)) {
         bytes = PyUnicode_AsLatin1String(encoded_string);
         if (!bytes) {
             return;
@@ -2670,7 +2632,7 @@
         PyBytes_AsStringAndSize(encoded_string, &buffer, &len);
     }

-    *text = calloc(len+1,1);
+    *text = calloc(len + 1, 1);
     if (*text) {
         memcpy(*text, buffer, len);
     } else {
@@ -2683,23 +2645,21 @@
     return;
 }

-
-static PyObject*
-_font_getmask(ImagingFontObject* self, PyObject* args)
-{
+static PyObject *
+_font_getmask(ImagingFontObject *self, PyObject *args) {
     Imaging im;
     Imaging bitmap;
     int x, b;
-    int i=0;
+    int i = 0;
     int status;
-    Glyph* glyph;
-
-    PyObject* encoded_string;
-
-    unsigned char* text;
-    char* mode = "";
-
-    if (!PyArg_ParseTuple(args, "O|s:getmask",  &encoded_string, &mode)){
+    Glyph *glyph;
+
+    PyObject *encoded_string;
+
+    unsigned char *text;
+    char *mode = "";
+
+    if (!PyArg_ParseTuple(args, "O|s:getmask", &encoded_string, &mode)) {
         return NULL;
     }

@@ -2715,22 +2675,24 @@
     }

     b = 0;
-    (void) ImagingFill(im, &b);
+    (void)ImagingFill(im, &b);

     b = self->baseline;
     for (x = 0; text[i]; i++) {
         glyph = &self->glyphs[text[i]];
-        bitmap = ImagingCrop(
-            self->bitmap,
-            glyph->sx0, glyph->sy0, glyph->sx1, glyph->sy1
-            );
+        bitmap =
+            ImagingCrop(self->bitmap, glyph->sx0, glyph->sy0, glyph->sx1, glyph->sy1);
         if (!bitmap) {
             goto failed;
         }
         status = ImagingPaste(
-            im, bitmap, NULL,
-            glyph->dx0+x, glyph->dy0+b, glyph->dx1+x, glyph->dy1+b
-            );
+            im,
+            bitmap,
+            NULL,
+            glyph->dx0 + x,
+            glyph->dy0 + b,
+            glyph->dx1 + x,
+            glyph->dy1 + b);
         ImagingDelete(bitmap);
         if (status < 0) {
             goto failed;
@@ -2741,18 +2703,17 @@
     free(text);
     return PyImagingNew(im);

-  failed:
+failed:
     free(text);
     ImagingDelete(im);
     Py_RETURN_NONE;
 }

-static PyObject*
-_font_getsize(ImagingFontObject* self, PyObject* args)
-{
-    unsigned char* text;
-    PyObject* encoded_string;
-    PyObject* val;
+static PyObject *
+_font_getsize(ImagingFontObject *self, PyObject *args) {
+    unsigned char *text;
+    PyObject *encoded_string;
+    PyObject *val;

     if (!PyArg_ParseTuple(args, "O:getsize", &encoded_string)) {
         return NULL;
@@ -2769,19 +2730,18 @@
 }

 static struct PyMethodDef _font_methods[] = {
-    {"getmask", (PyCFunction)_font_getmask, 1},
-    {"getsize", (PyCFunction)_font_getsize, 1},
+    {"getmask", (PyCFunction)_font_getmask, METH_VARARGS},
+    {"getsize", (PyCFunction)_font_getsize, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };

 /* -------------------------------------------------------------------- */

-static PyObject*
-_draw_new(PyObject* self_, PyObject* args)
-{
+static PyObject *
+_draw_new(PyObject *self_, PyObject *args) {
     ImagingDrawObject *self;

-    ImagingObject* imagep;
+    ImagingObject *imagep;
     int blend = 0;
     if (!PyArg_ParseTuple(args, "O!|i", &Imaging_Type, &imagep, &blend)) {
         return NULL;
@@ -2800,41 +2760,39 @@

     self->blend = blend;

-    return (PyObject*) self;
+    return (PyObject *)self;
 }

 static void
-_draw_dealloc(ImagingDrawObject* self)
-{
+_draw_dealloc(ImagingDrawObject *self) {
     Py_XDECREF(self->image);
     PyObject_Del(self);
 }

-extern Py_ssize_t PyPath_Flatten(PyObject* data, double **xy);
-
-static PyObject*
-_draw_ink(ImagingDrawObject* self, PyObject* args)
-{
+extern Py_ssize_t
+PyPath_Flatten(PyObject *data, double **xy);
+
+static PyObject *
+_draw_ink(ImagingDrawObject *self, PyObject *args) {
     INT32 ink = 0;
-    PyObject* color;
+    PyObject *color;
     if (!PyArg_ParseTuple(args, "O", &color)) {
         return NULL;
     }

-    if (!getink(color, self->image->image, (char*) &ink)) {
-        return NULL;
-    }
-
-    return PyLong_FromLong((int) ink);
-}
-
-static PyObject*
-_draw_arc(ImagingDrawObject* self, PyObject* args)
-{
-    double* xy;
+    if (!getink(color, self->image->image, (char *)&ink)) {
+        return NULL;
+    }
+
+    return PyLong_FromLong((int)ink);
+}
+
+static PyObject *
+_draw_arc(ImagingDrawObject *self, PyObject *args) {
+    double *xy;
     Py_ssize_t n;

-    PyObject* data;
+    PyObject *data;
     int ink;
     int width = 0;
     float start, end;
@@ -2852,11 +2810,17 @@
         return NULL;
     }

-    n = ImagingDrawArc(self->image->image,
-                       (int) xy[0], (int) xy[1],
-                       (int) xy[2], (int) xy[3],
-                       start, end, &ink, width, self->blend
-                       );
+    n = ImagingDrawArc(
+        self->image->image,
+        (int)xy[0],
+        (int)xy[1],
+        (int)xy[2],
+        (int)xy[3],
+        start,
+        end,
+        &ink,
+        width,
+        self->blend);

     free(xy);

@@ -2868,14 +2832,13 @@
     return Py_None;
 }

-static PyObject*
-_draw_bitmap(ImagingDrawObject* self, PyObject* args)
-{
+static PyObject *
+_draw_bitmap(ImagingDrawObject *self, PyObject *args) {
     double *xy;
     Py_ssize_t n;

     PyObject *data;
-    ImagingObject* bitmap;
+    ImagingObject *bitmap;
     int ink;
     if (!PyArg_ParseTuple(args, "OO!i", &data, &Imaging_Type, &bitmap, &ink)) {
         return NULL;
@@ -2886,17 +2849,14 @@
         return NULL;
     }
     if (n != 1) {
-        PyErr_SetString(PyExc_TypeError,
-                        "coordinate list must contain exactly 1 coordinate"
-                        );
+        PyErr_SetString(
+            PyExc_TypeError, "coordinate list must contain exactly 1 coordinate");
         free(xy);
         return NULL;
     }

     n = ImagingDrawBitmap(
-        self->image->image, (int) xy[0], (int) xy[1], bitmap->image,
-        &ink, self->blend
-        );
+        self->image->image, (int)xy[0], (int)xy[1], bitmap->image, &ink, self->blend);

     free(xy);

@@ -2908,18 +2868,16 @@
     return Py_None;
 }

-static PyObject*
-_draw_chord(ImagingDrawObject* self, PyObject* args)
-{
-    double* xy;
+static PyObject *
+_draw_chord(ImagingDrawObject *self, PyObject *args) {
+    double *xy;
     Py_ssize_t n;

-    PyObject* data;
+    PyObject *data;
     int ink, fill;
     int width = 0;
     float start, end;
-    if (!PyArg_ParseTuple(args, "Offii|i",
-                          &data, &start, &end, &ink, &fill, &width)) {
+    if (!PyArg_ParseTuple(args, "Offii|i", &data, &start, &end, &ink, &fill, &width)) {
         return NULL;
     }

@@ -2933,11 +2891,18 @@
         return NULL;
     }

-    n = ImagingDrawChord(self->image->image,
-                         (int) xy[0], (int) xy[1],
-                         (int) xy[2], (int) xy[3],
-                         start, end, &ink, fill, width, self->blend
-                         );
+    n = ImagingDrawChord(
+        self->image->image,
+        (int)xy[0],
+        (int)xy[1],
+        (int)xy[2],
+        (int)xy[3],
+        start,
+        end,
+        &ink,
+        fill,
+        width,
+        self->blend);

     free(xy);

@@ -2949,13 +2914,12 @@
     return Py_None;
 }

-static PyObject*
-_draw_ellipse(ImagingDrawObject* self, PyObject* args)
-{
-    double* xy;
+static PyObject *
+_draw_ellipse(ImagingDrawObject *self, PyObject *args) {
+    double *xy;
     Py_ssize_t n;

-    PyObject* data;
+    PyObject *data;
     int ink;
     int fill = 0;
     int width = 0;
@@ -2973,11 +2937,16 @@
         return NULL;
     }

-    n = ImagingDrawEllipse(self->image->image,
-                           (int) xy[0], (int) xy[1],
-                           (int) xy[2], (int) xy[3],
-                           &ink, fill, width, self->blend
-                           );
+    n = ImagingDrawEllipse(
+        self->image->image,
+        (int)xy[0],
+        (int)xy[1],
+        (int)xy[2],
+        (int)xy[3],
+        &ink,
+        fill,
+        width,
+        self->blend);

     free(xy);

@@ -2989,9 +2958,8 @@
     return Py_None;
 }

-static PyObject*
-_draw_lines(ImagingDrawObject* self, PyObject* args)
-{
+static PyObject *
+_draw_lines(ImagingDrawObject *self, PyObject *args) {
     double *xy;
     Py_ssize_t i, n;

@@ -3009,30 +2977,36 @@

     if (width <= 1) {
         double *p = NULL;
-        for (i = 0; i < n-1; i++) {
-            p = &xy[i+i];
+        for (i = 0; i < n - 1; i++) {
+            p = &xy[i + i];
             if (ImagingDrawLine(
                     self->image->image,
-                    (int) p[0], (int) p[1], (int) p[2], (int) p[3],
-                    &ink, self->blend) < 0) {
+                    (int)p[0],
+                    (int)p[1],
+                    (int)p[2],
+                    (int)p[3],
+                    &ink,
+                    self->blend) < 0) {
                 free(xy);
                 return NULL;
             }
         }
-        if (p) {/* draw last point */
+        if (p) { /* draw last point */
             ImagingDrawPoint(
-                    self->image->image,
-                    (int) p[2], (int) p[3],
-                    &ink, self->blend
-                );
+                self->image->image, (int)p[2], (int)p[3], &ink, self->blend);
         }
     } else {
-        for (i = 0; i < n-1; i++) {
-            double *p = &xy[i+i];
+        for (i = 0; i < n - 1; i++) {
+            double *p = &xy[i + i];
             if (ImagingDrawWideLine(
                     self->image->image,
-                    (int) p[0], (int) p[1], (int) p[2], (int) p[3],
-                    &ink, width, self->blend) < 0) {
+                    (int)p[0],
+                    (int)p[1],
+                    (int)p[2],
+                    (int)p[3],
+                    &ink,
+                    width,
+                    self->blend) < 0) {
                 free(xy);
                 return NULL;
             }
@@ -3045,9 +3019,8 @@
     return Py_None;
 }

-static PyObject*
-_draw_points(ImagingDrawObject* self, PyObject* args)
-{
+static PyObject *
+_draw_points(ImagingDrawObject *self, PyObject *args) {
     double *xy;
     Py_ssize_t i, n;

@@ -3063,12 +3036,12 @@
     }

     for (i = 0; i < n; i++) {
-    double *p = &xy[i+i];
-    if (ImagingDrawPoint(self->image->image, (int) p[0], (int) p[1],
-                             &ink, self->blend) < 0) {
-        free(xy);
-        return NULL;
-    }
+        double *p = &xy[i + i];
+        if (ImagingDrawPoint(
+                self->image->image, (int)p[0], (int)p[1], &ink, self->blend) < 0) {
+            free(xy);
+            return NULL;
+        }
     }

     free(xy);
@@ -3077,17 +3050,17 @@
     return Py_None;
 }

-#ifdef    WITH_ARROW
+#ifdef WITH_ARROW

 /* from outline.c */
-extern ImagingOutline PyOutline_AsOutline(PyObject* outline);
-
-static PyObject*
-_draw_outline(ImagingDrawObject* self, PyObject* args)
-{
+extern ImagingOutline
+PyOutline_AsOutline(PyObject *outline);
+
+static PyObject *
+_draw_outline(ImagingDrawObject *self, PyObject *args) {
     ImagingOutline outline;

-    PyObject* outline_;
+    PyObject *outline_;
     int ink;
     int fill = 0;
     if (!PyArg_ParseTuple(args, "Oi|i", &outline_, &ink, &fill)) {
@@ -3100,8 +3073,7 @@
         return NULL;
     }

-    if (ImagingDrawOutline(self->image->image, outline,
-                           &ink, fill, self->blend) < 0) {
+    if (ImagingDrawOutline(self->image->image, outline, &ink, fill, self->blend) < 0) {
         return NULL;
     }

@@ -3111,13 +3083,12 @@

 #endif

-static PyObject*
-_draw_pieslice(ImagingDrawObject* self, PyObject* args)
-{
-    double* xy;
+static PyObject *
+_draw_pieslice(ImagingDrawObject *self, PyObject *args) {
+    double *xy;
     Py_ssize_t n;

-    PyObject* data;
+    PyObject *data;
     int ink, fill;
     int width = 0;
     float start, end;
@@ -3135,11 +3106,18 @@
         return NULL;
     }

-    n = ImagingDrawPieslice(self->image->image,
-                            (int) xy[0], (int) xy[1],
-                            (int) xy[2], (int) xy[3],
-                            start, end, &ink, fill, width, self->blend
-                            );
+    n = ImagingDrawPieslice(
+        self->image->image,
+        (int)xy[0],
+        (int)xy[1],
+        (int)xy[2],
+        (int)xy[3],
+        start,
+        end,
+        &ink,
+        fill,
+        width,
+        self->blend);

     free(xy);

@@ -3151,65 +3129,13 @@
     return Py_None;
 }

-static PyObject*
-_draw_polygon(ImagingDrawObject* self, PyObject* args)
-{
+static PyObject *
+_draw_polygon(ImagingDrawObject *self, PyObject *args) {
     double *xy;
     int *ixy;
     Py_ssize_t n, i;

-    PyObject* data;
-    int ink;
-    int fill = 0;
-    if (!PyArg_ParseTuple(args, "Oi|i", &data, &ink, &fill)) {
-        return NULL;
-    }
-
-    n = PyPath_Flatten(data, &xy);
-    if (n < 0) {
-        return NULL;
-    }
-    if (n < 2) {
-        PyErr_SetString(PyExc_TypeError,
-                        "coordinate list must contain at least 2 coordinates"
-                        );
-        free(xy);
-        return NULL;
-    }
-
-    /* Copy list of vertices to array */
-    ixy = (int*) calloc(n, 2 * sizeof(int));
-    if (ixy == NULL) {
-        free(xy);
-        return ImagingError_MemoryError();
-    }
-
-    for (i = 0; i < n; i++) {
-        ixy[i+i] = (int) xy[i+i];
-        ixy[i+i+1] = (int) xy[i+i+1];
-    }
-
-    free(xy);
-
-    if (ImagingDrawPolygon(self->image->image, n, ixy,
-                           &ink, fill, self->blend) < 0) {
-        free(ixy);
-        return NULL;
-    }
-
-    free(ixy);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static PyObject*
-_draw_rectangle(ImagingDrawObject* self, PyObject* args)
-{
-    double* xy;
-    Py_ssize_t n;
-
-    PyObject* data;
+    PyObject *data;
     int ink;
     int fill = 0;
     int width = 0;
@@ -3221,17 +3147,71 @@
     if (n < 0) {
         return NULL;
     }
+    if (n < 2) {
+        PyErr_SetString(
+            PyExc_TypeError, "coordinate list must contain at least 2 coordinates");
+        free(xy);
+        return NULL;
+    }
+
+    /* Copy list of vertices to array */
+    ixy = (int *)calloc(n, 2 * sizeof(int));
+    if (ixy == NULL) {
+        free(xy);
+        return ImagingError_MemoryError();
+    }
+
+    for (i = 0; i < n; i++) {
+        ixy[i + i] = (int)xy[i + i];
+        ixy[i + i + 1] = (int)xy[i + i + 1];
+    }
+
+    free(xy);
+
+    if (ImagingDrawPolygon(self->image->image, n, ixy, &ink, fill, width, self->blend) < 0) {
+        free(ixy);
+        return NULL;
+    }
+
+    free(ixy);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+static PyObject *
+_draw_rectangle(ImagingDrawObject *self, PyObject *args) {
+    double *xy;
+    Py_ssize_t n;
+
+    PyObject *data;
+    int ink;
+    int fill = 0;
+    int width = 0;
+    if (!PyArg_ParseTuple(args, "Oi|ii", &data, &ink, &fill, &width)) {
+        return NULL;
+    }
+
+    n = PyPath_Flatten(data, &xy);
+    if (n < 0) {
+        return NULL;
+    }
     if (n != 2) {
         PyErr_SetString(PyExc_TypeError, must_be_two_coordinates);
         free(xy);
         return NULL;
     }

-    n = ImagingDrawRectangle(self->image->image,
-                             (int) xy[0], (int) xy[1],
-                             (int) xy[2], (int) xy[3],
-                             &ink, fill, width, self->blend
-                             );
+    n = ImagingDrawRectangle(
+        self->image->image,
+        (int)xy[0],
+        (int)xy[1],
+        (int)xy[2],
+        (int)xy[3],
+        &ink,
+        fill,
+        width,
+        self->blend);

     free(xy);

@@ -3246,29 +3226,27 @@
 static struct PyMethodDef _draw_methods[] = {
 #ifdef WITH_IMAGEDRAW
     /* Graphics (ImageDraw) */
-    {"draw_lines", (PyCFunction)_draw_lines, 1},
+    {"draw_lines", (PyCFunction)_draw_lines, METH_VARARGS},
 #ifdef WITH_ARROW
-    {"draw_outline", (PyCFunction)_draw_outline, 1},
-#endif
-    {"draw_polygon", (PyCFunction)_draw_polygon, 1},
-    {"draw_rectangle", (PyCFunction)_draw_rectangle, 1},
-    {"draw_points", (PyCFunction)_draw_points, 1},
-    {"draw_arc", (PyCFunction)_draw_arc, 1},
-    {"draw_bitmap", (PyCFunction)_draw_bitmap, 1},
-    {"draw_chord", (PyCFunction)_draw_chord, 1},
-    {"draw_ellipse", (PyCFunction)_draw_ellipse, 1},
-    {"draw_pieslice", (PyCFunction)_draw_pieslice, 1},
-    {"draw_ink", (PyCFunction)_draw_ink, 1},
+    {"draw_outline", (PyCFunction)_draw_outline, METH_VARARGS},
+#endif
+    {"draw_polygon", (PyCFunction)_draw_polygon, METH_VARARGS},
+    {"draw_rectangle", (PyCFunction)_draw_rectangle, METH_VARARGS},
+    {"draw_points", (PyCFunction)_draw_points, METH_VARARGS},
+    {"draw_arc", (PyCFunction)_draw_arc, METH_VARARGS},
+    {"draw_bitmap", (PyCFunction)_draw_bitmap, METH_VARARGS},
+    {"draw_chord", (PyCFunction)_draw_chord, METH_VARARGS},
+    {"draw_ellipse", (PyCFunction)_draw_ellipse, METH_VARARGS},
+    {"draw_pieslice", (PyCFunction)_draw_pieslice, METH_VARARGS},
+    {"draw_ink", (PyCFunction)_draw_ink, METH_VARARGS},
 #endif
     {NULL, NULL} /* sentinel */
 };

 #endif

-
-static PyObject*
-pixel_access_new(ImagingObject* imagep, PyObject* args)
-{
+static PyObject *
+pixel_access_new(ImagingObject *imagep, PyObject *args) {
     PixelAccessObject *self;

     int readonly = 0;
@@ -3287,19 +3265,17 @@

     self->readonly = readonly;

-    return (PyObject*) self;
+    return (PyObject *)self;
 }

 static void
-pixel_access_dealloc(PixelAccessObject* self)
-{
+pixel_access_dealloc(PixelAccessObject *self) {
     Py_XDECREF(self->image);
     PyObject_Del(self);
 }

 static PyObject *
-pixel_access_getitem(PixelAccessObject *self, PyObject *xy)
-{
+pixel_access_getitem(PixelAccessObject *self, PyObject *xy) {
     int x, y;
     if (_getxy(xy, &x, &y)) {
         return NULL;
@@ -3309,14 +3285,13 @@
 }

 static int
-pixel_access_setitem(PixelAccessObject *self, PyObject *xy, PyObject *color)
-{
+pixel_access_setitem(PixelAccessObject *self, PyObject *xy, PyObject *color) {
     Imaging im = self->image->image;
     char ink[4];
     int x, y;

     if (self->readonly) {
-        (void) ImagingError_ValueError(readonly);
+        (void)ImagingError_ValueError(readonly);
         return -1;
     }

@@ -3336,7 +3311,7 @@
         return -1;
     }

-    if (!color) {/* FIXME: raise exception? */
+    if (!color) { /* FIXME: raise exception? */
         return 0;
     }

@@ -3355,29 +3330,36 @@

 #ifdef WITH_EFFECTS

-static PyObject*
-_effect_mandelbrot(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_effect_mandelbrot(ImagingObject *self, PyObject *args) {
     int xsize = 512;
     int ysize = 512;
     double extent[4];
     int quality = 100;

-    extent[0] = -3; extent[1] = -2.5;
-    extent[2] = 2;  extent[3] = 2.5;
-
-    if (!PyArg_ParseTuple(args, "|(ii)(dddd)i", &xsize, &ysize,
-                          &extent[0], &extent[1], &extent[2], &extent[3],
-                          &quality)) {
+    extent[0] = -3;
+    extent[1] = -2.5;
+    extent[2] = 2;
+    extent[3] = 2.5;
+
+    if (!PyArg_ParseTuple(
+            args,
+            "|(ii)(dddd)i",
+            &xsize,
+            &ysize,
+            &extent[0],
+            &extent[1],
+            &extent[2],
+            &extent[3],
+            &quality)) {
         return NULL;
     }

     return PyImagingNew(ImagingEffectMandelbrot(xsize, ysize, extent, quality));
 }

-static PyObject*
-_effect_noise(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_effect_noise(ImagingObject *self, PyObject *args) {
     int xsize, ysize;
     float sigma = 128;
     if (!PyArg_ParseTuple(args, "(ii)|f", &xsize, &ysize, &sigma)) {
@@ -3387,9 +3369,8 @@
     return PyImagingNew(ImagingEffectNoise(xsize, ysize, sigma));
 }

-static PyObject*
-_effect_spread(ImagingObject* self, PyObject* args)
-{
+static PyObject *
+_effect_spread(ImagingObject *self, PyObject *args) {
     int dist;

     if (!PyArg_ParseTuple(args, "i", &dist)) {
@@ -3405,30 +3386,33 @@
 /* UTILITIES                                */
 /* -------------------------------------------------------------------- */

-
-static PyObject*
-_getcodecstatus(PyObject* self, PyObject* args)
-{
+static PyObject *
+_getcodecstatus(PyObject *self, PyObject *args) {
     int status;
-    char* msg;
+    char *msg;

     if (!PyArg_ParseTuple(args, "i", &status)) {
         return NULL;
     }

     switch (status) {
-    case IMAGING_CODEC_OVERRUN:
-        msg = "buffer overrun"; break;
-    case IMAGING_CODEC_BROKEN:
-        msg = "broken data stream"; break;
-    case IMAGING_CODEC_UNKNOWN:
-        msg = "unrecognized data stream contents"; break;
-    case IMAGING_CODEC_CONFIG:
-        msg = "codec configuration error"; break;
-    case IMAGING_CODEC_MEMORY:
-        msg = "out of memory"; break;
-    default:
-        Py_RETURN_NONE;
+        case IMAGING_CODEC_OVERRUN:
+            msg = "buffer overrun";
+            break;
+        case IMAGING_CODEC_BROKEN:
+            msg = "broken data stream";
+            break;
+        case IMAGING_CODEC_UNKNOWN:
+            msg = "unrecognized data stream contents";
+            break;
+        case IMAGING_CODEC_CONFIG:
+            msg = "codec configuration error";
+            break;
+        case IMAGING_CODEC_MEMORY:
+            msg = "out of memory";
+            break;
+        default:
+            Py_RETURN_NONE;
     }

     return PyUnicode_FromString(msg);
@@ -3438,11 +3422,9 @@
 /* DEBUGGING HELPERS                            */
 /* -------------------------------------------------------------------- */

-
-static PyObject*
-_save_ppm(ImagingObject* self, PyObject* args)
-{
-    char* filename;
+static PyObject *
+_save_ppm(ImagingObject *self, PyObject *args) {
+    char *filename;

     if (!PyArg_ParseTuple(args, "s", &filename)) {
         return NULL;
@@ -3456,7 +3438,6 @@
     return Py_None;
 }

-
 /* -------------------------------------------------------------------- */

 /* methods */
@@ -3464,171 +3445,163 @@
 static struct PyMethodDef methods[] = {

     /* Put commonly used methods first */
-    {"getpixel", (PyCFunction)_getpixel, 1},
-    {"putpixel", (PyCFunction)_putpixel, 1},
-
-    {"pixel_access", (PyCFunction)pixel_access_new, 1},
+    {"getpixel", (PyCFunction)_getpixel, METH_VARARGS},
+    {"putpixel", (PyCFunction)_putpixel, METH_VARARGS},
+
+    {"pixel_access", (PyCFunction)pixel_access_new, METH_VARARGS},

     /* Standard processing methods (Image) */
-    {"color_lut_3d", (PyCFunction)_color_lut_3d, 1},
-    {"convert", (PyCFunction)_convert, 1},
-    {"convert2", (PyCFunction)_convert2, 1},
-    {"convert_matrix", (PyCFunction)_convert_matrix, 1},
-    {"convert_transparent", (PyCFunction)_convert_transparent, 1},
-    {"copy", (PyCFunction)_copy, 1},
-    {"crop", (PyCFunction)_crop, 1},
-    {"expand", (PyCFunction)_expand_image, 1},
-    {"filter", (PyCFunction)_filter, 1},
-    {"histogram", (PyCFunction)_histogram, 1},
-    {"entropy", (PyCFunction)_entropy, 1},
+    {"color_lut_3d", (PyCFunction)_color_lut_3d, METH_VARARGS},
+    {"convert", (PyCFunction)_convert, METH_VARARGS},
+    {"convert2", (PyCFunction)_convert2, METH_VARARGS},
+    {"convert_matrix", (PyCFunction)_convert_matrix, METH_VARARGS},
+    {"convert_transparent", (PyCFunction)_convert_transparent, METH_VARARGS},
+    {"copy", (PyCFunction)_copy, METH_VARARGS},
+    {"crop", (PyCFunction)_crop, METH_VARARGS},
+    {"expand", (PyCFunction)_expand_image, METH_VARARGS},
+    {"filter", (PyCFunction)_filter, METH_VARARGS},
+    {"histogram", (PyCFunction)_histogram, METH_VARARGS},
+    {"entropy", (PyCFunction)_entropy, METH_VARARGS},
 #ifdef WITH_MODEFILTER
-    {"modefilter", (PyCFunction)_modefilter, 1},
-#endif
-    {"offset", (PyCFunction)_offset, 1},
-    {"paste", (PyCFunction)_paste, 1},
-    {"point", (PyCFunction)_point, 1},
-    {"point_transform", (PyCFunction)_point_transform, 1},
-    {"putdata", (PyCFunction)_putdata, 1},
+    {"modefilter", (PyCFunction)_modefilter, METH_VARARGS},
+#endif
+    {"offset", (PyCFunction)_offset, METH_VARARGS},
+    {"paste", (PyCFunction)_paste, METH_VARARGS},
+    {"point", (PyCFunction)_point, METH_VARARGS},
+    {"point_transform", (PyCFunction)_point_transform, METH_VARARGS},
+    {"putdata", (PyCFunction)_putdata, METH_VARARGS},
 #ifdef WITH_QUANTIZE
-    {"quantize", (PyCFunction)_quantize, 1},
+    {"quantize", (PyCFunction)_quantize, METH_VARARGS},
 #endif
 #ifdef WITH_RANKFILTER
-    {"rankfilter", (PyCFunction)_rankfilter, 1},
-#endif
-    {"resize", (PyCFunction)_resize, 1},
-    {"reduce", (PyCFunction)_reduce, 1},
-    {"transpose", (PyCFunction)_transpose, 1},
-    {"transform2", (PyCFunction)_transform2, 1},
-
-    {"isblock", (PyCFunction)_isblock, 1},
-
-    {"getbbox", (PyCFunction)_getbbox, 1},
-    {"getcolors", (PyCFunction)_getcolors, 1},
-    {"getextrema", (PyCFunction)_getextrema, 1},
-    {"getprojection", (PyCFunction)_getprojection, 1},
-
-    {"getband", (PyCFunction)_getband, 1},
-    {"putband", (PyCFunction)_putband, 1},
-    {"split", (PyCFunction)_split, 1},
-    {"fillband", (PyCFunction)_fillband, 1},
-
-    {"setmode", (PyCFunction)im_setmode, 1},
-
-    {"getpalette", (PyCFunction)_getpalette, 1},
-    {"getpalettemode", (PyCFunction)_getpalettemode, 1},
-    {"putpalette", (PyCFunction)_putpalette, 1},
-    {"putpalettealpha", (PyCFunction)_putpalettealpha, 1},
-    {"putpalettealphas", (PyCFunction)_putpalettealphas, 1},
+    {"rankfilter", (PyCFunction)_rankfilter, METH_VARARGS},
+#endif
+    {"resize", (PyCFunction)_resize, METH_VARARGS},
+    {"reduce", (PyCFunction)_reduce, METH_VARARGS},
+    {"transpose", (PyCFunction)_transpose, METH_VARARGS},
+    {"transform2", (PyCFunction)_transform2, METH_VARARGS},
+
+    {"isblock", (PyCFunction)_isblock, METH_NOARGS},
+
+    {"getbbox", (PyCFunction)_getbbox, METH_NOARGS},
+    {"getcolors", (PyCFunction)_getcolors, METH_VARARGS},
+    {"getextrema", (PyCFunction)_getextrema, METH_NOARGS},
+    {"getprojection", (PyCFunction)_getprojection, METH_NOARGS},
+
+    {"getband", (PyCFunction)_getband, METH_VARARGS},
+    {"putband", (PyCFunction)_putband, METH_VARARGS},
+    {"split", (PyCFunction)_split, METH_NOARGS},
+    {"fillband", (PyCFunction)_fillband, METH_VARARGS},
+
+    {"setmode", (PyCFunction)im_setmode, METH_VARARGS},
+
+    {"getpalette", (PyCFunction)_getpalette, METH_VARARGS},
+    {"getpalettemode", (PyCFunction)_getpalettemode, METH_NOARGS},
+    {"putpalette", (PyCFunction)_putpalette, METH_VARARGS},
+    {"putpalettealpha", (PyCFunction)_putpalettealpha, METH_VARARGS},
+    {"putpalettealphas", (PyCFunction)_putpalettealphas, METH_VARARGS},

 #ifdef WITH_IMAGECHOPS
     /* Channel operations (ImageChops) */
-    {"chop_invert", (PyCFunction)_chop_invert, 1},
-    {"chop_lighter", (PyCFunction)_chop_lighter, 1},
-    {"chop_darker", (PyCFunction)_chop_darker, 1},
-    {"chop_difference", (PyCFunction)_chop_difference, 1},
-    {"chop_multiply", (PyCFunction)_chop_multiply, 1},
-    {"chop_screen", (PyCFunction)_chop_screen, 1},
-    {"chop_add", (PyCFunction)_chop_add, 1},
-    {"chop_subtract", (PyCFunction)_chop_subtract, 1},
-    {"chop_add_modulo", (PyCFunction)_chop_add_modulo, 1},
-    {"chop_subtract_modulo", (PyCFunction)_chop_subtract_modulo, 1},
-    {"chop_and", (PyCFunction)_chop_and, 1},
-    {"chop_or", (PyCFunction)_chop_or, 1},
-    {"chop_xor", (PyCFunction)_chop_xor, 1},
-    {"chop_soft_light", (PyCFunction)_chop_soft_light, 1},
-    {"chop_hard_light", (PyCFunction)_chop_hard_light, 1},
-    {"chop_overlay", (PyCFunction)_chop_overlay, 1},
+    {"chop_invert", (PyCFunction)_chop_invert, METH_NOARGS},
+    {"chop_lighter", (PyCFunction)_chop_lighter, METH_VARARGS},
+    {"chop_darker", (PyCFunction)_chop_darker, METH_VARARGS},
+    {"chop_difference", (PyCFunction)_chop_difference, METH_VARARGS},
+    {"chop_multiply", (PyCFunction)_chop_multiply, METH_VARARGS},
+    {"chop_screen", (PyCFunction)_chop_screen, METH_VARARGS},
+    {"chop_add", (PyCFunction)_chop_add, METH_VARARGS},
+    {"chop_subtract", (PyCFunction)_chop_subtract, METH_VARARGS},
+    {"chop_add_modulo", (PyCFunction)_chop_add_modulo, METH_VARARGS},
+    {"chop_subtract_modulo", (PyCFunction)_chop_subtract_modulo, METH_VARARGS},
+    {"chop_and", (PyCFunction)_chop_and, METH_VARARGS},
+    {"chop_or", (PyCFunction)_chop_or, METH_VARARGS},
+    {"chop_xor", (PyCFunction)_chop_xor, METH_VARARGS},
+    {"chop_soft_light", (PyCFunction)_chop_soft_light, METH_VARARGS},
+    {"chop_hard_light", (PyCFunction)_chop_hard_light, METH_VARARGS},
+    {"chop_overlay", (PyCFunction)_chop_overlay, METH_VARARGS},

 #endif

 #ifdef WITH_UNSHARPMASK
     /* Kevin Cazabon's unsharpmask extension */
-    {"gaussian_blur", (PyCFunction)_gaussian_blur, 1},
-    {"unsharp_mask", (PyCFunction)_unsharp_mask, 1},
-#endif
-
-    {"box_blur", (PyCFunction)_box_blur, 1},
+    {"gaussian_blur", (PyCFunction)_gaussian_blur, METH_VARARGS},
+    {"unsharp_mask", (PyCFunction)_unsharp_mask, METH_VARARGS},
+#endif
+
+    {"box_blur", (PyCFunction)_box_blur, METH_VARARGS},

 #ifdef WITH_EFFECTS
     /* Special effects */
-    {"effect_spread", (PyCFunction)_effect_spread, 1},
+    {"effect_spread", (PyCFunction)_effect_spread, METH_VARARGS},
 #endif

     /* Misc. */
-    {"new_block", (PyCFunction)_new_block, 1},
-
-    {"save_ppm", (PyCFunction)_save_ppm, 1},
+    {"new_block", (PyCFunction)_new_block, METH_VARARGS},
+
+    {"save_ppm", (PyCFunction)_save_ppm, METH_VARARGS},

     {NULL, NULL} /* sentinel */
 };

-
 /* attributes */

-static PyObject*
-_getattr_mode(ImagingObject* self, void* closure)
-{
+static PyObject *
+_getattr_mode(ImagingObject *self, void *closure) {
     return PyUnicode_FromString(self->image->mode);
 }

-static PyObject*
-_getattr_size(ImagingObject* self, void* closure)
-{
+static PyObject *
+_getattr_size(ImagingObject *self, void *closure) {
     return Py_BuildValue("ii", self->image->xsize, self->image->ysize);
 }

-static PyObject*
-_getattr_bands(ImagingObject* self, void* closure)
-{
+static PyObject *
+_getattr_bands(ImagingObject *self, void *closure) {
     return PyLong_FromLong(self->image->bands);
 }

-static PyObject*
-_getattr_id(ImagingObject* self, void* closure)
-{
-    return PyLong_FromSsize_t((Py_ssize_t) self->image);
-}
-
-static PyObject*
-_getattr_ptr(ImagingObject* self, void* closure)
-{
+static PyObject *
+_getattr_id(ImagingObject *self, void *closure) {
+    return PyLong_FromSsize_t((Py_ssize_t)self->image);
+}
+
+static PyObject *
+_getattr_ptr(ImagingObject *self, void *closure) {
     return PyCapsule_New(self->image, IMAGING_MAGIC, NULL);
 }

-static PyObject*
-_getattr_unsafe_ptrs(ImagingObject* self, void* closure)
-{
-    return Py_BuildValue("(sn)(sn)(sn)",
-                         "image8", self->image->image8,
-                         "image32", self->image->image32,
-                         "image", self->image->image
-                        );
+static PyObject *
+_getattr_unsafe_ptrs(ImagingObject *self, void *closure) {
+    return Py_BuildValue(
+        "(sn)(sn)(sn)",
+        "image8",
+        self->image->image8,
+        "image32",
+        self->image->image32,
+        "image",
+        self->image->image);
 };

-
 static struct PyGetSetDef getsetters[] = {
-    { "mode",   (getter) _getattr_mode },
-    { "size",   (getter) _getattr_size },
-    { "bands",  (getter) _getattr_bands },
-    { "id",     (getter) _getattr_id },
-    { "ptr",    (getter) _getattr_ptr },
-    { "unsafe_ptrs", (getter) _getattr_unsafe_ptrs },
-    { NULL }
-};
+    {"mode", (getter)_getattr_mode},
+    {"size", (getter)_getattr_size},
+    {"bands", (getter)_getattr_bands},
+    {"id", (getter)_getattr_id},
+    {"ptr", (getter)_getattr_ptr},
+    {"unsafe_ptrs", (getter)_getattr_unsafe_ptrs},
+    {NULL}};

 /* basic sequence semantics */

 static Py_ssize_t
-image_length(ImagingObject *self)
-{
+image_length(ImagingObject *self) {
     Imaging im = self->image;

-    return (Py_ssize_t) im->xsize * im->ysize;
-}
-
-static PyObject *
-image_item(ImagingObject *self, Py_ssize_t i)
-{
+    return (Py_ssize_t)im->xsize * im->ysize;
+}
+
+static PyObject *
+image_item(ImagingObject *self, Py_ssize_t i) {
     int x, y;
     Imaging im = self->image;

@@ -3643,154 +3616,150 @@
 }

 static PySequenceMethods image_as_sequence = {
-    (lenfunc) image_length, /*sq_length*/
-    (binaryfunc) NULL, /*sq_concat*/
-    (ssizeargfunc) NULL, /*sq_repeat*/
-    (ssizeargfunc) image_item, /*sq_item*/
-    (ssizessizeargfunc) NULL, /*sq_slice*/
-    (ssizeobjargproc) NULL, /*sq_ass_item*/
-    (ssizessizeobjargproc) NULL, /*sq_ass_slice*/
+    (lenfunc)image_length,      /*sq_length*/
+    (binaryfunc)NULL,           /*sq_concat*/
+    (ssizeargfunc)NULL,         /*sq_repeat*/
+    (ssizeargfunc)image_item,   /*sq_item*/
+    (ssizessizeargfunc)NULL,    /*sq_slice*/
+    (ssizeobjargproc)NULL,      /*sq_ass_item*/
+    (ssizessizeobjargproc)NULL, /*sq_ass_slice*/
 };

-
 /* type description */

 static PyTypeObject Imaging_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "ImagingCore",        /*tp_name*/
-    sizeof(ImagingObject),    /*tp_size*/
-    0,                /*tp_itemsize*/
+    PyVarObject_HEAD_INIT(NULL, 0) "ImagingCore", /*tp_name*/
+    sizeof(ImagingObject),                        /*tp_size*/
+    0,                                            /*tp_itemsize*/
     /* methods */
-    (destructor)_dealloc,    /*tp_dealloc*/
-    0,                /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    &image_as_sequence,         /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    methods,                    /*tp_methods*/
-    0,                          /*tp_members*/
-    getsetters,                 /*tp_getset*/
+    (destructor)_dealloc, /*tp_dealloc*/
+    0,                    /*tp_print*/
+    0,                    /*tp_getattr*/
+    0,                    /*tp_setattr*/
+    0,                    /*tp_compare*/
+    0,                    /*tp_repr*/
+    0,                    /*tp_as_number */
+    &image_as_sequence,   /*tp_as_sequence */
+    0,                    /*tp_as_mapping */
+    0,                    /*tp_hash*/
+    0,                    /*tp_call*/
+    0,                    /*tp_str*/
+    0,                    /*tp_getattro*/
+    0,                    /*tp_setattro*/
+    0,                    /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,   /*tp_flags*/
+    0,                    /*tp_doc*/
+    0,                    /*tp_traverse*/
+    0,                    /*tp_clear*/
+    0,                    /*tp_richcompare*/
+    0,                    /*tp_weaklistoffset*/
+    0,                    /*tp_iter*/
+    0,                    /*tp_iternext*/
+    methods,              /*tp_methods*/
+    0,                    /*tp_members*/
+    getsetters,           /*tp_getset*/
 };

 #ifdef WITH_IMAGEDRAW

 static PyTypeObject ImagingFont_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "ImagingFont",        /*tp_name*/
-    sizeof(ImagingFontObject),    /*tp_size*/
-    0,                /*tp_itemsize*/
+    PyVarObject_HEAD_INIT(NULL, 0) "ImagingFont", /*tp_name*/
+    sizeof(ImagingFontObject),                    /*tp_size*/
+    0,                                            /*tp_itemsize*/
     /* methods */
-    (destructor)_font_dealloc,    /*tp_dealloc*/
-    0,                /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    _font_methods,              /*tp_methods*/
-    0,                          /*tp_members*/
-    0,                          /*tp_getset*/
+    (destructor)_font_dealloc, /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number */
+    0,                         /*tp_as_sequence */
+    0,                         /*tp_as_mapping */
+    0,                         /*tp_hash*/
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,        /*tp_flags*/
+    0,                         /*tp_doc*/
+    0,                         /*tp_traverse*/
+    0,                         /*tp_clear*/
+    0,                         /*tp_richcompare*/
+    0,                         /*tp_weaklistoffset*/
+    0,                         /*tp_iter*/
+    0,                         /*tp_iternext*/
+    _font_methods,             /*tp_methods*/
+    0,                         /*tp_members*/
+    0,                         /*tp_getset*/
 };

 static PyTypeObject ImagingDraw_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "ImagingDraw",        /*tp_name*/
-    sizeof(ImagingDrawObject),    /*tp_size*/
-    0,                /*tp_itemsize*/
+    PyVarObject_HEAD_INIT(NULL, 0) "ImagingDraw", /*tp_name*/
+    sizeof(ImagingDrawObject),                    /*tp_size*/
+    0,                                            /*tp_itemsize*/
     /* methods */
-    (destructor)_draw_dealloc,    /*tp_dealloc*/
-    0,                /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    _draw_methods,              /*tp_methods*/
-    0,                          /*tp_members*/
-    0,                          /*tp_getset*/
+    (destructor)_draw_dealloc, /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number */
+    0,                         /*tp_as_sequence */
+    0,                         /*tp_as_mapping */
+    0,                         /*tp_hash*/
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,        /*tp_flags*/
+    0,                         /*tp_doc*/
+    0,                         /*tp_traverse*/
+    0,                         /*tp_clear*/
+    0,                         /*tp_richcompare*/
+    0,                         /*tp_weaklistoffset*/
+    0,                         /*tp_iter*/
+    0,                         /*tp_iternext*/
+    _draw_methods,             /*tp_methods*/
+    0,                         /*tp_members*/
+    0,                         /*tp_getset*/
 };

 #endif

 static PyMappingMethods pixel_access_as_mapping = {
-    (lenfunc) NULL, /*mp_length*/
-    (binaryfunc) pixel_access_getitem, /*mp_subscript*/
-    (objobjargproc) pixel_access_setitem, /*mp_ass_subscript*/
+    (lenfunc)NULL,                       /*mp_length*/
+    (binaryfunc)pixel_access_getitem,    /*mp_subscript*/
+    (objobjargproc)pixel_access_setitem, /*mp_ass_subscript*/
 };

 /* type description */

 static PyTypeObject PixelAccess_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "PixelAccess", sizeof(PixelAccessObject), 0,
+    PyVarObject_HEAD_INIT(NULL, 0) "PixelAccess",
+    sizeof(PixelAccessObject),
+    0,
     /* methods */
     (destructor)pixel_access_dealloc, /*tp_dealloc*/
-    0, /*tp_print*/
-    0, /*tp_getattr*/
-    0, /*tp_setattr*/
-    0, /*tp_compare*/
-    0, /*tp_repr*/
-    0, /*tp_as_number */
-    0, /*tp_as_sequence */
-    &pixel_access_as_mapping, /*tp_as_mapping */
-    0 /*tp_hash*/
+    0,                                /*tp_print*/
+    0,                                /*tp_getattr*/
+    0,                                /*tp_setattr*/
+    0,                                /*tp_compare*/
+    0,                                /*tp_repr*/
+    0,                                /*tp_as_number */
+    0,                                /*tp_as_sequence */
+    &pixel_access_as_mapping,         /*tp_as_mapping */
+    0                                 /*tp_hash*/
 };

 /* -------------------------------------------------------------------- */

-static PyObject*
-_get_stats(PyObject* self, PyObject* args)
-{
-    PyObject* d;
+static PyObject *
+_get_stats(PyObject *self, PyObject *args) {
+    PyObject *d;
     ImagingMemoryArena arena = &ImagingDefaultArena;

     if (!PyArg_ParseTuple(args, ":get_stats")) {
@@ -3798,27 +3767,23 @@
     }

     d = PyDict_New();
-    if ( ! d) {
-        return NULL;
-    }
-    PyDict_SetItemString(d, "new_count",
-                         PyLong_FromLong(arena->stats_new_count));
-    PyDict_SetItemString(d, "allocated_blocks",
-                         PyLong_FromLong(arena->stats_allocated_blocks));
-    PyDict_SetItemString(d, "reused_blocks",
-                         PyLong_FromLong(arena->stats_reused_blocks));
-    PyDict_SetItemString(d, "reallocated_blocks",
-                         PyLong_FromLong(arena->stats_reallocated_blocks));
-    PyDict_SetItemString(d, "freed_blocks",
-                         PyLong_FromLong(arena->stats_freed_blocks));
-    PyDict_SetItemString(d, "blocks_cached",
-                         PyLong_FromLong(arena->blocks_cached));
+    if (!d) {
+        return NULL;
+    }
+    PyDict_SetItemString(d, "new_count", PyLong_FromLong(arena->stats_new_count));
+    PyDict_SetItemString(
+        d, "allocated_blocks", PyLong_FromLong(arena->stats_allocated_blocks));
+    PyDict_SetItemString(
+        d, "reused_blocks", PyLong_FromLong(arena->stats_reused_blocks));
+    PyDict_SetItemString(
+        d, "reallocated_blocks", PyLong_FromLong(arena->stats_reallocated_blocks));
+    PyDict_SetItemString(d, "freed_blocks", PyLong_FromLong(arena->stats_freed_blocks));
+    PyDict_SetItemString(d, "blocks_cached", PyLong_FromLong(arena->blocks_cached));
     return d;
 }

-static PyObject*
-_reset_stats(PyObject* self, PyObject* args)
-{
+static PyObject *
+_reset_stats(PyObject *self, PyObject *args) {
     ImagingMemoryArena arena = &ImagingDefaultArena;

     if (!PyArg_ParseTuple(args, ":reset_stats")) {
@@ -3835,9 +3800,8 @@
     return Py_None;
 }

-static PyObject*
-_get_alignment(PyObject* self, PyObject* args)
-{
+static PyObject *
+_get_alignment(PyObject *self, PyObject *args) {
     if (!PyArg_ParseTuple(args, ":get_alignment")) {
         return NULL;
     }
@@ -3845,9 +3809,8 @@
     return PyLong_FromLong(ImagingDefaultArena.alignment);
 }

-static PyObject*
-_get_block_size(PyObject* self, PyObject* args)
-{
+static PyObject *
+_get_block_size(PyObject *self, PyObject *args) {
     if (!PyArg_ParseTuple(args, ":get_block_size")) {
         return NULL;
     }
@@ -3855,9 +3818,8 @@
     return PyLong_FromLong(ImagingDefaultArena.block_size);
 }

-static PyObject*
-_get_blocks_max(PyObject* self, PyObject* args)
-{
+static PyObject *
+_get_blocks_max(PyObject *self, PyObject *args) {
     if (!PyArg_ParseTuple(args, ":get_blocks_max")) {
         return NULL;
     }
@@ -3865,9 +3827,8 @@
     return PyLong_FromLong(ImagingDefaultArena.blocks_max);
 }

-static PyObject*
-_set_alignment(PyObject* self, PyObject* args)
-{
+static PyObject *
+_set_alignment(PyObject *self, PyObject *args) {
     int alignment;
     if (!PyArg_ParseTuple(args, "i:set_alignment", &alignment)) {
         return NULL;
@@ -3889,23 +3850,20 @@
     return Py_None;
 }

-static PyObject*
-_set_block_size(PyObject* self, PyObject* args)
-{
+static PyObject *
+_set_block_size(PyObject *self, PyObject *args) {
     int block_size;
     if (!PyArg_ParseTuple(args, "i:set_block_size", &block_size)) {
         return NULL;
     }

     if (block_size <= 0) {
-        PyErr_SetString(PyExc_ValueError,
-            "block_size should be greater than 0");
+        PyErr_SetString(PyExc_ValueError, "block_size should be greater than 0");
         return NULL;
     }

     if (block_size & 0xfff) {
-        PyErr_SetString(PyExc_ValueError,
-            "block_size should be multiple of 4096");
+        PyErr_SetString(PyExc_ValueError, "block_size should be multiple of 4096");
         return NULL;
     }

@@ -3915,27 +3873,24 @@
     return Py_None;
 }

-static PyObject*
-_set_blocks_max(PyObject* self, PyObject* args)
-{
+static PyObject *
+_set_blocks_max(PyObject *self, PyObject *args) {
     int blocks_max;
     if (!PyArg_ParseTuple(args, "i:set_blocks_max", &blocks_max)) {
         return NULL;
     }

     if (blocks_max < 0) {
-        PyErr_SetString(PyExc_ValueError,
-            "blocks_max should be greater than 0");
-        return NULL;
-    }
-    else if ( (unsigned long)blocks_max > SIZE_MAX/sizeof(ImagingDefaultArena.blocks_pool[0])) {
-        PyErr_SetString(PyExc_ValueError,
-            "blocks_max is too large");
-        return NULL;
-    }
-
-
-    if ( ! ImagingMemorySetBlocksMax(&ImagingDefaultArena, blocks_max)) {
+        PyErr_SetString(PyExc_ValueError, "blocks_max should be greater than 0");
+        return NULL;
+    } else if (
+        (unsigned long)blocks_max >
+        SIZE_MAX / sizeof(ImagingDefaultArena.blocks_pool[0])) {
+        PyErr_SetString(PyExc_ValueError, "blocks_max is too large");
+        return NULL;
+    }
+
+    if (!ImagingMemorySetBlocksMax(&ImagingDefaultArena, blocks_max)) {
         return ImagingError_MemoryError();
     }

@@ -3943,9 +3898,8 @@
     return Py_None;
 }

-static PyObject*
-_clear_cache(PyObject* self, PyObject* args)
-{
+static PyObject *
+_clear_cache(PyObject *self, PyObject *args) {
     int i = 0;

     if (!PyArg_ParseTuple(args, "|i:clear_cache", &i)) {
@@ -3964,179 +3918,214 @@
    pluggable codecs, but not before PIL 1.2 */

 /* Decoders (in decode.c) */
-extern PyObject* PyImaging_BcnDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_BitDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_FliDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_GifDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_HexDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_JpegDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_Jpeg2KDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_LibTiffDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_PackbitsDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_PcdDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_PcxDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_RawDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_SgiRleDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_SunRleDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_TgaRleDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_XbmDecoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_ZipDecoderNew(PyObject* self, PyObject* args);
+extern PyObject *
+PyImaging_BcnDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_BitDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_FliDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_GifDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_HexDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_JpegDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_Jpeg2KDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_LibTiffDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_PackbitsDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_PcdDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_PcxDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_RawDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_SgiRleDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_SunRleDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_TgaRleDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_XbmDecoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_ZipDecoderNew(PyObject *self, PyObject *args);

 /* Encoders (in encode.c) */
-extern PyObject* PyImaging_EpsEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_GifEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_JpegEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_Jpeg2KEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_PcxEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_RawEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_TgaRleEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_XbmEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_ZipEncoderNew(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_LibTiffEncoderNew(PyObject* self, PyObject* args);
+extern PyObject *
+PyImaging_EpsEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_GifEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_JpegEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_Jpeg2KEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_PcxEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_RawEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_TgaRleEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_XbmEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_ZipEncoderNew(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_LibTiffEncoderNew(PyObject *self, PyObject *args);

 /* Display support etc (in display.c) */
 #ifdef _WIN32
-extern PyObject* PyImaging_CreateWindowWin32(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_DisplayWin32(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_DisplayModeWin32(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_GrabScreenWin32(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_GrabClipboardWin32(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_ListWindowsWin32(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_EventLoopWin32(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_DrawWmf(PyObject* self, PyObject* args);
+extern PyObject *
+PyImaging_CreateWindowWin32(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_DisplayWin32(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_DisplayModeWin32(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_GrabScreenWin32(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_GrabClipboardWin32(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_ListWindowsWin32(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_EventLoopWin32(PyObject *self, PyObject *args);
+extern PyObject *
+PyImaging_DrawWmf(PyObject *self, PyObject *args);
 #endif
 #ifdef HAVE_XCB
-extern PyObject* PyImaging_GrabScreenX11(PyObject* self, PyObject* args);
+extern PyObject *
+PyImaging_GrabScreenX11(PyObject *self, PyObject *args);
 #endif

 /* Experimental path stuff (in path.c) */
-extern PyObject* PyPath_Create(ImagingObject* self, PyObject* args);
+extern PyObject *
+PyPath_Create(ImagingObject *self, PyObject *args);

 /* Experimental outline stuff (in outline.c) */
-extern PyObject* PyOutline_Create(ImagingObject* self, PyObject* args);
-
-extern PyObject* PyImaging_Mapper(PyObject* self, PyObject* args);
-extern PyObject* PyImaging_MapBuffer(PyObject* self, PyObject* args);
+extern PyObject *
+PyOutline_Create(ImagingObject *self, PyObject *args);
+
+extern PyObject *
+PyImaging_MapBuffer(PyObject *self, PyObject *args);

 static PyMethodDef functions[] = {

     /* Object factories */
-    {"alpha_composite", (PyCFunction)_alpha_composite, 1},
-    {"blend", (PyCFunction)_blend, 1},
-    {"fill", (PyCFunction)_fill, 1},
-    {"new", (PyCFunction)_new, 1},
-    {"merge", (PyCFunction)_merge, 1},
+    {"alpha_composite", (PyCFunction)_alpha_composite, METH_VARARGS},
+    {"blend", (PyCFunction)_blend, METH_VARARGS},
+    {"fill", (PyCFunction)_fill, METH_VARARGS},
+    {"new", (PyCFunction)_new, METH_VARARGS},
+    {"merge", (PyCFunction)_merge, METH_VARARGS},

     /* Functions */
-    {"convert", (PyCFunction)_convert2, 1},
+    {"convert", (PyCFunction)_convert2, METH_VARARGS},

     /* Codecs */
-    {"bcn_decoder", (PyCFunction)PyImaging_BcnDecoderNew, 1},
-    {"bit_decoder", (PyCFunction)PyImaging_BitDecoderNew, 1},
-    {"eps_encoder", (PyCFunction)PyImaging_EpsEncoderNew, 1},
-    {"fli_decoder", (PyCFunction)PyImaging_FliDecoderNew, 1},
-    {"gif_decoder", (PyCFunction)PyImaging_GifDecoderNew, 1},
-    {"gif_encoder", (PyCFunction)PyImaging_GifEncoderNew, 1},
-    {"hex_decoder", (PyCFunction)PyImaging_HexDecoderNew, 1},
-    {"hex_encoder", (PyCFunction)PyImaging_EpsEncoderNew, 1}, /* EPS=HEX! */
+    {"bcn_decoder", (PyCFunction)PyImaging_BcnDecoderNew, METH_VARARGS},
+    {"bit_decoder", (PyCFunction)PyImaging_BitDecoderNew, METH_VARARGS},
+    {"eps_encoder", (PyCFunction)PyImaging_EpsEncoderNew, METH_VARARGS},
+    {"fli_decoder", (PyCFunction)PyImaging_FliDecoderNew, METH_VARARGS},
+    {"gif_decoder", (PyCFunction)PyImaging_GifDecoderNew, METH_VARARGS},
+    {"gif_encoder", (PyCFunction)PyImaging_GifEncoderNew, METH_VARARGS},
+    {"hex_decoder", (PyCFunction)PyImaging_HexDecoderNew, METH_VARARGS},
+    {"hex_encoder", (PyCFunction)PyImaging_EpsEncoderNew, METH_VARARGS}, /* EPS=HEX! */
 #ifdef HAVE_LIBJPEG
-    {"jpeg_decoder", (PyCFunction)PyImaging_JpegDecoderNew, 1},
-    {"jpeg_encoder", (PyCFunction)PyImaging_JpegEncoderNew, 1},
+    {"jpeg_decoder", (PyCFunction)PyImaging_JpegDecoderNew, METH_VARARGS},
+    {"jpeg_encoder", (PyCFunction)PyImaging_JpegEncoderNew, METH_VARARGS},
 #endif
 #ifdef HAVE_OPENJPEG
-    {"jpeg2k_decoder", (PyCFunction)PyImaging_Jpeg2KDecoderNew, 1},
-    {"jpeg2k_encoder", (PyCFunction)PyImaging_Jpeg2KEncoderNew, 1},
+    {"jpeg2k_decoder", (PyCFunction)PyImaging_Jpeg2KDecoderNew, METH_VARARGS},
+    {"jpeg2k_encoder", (PyCFunction)PyImaging_Jpeg2KEncoderNew, METH_VARARGS},
 #endif
 #ifdef HAVE_LIBTIFF
-    {"libtiff_decoder", (PyCFunction)PyImaging_LibTiffDecoderNew, 1},
-    {"libtiff_encoder", (PyCFunction)PyImaging_LibTiffEncoderNew, 1},
-#endif
-    {"packbits_decoder", (PyCFunction)PyImaging_PackbitsDecoderNew, 1},
-    {"pcd_decoder", (PyCFunction)PyImaging_PcdDecoderNew, 1},
-    {"pcx_decoder", (PyCFunction)PyImaging_PcxDecoderNew, 1},
-    {"pcx_encoder", (PyCFunction)PyImaging_PcxEncoderNew, 1},
-    {"raw_decoder", (PyCFunction)PyImaging_RawDecoderNew, 1},
-    {"raw_encoder", (PyCFunction)PyImaging_RawEncoderNew, 1},
-    {"sgi_rle_decoder", (PyCFunction)PyImaging_SgiRleDecoderNew, 1},
-    {"sun_rle_decoder", (PyCFunction)PyImaging_SunRleDecoderNew, 1},
-    {"tga_rle_decoder", (PyCFunction)PyImaging_TgaRleDecoderNew, 1},
-    {"tga_rle_encoder", (PyCFunction)PyImaging_TgaRleEncoderNew, 1},
-    {"xbm_decoder", (PyCFunction)PyImaging_XbmDecoderNew, 1},
-    {"xbm_encoder", (PyCFunction)PyImaging_XbmEncoderNew, 1},
+    {"libtiff_decoder", (PyCFunction)PyImaging_LibTiffDecoderNew, METH_VARARGS},
+    {"libtiff_encoder", (PyCFunction)PyImaging_LibTiffEncoderNew, METH_VARARGS},
+#endif
+    {"packbits_decoder", (PyCFunction)PyImaging_PackbitsDecoderNew, METH_VARARGS},
+    {"pcd_decoder", (PyCFunction)PyImaging_PcdDecoderNew, METH_VARARGS},
+    {"pcx_decoder", (PyCFunction)PyImaging_PcxDecoderNew, METH_VARARGS},
+    {"pcx_encoder", (PyCFunction)PyImaging_PcxEncoderNew, METH_VARARGS},
+    {"raw_decoder", (PyCFunction)PyImaging_RawDecoderNew, METH_VARARGS},
+    {"raw_encoder", (PyCFunction)PyImaging_RawEncoderNew, METH_VARARGS},
+    {"sgi_rle_decoder", (PyCFunction)PyImaging_SgiRleDecoderNew, METH_VARARGS},
+    {"sun_rle_decoder", (PyCFunction)PyImaging_SunRleDecoderNew, METH_VARARGS},
+    {"tga_rle_decoder", (PyCFunction)PyImaging_TgaRleDecoderNew, METH_VARARGS},
+    {"tga_rle_encoder", (PyCFunction)PyImaging_TgaRleEncoderNew, METH_VARARGS},
+    {"xbm_decoder", (PyCFunction)PyImaging_XbmDecoderNew, METH_VARARGS},
+    {"xbm_encoder", (PyCFunction)PyImaging_XbmEncoderNew, METH_VARARGS},
 #ifdef HAVE_LIBZ
-    {"zip_decoder", (PyCFunction)PyImaging_ZipDecoderNew, 1},
-    {"zip_encoder", (PyCFunction)PyImaging_ZipEncoderNew, 1},
-#endif
-
-    /* Memory mapping */
+    {"zip_decoder", (PyCFunction)PyImaging_ZipDecoderNew, METH_VARARGS},
+    {"zip_encoder", (PyCFunction)PyImaging_ZipEncoderNew, METH_VARARGS},
+#endif
+
+/* Memory mapping */
 #ifdef WITH_MAPPING
+    {"map_buffer", (PyCFunction)PyImaging_MapBuffer, METH_VARARGS},
+#endif
+
+/* Display support */
 #ifdef _WIN32
-    {"map", (PyCFunction)PyImaging_Mapper, 1},
-#endif
-    {"map_buffer", (PyCFunction)PyImaging_MapBuffer, 1},
-#endif
-
-    /* Display support */
-#ifdef _WIN32
-    {"display", (PyCFunction)PyImaging_DisplayWin32, 1},
-    {"display_mode", (PyCFunction)PyImaging_DisplayModeWin32, 1},
-    {"grabscreen_win32", (PyCFunction)PyImaging_GrabScreenWin32, 1},
-    {"grabclipboard_win32", (PyCFunction)PyImaging_GrabClipboardWin32, 1},
-    {"createwindow", (PyCFunction)PyImaging_CreateWindowWin32, 1},
-    {"eventloop", (PyCFunction)PyImaging_EventLoopWin32, 1},
-    {"listwindows", (PyCFunction)PyImaging_ListWindowsWin32, 1},
-    {"drawwmf", (PyCFunction)PyImaging_DrawWmf, 1},
+    {"display", (PyCFunction)PyImaging_DisplayWin32, METH_VARARGS},
+    {"display_mode", (PyCFunction)PyImaging_DisplayModeWin32, METH_VARARGS},
+    {"grabscreen_win32", (PyCFunction)PyImaging_GrabScreenWin32, METH_VARARGS},
+    {"grabclipboard_win32", (PyCFunction)PyImaging_GrabClipboardWin32, METH_VARARGS},
+    {"createwindow", (PyCFunction)PyImaging_CreateWindowWin32, METH_VARARGS},
+    {"eventloop", (PyCFunction)PyImaging_EventLoopWin32, METH_VARARGS},
+    {"listwindows", (PyCFunction)PyImaging_ListWindowsWin32, METH_VARARGS},
+    {"drawwmf", (PyCFunction)PyImaging_DrawWmf, METH_VARARGS},
 #endif
 #ifdef HAVE_XCB
-    {"grabscreen_x11", (PyCFunction)PyImaging_GrabScreenX11, 1},
+    {"grabscreen_x11", (PyCFunction)PyImaging_GrabScreenX11, METH_VARARGS},
 #endif

     /* Utilities */
-    {"getcodecstatus", (PyCFunction)_getcodecstatus, 1},
-
-    /* Special effects (experimental) */
+    {"getcodecstatus", (PyCFunction)_getcodecstatus, METH_VARARGS},
+
+/* Special effects (experimental) */
 #ifdef WITH_EFFECTS
-    {"effect_mandelbrot", (PyCFunction)_effect_mandelbrot, 1},
-    {"effect_noise", (PyCFunction)_effect_noise, 1},
-    {"linear_gradient", (PyCFunction)_linear_gradient, 1},
-    {"radial_gradient", (PyCFunction)_radial_gradient, 1},
-    {"wedge", (PyCFunction)_linear_gradient, 1}, /* Compatibility */
-#endif
-
-    /* Drawing support stuff */
+    {"effect_mandelbrot", (PyCFunction)_effect_mandelbrot, METH_VARARGS},
+    {"effect_noise", (PyCFunction)_effect_noise, METH_VARARGS},
+    {"linear_gradient", (PyCFunction)_linear_gradient, METH_VARARGS},
+    {"radial_gradient", (PyCFunction)_radial_gradient, METH_VARARGS},
+    {"wedge", (PyCFunction)_linear_gradient, METH_VARARGS}, /* Compatibility */
+#endif
+
+/* Drawing support stuff */
 #ifdef WITH_IMAGEDRAW
-    {"font", (PyCFunction)_font_new, 1},
-    {"draw", (PyCFunction)_draw_new, 1},
-#endif
-
-    /* Experimental path stuff */
+    {"font", (PyCFunction)_font_new, METH_VARARGS},
+    {"draw", (PyCFunction)_draw_new, METH_VARARGS},
+#endif
+
+/* Experimental path stuff */
 #ifdef WITH_IMAGEPATH
-    {"path", (PyCFunction)PyPath_Create, 1},
-#endif
-
-    /* Experimental arrow graphics stuff */
+    {"path", (PyCFunction)PyPath_Create, METH_VARARGS},
+#endif
+
+/* Experimental arrow graphics stuff */
 #ifdef WITH_ARROW
-    {"outline", (PyCFunction)PyOutline_Create, 1},
+    {"outline", (PyCFunction)PyOutline_Create, METH_VARARGS},
 #endif

     /* Resource management */
-    {"get_stats", (PyCFunction)_get_stats, 1},
-    {"reset_stats", (PyCFunction)_reset_stats, 1},
-    {"get_alignment", (PyCFunction)_get_alignment, 1},
-    {"get_block_size", (PyCFunction)_get_block_size, 1},
-    {"get_blocks_max", (PyCFunction)_get_blocks_max, 1},
-    {"set_alignment", (PyCFunction)_set_alignment, 1},
-    {"set_block_size", (PyCFunction)_set_block_size, 1},
-    {"set_blocks_max", (PyCFunction)_set_blocks_max, 1},
-    {"clear_cache", (PyCFunction)_clear_cache, 1},
+    {"get_stats", (PyCFunction)_get_stats, METH_VARARGS},
+    {"reset_stats", (PyCFunction)_reset_stats, METH_VARARGS},
+    {"get_alignment", (PyCFunction)_get_alignment, METH_VARARGS},
+    {"get_block_size", (PyCFunction)_get_block_size, METH_VARARGS},
+    {"get_blocks_max", (PyCFunction)_get_blocks_max, METH_VARARGS},
+    {"set_alignment", (PyCFunction)_set_alignment, METH_VARARGS},
+    {"set_block_size", (PyCFunction)_set_block_size, METH_VARARGS},
+    {"set_blocks_max", (PyCFunction)_set_blocks_max, METH_VARARGS},
+    {"clear_cache", (PyCFunction)_clear_cache, METH_VARARGS},

     {NULL, NULL} /* sentinel */
 };

 static int
-setup_module(PyObject* m) {
-    PyObject* d = PyModule_GetDict(m);
-    const char* version = (char*)PILLOW_VERSION;
+setup_module(PyObject *m) {
+    PyObject *d = PyModule_GetDict(m);
+    const char *version = (char *)PILLOW_VERSION;

     /* Ready object types */
     if (PyType_Ready(&Imaging_Type) < 0) {
@@ -4159,74 +4148,90 @@
     ImagingAccessInit();

 #ifdef HAVE_LIBJPEG
-  {
-    extern const char* ImagingJpegVersion(void);
-    PyDict_SetItemString(d, "jpeglib_version", PyUnicode_FromString(ImagingJpegVersion()));
-  }
+    {
+        extern const char *ImagingJpegVersion(void);
+        PyDict_SetItemString(
+            d, "jpeglib_version", PyUnicode_FromString(ImagingJpegVersion()));
+    }
 #endif

 #ifdef HAVE_OPENJPEG
-  {
-    extern const char *ImagingJpeg2KVersion(void);
-    PyDict_SetItemString(d, "jp2klib_version", PyUnicode_FromString(ImagingJpeg2KVersion()));
-  }
-#endif
-
+    {
+        extern const char *ImagingJpeg2KVersion(void);
+        PyDict_SetItemString(
+            d, "jp2klib_version", PyUnicode_FromString(ImagingJpeg2KVersion()));
+    }
+#endif
+
+    PyObject *have_libjpegturbo;
 #ifdef LIBJPEG_TURBO_VERSION
-    PyModule_AddObject(m, "HAVE_LIBJPEGTURBO", Py_True);
-    #define tostr1(a) #a
-    #define tostr(a) tostr1(a)
-    PyDict_SetItemString(d, "libjpeg_turbo_version", PyUnicode_FromString(tostr(LIBJPEG_TURBO_VERSION)));
-    #undef tostr
-    #undef tostr1
+    have_libjpegturbo = Py_True;
+#define tostr1(a) #a
+#define tostr(a) tostr1(a)
+    PyDict_SetItemString(
+        d, "libjpeg_turbo_version", PyUnicode_FromString(tostr(LIBJPEG_TURBO_VERSION)));
+#undef tostr
+#undef tostr1
 #else
-    PyModule_AddObject(m, "HAVE_LIBJPEGTURBO", Py_False);
-#endif
-
+    have_libjpegturbo = Py_False;
+#endif
+    Py_INCREF(have_libjpegturbo);
+    PyModule_AddObject(m, "HAVE_LIBJPEGTURBO", have_libjpegturbo);
+
+    PyObject *have_libimagequant;
 #ifdef HAVE_LIBIMAGEQUANT
-    PyModule_AddObject(m, "HAVE_LIBIMAGEQUANT", Py_True);
+    have_libimagequant = Py_True;
     {
-        extern const char* ImagingImageQuantVersion(void);
-        PyDict_SetItemString(d, "imagequant_version", PyUnicode_FromString(ImagingImageQuantVersion()));
+        extern const char *ImagingImageQuantVersion(void);
+        PyDict_SetItemString(
+            d, "imagequant_version", PyUnicode_FromString(ImagingImageQuantVersion()));
     }
 #else
-    PyModule_AddObject(m, "HAVE_LIBIMAGEQUANT", Py_False);
-#endif
+    have_libimagequant = Py_False;
+#endif
+    Py_INCREF(have_libimagequant);
+    PyModule_AddObject(m, "HAVE_LIBIMAGEQUANT", have_libimagequant);

 #ifdef HAVE_LIBZ
-  /* zip encoding strategies */
-  PyModule_AddIntConstant(m, "DEFAULT_STRATEGY", Z_DEFAULT_STRATEGY);
-  PyModule_AddIntConstant(m, "FILTERED", Z_FILTERED);
-  PyModule_AddIntConstant(m, "HUFFMAN_ONLY", Z_HUFFMAN_ONLY);
-  PyModule_AddIntConstant(m, "RLE", Z_RLE);
-  PyModule_AddIntConstant(m, "FIXED", Z_FIXED);
-  {
-    extern const char* ImagingZipVersion(void);
-    PyDict_SetItemString(d, "zlib_version", PyUnicode_FromString(ImagingZipVersion()));
-  }
+    /* zip encoding strategies */
+    PyModule_AddIntConstant(m, "DEFAULT_STRATEGY", Z_DEFAULT_STRATEGY);
+    PyModule_AddIntConstant(m, "FILTERED", Z_FILTERED);
+    PyModule_AddIntConstant(m, "HUFFMAN_ONLY", Z_HUFFMAN_ONLY);
+    PyModule_AddIntConstant(m, "RLE", Z_RLE);
+    PyModule_AddIntConstant(m, "FIXED", Z_FIXED);
+    {
+        extern const char *ImagingZipVersion(void);
+        PyDict_SetItemString(
+            d, "zlib_version", PyUnicode_FromString(ImagingZipVersion()));
+    }
 #endif

 #ifdef HAVE_LIBTIFF
-  {
-    extern const char * ImagingTiffVersion(void);
-    PyDict_SetItemString(d, "libtiff_version", PyUnicode_FromString(ImagingTiffVersion()));
-
-    // Test for libtiff 4.0 or later, excluding libtiff 3.9.6 and 3.9.7
-    PyObject* support_custom_tags;
-#if TIFFLIB_VERSION >= 20111221 && TIFFLIB_VERSION != 20120218 && TIFFLIB_VERSION != 20120922
-    support_custom_tags = Py_True;
+    {
+        extern const char *ImagingTiffVersion(void);
+        PyDict_SetItemString(
+            d, "libtiff_version", PyUnicode_FromString(ImagingTiffVersion()));
+
+        // Test for libtiff 4.0 or later, excluding libtiff 3.9.6 and 3.9.7
+        PyObject *support_custom_tags;
+#if TIFFLIB_VERSION >= 20111221 && TIFFLIB_VERSION != 20120218 && \
+    TIFFLIB_VERSION != 20120922
+        support_custom_tags = Py_True;
 #else
-    support_custom_tags = Py_False;
-#endif
-    PyDict_SetItemString(d, "libtiff_support_custom_tags", support_custom_tags);
-  }
-#endif
-
+        support_custom_tags = Py_False;
+#endif
+        PyDict_SetItemString(d, "libtiff_support_custom_tags", support_custom_tags);
+    }
+#endif
+
+    PyObject *have_xcb;
 #ifdef HAVE_XCB
-    PyModule_AddObject(m, "HAVE_XCB", Py_True);
+    have_xcb = Py_True;
 #else
-    PyModule_AddObject(m, "HAVE_XCB", Py_False);
-#endif
+    have_xcb = Py_False;
+#endif
+    Py_INCREF(have_xcb);
+    PyModule_AddObject(m, "HAVE_XCB", have_xcb);

     PyDict_SetItemString(d, "PILLOW_VERSION", PyUnicode_FromString(version));

@@ -4235,14 +4240,14 @@

 PyMODINIT_FUNC
 PyInit__imaging(void) {
-    PyObject* m;
+    PyObject *m;

     static PyModuleDef module_def = {
         PyModuleDef_HEAD_INIT,
-        "_imaging",         /* m_name */
-        NULL,               /* m_doc */
-        -1,                 /* m_size */
-        functions,          /* m_methods */
+        "_imaging", /* m_name */
+        NULL,       /* m_doc */
+        -1,         /* m_size */
+        functions,  /* m_methods */
     };

     m = PyModule_Create(&module_def);
('src', '_imagingcms.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -3,30 +3,31 @@
  * a Python / PIL interface to the littleCMS ICC Color Management System
  * Copyright (C) 2002-2003 Kevin Cazabon
  * kevin@cazabon.com
- * http://www.cazabon.com
+ * https://www.cazabon.com
  * Adapted/reworked for PIL by Fredrik Lundh
  * Copyright (c) 2009 Fredrik Lundh
  * Updated to LCMS2
  * Copyright (c) 2013 Eric Soroos
  *
- * pyCMS home page:  http://www.cazabon.com/pyCMS
- * littleCMS home page:  http://www.littlecms.com
+ * pyCMS home page:  https://www.cazabon.com/pyCMS
+ * littleCMS home page:  https://www.littlecms.com
  * (littleCMS is Copyright (C) 1998-2001 Marti Maria)
  *
  * Originally released under LGPL.  Graciously donated to PIL in
  * March 2009, for distribution under the standard PIL license
  */

-#define COPYRIGHTINFO "\
+#define COPYRIGHTINFO \
+    "\
 pyCMS\n\
 a Python / PIL interface to the littleCMS ICC Color Management System\n\
 Copyright (C) 2002-2003 Kevin Cazabon\n\
 kevin@cazabon.com\n\
-http://www.cazabon.com\n\
+https://www.cazabon.com\n\
 "

 #define PY_SSIZE_T_CLEAN
-#include "Python.h" // Include before wchar.h so _GNU_SOURCE is set
+#include "Python.h"  // Include before wchar.h so _GNU_SOURCE is set
 #include "wchar.h"
 #include "datetime.h"

@@ -41,10 +42,11 @@
   1.0.0 pil Integrating littleCMS2
   0.1.0 pil integration & refactoring
   0.0.2 alpha:  Minor updates, added interfaces to littleCMS features, Jan 6, 2003
-  - fixed some memory holes in how transforms/profiles were created and passed back to Python
-  due to improper destructor setup for PyCObjects
+  - fixed some memory holes in how transforms/profiles were created and passed back to
+  Python due to improper destructor setup for PyCObjects
   - added buildProofTransformFromOpenProfiles() function
-  - eliminated some code redundancy, centralizing several common tasks with internal functions
+  - eliminated some code redundancy, centralizing several common tasks with internal
+  functions

   0.0.1 alpha:  First public release Dec 26, 2002

@@ -74,18 +76,16 @@
 /* a profile represents the ICC characteristics for a specific device */

 typedef struct {
-    PyObject_HEAD
-    cmsHPROFILE profile;
+    PyObject_HEAD cmsHPROFILE profile;
 } CmsProfileObject;

 static PyTypeObject CmsProfile_Type;

 #define CmsProfile_Check(op) (Py_TYPE(op) == &CmsProfile_Type)

-static PyObject*
-cms_profile_new(cmsHPROFILE profile)
-{
-    CmsProfileObject* self;
+static PyObject *
+cms_profile_new(cmsHPROFILE profile) {
+    CmsProfileObject *self;

     self = PyObject_New(CmsProfileObject, &CmsProfile_Type);
     if (!self) {
@@ -94,15 +94,14 @@

     self->profile = profile;

-    return (PyObject*) self;
-}
-
-static PyObject*
-cms_profile_open(PyObject* self, PyObject* args)
-{
+    return (PyObject *)self;
+}
+
+static PyObject *
+cms_profile_open(PyObject *self, PyObject *args) {
     cmsHPROFILE hProfile;

-    char* sProfile;
+    char *sProfile;
     if (!PyArg_ParseTuple(args, "s:profile_open", &sProfile)) {
         return NULL;
     }
@@ -116,12 +115,11 @@
     return cms_profile_new(hProfile);
 }

-static PyObject*
-cms_profile_fromstring(PyObject* self, PyObject* args)
-{
+static PyObject *
+cms_profile_fromstring(PyObject *self, PyObject *args) {
     cmsHPROFILE hProfile;

-    char* pProfile;
+    char *pProfile;
     Py_ssize_t nProfile;
     if (!PyArg_ParseTuple(args, "y#:profile_frombytes", &pProfile, &nProfile)) {
         return NULL;
@@ -136,28 +134,27 @@
     return cms_profile_new(hProfile);
 }

-static PyObject*
-cms_profile_tobytes(PyObject* self, PyObject* args)
-{
-    char *pProfile =NULL;
+static PyObject *
+cms_profile_tobytes(PyObject *self, PyObject *args) {
+    char *pProfile = NULL;
     cmsUInt32Number nProfile;
-    PyObject* CmsProfile;
+    PyObject *CmsProfile;

     cmsHPROFILE *profile;

-    PyObject* ret;
-    if (!PyArg_ParseTuple(args, "O", &CmsProfile)){
-        return NULL;
-    }
-
-    profile = ((CmsProfileObject*)CmsProfile)->profile;
+    PyObject *ret;
+    if (!PyArg_ParseTuple(args, "O", &CmsProfile)) {
+        return NULL;
+    }
+
+    profile = ((CmsProfileObject *)CmsProfile)->profile;

     if (!cmsSaveProfileToMem(profile, pProfile, &nProfile)) {
         PyErr_SetString(PyExc_OSError, "Could not determine profile size");
         return NULL;
     }

-    pProfile = (char*)malloc(nProfile);
+    pProfile = (char *)malloc(nProfile);
     if (!pProfile) {
         PyErr_SetString(PyExc_OSError, "Out of Memory");
         return NULL;
@@ -176,17 +173,15 @@
 }

 static void
-cms_profile_dealloc(CmsProfileObject* self)
-{
-    (void) cmsCloseProfile(self->profile);
+cms_profile_dealloc(CmsProfileObject *self) {
+    (void)cmsCloseProfile(self->profile);
     PyObject_Del(self);
 }

 /* a transform represents the mapping between two profiles */

 typedef struct {
-    PyObject_HEAD
-    char mode_in[8];
+    PyObject_HEAD char mode_in[8];
     char mode_out[8];
     cmsHTRANSFORM transform;
 } CmsTransformObject;
@@ -195,10 +190,9 @@

 #define CmsTransform_Check(op) (Py_TYPE(op) == &CmsTransform_Type)

-static PyObject*
-cms_transform_new(cmsHTRANSFORM transform, char* mode_in, char* mode_out)
-{
-    CmsTransformObject* self;
+static PyObject *
+cms_transform_new(cmsHTRANSFORM transform, char *mode_in, char *mode_out) {
+    CmsTransformObject *self;

     self = PyObject_New(CmsTransformObject, &CmsTransform_Type);
     if (!self) {
@@ -210,12 +204,11 @@
     strcpy(self->mode_in, mode_in);
     strcpy(self->mode_out, mode_out);

-    return (PyObject*) self;
+    return (PyObject *)self;
 }

 static void
-cms_transform_dealloc(CmsTransformObject* self)
-{
+cms_transform_dealloc(CmsTransformObject *self) {
     cmsDeleteTransform(self->transform);
     PyObject_Del(self);
 }
@@ -224,41 +217,30 @@
 /* internal functions */

 static cmsUInt32Number
-findLCMStype(char* PILmode)
-{
+findLCMStype(char *PILmode) {
     if (strcmp(PILmode, "RGB") == 0) {
         return TYPE_RGBA_8;
-    }
-    else if (strcmp(PILmode, "RGBA") == 0) {
+    } else if (strcmp(PILmode, "RGBA") == 0) {
         return TYPE_RGBA_8;
-    }
-    else if (strcmp(PILmode, "RGBX") == 0) {
+    } else if (strcmp(PILmode, "RGBX") == 0) {
         return TYPE_RGBA_8;
-    }
-    else if (strcmp(PILmode, "RGBA;16B") == 0) {
+    } else if (strcmp(PILmode, "RGBA;16B") == 0) {
         return TYPE_RGBA_16;
-    }
-    else if (strcmp(PILmode, "CMYK") == 0) {
+    } else if (strcmp(PILmode, "CMYK") == 0) {
         return TYPE_CMYK_8;
-    }
-    else if (strcmp(PILmode, "L") == 0) {
+    } else if (strcmp(PILmode, "L") == 0) {
         return TYPE_GRAY_8;
-    }
-    else if (strcmp(PILmode, "L;16") == 0) {
+    } else if (strcmp(PILmode, "L;16") == 0) {
         return TYPE_GRAY_16;
-    }
-    else if (strcmp(PILmode, "L;16B") == 0) {
+    } else if (strcmp(PILmode, "L;16B") == 0) {
         return TYPE_GRAY_16_SE;
-    }
-    else if (strcmp(PILmode, "YCCA") == 0) {
+    } else if (strcmp(PILmode, "YCCA") == 0) {
         return TYPE_YCbCr_8;
-    }
-    else if (strcmp(PILmode, "YCC") == 0) {
+    } else if (strcmp(PILmode, "YCC") == 0) {
         return TYPE_YCbCr_8;
-    }
-    else if (strcmp(PILmode, "LAB") == 0) {
+    } else if (strcmp(PILmode, "LAB") == 0) {
         // LabX equivalent like ALab, but not reversed -- no #define in lcms2
-        return (COLORSPACE_SH(PT_LabV2)|CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1));
+        return (COLORSPACE_SH(PT_LabV2) | CHANNELS_SH(3) | BYTES_SH(1) | EXTRA_SH(1));
     }

     else {
@@ -270,8 +252,7 @@
 #define Cms_Min(a, b) ((a) < (b) ? (a) : (b))

 static int
-pyCMSgetAuxChannelChannel (cmsUInt32Number format, int auxChannelNdx)
-{
+pyCMSgetAuxChannelChannel(cmsUInt32Number format, int auxChannelNdx) {
     int numColors = T_CHANNELS(format);
     int numExtras = T_EXTRA(format);

@@ -282,28 +263,24 @@
         } else {
             return numExtras - 2 - auxChannelNdx;
         }
-    }
-    else if (T_SWAPFIRST(format)) {
+    } else if (T_SWAPFIRST(format)) {
         // in order, after color channels, but last extra is shifted to first
         if (auxChannelNdx == numExtras - 1) {
             return 0;
         } else {
             return numColors + 1 + auxChannelNdx;
         }
-    }
-    else if (T_DOSWAP(format)) {
+    } else if (T_DOSWAP(format)) {
         // reverse order, before anything
         return numExtras - 1 - auxChannelNdx;
-    }
-    else {
+    } else {
         // in order, after color channels
         return numColors + auxChannelNdx;
     }
 }

 static void
-pyCMScopyAux (cmsHTRANSFORM hTransform, Imaging imDst, const Imaging imSrc)
-{
+pyCMScopyAux(cmsHTRANSFORM hTransform, Imaging imDst, const Imaging imSrc) {
     cmsUInt32Number dstLCMSFormat;
     cmsUInt32Number srcLCMSFormat;
     int numSrcExtras;
@@ -331,11 +308,11 @@

     // copy only if channel format is identical, except OPTIMIZED is ignored as it
     // does not affect the aux channel
-    if (T_FLOAT(dstLCMSFormat) != T_FLOAT(srcLCMSFormat)
-        || T_FLAVOR(dstLCMSFormat) != T_FLAVOR(srcLCMSFormat)
-        || T_ENDIAN16(dstLCMSFormat) != T_ENDIAN16(srcLCMSFormat)
-        || T_BYTES(dstLCMSFormat) != T_BYTES(srcLCMSFormat)) {
-      return;
+    if (T_FLOAT(dstLCMSFormat) != T_FLOAT(srcLCMSFormat) ||
+        T_FLAVOR(dstLCMSFormat) != T_FLAVOR(srcLCMSFormat) ||
+        T_ENDIAN16(dstLCMSFormat) != T_ENDIAN16(srcLCMSFormat) ||
+        T_BYTES(dstLCMSFormat) != T_BYTES(srcLCMSFormat)) {
+        return;
     }

     numSrcExtras = T_EXTRA(srcLCMSFormat);
@@ -354,19 +331,21 @@

         for (y = 0; y < ySize; y++) {
             int x;
-            char* pDstExtras = imDst->image[y] + dstChannel * channelSize;
-            const char* pSrcExtras = imSrc->image[y] + srcChannel * channelSize;
+            char *pDstExtras = imDst->image[y] + dstChannel * channelSize;
+            const char *pSrcExtras = imSrc->image[y] + srcChannel * channelSize;

             for (x = 0; x < xSize; x++) {
-                memcpy(pDstExtras + x * dstChunkSize, pSrcExtras + x * srcChunkSize, channelSize);
+                memcpy(
+                    pDstExtras + x * dstChunkSize,
+                    pSrcExtras + x * srcChunkSize,
+                    channelSize);
             }
         }
     }
 }

 static int
-pyCMSdoTransform(Imaging im, Imaging imOut, cmsHTRANSFORM hTransform)
-{
+pyCMSdoTransform(Imaging im, Imaging imOut, cmsHTRANSFORM hTransform) {
     int i;

     if (im->xsize > imOut->xsize || im->ysize > imOut->ysize) {
@@ -375,8 +354,8 @@

     Py_BEGIN_ALLOW_THREADS

-    // transform color channels only
-    for (i = 0; i < im->ysize; i++) {
+        // transform color channels only
+        for (i = 0; i < im->ysize; i++) {
         cmsDoTransform(hTransform, im->image[i], imOut->image[i], im->xsize);
     }

@@ -391,26 +370,33 @@

     Py_END_ALLOW_THREADS

-    return 0;
+        return 0;
 }

 static cmsHTRANSFORM
-_buildTransform(cmsHPROFILE hInputProfile, cmsHPROFILE hOutputProfile, char *sInMode, char *sOutMode, int iRenderingIntent, cmsUInt32Number cmsFLAGS)
-{
+_buildTransform(
+    cmsHPROFILE hInputProfile,
+    cmsHPROFILE hOutputProfile,
+    char *sInMode,
+    char *sOutMode,
+    int iRenderingIntent,
+    cmsUInt32Number cmsFLAGS) {
     cmsHTRANSFORM hTransform;

     Py_BEGIN_ALLOW_THREADS

-    /* create the transform */
-    hTransform = cmsCreateTransform(hInputProfile,
-                                    findLCMStype(sInMode),
-                                    hOutputProfile,
-                                    findLCMStype(sOutMode),
-                                    iRenderingIntent, cmsFLAGS);
+        /* create the transform */
+        hTransform = cmsCreateTransform(
+            hInputProfile,
+            findLCMStype(sInMode),
+            hOutputProfile,
+            findLCMStype(sOutMode),
+            iRenderingIntent,
+            cmsFLAGS);

     Py_END_ALLOW_THREADS

-    if (!hTransform) {
+        if (!hTransform) {
         PyErr_SetString(PyExc_ValueError, "cannot build transform");
     }

@@ -418,25 +404,33 @@
 }

 static cmsHTRANSFORM
-_buildProofTransform(cmsHPROFILE hInputProfile, cmsHPROFILE hOutputProfile, cmsHPROFILE hProofProfile, char *sInMode, char *sOutMode, int iRenderingIntent, int iProofIntent, cmsUInt32Number cmsFLAGS)
-{
+_buildProofTransform(
+    cmsHPROFILE hInputProfile,
+    cmsHPROFILE hOutputProfile,
+    cmsHPROFILE hProofProfile,
+    char *sInMode,
+    char *sOutMode,
+    int iRenderingIntent,
+    int iProofIntent,
+    cmsUInt32Number cmsFLAGS) {
     cmsHTRANSFORM hTransform;

     Py_BEGIN_ALLOW_THREADS

-    /* create the transform */
-    hTransform =  cmsCreateProofingTransform(hInputProfile,
-                                             findLCMStype(sInMode),
-                                             hOutputProfile,
-                                             findLCMStype(sOutMode),
-                                             hProofProfile,
-                                             iRenderingIntent,
-                                             iProofIntent,
-                                             cmsFLAGS);
+        /* create the transform */
+        hTransform = cmsCreateProofingTransform(
+            hInputProfile,
+            findLCMStype(sInMode),
+            hOutputProfile,
+            findLCMStype(sOutMode),
+            hProofProfile,
+            iRenderingIntent,
+            iProofIntent,
+            cmsFLAGS);

     Py_END_ALLOW_THREADS

-    if (!hTransform) {
+        if (!hTransform) {
         PyErr_SetString(PyExc_ValueError, "cannot build proof transform");
     }

@@ -457,11 +451,27 @@

     cmsHTRANSFORM transform = NULL;

-    if (!PyArg_ParseTuple(args, "O!O!ss|ii:buildTransform", &CmsProfile_Type, &pInputProfile, &CmsProfile_Type, &pOutputProfile, &sInMode, &sOutMode, &iRenderingIntent, &cmsFLAGS)) {
-        return NULL;
-    }
-
-    transform = _buildTransform(pInputProfile->profile, pOutputProfile->profile, sInMode, sOutMode, iRenderingIntent, cmsFLAGS);
+    if (!PyArg_ParseTuple(
+            args,
+            "O!O!ss|ii:buildTransform",
+            &CmsProfile_Type,
+            &pInputProfile,
+            &CmsProfile_Type,
+            &pOutputProfile,
+            &sInMode,
+            &sOutMode,
+            &iRenderingIntent,
+            &cmsFLAGS)) {
+        return NULL;
+    }
+
+    transform = _buildTransform(
+        pInputProfile->profile,
+        pOutputProfile->profile,
+        sInMode,
+        sOutMode,
+        iRenderingIntent,
+        cmsFLAGS);

     if (!transform) {
         return NULL;
@@ -471,8 +481,7 @@
 }

 static PyObject *
-buildProofTransform(PyObject *self, PyObject *args)
-{
+buildProofTransform(PyObject *self, PyObject *args) {
     CmsProfileObject *pInputProfile;
     CmsProfileObject *pOutputProfile;
     CmsProfileObject *pProofProfile;
@@ -484,23 +493,42 @@

     cmsHTRANSFORM transform = NULL;

-    if (!PyArg_ParseTuple(args, "O!O!O!ss|iii:buildProofTransform", &CmsProfile_Type, &pInputProfile, &CmsProfile_Type, &pOutputProfile, &CmsProfile_Type, &pProofProfile, &sInMode, &sOutMode, &iRenderingIntent, &iProofIntent, &cmsFLAGS)) {
-        return NULL;
-    }
-
-    transform = _buildProofTransform(pInputProfile->profile, pOutputProfile->profile, pProofProfile->profile, sInMode, sOutMode, iRenderingIntent, iProofIntent, cmsFLAGS);
+    if (!PyArg_ParseTuple(
+            args,
+            "O!O!O!ss|iii:buildProofTransform",
+            &CmsProfile_Type,
+            &pInputProfile,
+            &CmsProfile_Type,
+            &pOutputProfile,
+            &CmsProfile_Type,
+            &pProofProfile,
+            &sInMode,
+            &sOutMode,
+            &iRenderingIntent,
+            &iProofIntent,
+            &cmsFLAGS)) {
+        return NULL;
+    }
+
+    transform = _buildProofTransform(
+        pInputProfile->profile,
+        pOutputProfile->profile,
+        pProofProfile->profile,
+        sInMode,
+        sOutMode,
+        iRenderingIntent,
+        iProofIntent,
+        cmsFLAGS);

     if (!transform) {
         return NULL;
     }

     return cms_transform_new(transform, sInMode, sOutMode);
-
-}
-
-static PyObject *
-cms_transform_apply(CmsTransformObject *self, PyObject *args)
-{
+}
+
+static PyObject *
+cms_transform_apply(CmsTransformObject *self, PyObject *args) {
     Py_ssize_t idIn;
     Py_ssize_t idOut;
     Imaging im;
@@ -512,8 +540,8 @@
         return NULL;
     }

-    im = (Imaging) idIn;
-    imOut = (Imaging) idOut;
+    im = (Imaging)idIn;
+    imOut = (Imaging)idOut;

     result = pyCMSdoTransform(im, imOut, self->transform);

@@ -524,8 +552,7 @@
 /* Python-Callable On-The-Fly profile creation functions */

 static PyObject *
-createProfile(PyObject *self, PyObject *args)
-{
+createProfile(PyObject *self, PyObject *args) {
     char *sColorSpace;
     cmsHPROFILE hProfile;
     cmsFloat64Number dColorTemp = 0.0;
@@ -540,21 +567,21 @@
         if (dColorTemp > 0.0) {
             result = cmsWhitePointFromTemp(&whitePoint, dColorTemp);
             if (!result) {
-                PyErr_SetString(PyExc_ValueError, "ERROR: Could not calculate white point from color temperature provided, must be float in degrees Kelvin");
+                PyErr_SetString(
+                    PyExc_ValueError,
+                    "ERROR: Could not calculate white point from color temperature "
+                    "provided, must be float in degrees Kelvin");
                 return NULL;
             }
             hProfile = cmsCreateLab2Profile(&whitePoint);
         } else {
             hProfile = cmsCreateLab2Profile(NULL);
         }
-    }
-    else if (strcmp(sColorSpace, "XYZ") == 0) {
+    } else if (strcmp(sColorSpace, "XYZ") == 0) {
         hProfile = cmsCreateXYZProfile();
-    }
-    else if (strcmp(sColorSpace, "sRGB") == 0) {
+    } else if (strcmp(sColorSpace, "sRGB") == 0) {
         hProfile = cmsCreate_sRGBProfile();
-    }
-    else {
+    } else {
         hProfile = NULL;
     }

@@ -570,8 +597,7 @@
 /* profile methods */

 static PyObject *
-cms_profile_is_intent_supported(CmsProfileObject *self, PyObject *args)
-{
+cms_profile_is_intent_supported(CmsProfileObject *self, PyObject *args) {
     cmsBool result;

     int intent;
@@ -582,7 +608,8 @@

     result = cmsIsIntentSupported(self->profile, intent, direction);

-    /* printf("cmsIsIntentSupported(%p, %d, %d) => %d\n", self->profile, intent, direction, result); */
+    /* printf("cmsIsIntentSupported(%p, %d, %d) => %d\n", self->profile, intent,
+     * direction, result); */

     return PyLong_FromLong(result != 0);
 }
@@ -596,30 +623,30 @@
 #endif

 static PyObject *
-cms_get_display_profile_win32(PyObject* self, PyObject* args)
-{
+cms_get_display_profile_win32(PyObject *self, PyObject *args) {
     char filename[MAX_PATH];
     cmsUInt32Number filename_size;
     BOOL ok;

     HANDLE handle = 0;
     int is_dc = 0;
-    if (!PyArg_ParseTuple(args, "|" F_HANDLE "i:get_display_profile", &handle, &is_dc)) {
+    if (!PyArg_ParseTuple(
+            args, "|" F_HANDLE "i:get_display_profile", &handle, &is_dc)) {
         return NULL;
     }

     filename_size = sizeof(filename);

     if (is_dc) {
-        ok = GetICMProfile((HDC) handle, &filename_size, filename);
+        ok = GetICMProfile((HDC)handle, &filename_size, filename);
     } else {
-        HDC dc = GetDC((HWND) handle);
+        HDC dc = GetDC((HWND)handle);
         ok = GetICMProfile(dc, &filename_size, filename);
-        ReleaseDC((HWND) handle, dc);
+        ReleaseDC((HWND)handle, dc);
     }

     if (ok) {
-        return PyUnicode_FromStringAndSize(filename, filename_size-1);
+        return PyUnicode_FromStringAndSize(filename, filename_size - 1);
     }

     Py_INCREF(Py_None);
@@ -630,9 +657,8 @@
 /* -------------------------------------------------------------------- */
 /* Helper functions.  */

-static PyObject*
-_profile_read_mlu(CmsProfileObject* self, cmsTagSignature info)
-{
+static PyObject *
+_profile_read_mlu(CmsProfileObject *self, cmsTagSignature info) {
     PyObject *uni;
     char *lc = "en";
     char *cc = cmsNoCountry;
@@ -673,26 +699,22 @@
     return uni;
 }

-
-static PyObject*
-_profile_read_int_as_string(cmsUInt32Number nr)
-{
-    PyObject* ret;
+static PyObject *
+_profile_read_int_as_string(cmsUInt32Number nr) {
+    PyObject *ret;
     char buf[5];
-    buf[0] = (char) ((nr >> 24) & 0xff);
-    buf[1] = (char) ((nr >> 16) & 0xff);
-    buf[2] = (char) ((nr >> 8) & 0xff);
-    buf[3] = (char) (nr & 0xff);
+    buf[0] = (char)((nr >> 24) & 0xff);
+    buf[1] = (char)((nr >> 16) & 0xff);
+    buf[2] = (char)((nr >> 8) & 0xff);
+    buf[3] = (char)(nr & 0xff);
     buf[4] = 0;

     ret = PyUnicode_DecodeASCII(buf, 4, NULL);
     return ret;
 }

-
-static PyObject*
-_profile_read_signature(CmsProfileObject* self, cmsTagSignature info)
-{
+static PyObject *
+_profile_read_signature(CmsProfileObject *self, cmsTagSignature info) {
     unsigned int *sig;

     if (!cmsIsTag(self->profile, info)) {
@@ -700,7 +722,7 @@
         return Py_None;
     }

-    sig = (unsigned int *) cmsReadTag(self->profile, info);
+    sig = (unsigned int *)cmsReadTag(self->profile, info);
     if (!sig) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -709,42 +731,53 @@
     return _profile_read_int_as_string(*sig);
 }

-static PyObject*
-_xyz_py(cmsCIEXYZ* XYZ)
-{
+static PyObject *
+_xyz_py(cmsCIEXYZ *XYZ) {
     cmsCIExyY xyY;
     cmsXYZ2xyY(&xyY, XYZ);
-    return Py_BuildValue("((d,d,d),(d,d,d))", XYZ->X, XYZ->Y, XYZ->Z, xyY.x, xyY.y, xyY.Y);
-}
-
-static PyObject*
-_xyz3_py(cmsCIEXYZ* XYZ)
-{
+    return Py_BuildValue(
+        "((d,d,d),(d,d,d))", XYZ->X, XYZ->Y, XYZ->Z, xyY.x, xyY.y, xyY.Y);
+}
+
+static PyObject *
+_xyz3_py(cmsCIEXYZ *XYZ) {
     cmsCIExyY xyY[3];
     cmsXYZ2xyY(&xyY[0], &XYZ[0]);
     cmsXYZ2xyY(&xyY[1], &XYZ[1]);
     cmsXYZ2xyY(&xyY[2], &XYZ[2]);

-    return Py_BuildValue("(((d,d,d),(d,d,d),(d,d,d)),((d,d,d),(d,d,d),(d,d,d)))",
-        XYZ[0].X, XYZ[0].Y, XYZ[0].Z,
-        XYZ[1].X, XYZ[1].Y, XYZ[1].Z,
-        XYZ[2].X, XYZ[2].Y, XYZ[2].Z,
-        xyY[0].x, xyY[0].y, xyY[0].Y,
-        xyY[1].x, xyY[1].y, xyY[1].Y,
-        xyY[2].x, xyY[2].y, xyY[2].Y);
-}
-
-static PyObject*
-_profile_read_ciexyz(CmsProfileObject* self, cmsTagSignature info, int multi)
-{
-    cmsCIEXYZ* XYZ;
+    return Py_BuildValue(
+        "(((d,d,d),(d,d,d),(d,d,d)),((d,d,d),(d,d,d),(d,d,d)))",
+        XYZ[0].X,
+        XYZ[0].Y,
+        XYZ[0].Z,
+        XYZ[1].X,
+        XYZ[1].Y,
+        XYZ[1].Z,
+        XYZ[2].X,
+        XYZ[2].Y,
+        XYZ[2].Z,
+        xyY[0].x,
+        xyY[0].y,
+        xyY[0].Y,
+        xyY[1].x,
+        xyY[1].y,
+        xyY[1].Y,
+        xyY[2].x,
+        xyY[2].y,
+        xyY[2].Y);
+}
+
+static PyObject *
+_profile_read_ciexyz(CmsProfileObject *self, cmsTagSignature info, int multi) {
+    cmsCIEXYZ *XYZ;

     if (!cmsIsTag(self->profile, info)) {
         Py_INCREF(Py_None);
         return Py_None;
     }

-    XYZ = (cmsCIEXYZ*) cmsReadTag(self->profile, info);
+    XYZ = (cmsCIEXYZ *)cmsReadTag(self->profile, info);
     if (!XYZ) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -756,17 +789,16 @@
     }
 }

-static PyObject*
-_profile_read_ciexyy_triple(CmsProfileObject* self, cmsTagSignature info)
-{
-    cmsCIExyYTRIPLE* triple;
+static PyObject *
+_profile_read_ciexyy_triple(CmsProfileObject *self, cmsTagSignature info) {
+    cmsCIExyYTRIPLE *triple;

     if (!cmsIsTag(self->profile, info)) {
         Py_INCREF(Py_None);
         return Py_None;
     }

-    triple = (cmsCIExyYTRIPLE*) cmsReadTag(self->profile, info);
+    triple = (cmsCIExyYTRIPLE *)cmsReadTag(self->profile, info);
     if (!triple) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -774,26 +806,32 @@

     /* Note: lcms does all the heavy lifting and error checking (nr of
        channels == 3).  */
-    return Py_BuildValue("((d,d,d),(d,d,d),(d,d,d)),",
-        triple->Red.x, triple->Red.y, triple->Red.Y,
-        triple->Green.x, triple->Green.y, triple->Green.Y,
-        triple->Blue.x, triple->Blue.y, triple->Blue.Y);
-}
-
-static PyObject*
-_profile_read_named_color_list(CmsProfileObject* self, cmsTagSignature info)
-{
-    cmsNAMEDCOLORLIST* ncl;
+    return Py_BuildValue(
+        "((d,d,d),(d,d,d),(d,d,d)),",
+        triple->Red.x,
+        triple->Red.y,
+        triple->Red.Y,
+        triple->Green.x,
+        triple->Green.y,
+        triple->Green.Y,
+        triple->Blue.x,
+        triple->Blue.y,
+        triple->Blue.Y);
+}
+
+static PyObject *
+_profile_read_named_color_list(CmsProfileObject *self, cmsTagSignature info) {
+    cmsNAMEDCOLORLIST *ncl;
     int i, n;
     char name[cmsMAX_PATH];
-    PyObject* result;
+    PyObject *result;

     if (!cmsIsTag(self->profile, info)) {
         Py_INCREF(Py_None);
         return Py_None;
     }

-    ncl = (cmsNAMEDCOLORLIST*) cmsReadTag(self->profile, info);
+    ncl = (cmsNAMEDCOLORLIST *)cmsReadTag(self->profile, info);
     if (ncl == NULL) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -807,7 +845,7 @@
     }

     for (i = 0; i < n; i++) {
-        PyObject* str;
+        PyObject *str;
         cmsNamedColorInfo(ncl, i, name, NULL, NULL, NULL, NULL);
         str = PyUnicode_FromString(name);
         if (str == NULL) {
@@ -821,9 +859,9 @@
     return result;
 }

-static cmsBool _calculate_rgb_primaries(CmsProfileObject* self, cmsCIEXYZTRIPLE* result)
-{
-    double input[3][3] = { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
+static cmsBool
+_calculate_rgb_primaries(CmsProfileObject *self, cmsCIEXYZTRIPLE *result) {
+    double input[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
     cmsHPROFILE hXYZ;
     cmsHTRANSFORM hTransform;

@@ -836,36 +874,41 @@
     }

     // transform from our profile to XYZ using doubles for highest precision
-    hTransform = cmsCreateTransform(self->profile, TYPE_RGB_DBL,
-                                    hXYZ, TYPE_XYZ_DBL,
-                                    INTENT_RELATIVE_COLORIMETRIC,
-                                    cmsFLAGS_NOCACHE | cmsFLAGS_NOOPTIMIZE);
+    hTransform = cmsCreateTransform(
+        self->profile,
+        TYPE_RGB_DBL,
+        hXYZ,
+        TYPE_XYZ_DBL,
+        INTENT_RELATIVE_COLORIMETRIC,
+        cmsFLAGS_NOCACHE | cmsFLAGS_NOOPTIMIZE);
     cmsCloseProfile(hXYZ);
     if (hTransform == NULL) {
         return 0;
     }

-    cmsDoTransform(hTransform, (void*) input, result, 3);
+    cmsDoTransform(hTransform, (void *)input, result, 3);
     cmsDeleteTransform(hTransform);
     return 1;
 }

-static cmsBool _check_intent(int clut, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number UsedDirection)
-{
+static cmsBool
+_check_intent(
+    int clut,
+    cmsHPROFILE hProfile,
+    cmsUInt32Number Intent,
+    cmsUInt32Number UsedDirection) {
     if (clut) {
         return cmsIsCLUT(hProfile, Intent, UsedDirection);
-    }
-    else {
+    } else {
         return cmsIsIntentSupported(hProfile, Intent, UsedDirection);
     }
 }

 #define INTENTS 200

-static PyObject*
-_is_intent_supported(CmsProfileObject* self, int clut)
-{
-    PyObject* result;
+static PyObject *
+_is_intent_supported(CmsProfileObject *self, int clut) {
+    PyObject *result;
     int n;
     int i;
     cmsUInt32Number intent_ids[INTENTS];
@@ -877,26 +920,28 @@
         return Py_None;
     }

-
-    n = cmsGetSupportedIntents(INTENTS,
-                               intent_ids,
-                               intent_descs);
+    n = cmsGetSupportedIntents(INTENTS, intent_ids, intent_descs);
     for (i = 0; i < n; i++) {
-        int intent = (int) intent_ids[i];
-        PyObject* id;
-        PyObject* entry;
-
-        /* Only valid for ICC Intents (otherwise we read invalid memory in lcms cmsio1.c). */
-        if (!(intent == INTENT_PERCEPTUAL || intent == INTENT_RELATIVE_COLORIMETRIC
-            || intent == INTENT_SATURATION || intent == INTENT_ABSOLUTE_COLORIMETRIC)) {
+        int intent = (int)intent_ids[i];
+        PyObject *id;
+        PyObject *entry;
+
+        /* Only valid for ICC Intents (otherwise we read invalid memory in lcms
+         * cmsio1.c). */
+        if (!(intent == INTENT_PERCEPTUAL || intent == INTENT_RELATIVE_COLORIMETRIC ||
+              intent == INTENT_SATURATION || intent == INTENT_ABSOLUTE_COLORIMETRIC)) {
             continue;
         }

-        id = PyLong_FromLong((long) intent);
-        entry = Py_BuildValue("(OOO)",
-            _check_intent(clut, self->profile, intent, LCMS_USED_AS_INPUT) ? Py_True : Py_False,
-            _check_intent(clut, self->profile, intent, LCMS_USED_AS_OUTPUT) ? Py_True : Py_False,
-            _check_intent(clut, self->profile, intent, LCMS_USED_AS_PROOF) ? Py_True : Py_False);
+        id = PyLong_FromLong((long)intent);
+        entry = Py_BuildValue(
+            "(OOO)",
+            _check_intent(clut, self->profile, intent, LCMS_USED_AS_INPUT) ? Py_True
+                                                                           : Py_False,
+            _check_intent(clut, self->profile, intent, LCMS_USED_AS_OUTPUT) ? Py_True
+                                                                            : Py_False,
+            _check_intent(clut, self->profile, intent, LCMS_USED_AS_PROOF) ? Py_True
+                                                                           : Py_False);
         if (id == NULL || entry == NULL) {
             Py_XDECREF(id);
             Py_XDECREF(entry);
@@ -914,195 +959,171 @@

 static PyMethodDef pyCMSdll_methods[] = {

-    {"profile_open", cms_profile_open, 1},
-    {"profile_frombytes", cms_profile_fromstring, 1},
-    {"profile_fromstring", cms_profile_fromstring, 1},
-    {"profile_tobytes", cms_profile_tobytes, 1},
+    {"profile_open", cms_profile_open, METH_VARARGS},
+    {"profile_frombytes", cms_profile_fromstring, METH_VARARGS},
+    {"profile_fromstring", cms_profile_fromstring, METH_VARARGS},
+    {"profile_tobytes", cms_profile_tobytes, METH_VARARGS},

     /* profile and transform functions */
-    {"buildTransform", buildTransform, 1},
-    {"buildProofTransform", buildProofTransform, 1},
-    {"createProfile", createProfile, 1},
-
-    /* platform specific tools */
+    {"buildTransform", buildTransform, METH_VARARGS},
+    {"buildProofTransform", buildProofTransform, METH_VARARGS},
+    {"createProfile", createProfile, METH_VARARGS},
+
+/* platform specific tools */
 #ifdef _WIN32
-    {"get_display_profile_win32", cms_get_display_profile_win32, 1},
+    {"get_display_profile_win32", cms_get_display_profile_win32, METH_VARARGS},
 #endif

-    {NULL, NULL}
-};
+    {NULL, NULL}};

 static struct PyMethodDef cms_profile_methods[] = {
-    {"is_intent_supported", (PyCFunction) cms_profile_is_intent_supported, 1},
+    {"is_intent_supported", (PyCFunction)cms_profile_is_intent_supported, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };

-static PyObject*
-cms_profile_getattr_rendering_intent(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_rendering_intent(CmsProfileObject *self, void *closure) {
     return PyLong_FromLong(cmsGetHeaderRenderingIntent(self->profile));
 }

 /* New-style unicode interfaces.  */
-static PyObject*
-cms_profile_getattr_copyright(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_copyright(CmsProfileObject *self, void *closure) {
     return _profile_read_mlu(self, cmsSigCopyrightTag);
 }

-static PyObject*
-cms_profile_getattr_target(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_target(CmsProfileObject *self, void *closure) {
     return _profile_read_mlu(self, cmsSigCharTargetTag);
 }

-static PyObject*
-cms_profile_getattr_manufacturer(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_manufacturer(CmsProfileObject *self, void *closure) {
     return _profile_read_mlu(self, cmsSigDeviceMfgDescTag);
 }

-static PyObject*
-cms_profile_getattr_model(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_model(CmsProfileObject *self, void *closure) {
     return _profile_read_mlu(self, cmsSigDeviceModelDescTag);
 }

-static PyObject*
-cms_profile_getattr_profile_description(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_profile_description(CmsProfileObject *self, void *closure) {
     return _profile_read_mlu(self, cmsSigProfileDescriptionTag);
 }

-static PyObject*
-cms_profile_getattr_screening_description(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_screening_description(CmsProfileObject *self, void *closure) {
     return _profile_read_mlu(self, cmsSigScreeningDescTag);
 }

-static PyObject*
-cms_profile_getattr_viewing_condition(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_viewing_condition(CmsProfileObject *self, void *closure) {
     return _profile_read_mlu(self, cmsSigViewingCondDescTag);
 }

-static PyObject*
-cms_profile_getattr_creation_date(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_creation_date(CmsProfileObject *self, void *closure) {
     cmsBool result;
     struct tm ct;

     result = cmsGetHeaderCreationDateTime(self->profile, &ct);
-    if (! result) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-
-    return PyDateTime_FromDateAndTime(1900 + ct.tm_year, ct.tm_mon, ct.tm_mday,
-                                      ct.tm_hour, ct.tm_min, ct.tm_sec, 0);
-}
-
-static PyObject*
-cms_profile_getattr_version(CmsProfileObject* self, void* closure)
-{
+    if (!result) {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+
+    return PyDateTime_FromDateAndTime(
+        1900 + ct.tm_year, ct.tm_mon, ct.tm_mday, ct.tm_hour, ct.tm_min, ct.tm_sec, 0);
+}
+
+static PyObject *
+cms_profile_getattr_version(CmsProfileObject *self, void *closure) {
     cmsFloat64Number version = cmsGetProfileVersion(self->profile);
     return PyFloat_FromDouble(version);
 }

-static PyObject*
-cms_profile_getattr_icc_version(CmsProfileObject* self, void* closure)
-{
-    return PyLong_FromLong((long) cmsGetEncodedICCversion(self->profile));
-}
-
-static PyObject*
-cms_profile_getattr_attributes(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_icc_version(CmsProfileObject *self, void *closure) {
+    return PyLong_FromLong((long)cmsGetEncodedICCversion(self->profile));
+}
+
+static PyObject *
+cms_profile_getattr_attributes(CmsProfileObject *self, void *closure) {
     cmsUInt64Number attr;
     cmsGetHeaderAttributes(self->profile, &attr);
     /* This works just as well on Windows (LLP64), 32-bit Linux
        (ILP32) and 64-bit Linux (LP64) systems.  */
-    return PyLong_FromUnsignedLongLong((unsigned long long) attr);
-}
-
-static PyObject*
-cms_profile_getattr_header_flags(CmsProfileObject* self, void* closure)
-{
+    return PyLong_FromUnsignedLongLong((unsigned long long)attr);
+}
+
+static PyObject *
+cms_profile_getattr_header_flags(CmsProfileObject *self, void *closure) {
     cmsUInt32Number flags = cmsGetHeaderFlags(self->profile);
     return PyLong_FromLong(flags);
 }

-static PyObject*
-cms_profile_getattr_header_manufacturer(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_header_manufacturer(CmsProfileObject *self, void *closure) {
     return _profile_read_int_as_string(cmsGetHeaderManufacturer(self->profile));
 }

-static PyObject*
-cms_profile_getattr_header_model(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_header_model(CmsProfileObject *self, void *closure) {
     return _profile_read_int_as_string(cmsGetHeaderModel(self->profile));
 }

-static PyObject*
-cms_profile_getattr_device_class(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_device_class(CmsProfileObject *self, void *closure) {
     return _profile_read_int_as_string(cmsGetDeviceClass(self->profile));
 }

-static PyObject*
-cms_profile_getattr_connection_space(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_connection_space(CmsProfileObject *self, void *closure) {
     return _profile_read_int_as_string(cmsGetPCS(self->profile));
 }

-static PyObject*
-cms_profile_getattr_xcolor_space(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_xcolor_space(CmsProfileObject *self, void *closure) {
     return _profile_read_int_as_string(cmsGetColorSpace(self->profile));
 }

-static PyObject*
-cms_profile_getattr_profile_id(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_profile_id(CmsProfileObject *self, void *closure) {
     cmsUInt8Number id[16];
     cmsGetHeaderProfileID(self->profile, id);
-    return PyBytes_FromStringAndSize((char *) id, 16);
-}
-
-static PyObject*
-cms_profile_getattr_is_matrix_shaper(CmsProfileObject* self, void* closure)
-{
-    return PyBool_FromLong((long) cmsIsMatrixShaper(self->profile));
-}
-
-static PyObject*
-cms_profile_getattr_technology(CmsProfileObject* self, void* closure)
-{
+    return PyBytes_FromStringAndSize((char *)id, 16);
+}
+
+static PyObject *
+cms_profile_getattr_is_matrix_shaper(CmsProfileObject *self, void *closure) {
+    return PyBool_FromLong((long)cmsIsMatrixShaper(self->profile));
+}
+
+static PyObject *
+cms_profile_getattr_technology(CmsProfileObject *self, void *closure) {
     return _profile_read_signature(self, cmsSigTechnologyTag);
 }

-static PyObject*
-cms_profile_getattr_colorimetric_intent(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_colorimetric_intent(CmsProfileObject *self, void *closure) {
     return _profile_read_signature(self, cmsSigColorimetricIntentImageStateTag);
 }

-static PyObject*
-cms_profile_getattr_perceptual_rendering_intent_gamut(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_perceptual_rendering_intent_gamut(
+    CmsProfileObject *self, void *closure) {
     return _profile_read_signature(self, cmsSigPerceptualRenderingIntentGamutTag);
 }

-static PyObject*
-cms_profile_getattr_saturation_rendering_intent_gamut(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_saturation_rendering_intent_gamut(
+    CmsProfileObject *self, void *closure) {
     return _profile_read_signature(self, cmsSigSaturationRenderingIntentGamutTag);
 }

-static PyObject*
-cms_profile_getattr_red_colorant(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_red_colorant(CmsProfileObject *self, void *closure) {
     if (!cmsIsMatrixShaper(self->profile)) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -1110,10 +1131,8 @@
     return _profile_read_ciexyz(self, cmsSigRedColorantTag, 0);
 }

-
-static PyObject*
-cms_profile_getattr_green_colorant(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_green_colorant(CmsProfileObject *self, void *closure) {
     if (!cmsIsMatrixShaper(self->profile)) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -1121,10 +1140,8 @@
     return _profile_read_ciexyz(self, cmsSigGreenColorantTag, 0);
 }

-
-static PyObject*
-cms_profile_getattr_blue_colorant(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_blue_colorant(CmsProfileObject *self, void *closure) {
     if (!cmsIsMatrixShaper(self->profile)) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -1132,10 +1149,10 @@
     return _profile_read_ciexyz(self, cmsSigBlueColorantTag, 0);
 }

-static PyObject*
-cms_profile_getattr_media_white_point_temperature(CmsProfileObject *self, void* closure)
-{
-    cmsCIEXYZ* XYZ;
+static PyObject *
+cms_profile_getattr_media_white_point_temperature(
+    CmsProfileObject *self, void *closure) {
+    cmsCIEXYZ *XYZ;
     cmsCIExyY xyY;
     cmsFloat64Number tempK;
     cmsTagSignature info = cmsSigMediaWhitePointTag;
@@ -1146,7 +1163,7 @@
         return Py_None;
     }

-    XYZ = (cmsCIEXYZ*) cmsReadTag(self->profile, info);
+    XYZ = (cmsCIEXYZ *)cmsReadTag(self->profile, info);
     if (XYZ == NULL || XYZ->X == 0) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -1161,47 +1178,40 @@
     return PyFloat_FromDouble(tempK);
 }

-static PyObject*
-cms_profile_getattr_media_white_point(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_media_white_point(CmsProfileObject *self, void *closure) {
     return _profile_read_ciexyz(self, cmsSigMediaWhitePointTag, 0);
 }

-
-static PyObject*
-cms_profile_getattr_media_black_point(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_media_black_point(CmsProfileObject *self, void *closure) {
     return _profile_read_ciexyz(self, cmsSigMediaBlackPointTag, 0);
 }

-static PyObject*
-cms_profile_getattr_luminance(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_luminance(CmsProfileObject *self, void *closure) {
     return _profile_read_ciexyz(self, cmsSigLuminanceTag, 0);
 }

-static PyObject*
-cms_profile_getattr_chromatic_adaptation(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_chromatic_adaptation(CmsProfileObject *self, void *closure) {
     return _profile_read_ciexyz(self, cmsSigChromaticAdaptationTag, 1);
 }

-static PyObject*
-cms_profile_getattr_chromaticity(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_chromaticity(CmsProfileObject *self, void *closure) {
     return _profile_read_ciexyy_triple(self, cmsSigChromaticityTag);
 }

-static PyObject*
-cms_profile_getattr_red_primary(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_red_primary(CmsProfileObject *self, void *closure) {
     cmsBool result = 0;
     cmsCIEXYZTRIPLE primaries;

     if (cmsIsMatrixShaper(self->profile)) {
         result = _calculate_rgb_primaries(self, &primaries);
     }
-    if (! result) {
+    if (!result) {
         Py_INCREF(Py_None);
         return Py_None;
     }
@@ -1209,16 +1219,15 @@
     return _xyz_py(&primaries.Red);
 }

-static PyObject*
-cms_profile_getattr_green_primary(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_green_primary(CmsProfileObject *self, void *closure) {
     cmsBool result = 0;
     cmsCIEXYZTRIPLE primaries;

     if (cmsIsMatrixShaper(self->profile)) {
         result = _calculate_rgb_primaries(self, &primaries);
     }
-    if (! result) {
+    if (!result) {
         Py_INCREF(Py_None);
         return Py_None;
     }
@@ -1226,16 +1235,15 @@
     return _xyz_py(&primaries.Green);
 }

-static PyObject*
-cms_profile_getattr_blue_primary(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_blue_primary(CmsProfileObject *self, void *closure) {
     cmsBool result = 0;
     cmsCIEXYZTRIPLE primaries;

     if (cmsIsMatrixShaper(self->profile)) {
         result = _calculate_rgb_primaries(self, &primaries);
     }
-    if (! result) {
+    if (!result) {
         Py_INCREF(Py_None);
         return Py_None;
     }
@@ -1243,61 +1251,55 @@
     return _xyz_py(&primaries.Blue);
 }

-static PyObject*
-cms_profile_getattr_colorant_table(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_colorant_table(CmsProfileObject *self, void *closure) {
     return _profile_read_named_color_list(self, cmsSigColorantTableTag);
 }

-static PyObject*
-cms_profile_getattr_colorant_table_out(CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_colorant_table_out(CmsProfileObject *self, void *closure) {
     return _profile_read_named_color_list(self, cmsSigColorantTableOutTag);
 }

-static PyObject*
-cms_profile_getattr_is_intent_supported (CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_is_intent_supported(CmsProfileObject *self, void *closure) {
     return _is_intent_supported(self, 0);
 }

-static PyObject*
-cms_profile_getattr_is_clut (CmsProfileObject* self, void* closure)
-{
+static PyObject *
+cms_profile_getattr_is_clut(CmsProfileObject *self, void *closure) {
     return _is_intent_supported(self, 1);
 }

-static const char*
-_illu_map(int i)
-{
-    switch(i) {
-    case 0:
-        return "unknown";
-    case 1:
-        return "D50";
-    case 2:
-        return "D65";
-    case 3:
-        return "D93";
-    case 4:
-        return "F2";
-    case 5:
-        return "D55";
-    case 6:
-        return "A";
-    case 7:
-        return "E";
-    case 8:
-        return "F8";
-    default:
-        return NULL;
-    }
-}
-
-static PyObject*
-cms_profile_getattr_icc_measurement_condition (CmsProfileObject* self, void* closure)
-{
-    cmsICCMeasurementConditions* mc;
+static const char *
+_illu_map(int i) {
+    switch (i) {
+        case 0:
+            return "unknown";
+        case 1:
+            return "D50";
+        case 2:
+            return "D65";
+        case 3:
+            return "D93";
+        case 4:
+            return "F2";
+        case 5:
+            return "D55";
+        case 6:
+            return "A";
+        case 7:
+            return "E";
+        case 8:
+            return "F8";
+        default:
+            return NULL;
+    }
+}
+
+static PyObject *
+cms_profile_getattr_icc_measurement_condition(CmsProfileObject *self, void *closure) {
+    cmsICCMeasurementConditions *mc;
     cmsTagSignature info = cmsSigMeasurementTag;
     const char *geo;

@@ -1306,7 +1308,7 @@
         return Py_None;
     }

-    mc = (cmsICCMeasurementConditions*) cmsReadTag(self->profile, info);
+    mc = (cmsICCMeasurementConditions *)cmsReadTag(self->profile, info);
     if (!mc) {
         Py_INCREF(Py_None);
         return Py_None;
@@ -1320,18 +1322,25 @@
         geo = "unknown";
     }

-    return Py_BuildValue("{s:i,s:(ddd),s:s,s:d,s:s}",
-                         "observer", mc->Observer,
-                         "backing", mc->Backing.X, mc->Backing.Y, mc->Backing.Z,
-                         "geo", geo,
-                         "flare", mc->Flare,
-                         "illuminant_type", _illu_map(mc->IlluminantType));
-}
-
-static PyObject*
-cms_profile_getattr_icc_viewing_condition (CmsProfileObject* self, void* closure)
-{
-    cmsICCViewingConditions* vc;
+    return Py_BuildValue(
+        "{s:i,s:(ddd),s:s,s:d,s:s}",
+        "observer",
+        mc->Observer,
+        "backing",
+        mc->Backing.X,
+        mc->Backing.Y,
+        mc->Backing.Z,
+        "geo",
+        geo,
+        "flare",
+        mc->Flare,
+        "illuminant_type",
+        _illu_map(mc->IlluminantType));
+}
+
+static PyObject *
+cms_profile_getattr_icc_viewing_condition(CmsProfileObject *self, void *closure) {
+    cmsICCViewingConditions *vc;
     cmsTagSignature info = cmsSigViewingConditionsTag;

     if (!cmsIsTag(self->profile, info)) {
@@ -1339,158 +1348,164 @@
         return Py_None;
     }

-    vc = (cmsICCViewingConditions*) cmsReadTag(self->profile, info);
+    vc = (cmsICCViewingConditions *)cmsReadTag(self->profile, info);
     if (!vc) {
         Py_INCREF(Py_None);
         return Py_None;
     }

-    return Py_BuildValue("{s:(ddd),s:(ddd),s:s}",
-        "illuminant", vc->IlluminantXYZ.X, vc->IlluminantXYZ.Y, vc->IlluminantXYZ.Z,
-        "surround", vc->SurroundXYZ.X, vc->SurroundXYZ.Y, vc->SurroundXYZ.Z,
-        "illuminant_type", _illu_map(vc->IlluminantType));
-}
-
+    return Py_BuildValue(
+        "{s:(ddd),s:(ddd),s:s}",
+        "illuminant",
+        vc->IlluminantXYZ.X,
+        vc->IlluminantXYZ.Y,
+        vc->IlluminantXYZ.Z,
+        "surround",
+        vc->SurroundXYZ.X,
+        vc->SurroundXYZ.Y,
+        vc->SurroundXYZ.Z,
+        "illuminant_type",
+        _illu_map(vc->IlluminantType));
+}

 static struct PyGetSetDef cms_profile_getsetters[] = {
     /* New style interfaces.  */
-    { "rendering_intent",   (getter) cms_profile_getattr_rendering_intent },
-    { "creation_date",      (getter) cms_profile_getattr_creation_date },
-    { "copyright",          (getter) cms_profile_getattr_copyright },
-    { "target",             (getter) cms_profile_getattr_target },
-    { "manufacturer",       (getter) cms_profile_getattr_manufacturer },
-    { "model",              (getter) cms_profile_getattr_model },
-    { "profile_description", (getter) cms_profile_getattr_profile_description },
-    { "screening_description", (getter) cms_profile_getattr_screening_description },
-    { "viewing_condition",  (getter) cms_profile_getattr_viewing_condition },
-    { "version",            (getter) cms_profile_getattr_version },
-    { "icc_version",        (getter) cms_profile_getattr_icc_version },
-    { "attributes",         (getter) cms_profile_getattr_attributes },
-    { "header_flags",       (getter) cms_profile_getattr_header_flags },
-    { "header_manufacturer", (getter) cms_profile_getattr_header_manufacturer },
-    { "header_model",       (getter) cms_profile_getattr_header_model },
-    { "device_class",       (getter) cms_profile_getattr_device_class },
-    { "connection_space",   (getter) cms_profile_getattr_connection_space },
-    { "xcolor_space",       (getter) cms_profile_getattr_xcolor_space },
-    { "profile_id",         (getter) cms_profile_getattr_profile_id },
-    { "is_matrix_shaper",   (getter) cms_profile_getattr_is_matrix_shaper },
-    { "technology",         (getter) cms_profile_getattr_technology },
-    { "colorimetric_intent", (getter) cms_profile_getattr_colorimetric_intent },
-    { "perceptual_rendering_intent_gamut", (getter) cms_profile_getattr_perceptual_rendering_intent_gamut },
-    { "saturation_rendering_intent_gamut", (getter) cms_profile_getattr_saturation_rendering_intent_gamut },
-    { "red_colorant",       (getter) cms_profile_getattr_red_colorant },
-    { "green_colorant",     (getter) cms_profile_getattr_green_colorant },
-    { "blue_colorant",      (getter) cms_profile_getattr_blue_colorant },
-    { "red_primary",        (getter) cms_profile_getattr_red_primary },
-    { "green_primary",      (getter) cms_profile_getattr_green_primary },
-    { "blue_primary",       (getter) cms_profile_getattr_blue_primary },
-    { "media_white_point_temperature", (getter) cms_profile_getattr_media_white_point_temperature },
-    { "media_white_point",  (getter) cms_profile_getattr_media_white_point },
-    { "media_black_point",  (getter) cms_profile_getattr_media_black_point },
-    { "luminance",          (getter) cms_profile_getattr_luminance },
-    { "chromatic_adaptation", (getter) cms_profile_getattr_chromatic_adaptation },
-    { "chromaticity",       (getter) cms_profile_getattr_chromaticity },
-    { "colorant_table",     (getter) cms_profile_getattr_colorant_table },
-    { "colorant_table_out", (getter) cms_profile_getattr_colorant_table_out },
-    { "intent_supported",   (getter) cms_profile_getattr_is_intent_supported },
-    { "clut",               (getter) cms_profile_getattr_is_clut },
-    { "icc_measurement_condition", (getter) cms_profile_getattr_icc_measurement_condition },
-    { "icc_viewing_condition", (getter) cms_profile_getattr_icc_viewing_condition },
-
-    { NULL }
+    {"rendering_intent", (getter)cms_profile_getattr_rendering_intent},
+    {"creation_date", (getter)cms_profile_getattr_creation_date},
+    {"copyright", (getter)cms_profile_getattr_copyright},
+    {"target", (getter)cms_profile_getattr_target},
+    {"manufacturer", (getter)cms_profile_getattr_manufacturer},
+    {"model", (getter)cms_profile_getattr_model},
+    {"profile_description", (getter)cms_profile_getattr_profile_description},
+    {"screening_description", (getter)cms_profile_getattr_screening_description},
+    {"viewing_condition", (getter)cms_profile_getattr_viewing_condition},
+    {"version", (getter)cms_profile_getattr_version},
+    {"icc_version", (getter)cms_profile_getattr_icc_version},
+    {"attributes", (getter)cms_profile_getattr_attributes},
+    {"header_flags", (getter)cms_profile_getattr_header_flags},
+    {"header_manufacturer", (getter)cms_profile_getattr_header_manufacturer},
+    {"header_model", (getter)cms_profile_getattr_header_model},
+    {"device_class", (getter)cms_profile_getattr_device_class},
+    {"connection_space", (getter)cms_profile_getattr_connection_space},
+    {"xcolor_space", (getter)cms_profile_getattr_xcolor_space},
+    {"profile_id", (getter)cms_profile_getattr_profile_id},
+    {"is_matrix_shaper", (getter)cms_profile_getattr_is_matrix_shaper},
+    {"technology", (getter)cms_profile_getattr_technology},
+    {"colorimetric_intent", (getter)cms_profile_getattr_colorimetric_intent},
+    {"perceptual_rendering_intent_gamut",
+     (getter)cms_profile_getattr_perceptual_rendering_intent_gamut},
+    {"saturation_rendering_intent_gamut",
+     (getter)cms_profile_getattr_saturation_rendering_intent_gamut},
+    {"red_colorant", (getter)cms_profile_getattr_red_colorant},
+    {"green_colorant", (getter)cms_profile_getattr_green_colorant},
+    {"blue_colorant", (getter)cms_profile_getattr_blue_colorant},
+    {"red_primary", (getter)cms_profile_getattr_red_primary},
+    {"green_primary", (getter)cms_profile_getattr_green_primary},
+    {"blue_primary", (getter)cms_profile_getattr_blue_primary},
+    {"media_white_point_temperature",
+     (getter)cms_profile_getattr_media_white_point_temperature},
+    {"media_white_point", (getter)cms_profile_getattr_media_white_point},
+    {"media_black_point", (getter)cms_profile_getattr_media_black_point},
+    {"luminance", (getter)cms_profile_getattr_luminance},
+    {"chromatic_adaptation", (getter)cms_profile_getattr_chromatic_adaptation},
+    {"chromaticity", (getter)cms_profile_getattr_chromaticity},
+    {"colorant_table", (getter)cms_profile_getattr_colorant_table},
+    {"colorant_table_out", (getter)cms_profile_getattr_colorant_table_out},
+    {"intent_supported", (getter)cms_profile_getattr_is_intent_supported},
+    {"clut", (getter)cms_profile_getattr_is_clut},
+    {"icc_measurement_condition",
+     (getter)cms_profile_getattr_icc_measurement_condition},
+    {"icc_viewing_condition", (getter)cms_profile_getattr_icc_viewing_condition},
+
+    {NULL}};
+
+static PyTypeObject CmsProfile_Type = {
+    PyVarObject_HEAD_INIT(NULL, 0) "PIL._imagingcms.CmsProfile", /*tp_name */
+    sizeof(CmsProfileObject),
+    0, /*tp_basicsize, tp_itemsize */
+    /* methods */
+    (destructor)cms_profile_dealloc, /*tp_dealloc*/
+    0,                               /*tp_print*/
+    0,                               /*tp_getattr*/
+    0,                               /*tp_setattr*/
+    0,                               /*tp_compare*/
+    0,                               /*tp_repr*/
+    0,                               /*tp_as_number */
+    0,                               /*tp_as_sequence */
+    0,                               /*tp_as_mapping */
+    0,                               /*tp_hash*/
+    0,                               /*tp_call*/
+    0,                               /*tp_str*/
+    0,                               /*tp_getattro*/
+    0,                               /*tp_setattro*/
+    0,                               /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,              /*tp_flags*/
+    0,                               /*tp_doc*/
+    0,                               /*tp_traverse*/
+    0,                               /*tp_clear*/
+    0,                               /*tp_richcompare*/
+    0,                               /*tp_weaklistoffset*/
+    0,                               /*tp_iter*/
+    0,                               /*tp_iternext*/
+    cms_profile_methods,             /*tp_methods*/
+    0,                               /*tp_members*/
+    cms_profile_getsetters,          /*tp_getset*/
 };

-
-static PyTypeObject CmsProfile_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "PIL._imagingcms.CmsProfile",   /*tp_name */
-    sizeof(CmsProfileObject), 0,/*tp_basicsize, tp_itemsize */
+static struct PyMethodDef cms_transform_methods[] = {
+    {"apply", (PyCFunction)cms_transform_apply, 1}, {NULL, NULL} /* sentinel */
+};
+
+static PyObject *
+cms_transform_getattr_inputMode(CmsTransformObject *self, void *closure) {
+    return PyUnicode_FromString(self->mode_in);
+}
+
+static PyObject *
+cms_transform_getattr_outputMode(CmsTransformObject *self, void *closure) {
+    return PyUnicode_FromString(self->mode_out);
+}
+
+static struct PyGetSetDef cms_transform_getsetters[] = {
+    {"inputMode", (getter)cms_transform_getattr_inputMode},
+    {"outputMode", (getter)cms_transform_getattr_outputMode},
+    {NULL}};
+
+static PyTypeObject CmsTransform_Type = {
+    PyVarObject_HEAD_INIT(NULL, 0) "CmsTransform",
+    sizeof(CmsTransformObject),
+    0,
     /* methods */
-    (destructor) cms_profile_dealloc, /*tp_dealloc*/
-    0, /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    cms_profile_methods,        /*tp_methods*/
-    0,                          /*tp_members*/
-    cms_profile_getsetters,     /*tp_getset*/
+    (destructor)cms_transform_dealloc, /*tp_dealloc*/
+    0,                                 /*tp_print*/
+    0,                                 /*tp_getattr*/
+    0,                                 /*tp_setattr*/
+    0,                                 /*tp_compare*/
+    0,                                 /*tp_repr*/
+    0,                                 /*tp_as_number */
+    0,                                 /*tp_as_sequence */
+    0,                                 /*tp_as_mapping */
+    0,                                 /*tp_hash*/
+    0,                                 /*tp_call*/
+    0,                                 /*tp_str*/
+    0,                                 /*tp_getattro*/
+    0,                                 /*tp_setattro*/
+    0,                                 /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT,                /*tp_flags*/
+    0,                                 /*tp_doc*/
+    0,                                 /*tp_traverse*/
+    0,                                 /*tp_clear*/
+    0,                                 /*tp_richcompare*/
+    0,                                 /*tp_weaklistoffset*/
+    0,                                 /*tp_iter*/
+    0,                                 /*tp_iternext*/
+    cms_transform_methods,             /*tp_methods*/
+    0,                                 /*tp_members*/
+    cms_transform_getsetters,          /*tp_getset*/
 };

-static struct PyMethodDef cms_transform_methods[] = {
-    {"apply", (PyCFunction) cms_transform_apply, 1},
-    {NULL, NULL} /* sentinel */
-};
-
-static PyObject*
-cms_transform_getattr_inputMode(CmsTransformObject* self, void* closure)
-{
-    return PyUnicode_FromString(self->mode_in);
-}
-
-static PyObject*
-cms_transform_getattr_outputMode(CmsTransformObject* self, void* closure)
-{
-    return PyUnicode_FromString(self->mode_out);
-}
-
-static struct PyGetSetDef cms_transform_getsetters[] = {
-    { "inputMode",      (getter) cms_transform_getattr_inputMode },
-    { "outputMode",     (getter) cms_transform_getattr_outputMode },
-    { NULL }
-};
-
-static PyTypeObject CmsTransform_Type = {
-    PyVarObject_HEAD_INIT(NULL, 0)
-    "CmsTransform", sizeof(CmsTransformObject), 0,
-    /* methods */
-    (destructor) cms_transform_dealloc, /*tp_dealloc*/
-    0, /*tp_print*/
-    0,                          /*tp_getattr*/
-    0,                          /*tp_setattr*/
-    0,                          /*tp_compare*/
-    0,                          /*tp_repr*/
-    0,                          /*tp_as_number */
-    0,                          /*tp_as_sequence */
-    0,                          /*tp_as_mapping */
-    0,                          /*tp_hash*/
-    0,                          /*tp_call*/
-    0,                          /*tp_str*/
-    0,                          /*tp_getattro*/
-    0,                          /*tp_setattro*/
-    0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
-    0,                          /*tp_doc*/
-    0,                          /*tp_traverse*/
-    0,                          /*tp_clear*/
-    0,                          /*tp_richcompare*/
-    0,                          /*tp_weaklistoffset*/
-    0,                          /*tp_iter*/
-    0,                          /*tp_iternext*/
-    cms_transform_methods,      /*tp_methods*/
-    0,                          /*tp_members*/
-    cms_transform_getsetters,   /*tp_getset*/
-};
-
 static int
-setup_module(PyObject* m) {
+setup_module(PyObject *m) {
     PyObject *d;
     PyObject *v;
     int vn;
@@ -1524,14 +1539,14 @@

 PyMODINIT_FUNC
 PyInit__imagingcms(void) {
-    PyObject* m;
+    PyObject *m;

     static PyModuleDef module_def = {
         PyModuleDef_HEAD_INIT,
-        "_imagingcms",      /* m_name */
-        NULL,               /* m_doc */
-        -1,                 /* m_size */
-        pyCMSdll_methods,   /* m_methods */
+        "_imagingcms",    /* m_name */
+        NULL,             /* m_doc */
+        -1,               /* m_size */
+        pyCMSdll_methods, /* m_methods */
     };

     m = PyModule_Create(&module_def);
('src/libImaging', 'UnsharpMask.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -8,26 +8,22 @@

 #include "Imaging.h"

-
 typedef UINT8 pixel[4];

-
-static inline UINT8 clip8(int in)
-{
+static inline UINT8
+clip8(int in) {
     if (in >= 255) {
-       return 255;
+        return 255;
     }
     if (in <= 0) {
         return 0;
     }
-    return (UINT8) in;
+    return (UINT8)in;
 }

-
 Imaging
-ImagingUnsharpMask(Imaging imOut, Imaging imIn, float radius, int percent,
-                   int threshold)
-{
+ImagingUnsharpMask(
+    Imaging imOut, Imaging imIn, float radius, int percent, int threshold) {
     ImagingSectionCookie cookie;
     Imaging result;

@@ -53,8 +49,7 @@
     ImagingSectionEnter(&cookie);

     for (y = 0; y < imIn->ysize; y++) {
-        if (imIn->image8)
-        {
+        if (imIn->image8) {
             lineIn8 = imIn->image8[y];
             lineOut8 = imOut->image8[y];
             for (x = 0; x < imIn->xsize; x++) {
@@ -74,20 +69,24 @@
             for (x = 0; x < imIn->xsize; x++) {
                 /* compare in/out pixels, apply sharpening */
                 diff = lineIn[x][0] - lineOut[x][0];
-                lineOut[x][0] = abs(diff) > threshold ?
-                    clip8(lineIn[x][0] + diff * percent / 100) : lineIn[x][0];
+                lineOut[x][0] = abs(diff) > threshold
+                                    ? clip8(lineIn[x][0] + diff * percent / 100)
+                                    : lineIn[x][0];

                 diff = lineIn[x][1] - lineOut[x][1];
-                lineOut[x][1] = abs(diff) > threshold ?
-                    clip8(lineIn[x][1] + diff * percent / 100) : lineIn[x][1];
+                lineOut[x][1] = abs(diff) > threshold
+                                    ? clip8(lineIn[x][1] + diff * percent / 100)
+                                    : lineIn[x][1];

                 diff = lineIn[x][2] - lineOut[x][2];
-                lineOut[x][2] = abs(diff) > threshold ?
-                    clip8(lineIn[x][2] + diff * percent / 100) : lineIn[x][2];
+                lineOut[x][2] = abs(diff) > threshold
+                                    ? clip8(lineIn[x][2] + diff * percent / 100)
+                                    : lineIn[x][2];

                 diff = lineIn[x][3] - lineOut[x][3];
-                lineOut[x][3] = abs(diff) > threshold ?
-                    clip8(lineIn[x][3] + diff * percent / 100) : lineIn[x][3];
+                lineOut[x][3] = abs(diff) > threshold
+                                    ? clip8(lineIn[x][3] + diff * percent / 100)
+                                    : lineIn[x][3];
             }
         }
     }
('src/libImaging', 'Crop.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,20 +15,17 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 Imaging
-ImagingCrop(Imaging imIn, int sx0, int sy0, int sx1, int sy1)
-{
+ImagingCrop(Imaging imIn, int sx0, int sy0, int sx1, int sy1) {
     Imaging imOut;
     int xsize, ysize;
     int dx0, dy0, dx1, dy1;
     INT32 zero = 0;

     if (!imIn) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     xsize = sx1 - sx0;
@@ -48,7 +45,7 @@
     ImagingCopyPalette(imOut, imIn);

     if (sx0 < 0 || sy0 < 0 || sx1 > imIn->xsize || sy1 > imIn->ysize) {
-        (void) ImagingFill(imOut, &zero);
+        (void)ImagingFill(imOut, &zero);
     }

     dx0 = -sx0;
('src/libImaging', 'PcxDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,14 +13,12 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 int
-ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
+ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
     UINT8 n;
-    UINT8* ptr;
+    UINT8 *ptr;

     if ((state->xsize * state->bits + 7) / 8 > state->bytes) {
         state->errcode = IMAGING_CODEC_OVERRUN;
@@ -30,13 +28,11 @@
     ptr = buf;

     for (;;) {
-
         if (bytes < 1) {
             return ptr - buf;
         }

         if ((*ptr & 0xC0) == 0xC0) {
-
             /* Run */
             if (bytes < 2) {
                 return ptr - buf;
@@ -53,14 +49,14 @@
                 n--;
             }

-            ptr += 2; bytes -= 2;
+            ptr += 2;
+            bytes -= 2;

         } else {
-
             /* Literal */
             state->buffer[state->x++] = ptr[0];
-            ptr++; bytes--;
-
+            ptr++;
+            bytes--;
         }

         if (state->x >= state->bytes) {
@@ -68,16 +64,19 @@
                 int bands = state->bytes / state->xsize;
                 int stride = state->bytes / bands;
                 int i;
-                for (i=1; i< bands; i++) {  // note -- skipping first band
-                    memmove(&state->buffer[i*state->xsize],
-                            &state->buffer[i*stride],
-                            state->xsize);
+                for (i = 1; i < bands; i++) {  // note -- skipping first band
+                    memmove(
+                        &state->buffer[i * state->xsize],
+                        &state->buffer[i * stride],
+                        state->xsize);
                 }
             }
             /* Got a full line, unpack it */
-            state->shuffle((UINT8*) im->image[state->y + state->yoff] +
-                   state->xoff * im->pixelsize, state->buffer,
-                   state->xsize);
+            state->shuffle(
+                (UINT8 *)im->image[state->y + state->yoff] +
+                    state->xoff * im->pixelsize,
+                state->buffer,
+                state->xsize);

             state->x = 0;

@@ -86,6 +85,5 @@
                 return -1;
             }
         }
-
     }
 }
('src/libImaging', 'ImPlatform.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -8,11 +8,6 @@
  */

 #include "Python.h"
-
-/* Workaround issue #2479 */
-#if PY_VERSION_HEX < 0x03070000 && defined(PySlice_GetIndicesEx) && !defined(PYPY_VERSION)
-#undef PySlice_GetIndicesEx
-#endif

 /* Check that we have an ANSI compliant compiler */
 #ifndef HAVE_PROTOTYPES
@@ -30,10 +25,17 @@
 #endif
 #endif

-#ifdef _WIN32
+#if defined(_WIN32) || defined(__CYGWIN__)

 #define WIN32_LEAN_AND_MEAN
 #include <Windows.h>
+
+#ifdef __CYGWIN__
+#undef _WIN64
+#undef _WIN32
+#undef __WIN32__
+#undef WIN32
+#endif

 #else
 /* For System that are not Windows, we'll need to define these. */
@@ -62,7 +64,7 @@
 #define INT64 long
 #endif

-#define INT8  signed char
+#define INT8 signed char
 #define UINT8 unsigned char

 #define UINT16 unsigned INT16
@@ -76,11 +78,9 @@
 #define FLOAT64 double

 #ifdef _MSC_VER
-typedef signed __int64       int64_t;
+typedef signed __int64 int64_t;
 #endif

 #ifdef __GNUC__
-    #define GCC_VERSION (__GNUC__ * 10000 \
-                       + __GNUC_MINOR__ * 100 \
-                       + __GNUC_PATCHLEVEL__)
+#define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
 #endif
('src/libImaging', 'Jpeg2KDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,7 +23,7 @@
 typedef struct {
     OPJ_UINT32 tile_index;
     OPJ_UINT32 data_size;
-    OPJ_INT32  x0, y0, x1, y1;
+    OPJ_INT32 x0, y0, x1, y1;
     OPJ_UINT32 nb_comps;
 } JPEG2KTILEINFO;

@@ -32,9 +32,8 @@
 /* -------------------------------------------------------------------- */

 static void
-j2k_error(const char *msg, void *client_data)
-{
-    JPEG2KDECODESTATE *state = (JPEG2KDECODESTATE *) client_data;
+j2k_error(const char *msg, void *client_data) {
+    JPEG2KDECODESTATE *state = (JPEG2KDECODESTATE *)client_data;
     free((void *)state->error_msg);
     state->error_msg = strdup(msg);
 }
@@ -44,8 +43,7 @@
 /* -------------------------------------------------------------------- */

 static OPJ_SIZE_T
-j2k_read(void *p_buffer, OPJ_SIZE_T p_nb_bytes, void *p_user_data)
-{
+j2k_read(void *p_buffer, OPJ_SIZE_T p_nb_bytes, void *p_user_data) {
     ImagingCodecState state = (ImagingCodecState)p_user_data;

     size_t len = _imaging_read_pyFd(state->fd, p_buffer, p_nb_bytes);
@@ -54,8 +52,7 @@
 }

 static OPJ_OFF_T
-j2k_skip(OPJ_OFF_T p_nb_bytes, void *p_user_data)
-{
+j2k_skip(OPJ_OFF_T p_nb_bytes, void *p_user_data) {
     off_t pos;
     ImagingCodecState state = (ImagingCodecState)p_user_data;

@@ -69,21 +66,20 @@
 /* Unpackers                                                            */
 /* -------------------------------------------------------------------- */

-typedef void (*j2k_unpacker_t)(opj_image_t *in,
-                               const JPEG2KTILEINFO *tileInfo,
-                               const UINT8 *data,
-                               Imaging im);
+typedef void (*j2k_unpacker_t)(
+    opj_image_t *in, const JPEG2KTILEINFO *tileInfo, const UINT8 *data, Imaging im);

 struct j2k_decode_unpacker {
-    const char          *mode;
-    OPJ_COLOR_SPACE     color_space;
-    unsigned            components;
-    j2k_unpacker_t      unpacker;
+    const char *mode;
+    OPJ_COLOR_SPACE color_space;
+    unsigned components;
+    /* bool indicating if unpacker supports subsampling */
+    int subsampling;
+    j2k_unpacker_t unpacker;
 };

-static inline
-unsigned j2ku_shift(unsigned x, int n)
-{
+static inline unsigned
+j2ku_shift(unsigned x, int n) {
     if (n < 0) {
         return x >> -n;
     } else {
@@ -92,9 +88,11 @@
 }

 static void
-j2ku_gray_l(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
-            const UINT8 *tiledata, Imaging im)
-{
+j2ku_gray_l(
+    opj_image_t *in,
+    const JPEG2KTILEINFO *tileinfo,
+    const UINT8 *tiledata,
+    Imaging im) {
     unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;
     unsigned w = tileinfo->x1 - tileinfo->x0;
     unsigned h = tileinfo->y1 - tileinfo->y0;
@@ -115,41 +113,42 @@

     /* csiz*h*w + offset = tileinfo.datasize */
     switch (csiz) {
-    case 1:
-        for (y = 0; y < h; ++y) {
-            const UINT8 *data = &tiledata[y * w];
-            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                *row++ = j2ku_shift(offset + *data++, shift);
-            }
-        }
-        break;
-    case 2:
-        for (y = 0; y < h; ++y) {
-            const UINT16 *data = (const UINT16 *)&tiledata[2 * y * w];
-            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                *row++ = j2ku_shift(offset + *data++, shift);
-            }
-        }
-        break;
-    case 4:
-        for (y = 0; y < h; ++y) {
-            const UINT32 *data = (const UINT32 *)&tiledata[4 * y * w];
-            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                *row++ = j2ku_shift(offset + *data++, shift);
-            }
-        }
-        break;
-    }
-}
-
+        case 1:
+            for (y = 0; y < h; ++y) {
+                const UINT8 *data = &tiledata[y * w];
+                UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    *row++ = j2ku_shift(offset + *data++, shift);
+                }
+            }
+            break;
+        case 2:
+            for (y = 0; y < h; ++y) {
+                const UINT16 *data = (const UINT16 *)&tiledata[2 * y * w];
+                UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    *row++ = j2ku_shift(offset + *data++, shift);
+                }
+            }
+            break;
+        case 4:
+            for (y = 0; y < h; ++y) {
+                const UINT32 *data = (const UINT32 *)&tiledata[4 * y * w];
+                UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    *row++ = j2ku_shift(offset + *data++, shift);
+                }
+            }
+            break;
+    }
+}

 static void
-j2ku_gray_i(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
-            const UINT8 *tiledata, Imaging im)
-{
+j2ku_gray_i(
+    opj_image_t *in,
+    const JPEG2KTILEINFO *tileinfo,
+    const UINT8 *tiledata,
+    Imaging im) {
     unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;
     unsigned w = tileinfo->x1 - tileinfo->x0;
     unsigned h = tileinfo->y1 - tileinfo->y0;
@@ -169,41 +168,44 @@
     }

     switch (csiz) {
-    case 1:
-        for (y = 0; y < h; ++y) {
-            const UINT8 *data = &tiledata[y * w];
-            UINT16 *row = (UINT16 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                *row++ = j2ku_shift(offset + *data++, shift);
-            }
-        }
-        break;
-    case 2:
-        for (y = 0; y < h; ++y) {
-            const UINT16 *data = (const UINT16 *)&tiledata[2 * y * w];
-            UINT16 *row = (UINT16 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                *row++ = j2ku_shift(offset + *data++, shift);
-            }
-        }
-        break;
-    case 4:
-        for (y = 0; y < h; ++y) {
-            const UINT32 *data = (const UINT32 *)&tiledata[4 * y * w];
-            UINT16 *row = (UINT16 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                *row++ = j2ku_shift(offset + *data++, shift);
-            }
-        }
-        break;
-    }
-}
-
+        case 1:
+            for (y = 0; y < h; ++y) {
+                const UINT8 *data = &tiledata[y * w];
+                UINT16 *row = (UINT16 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    *row++ = j2ku_shift(offset + *data++, shift);
+                }
+            }
+            break;
+        case 2:
+            for (y = 0; y < h; ++y) {
+                const UINT16 *data = (const UINT16 *)&tiledata[2 * y * w];
+                UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    UINT16 pixel = j2ku_shift(offset + *data++, shift);
+                    *row++ = pixel;
+                    *row++ = pixel >> 8;
+                }
+            }
+            break;
+        case 4:
+            for (y = 0; y < h; ++y) {
+                const UINT32 *data = (const UINT32 *)&tiledata[4 * y * w];
+                UINT16 *row = (UINT16 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    *row++ = j2ku_shift(offset + *data++, shift);
+                }
+            }
+            break;
+    }
+}

 static void
-j2ku_gray_rgb(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
-              const UINT8 *tiledata, Imaging im)
-{
+j2ku_gray_rgb(
+    opj_image_t *in,
+    const JPEG2KTILEINFO *tileinfo,
+    const UINT8 *tiledata,
+    Imaging im) {
     unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;
     unsigned w = tileinfo->x1 - tileinfo->x0;
     unsigned h = tileinfo->y1 - tileinfo->y0;
@@ -223,49 +225,51 @@
     }

     switch (csiz) {
-    case 1:
-        for (y = 0; y < h; ++y) {
-            const UINT8 *data = &tiledata[y * w];
-            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                UINT8 byte = j2ku_shift(offset + *data++, shift);
-                row[0] = row[1] = row[2] = byte;
-                row[3] = 0xff;
-                row += 4;
-            }
-        }
-        break;
-    case 2:
-        for (y = 0; y < h; ++y) {
-            const UINT16 *data = (UINT16 *)&tiledata[2 * y * w];
-            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                UINT8 byte = j2ku_shift(offset + *data++, shift);
-                row[0] = row[1] = row[2] = byte;
-                row[3] = 0xff;
-                row += 4;
-            }
-        }
-        break;
-    case 4:
-        for (y = 0; y < h; ++y) {
-            const UINT32 *data = (UINT32 *)&tiledata[4 * y * w];
-            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
-            for (x = 0; x < w; ++x) {
-                UINT8 byte = j2ku_shift(offset + *data++, shift);
-                row[0] = row[1] = row[2] = byte;
-                row[3] = 0xff;
-                row += 4;
-            }
-        }
-        break;
+        case 1:
+            for (y = 0; y < h; ++y) {
+                const UINT8 *data = &tiledata[y * w];
+                UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    UINT8 byte = j2ku_shift(offset + *data++, shift);
+                    row[0] = row[1] = row[2] = byte;
+                    row[3] = 0xff;
+                    row += 4;
+                }
+            }
+            break;
+        case 2:
+            for (y = 0; y < h; ++y) {
+                const UINT16 *data = (UINT16 *)&tiledata[2 * y * w];
+                UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    UINT8 byte = j2ku_shift(offset + *data++, shift);
+                    row[0] = row[1] = row[2] = byte;
+                    row[3] = 0xff;
+                    row += 4;
+                }
+            }
+            break;
+        case 4:
+            for (y = 0; y < h; ++y) {
+                const UINT32 *data = (UINT32 *)&tiledata[4 * y * w];
+                UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;
+                for (x = 0; x < w; ++x) {
+                    UINT8 byte = j2ku_shift(offset + *data++, shift);
+                    row[0] = row[1] = row[2] = byte;
+                    row[3] = 0xff;
+                    row += 4;
+                }
+            }
+            break;
     }
 }

 static void
-j2ku_graya_la(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
-              const UINT8 *tiledata, Imaging im)
-{
+j2ku_graya_la(
+    opj_image_t *in,
+    const JPEG2KTILEINFO *tileinfo,
+    const UINT8 *tiledata,
+    Imaging im) {
     unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;
     unsigned w = tileinfo->x1 - tileinfo->x0;
     unsigned h = tileinfo->y1 - tileinfo->y0;
@@ -304,15 +308,31 @@
             UINT32 word = 0, aword = 0, byte;

             switch (csiz) {
-            case 1: word = *data++; break;
-            case 2: word = *(const UINT16 *)data; data += 2; break;
-            case 4: word = *(const UINT32 *)data; data += 4; break;
+                case 1:
+                    word = *data++;
+                    break;
+                case 2:
+                    word = *(const UINT16 *)data;
+                    data += 2;
+                    break;
+                case 4:
+                    word = *(const UINT32 *)data;
+                    data += 4;
+                    break;
             }

             switch (acsiz) {
-            case 1: aword = *adata++; break;
-            case 2: aword = *(const UINT16 *)adata; adata += 2; break;
-            case 4: aword = *(const UINT32 *)adata; adata += 4; break;
+                case 1:
+                    aword = *adata++;
+                    break;
+                case 2:
+                    aword = *(const UINT16 *)adata;
+                    adata += 2;
+                    break;
+                case 4:
+                    aword = *(const UINT32 *)adata;
+                    adata += 4;
+                    break;
             }

             byte = j2ku_shift(offset + word, shift);
@@ -324,14 +344,17 @@
 }

 static void
-j2ku_srgb_rgb(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
-              const UINT8 *tiledata, Imaging im)
-{
+j2ku_srgb_rgb(
+    opj_image_t *in,
+    const JPEG2KTILEINFO *tileinfo,
+    const UINT8 *tiledata,
+    Imaging im) {
     unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;
     unsigned w = tileinfo->x1 - tileinfo->x0;
     unsigned h = tileinfo->y1 - tileinfo->y0;

     int shifts[3], offsets[3], csiz[3];
+    unsigned dx[3], dy[3];
     const UINT8 *cdata[3];
     const UINT8 *cptr = tiledata;
     unsigned n, x, y;
@@ -341,6 +364,8 @@
         shifts[n] = 8 - in->comps[n].prec;
         offsets[n] = in->comps[n].sgnd ? 1 << (in->comps[n].prec - 1) : 0;
         csiz[n] = (in->comps[n].prec + 7) >> 3;
+        dx[n] = (in->comps[n].dx);
+        dy[n] = (in->comps[n].dy);

         if (csiz[n] == 3) {
             csiz[n] = 4;
@@ -350,14 +375,14 @@
             offsets[n] += 1 << (-shifts[n] - 1);
         }

-        cptr += csiz[n] * w * h;
+        cptr += csiz[n] * (w / dx[n]) * (h / dy[n]);
     }

     for (y = 0; y < h; ++y) {
         const UINT8 *data[3];
         UINT8 *row = (UINT8 *)im->image[y0 + y] + x0 * 4;
         for (n = 0; n < 3; ++n) {
-            data[n] = &cdata[n][csiz[n] * y * w];
+            data[n] = &cdata[n][csiz[n] * (y / dy[n]) * (w / dx[n])];
         }

         for (x = 0; x < w; ++x) {
@@ -365,9 +390,15 @@
                 UINT32 word = 0;

                 switch (csiz[n]) {
-                case 1: word = *data[n]++; break;
-                case 2: word = *(const UINT16 *)data[n]; data[n] += 2; break;
-                case 4: word = *(const UINT32 *)data[n]; data[n] += 4; break;
+                    case 1:
+                        word = data[n][x / dx[n]];
+                        break;
+                    case 2:
+                        word = ((const UINT16 *)data[n])[x / dx[n]];
+                        break;
+                    case 4:
+                        word = ((const UINT32 *)data[n])[x / dx[n]];
+                        break;
                 }

                 row[n] = j2ku_shift(offsets[n] + word, shifts[n]);
@@ -379,14 +410,17 @@
 }

 static void
-j2ku_sycc_rgb(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
-              const UINT8 *tiledata, Imaging im)
-{
+j2ku_sycc_rgb(
+    opj_image_t *in,
+    const JPEG2KTILEINFO *tileinfo,
+    const UINT8 *tiledata,
+    Imaging im) {
     unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;
     unsigned w = tileinfo->x1 - tileinfo->x0;
     unsigned h = tileinfo->y1 - tileinfo->y0;

     int shifts[3], offsets[3], csiz[3];
+    unsigned dx[3], dy[3];
     const UINT8 *cdata[3];
     const UINT8 *cptr = tiledata;
     unsigned n, x, y;
@@ -396,6 +430,8 @@
         shifts[n] = 8 - in->comps[n].prec;
         offsets[n] = in->comps[n].sgnd ? 1 << (in->comps[n].prec - 1) : 0;
         csiz[n] = (in->comps[n].prec + 7) >> 3;
+        dx[n] = (in->comps[n].dx);
+        dy[n] = (in->comps[n].dy);

         if (csiz[n] == 3) {
             csiz[n] = 4;
@@ -405,7 +441,7 @@
             offsets[n] += 1 << (-shifts[n] - 1);
         }

-        cptr += csiz[n] * w * h;
+        cptr += csiz[n] * (w / dx[n]) * (h / dy[n]);
     }

     for (y = 0; y < h; ++y) {
@@ -413,7 +449,7 @@
         UINT8 *row = (UINT8 *)im->image[y0 + y] + x0 * 4;
         UINT8 *row_start = row;
         for (n = 0; n < 3; ++n) {
-            data[n] = &cdata[n][csiz[n] * y * w];
+            data[n] = &cdata[n][csiz[n] * (y / dy[n]) * (w / dx[n])];
         }

         for (x = 0; x < w; ++x) {
@@ -421,9 +457,15 @@
                 UINT32 word = 0;

                 switch (csiz[n]) {
-                case 1: word = *data[n]++; break;
-                case 2: word = *(const UINT16 *)data[n]; data[n] += 2; break;
-                case 4: word = *(const UINT32 *)data[n]; data[n] += 4; break;
+                    case 1:
+                        word = data[n][x / dx[n]];
+                        break;
+                    case 2:
+                        word = ((const UINT16 *)data[n])[x / dx[n]];
+                        break;
+                    case 4:
+                        word = ((const UINT32 *)data[n])[x / dx[n]];
+                        break;
                 }

                 row[n] = j2ku_shift(offsets[n] + word, shifts[n]);
@@ -437,14 +479,17 @@
 }

 static void
-j2ku_srgba_rgba(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
-                const UINT8 *tiledata, Imaging im)
-{
+j2ku_srgba_rgba(
+    opj_image_t *in,
+    const JPEG2KTILEINFO *tileinfo,
+    const UINT8 *tiledata,
+    Imaging im) {
     unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;
     unsigned w = tileinfo->x1 - tileinfo->x0;
     unsigned h = tileinfo->y1 - tileinfo->y0;

     int shifts[4], offsets[4], csiz[4];
+    unsigned dx[4], dy[4];
     const UINT8 *cdata[4];
     const UINT8 *cptr = tiledata;
     unsigned n, x, y;
@@ -454,6 +499,8 @@
         shifts[n] = 8 - in->comps[n].prec;
         offsets[n] = in->comps[n].sgnd ? 1 << (in->comps[n].prec - 1) : 0;
         csiz[n] = (in->comps[n].prec + 7) >> 3;
+        dx[n] = (in->comps[n].dx);
+        dy[n] = (in->comps[n].dy);

         if (csiz[n] == 3) {
             csiz[n] = 4;
@@ -463,14 +510,14 @@
             offsets[n] += 1 << (-shifts[n] - 1);
         }

-        cptr += csiz[n] * w * h;
+        cptr += csiz[n] * (w / dx[n]) * (h / dy[n]);
     }

     for (y = 0; y < h; ++y) {
         const UINT8 *data[4];
         UINT8 *row = (UINT8 *)im->image[y0 + y] + x0 * 4;
         for (n = 0; n < 4; ++n) {
-            data[n] = &cdata[n][csiz[n] * y * w];
+            data[n] = &cdata[n][csiz[n] * (y / dy[n]) * (w / dx[n])];
         }

         for (x = 0; x < w; ++x) {
@@ -478,9 +525,15 @@
                 UINT32 word = 0;

                 switch (csiz[n]) {
-                case 1: word = *data[n]++; break;
-                case 2: word = *(const UINT16 *)data[n]; data[n] += 2; break;
-                case 4: word = *(const UINT32 *)data[n]; data[n] += 4; break;
+                    case 1:
+                        word = data[n][x / dx[n]];
+                        break;
+                    case 2:
+                        word = ((const UINT16 *)data[n])[x / dx[n]];
+                        break;
+                    case 4:
+                        word = ((const UINT32 *)data[n])[x / dx[n]];
+                        break;
                 }

                 row[n] = j2ku_shift(offsets[n] + word, shifts[n]);
@@ -491,14 +544,17 @@
 }

 static void
-j2ku_sycca_rgba(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
-                const UINT8 *tiledata, Imaging im)
-{
+j2ku_sycca_rgba(
+    opj_image_t *in,
+    const JPEG2KTILEINFO *tileinfo,
+    const UINT8 *tiledata,
+    Imaging im) {
     unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;
     unsigned w = tileinfo->x1 - tileinfo->x0;
     unsigned h = tileinfo->y1 - tileinfo->y0;

     int shifts[4], offsets[4], csiz[4];
+    unsigned dx[4], dy[4];
     const UINT8 *cdata[4];
     const UINT8 *cptr = tiledata;
     unsigned n, x, y;
@@ -508,6 +564,8 @@
         shifts[n] = 8 - in->comps[n].prec;
         offsets[n] = in->comps[n].sgnd ? 1 << (in->comps[n].prec - 1) : 0;
         csiz[n] = (in->comps[n].prec + 7) >> 3;
+        dx[n] = (in->comps[n].dx);
+        dy[n] = (in->comps[n].dy);

         if (csiz[n] == 3) {
             csiz[n] = 4;
@@ -517,7 +575,7 @@
             offsets[n] += 1 << (-shifts[n] - 1);
         }

-        cptr += csiz[n] * w * h;
+        cptr += csiz[n] * (w / dx[n]) * (h / dy[n]);
     }

     for (y = 0; y < h; ++y) {
@@ -525,7 +583,7 @@
         UINT8 *row = (UINT8 *)im->image[y0 + y] + x0 * 4;
         UINT8 *row_start = row;
         for (n = 0; n < 4; ++n) {
-            data[n] = &cdata[n][csiz[n] * y * w];
+            data[n] = &cdata[n][csiz[n] * (y / dy[n]) * (w / dx[n])];
         }

         for (x = 0; x < w; ++x) {
@@ -533,9 +591,15 @@
                 UINT32 word = 0;

                 switch (csiz[n]) {
-                case 1: word = *data[n]++; break;
-                case 2: word = *(const UINT16 *)data[n]; data[n] += 2; break;
-                case 4: word = *(const UINT32 *)data[n]; data[n] += 4; break;
+                    case 1:
+                        word = data[n][x / dx[n]];
+                        break;
+                    case 2:
+                        word = ((const UINT16 *)data[n])[x / dx[n]];
+                        break;
+                    case 4:
+                        word = ((const UINT32 *)data[n])[x / dx[n]];
+                        break;
                 }

                 row[n] = j2ku_shift(offsets[n] + word, shifts[n]);
@@ -548,22 +612,22 @@
 }

 static const struct j2k_decode_unpacker j2k_unpackers[] = {
-    { "L", OPJ_CLRSPC_GRAY, 1, j2ku_gray_l },
-    { "I;16", OPJ_CLRSPC_GRAY, 1, j2ku_gray_i },
-    { "I;16B", OPJ_CLRSPC_GRAY, 1, j2ku_gray_i },
-    { "LA", OPJ_CLRSPC_GRAY, 2, j2ku_graya_la },
-    { "RGB", OPJ_CLRSPC_GRAY, 1, j2ku_gray_rgb },
-    { "RGB", OPJ_CLRSPC_GRAY, 2, j2ku_gray_rgb },
-    { "RGB", OPJ_CLRSPC_SRGB, 3, j2ku_srgb_rgb },
-    { "RGB", OPJ_CLRSPC_SYCC, 3, j2ku_sycc_rgb },
-    { "RGB", OPJ_CLRSPC_SRGB, 4, j2ku_srgb_rgb },
-    { "RGB", OPJ_CLRSPC_SYCC, 4, j2ku_sycc_rgb },
-    { "RGBA", OPJ_CLRSPC_GRAY, 1, j2ku_gray_rgb },
-    { "RGBA", OPJ_CLRSPC_GRAY, 2, j2ku_graya_la },
-    { "RGBA", OPJ_CLRSPC_SRGB, 3, j2ku_srgb_rgb },
-    { "RGBA", OPJ_CLRSPC_SYCC, 3, j2ku_sycc_rgb },
-    { "RGBA", OPJ_CLRSPC_SRGB, 4, j2ku_srgba_rgba },
-    { "RGBA", OPJ_CLRSPC_SYCC, 4, j2ku_sycca_rgba },
+    {"L", OPJ_CLRSPC_GRAY, 1, 0, j2ku_gray_l},
+    {"I;16", OPJ_CLRSPC_GRAY, 1, 0, j2ku_gray_i},
+    {"I;16B", OPJ_CLRSPC_GRAY, 1, 0, j2ku_gray_i},
+    {"LA", OPJ_CLRSPC_GRAY, 2, 0, j2ku_graya_la},
+    {"RGB", OPJ_CLRSPC_GRAY, 1, 0, j2ku_gray_rgb},
+    {"RGB", OPJ_CLRSPC_GRAY, 2, 0, j2ku_gray_rgb},
+    {"RGB", OPJ_CLRSPC_SRGB, 3, 1, j2ku_srgb_rgb},
+    {"RGB", OPJ_CLRSPC_SYCC, 3, 1, j2ku_sycc_rgb},
+    {"RGB", OPJ_CLRSPC_SRGB, 4, 1, j2ku_srgb_rgb},
+    {"RGB", OPJ_CLRSPC_SYCC, 4, 1, j2ku_sycc_rgb},
+    {"RGBA", OPJ_CLRSPC_GRAY, 1, 0, j2ku_gray_rgb},
+    {"RGBA", OPJ_CLRSPC_GRAY, 2, 0, j2ku_graya_la},
+    {"RGBA", OPJ_CLRSPC_SRGB, 3, 1, j2ku_srgb_rgb},
+    {"RGBA", OPJ_CLRSPC_SYCC, 3, 1, j2ku_sycc_rgb},
+    {"RGBA", OPJ_CLRSPC_SRGB, 4, 1, j2ku_srgba_rgba},
+    {"RGBA", OPJ_CLRSPC_SYCC, 4, 1, j2ku_sycca_rgba},
 };

 /* -------------------------------------------------------------------- */
@@ -578,9 +642,8 @@
 };

 static int
-j2k_decode_entry(Imaging im, ImagingCodecState state)
-{
-    JPEG2KDECODESTATE *context = (JPEG2KDECODESTATE *) state->context;
+j2k_decode_entry(Imaging im, ImagingCodecState state) {
+    JPEG2KDECODESTATE *context = (JPEG2KDECODESTATE *)state->context;
     opj_stream_t *stream = NULL;
     opj_image_t *image = NULL;
     opj_codec_t *codec = NULL;
@@ -589,8 +652,8 @@
     j2k_unpacker_t unpack = NULL;
     size_t buffer_size = 0, tile_bytes = 0;
     unsigned n, tile_height, tile_width;
-    int components;
-
+    int subsampling;
+    int total_component_width = 0;

     stream = opj_stream_create(BUFFER_SIZE, OPJ_TRUE);

@@ -645,18 +708,23 @@
     }

     /* Check that this image is something we can handle */
-    if (image->numcomps < 1 || image->numcomps > 4
-        || image->color_space == OPJ_CLRSPC_UNKNOWN) {
+    if (image->numcomps < 1 || image->numcomps > 4 ||
+        image->color_space == OPJ_CLRSPC_UNKNOWN) {
         state->errcode = IMAGING_CODEC_BROKEN;
         state->state = J2K_STATE_FAILED;
         goto quick_exit;
     }

-    for (n = 1; n < image->numcomps; ++n) {
+    /*
+     * Find first component with subsampling.
+     *
+     * This is a heuristic to determine the colorspace if unspecified.
+     */
+    subsampling = -1;
+    for (n = 0; n < image->numcomps; ++n) {
         if (image->comps[n].dx != 1 || image->comps[n].dy != 1) {
-            state->errcode = IMAGING_CODEC_BROKEN;
-            state->state = J2K_STATE_FAILED;
-            goto quick_exit;
+            subsampling = n;
+            break;
         }
     }

@@ -672,12 +740,14 @@

        If colorspace is unspecified, we assume:

-           Number of components   Colorspace
-         -----------------------------------------
-           1                      gray
-           2                      gray (+ alpha)
-           3                      sRGB
-           4                      sRGB (+ alpha)
+           Number of components   Subsampling   Colorspace
+         -------------------------------------------------------
+           1                      Any           gray
+           2                      Any           gray (+ alpha)
+           3                      -1, 0         sRGB
+           3                      1, 2          YCbCr
+           4                      -1, 0, 3      sRGB (+ alpha)
+           4                      1, 2          YCbCr (+ alpha)

     */

@@ -686,15 +756,32 @@

     if (color_space == OPJ_CLRSPC_UNSPECIFIED) {
         switch (image->numcomps) {
-        case 1: case 2: color_space = OPJ_CLRSPC_GRAY; break;
-        case 3: case 4: color_space = OPJ_CLRSPC_SRGB; break;
-        }
-    }
-
-    for (n = 0; n < sizeof(j2k_unpackers) / sizeof (j2k_unpackers[0]); ++n) {
-        if (color_space == j2k_unpackers[n].color_space
-            && image->numcomps == j2k_unpackers[n].components
-            && strcmp (im->mode, j2k_unpackers[n].mode) == 0) {
+            case 1:
+            case 2:
+                color_space = OPJ_CLRSPC_GRAY;
+                break;
+            case 3:
+            case 4:
+                switch (subsampling) {
+                    case -1:
+                    case 0:
+                    case 3:
+                        color_space = OPJ_CLRSPC_SRGB;
+                        break;
+                    case 1:
+                    case 2:
+                        color_space = OPJ_CLRSPC_SYCC;
+                        break;
+                }
+            break;
+        }
+    }
+
+    for (n = 0; n < sizeof(j2k_unpackers) / sizeof(j2k_unpackers[0]); ++n) {
+        if (color_space == j2k_unpackers[n].color_space &&
+            image->numcomps == j2k_unpackers[n].components &&
+            (j2k_unpackers[n].subsampling || (subsampling == -1)) &&
+            strcmp(im->mode, j2k_unpackers[n].mode) == 0) {
             unpack = j2k_unpackers[n].unpacker;
             break;
         }
@@ -713,14 +800,17 @@
         OPJ_BOOL should_continue;
         unsigned correction = (1 << params.cp_reduce) - 1;

-        if (!opj_read_tile_header(codec,
-                                  stream,
-                                  &tile_info.tile_index,
-                                  &tile_info.data_size,
-                                  &tile_info.x0, &tile_info.y0,
-                                  &tile_info.x1, &tile_info.y1,
-                                  &tile_info.nb_comps,
-                                  &should_continue)) {
+        if (!opj_read_tile_header(
+                codec,
+                stream,
+                &tile_info.tile_index,
+                &tile_info.data_size,
+                &tile_info.x0,
+                &tile_info.y0,
+                &tile_info.x1,
+                &tile_info.y1,
+                &tile_info.nb_comps,
+                &should_continue)) {
             state->errcode = IMAGING_CODEC_BROKEN;
             state->state = J2K_STATE_FAILED;
             goto quick_exit;
@@ -740,36 +830,51 @@
         /* Check the tile bounds; if the tile is outside the image area,
            or if it has a negative width or height (i.e. the coordinates are
            swapped), bail. */
-        if (tile_info.x0 >= tile_info.x1
-            || tile_info.y0 >= tile_info.y1
-            || tile_info.x0 < 0
-            || tile_info.y0 < 0
-            || (OPJ_UINT32)tile_info.x0 < image->x0
-            || (OPJ_UINT32)tile_info.y0 < image->y0
-            || (OPJ_INT32)(tile_info.x1 - image->x0) > im->xsize
-            || (OPJ_INT32)(tile_info.y1 - image->y0) > im->ysize) {
+        if (tile_info.x0 >= tile_info.x1 || tile_info.y0 >= tile_info.y1 ||
+            tile_info.x0 < 0 || tile_info.y0 < 0 ||
+            (OPJ_UINT32)tile_info.x0 < image->x0 ||
+            (OPJ_UINT32)tile_info.y0 < image->y0 ||
+            (OPJ_INT32)(tile_info.x1 - image->x0) > im->xsize ||
+            (OPJ_INT32)(tile_info.y1 - image->y0) > im->ysize) {
             state->errcode = IMAGING_CODEC_BROKEN;
             state->state = J2K_STATE_FAILED;
             goto quick_exit;
         }

-        /* Sometimes the tile_info.datasize we get back from openjpeg
-           is less than numcomps*w*h, and we overflow in the
-           shuffle stage */
-
-        tile_width = tile_info.x1 - tile_info.x0;
-        tile_height = tile_info.y1 - tile_info.y0;
-        components = tile_info.nb_comps == 3 ? 4 : tile_info.nb_comps;
-        if (( tile_width > UINT_MAX / components ) ||
-            ( tile_height > UINT_MAX / components ) ||
-            ( tile_width > UINT_MAX / (tile_height * components )) ||
-            ( tile_height > UINT_MAX / (tile_width * components ))) {
+        if (tile_info.nb_comps != image->numcomps) {
             state->errcode = IMAGING_CODEC_BROKEN;
             state->state = J2K_STATE_FAILED;
             goto quick_exit;
         }

-        tile_bytes = tile_width * tile_height * components;
+        /* Sometimes the tile_info.datasize we get back from openjpeg
+           is less than sum(comp_bytes)*w*h, and we overflow in the
+           shuffle stage */
+
+        tile_width = tile_info.x1 - tile_info.x0;
+        tile_height = tile_info.y1 - tile_info.y0;
+
+        /* Total component width = sum (component_width) e.g, it's
+         legal for an la file to have a 1 byte width for l, and 4 for
+         a, and then a malicious file could have a smaller tile_bytes
+        */
+
+        for (n=0; n < tile_info.nb_comps; n++) {
+            // see csize /acsize calcs
+            int csize = (image->comps[n].prec + 7) >> 3;
+            csize = (csize == 3) ? 4 : csize;
+            total_component_width += csize;
+        }
+        if ((tile_width > UINT_MAX / total_component_width) ||
+            (tile_height > UINT_MAX / total_component_width) ||
+            (tile_width > UINT_MAX / (tile_height * total_component_width)) ||
+            (tile_height > UINT_MAX / (tile_width * total_component_width))) {
+            state->errcode = IMAGING_CODEC_BROKEN;
+            state->state = J2K_STATE_FAILED;
+            goto quick_exit;
+        }
+
+        tile_bytes = tile_width * tile_height * total_component_width;

         if (tile_bytes > tile_info.data_size) {
             tile_info.data_size = tile_bytes;
@@ -777,22 +882,26 @@

         if (buffer_size < tile_info.data_size) {
             /* malloc check ok, overflow and tile size sanity check above */
-            UINT8 *new = realloc (state->buffer, tile_info.data_size);
+            UINT8 *new = realloc(state->buffer, tile_info.data_size);
             if (!new) {
                 state->errcode = IMAGING_CODEC_MEMORY;
                 state->state = J2K_STATE_FAILED;
                 goto quick_exit;
             }
+            /* Undefined behavior, sometimes decode_tile_data doesn't
+               fill the buffer and we do things with it later, leading
+               to valgrind errors. */
+            memset(new, 0, tile_info.data_size);
             state->buffer = new;
             buffer_size = tile_info.data_size;
         }

-
-        if (!opj_decode_tile_data(codec,
-                                  tile_info.tile_index,
-                                  (OPJ_BYTE *)state->buffer,
-                                  tile_info.data_size,
-                                  stream)) {
+        if (!opj_decode_tile_data(
+                codec,
+                tile_info.tile_index,
+                (OPJ_BYTE *)state->buffer,
+                tile_info.data_size,
+                stream)) {
             state->errcode = IMAGING_CODEC_BROKEN;
             state->state = J2K_STATE_FAILED;
             goto quick_exit;
@@ -811,12 +920,12 @@
     state->errcode = IMAGING_CODEC_END;

     if (context->pfile) {
-        if(fclose(context->pfile)){
+        if (fclose(context->pfile)) {
             context->pfile = NULL;
         }
     }

- quick_exit:
+quick_exit:
     if (codec) {
         opj_destroy_codec(codec);
     }
@@ -831,10 +940,8 @@
 }

 int
-ImagingJpeg2KDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
-
-    if (bytes){
+ImagingJpeg2KDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
+    if (bytes) {
         state->errcode = IMAGING_CODEC_BROKEN;
         state->state = J2K_STATE_FAILED;
         return -1;
@@ -867,7 +974,7 @@
     JPEG2KDECODESTATE *context = (JPEG2KDECODESTATE *)state->context;

     if (context->error_msg) {
-        free ((void *)context->error_msg);
+        free((void *)context->error_msg);
     }

     context->error_msg = NULL;
@@ -876,8 +983,7 @@
 }

 const char *
-ImagingJpeg2KVersion(void)
-{
+ImagingJpeg2KVersion(void) {
     return opj_version();
 }

('src/libImaging', 'PcxEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,7 +13,6 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 enum { INIT, FETCH, ENCODE };
@@ -22,9 +21,8 @@
 #define LAST ystep

 int
-ImagingPcxEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)
-{
-    UINT8* ptr;
+ImagingPcxEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes) {
+    UINT8 *ptr;
     int this;
     int bytes_per_line = 0;
     int padding = 0;
@@ -45,12 +43,12 @@
     }

     bpp = state->bits;
-    if (state->bits == 24){
+    if (state->bits == 24) {
         planes = 3;
         bpp = 8;
     }

-    bytes_per_line = (state->xsize*bpp + 7) / 8;
+    bytes_per_line = (state->xsize * bpp + 7) / 8;
     /* The stride here needs to be kept in sync with the version in
        PcxImagePlugin.py. If it's not, the header and the body of the
        image will be out of sync and bad things will happen on decode.
@@ -59,133 +57,131 @@

     padding = stride - bytes_per_line;

+    for (;;) {
+        switch (state->state) {
+            case FETCH:

-    for (;;) {
+                /* get a line of data */
+                if (state->y >= state->ysize) {
+                    state->errcode = IMAGING_CODEC_END;
+                    return ptr - buf;
+                }

-        switch (state->state) {
-        case FETCH:
+                state->shuffle(
+                    state->buffer,
+                    (UINT8 *)im->image[state->y + state->yoff] +
+                        state->xoff * im->pixelsize,
+                    state->xsize);

-            /* get a line of data */
-            if (state->y >= state->ysize) {
-                state->errcode = IMAGING_CODEC_END;
-                return ptr - buf;
-            }
+                state->y += 1;

-            state->shuffle(state->buffer,
-                           (UINT8*) im->image[state->y + state->yoff] +
-                           state->xoff * im->pixelsize, state->xsize);
+                state->count = 1;
+                state->LAST = state->buffer[0];

-            state->y += 1;
+                state->x = 1;

-            state->count = 1;
-            state->LAST = state->buffer[0];
+                state->state = ENCODE;
+                /* fall through */

-            state->x = 1;
+            case ENCODE:
+                /* compress this line */

-            state->state = ENCODE;
-            /* fall through */
+                /* when we arrive here, "count" contains the number of
+                   bytes having the value of "LAST" that we've already
+                   seen */
+                do {
+                    /* If we're encoding an odd width file, and we've
+                       got more than one plane, we need to pad each
+                       color row with padding bytes at the end. Since
+                       The pixels are stored RRRRRGGGGGBBBBB, so we need
+                       to have the padding be RRRRRPGGGGGPBBBBBP. Hence
+                       the double loop
+                    */
+                    while (state->x % bytes_per_line) {
+                        if (state->count == 63) {
+                            /* this run is full; flush it */
+                            if (bytes < 2) {
+                                return ptr - buf;
+                            }
+                            ptr[0] = 0xff;
+                            ptr[1] = state->LAST;
+                            ptr += 2;
+                            bytes -= 2;

-        case ENCODE:
-            /* compress this line */
+                            state->count = 0;
+                        }

-            /* when we arrive here, "count" contains the number of
-               bytes having the value of "LAST" that we've already
-               seen */
-            do {
-                /* If we're encoding an odd width file, and we've
-                   got more than one plane, we need to pad each
-                   color row with padding bytes at the end. Since
-                   The pixels are stored RRRRRGGGGGBBBBB, so we need
-                   to have the padding be RRRRRPGGGGGPBBBBBP. Hence
-                   the double loop
-                */
-                while (state->x % bytes_per_line) {
+                        this = state->buffer[state->x];

-                    if (state->count == 63) {
-                        /* this run is full; flush it */
-                        if (bytes < 2) {
+                        if (this == state->LAST) {
+                            /* extend the current run */
+                            state->x += 1;
+                            state->count += 1;
+
+                        } else {
+                            /* start a new run */
+                            if (state->count == 1 && (state->LAST < 0xc0)) {
+                                if (bytes < 1) {
+                                    return ptr - buf;
+                                }
+                                ptr[0] = state->LAST;
+                                ptr += 1;
+                                bytes -= 1;
+                            } else {
+                                if (state->count > 0) {
+                                    if (bytes < 2) {
+                                        return ptr - buf;
+                                    }
+                                    ptr[0] = 0xc0 | state->count;
+                                    ptr[1] = state->LAST;
+                                    ptr += 2;
+                                    bytes -= 2;
+                                }
+                            }
+
+                            state->LAST = this;
+                            state->count = 1;
+
+                            state->x += 1;
+                        }
+                    }
+
+                    /* end of line; flush the current run */
+                    if (state->count == 1 && (state->LAST < 0xc0)) {
+                        if (bytes < 1 + padding) {
                             return ptr - buf;
                         }
-                        ptr[0] = 0xff;
-                        ptr[1] = state->LAST;
-                        ptr += 2;
-                        bytes -= 2;
-
-                        state->count = 0;
-                    }
-
-                    this = state->buffer[state->x];
-
-                    if (this == state->LAST) {
-                        /* extend the current run */
-                        state->x += 1;
-                        state->count += 1;
-
+                        ptr[0] = state->LAST;
+                        ptr += 1;
+                        bytes -= 1;
                     } else {
-                        /* start a new run */
-                        if (state->count == 1 && (state->LAST < 0xc0)) {
-                            if (bytes < 1) {
+                        if (state->count > 0) {
+                            if (bytes < 2 + padding) {
                                 return ptr - buf;
                             }
-                            ptr[0] = state->LAST;
-                            ptr += 1;
-                            bytes -= 1;
-                        } else {
-                            if (state->count > 0) {
-                                if (bytes < 2) {
-                                    return ptr - buf;
-                                }
-                                ptr[0] = 0xc0 | state->count;
-                                ptr[1] = state->LAST;
-                                ptr += 2;
-                                bytes -= 2;
-                            }
+                            ptr[0] = 0xc0 | state->count;
+                            ptr[1] = state->LAST;
+                            ptr += 2;
+                            bytes -= 2;
                         }
-
-                        state->LAST = this;
+                    }
+                    /* add the padding */
+                    for (i = 0; i < padding; i++) {
+                        ptr[0] = 0;
+                        ptr += 1;
+                        bytes -= 1;
+                    }
+                    /* reset for the next color plane. */
+                    if (state->x < planes * bytes_per_line) {
                         state->count = 1;
-
+                        state->LAST = state->buffer[state->x];
                         state->x += 1;
                     }
-                }
+                } while (state->x < planes * bytes_per_line);

-                /* end of line; flush the current run */
-                if (state->count == 1 && (state->LAST < 0xc0)) {
-                    if (bytes < 1 + padding) {
-                        return ptr - buf;
-                    }
-                    ptr[0] = state->LAST;
-                    ptr += 1;
-                    bytes -= 1;
-                } else {
-                    if (state->count > 0) {
-                        if (bytes < 2 + padding) {
-                            return ptr - buf;
-                        }
-                        ptr[0] = 0xc0 | state->count;
-                        ptr[1] = state->LAST;
-                        ptr += 2;
-                        bytes -= 2;
-                    }
-                }
-                /* add the padding */
-                for (i = 0; i < padding; i++) {
-                    ptr[0] = 0;
-                    ptr += 1;
-                    bytes -= 1;
-                }
-                /* reset for the next color plane. */
-                if (state->x < planes * bytes_per_line) {
-                    state->count = 1;
-                    state->LAST = state->buffer[state->x];
-                    state->x += 1;
-                }
-            } while (state->x < planes * bytes_per_line);
-
-            /* read next line */
-            state->state = FETCH;
-            break;
+                /* read next line */
+                state->state = FETCH;
+                break;
         }
     }
 }
-
('src/libImaging', 'PcdDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,24 +19,20 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 int
-ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
+ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
     int x;
     int chunk;
-    UINT8* out;
-    UINT8* ptr;
+    UINT8 *out;
+    UINT8 *ptr;

     ptr = buf;

     chunk = 3 * state->xsize;

     for (;;) {
-
         /* We need data for two full lines before we can do anything */
         if (bytes < chunk) {
             return ptr - buf;
@@ -46,13 +42,12 @@
         out = state->buffer;
         for (x = 0; x < state->xsize; x++) {
             out[0] = ptr[x];
-            out[1] = ptr[(x+4*state->xsize)/2];
-            out[2] = ptr[(x+5*state->xsize)/2];
+            out[1] = ptr[(x + 4 * state->xsize) / 2];
+            out[2] = ptr[(x + 5 * state->xsize) / 2];
             out += 3;
         }

-        state->shuffle((UINT8*) im->image[state->y],
-                   state->buffer, state->xsize);
+        state->shuffle((UINT8 *)im->image[state->y], state->buffer, state->xsize);

         if (++state->y >= state->ysize) {
             return -1; /* This can hardly happen */
@@ -61,14 +56,13 @@
         /* Unpack second line */
         out = state->buffer;
         for (x = 0; x < state->xsize; x++) {
-            out[0] = ptr[x+state->xsize];
-            out[1] = ptr[(x+4*state->xsize)/2];
-            out[2] = ptr[(x+5*state->xsize)/2];
+            out[0] = ptr[x + state->xsize];
+            out[1] = ptr[(x + 4 * state->xsize) / 2];
+            out[2] = ptr[(x + 5 * state->xsize) / 2];
             out += 3;
         }

-        state->shuffle((UINT8*) im->image[state->y],
-                   state->buffer, state->xsize);
+        state->shuffle((UINT8 *)im->image[state->y], state->buffer, state->xsize);

         if (++state->y >= state->ysize) {
             return -1;
@@ -76,6 +70,5 @@

         ptr += chunk;
         bytes -= chunk;
-
     }
 }
('src/libImaging', 'Palette.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,46 +16,42 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #include <math.h>

-
 ImagingPalette
-ImagingPaletteNew(const char* mode)
-{
+ImagingPaletteNew(const char *mode) {
     /* Create a palette object */

     int i;
     ImagingPalette palette;

     if (strcmp(mode, "RGB") && strcmp(mode, "RGBA")) {
-        return (ImagingPalette) ImagingError_ModeError();
+        return (ImagingPalette)ImagingError_ModeError();
     }

     palette = calloc(1, sizeof(struct ImagingPaletteInstance));
     if (!palette) {
-        return (ImagingPalette) ImagingError_MemoryError();
-    }
-
-    strncpy(palette->mode, mode, IMAGING_MODE_LENGTH-1);
-    palette->mode[IMAGING_MODE_LENGTH-1] = 0;
+        return (ImagingPalette)ImagingError_MemoryError();
+    }
+
+    strncpy(palette->mode, mode, IMAGING_MODE_LENGTH - 1);
+    palette->mode[IMAGING_MODE_LENGTH - 1] = 0;

     /* Initialize to ramp */
+    palette->size = 256;
     for (i = 0; i < 256; i++) {
-        palette->palette[i*4+0] =
-        palette->palette[i*4+1] =
-        palette->palette[i*4+2] = (UINT8) i;
-        palette->palette[i*4+3] = 255; /* opaque */
+        palette->palette[i * 4 + 0] = palette->palette[i * 4 + 1] =
+            palette->palette[i * 4 + 2] = (UINT8)i;
+        palette->palette[i * 4 + 3] = 255; /* opaque */
     }

     return palette;
 }

 ImagingPalette
-ImagingPaletteNewBrowser(void)
-{
+ImagingPaletteNewBrowser(void) {
     /* Create a standard "browser" palette object */

     int i, r, g, b;
@@ -70,9 +66,8 @@
     /* FIXME: Add 10-level windows palette here? */

     for (i = 0; i < 10; i++) {
-        palette->palette[i*4+0] =
-        palette->palette[i*4+1] =
-        palette->palette[i*4+2] = 0;
+        palette->palette[i * 4 + 0] = palette->palette[i * 4 + 1] =
+            palette->palette[i * 4 + 2] = 0;
     }

     /* Simple 6x6x6 colour cube */
@@ -80,9 +75,9 @@
     for (b = 0; b < 256; b += 51) {
         for (g = 0; g < 256; g += 51) {
             for (r = 0; r < 256; r += 51) {
-                palette->palette[i*4+0] = r;
-                palette->palette[i*4+1] = g;
-                palette->palette[i*4+2] = b;
+                palette->palette[i * 4 + 0] = r;
+                palette->palette[i * 4 + 1] = g;
+                palette->palette[i * 4 + 2] = b;
                 i++;
             }
         }
@@ -92,17 +87,15 @@
     /* FIXME: add 30-level greyscale wedge here? */

     for (; i < 256; i++) {
-        palette->palette[i*4+0] =
-        palette->palette[i*4+1] =
-        palette->palette[i*4+2] = 0;
+        palette->palette[i * 4 + 0] = palette->palette[i * 4 + 1] =
+            palette->palette[i * 4 + 2] = 0;
     }

     return palette;
 }

 ImagingPalette
-ImagingPaletteDuplicate(ImagingPalette palette)
-{
+ImagingPaletteDuplicate(ImagingPalette palette) {
     /* Duplicate palette descriptor */

     ImagingPalette new_palette;
@@ -113,7 +106,7 @@
     /* malloc check ok, small constant allocation */
     new_palette = malloc(sizeof(struct ImagingPaletteInstance));
     if (!new_palette) {
-        return (ImagingPalette) ImagingError_MemoryError();
+        return (ImagingPalette)ImagingError_MemoryError();
     }

     memcpy(new_palette, palette, sizeof(struct ImagingPaletteInstance));
@@ -125,8 +118,7 @@
 }

 void
-ImagingPaletteDelete(ImagingPalette palette)
-{
+ImagingPaletteDelete(ImagingPalette palette) {
     /* Destroy palette object */

     if (palette) {
@@ -136,7 +128,6 @@
         free(palette);
     }
 }
-

 /* -------------------------------------------------------------------- */
 /* Colour mapping                                                       */
@@ -155,27 +146,26 @@
 #define DIST(a, b, s) (a - b) * (a - b) * s

 /* Colour weights (no scaling, for now) */
-#define RSCALE  1
-#define GSCALE  1
-#define BSCALE  1
+#define RSCALE 1
+#define GSCALE 1
+#define BSCALE 1

 /* Calculated scaled distances */
-#define RDIST(a, b) DIST(a, b, RSCALE*RSCALE)
-#define GDIST(a, b) DIST(a, b, GSCALE*GSCALE)
-#define BDIST(a, b) DIST(a, b, BSCALE*BSCALE)
+#define RDIST(a, b) DIST(a, b, RSCALE *RSCALE)
+#define GDIST(a, b) DIST(a, b, GSCALE *GSCALE)
+#define BDIST(a, b) DIST(a, b, BSCALE *BSCALE)

 /* Incremental steps */
-#define RSTEP   (4 * RSCALE)
-#define GSTEP   (4 * GSCALE)
-#define BSTEP   (4 * BSCALE)
-
-#define BOX     8
-
-#define BOXVOLUME BOX*BOX*BOX
+#define RSTEP (4 * RSCALE)
+#define GSTEP (4 * GSCALE)
+#define BSTEP (4 * BSCALE)
+
+#define BOX 8
+
+#define BOXVOLUME BOX *BOX *BOX

 void
-ImagingPaletteCacheUpdate(ImagingPalette palette, int r, int g, int b)
-{
+ImagingPaletteCacheUpdate(ImagingPalette palette, int r, int g, int b) {
     int i, j;
     unsigned int dmin[256], dmax;
     int r0, g0, b0;
@@ -187,32 +177,37 @@
     /* Get box boundaries for the given (r,g,b)-triplet.  Each box
        covers eight cache slots (32 colour values, that is). */

-    r0 = r & 0xe0; r1 = r0 + 0x1f; rc = (r0 + r1) / 2;
-    g0 = g & 0xe0; g1 = g0 + 0x1f; gc = (g0 + g1) / 2;
-    b0 = b & 0xe0; b1 = b0 + 0x1f; bc = (b0 + b1) / 2;
+    r0 = r & 0xe0;
+    r1 = r0 + 0x1f;
+    rc = (r0 + r1) / 2;
+    g0 = g & 0xe0;
+    g1 = g0 + 0x1f;
+    gc = (g0 + g1) / 2;
+    b0 = b & 0xe0;
+    b1 = b0 + 0x1f;
+    bc = (b0 + b1) / 2;

     /* Step 1 -- Select relevant palette entries (after Heckbert) */

     /* For each palette entry, calculate the min and max distances to
      * any position in the box given by the colour we're looking for. */

-    dmax = (unsigned int) ~0;
-
-    for (i = 0; i < 256; i++) {
-
+    dmax = (unsigned int)~0;
+
+    for (i = 0; i < palette->size; i++) {
         int r, g, b;
         unsigned int tmin, tmax;

         /* Find min and max distances to any point in the box */
-        r = palette->palette[i*4+0];
+        r = palette->palette[i * 4 + 0];
         tmin = (r < r0) ? RDIST(r, r1) : (r > r1) ? RDIST(r, r0) : 0;
         tmax = (r <= rc) ? RDIST(r, r1) : RDIST(r, r0);

-        g = palette->palette[i*4+1];
+        g = palette->palette[i * 4 + 1];
         tmin += (g < g0) ? GDIST(g, g1) : (g > g1) ? GDIST(g, g0) : 0;
         tmax += (g <= gc) ? GDIST(g, g1) : GDIST(g, g0);

-        b = palette->palette[i*4+2];
+        b = palette->palette[i * 4 + 2];
         tmin += (b < b0) ? BDIST(b, b1) : (b > b1) ? BDIST(b, b0) : 0;
         tmax += (b <= bc) ? BDIST(b, b1) : BDIST(b, b0);

@@ -220,7 +215,6 @@
         if (tmax < dmax) {
             dmax = tmax; /* keep the smallest max distance only */
         }
-
     }

     /* Step 2 -- Incrementally update cache slot (after Thomas) */
@@ -230,22 +224,20 @@
      * distance is less than or equal the smallest max distance */

     for (i = 0; i < BOXVOLUME; i++) {
-        d[i] = (unsigned int) ~0;
-    }
-
-    for (i = 0; i < 256; i++) {
-
+        d[i] = (unsigned int)~0;
+    }
+
+    for (i = 0; i < palette->size; i++) {
         if (dmin[i] <= dmax) {
-
             int rd, gd, bd;
             int ri, gi, bi;
             int rx, gx, bx;

-            ri = (r0 - palette->palette[i*4+0]) * RSCALE;
-            gi = (g0 - palette->palette[i*4+1]) * GSCALE;
-            bi = (b0 - palette->palette[i*4+2]) * BSCALE;
-
-            rd = ri*ri + gi*gi + bi*bi;
+            ri = (r0 - palette->palette[i * 4 + 0]) * RSCALE;
+            gi = (g0 - palette->palette[i * 4 + 1]) * GSCALE;
+            bi = (b0 - palette->palette[i * 4 + 2]) * BSCALE;
+
+            rd = ri * ri + gi * gi + bi * bi;

             ri = ri * (2 * RSTEP) + RSTEP * RSTEP;
             gi = gi * (2 * GSTEP) + GSTEP * GSTEP;
@@ -253,13 +245,15 @@

             rx = ri;
             for (r = j = 0; r < BOX; r++) {
-                gd = rd; gx = gi;
+                gd = rd;
+                gx = gi;
                 for (g = 0; g < BOX; g++) {
-                    bd = gd; bx = bi;
+                    bd = gd;
+                    bx = bi;
                     for (b = 0; b < BOX; b++) {
-                        if ((unsigned int) bd < d[j]) {
+                        if ((unsigned int)bd < d[j]) {
                             d[j] = bd;
-                            c[j] = (UINT8) i;
+                            c[j] = (UINT8)i;
                         }
                         bd += bx;
                         bx += 2 * BSTEP * BSTEP;
@@ -280,33 +274,30 @@
      * cache slot in the box.  Update the cache. */

     j = 0;
-    for (r = r0; r < r1; r+=4) {
-        for (g = g0; g < g1; g+=4) {
-            for (b = b0; b < b1; b+=4) {
+    for (r = r0; r < r1; r += 4) {
+        for (g = g0; g < g1; g += 4) {
+            for (b = b0; b < b1; b += 4) {
                 ImagingPaletteCache(palette, r, g, b) = c[j++];
             }
         }
     }
 }

-
 int
-ImagingPaletteCachePrepare(ImagingPalette palette)
-{
+ImagingPaletteCachePrepare(ImagingPalette palette) {
     /* Add a colour cache to a palette */

     int i;
-    int entries = 64*64*64;
+    int entries = 64 * 64 * 64;

     if (palette->cache == NULL) {
-
         /* The cache is 512k.  It might be a good idea to break it
            up into a pointer array (e.g. an 8-bit image?) */

         /* malloc check ok, small constant allocation */
-        palette->cache = (INT16*) malloc(entries * sizeof(INT16));
+        palette->cache = (INT16 *)malloc(entries * sizeof(INT16));
         if (!palette->cache) {
-            (void) ImagingError_MemoryError();
+            (void)ImagingError_MemoryError();
             return -1;
         }

@@ -314,16 +305,13 @@
         for (i = 0; i < entries; i++) {
             palette->cache[i] = 0x100;
         }
-
     }

     return 0;
 }

-
 void
-ImagingPaletteCacheDelete(ImagingPalette palette)
-{
+ImagingPaletteCacheDelete(ImagingPalette palette) {
     /* Release the colour cache, if any */

     if (palette && palette->cache) {
('src/libImaging', 'QuantHash.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,290 +24,313 @@
 #include "QuantHash.h"

 typedef struct _HashNode {
-   struct _HashNode *next;
-   HashKey_t key;
-   HashVal_t value;
+    struct _HashNode *next;
+    HashKey_t key;
+    HashVal_t value;
 } HashNode;

 struct _HashTable {
-   HashNode **table;
-   uint32_t length;
-   uint32_t count;
-   HashFunc hashFunc;
-   HashCmpFunc cmpFunc;
-   void *userData;
+    HashNode **table;
+    uint32_t length;
+    uint32_t count;
+    HashFunc hashFunc;
+    HashCmpFunc cmpFunc;
+    void *userData;
 };

 #define MIN_LENGTH 11
 #define RESIZE_FACTOR 3

-static int _hashtable_insert_node(HashTable *,HashNode *,int,int,CollisionFunc);
-
-HashTable *hashtable_new(HashFunc hf,HashCmpFunc cf) {
-   HashTable *h;
-   h=malloc(sizeof(HashTable));
-   if (!h) { return NULL; }
-   h->hashFunc=hf;
-   h->cmpFunc=cf;
-   h->length=MIN_LENGTH;
-   h->count=0;
-   h->userData=NULL;
-   h->table=malloc(sizeof(HashNode *)*h->length);
-   if (!h->table) { free(h); return NULL; }
-   memset (h->table,0,sizeof(HashNode *)*h->length);
-   return h;
-}
-
-static uint32_t _findPrime(uint32_t start,int dir) {
-   static int unit[]={0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,0};
-   uint32_t t;
-   while (start>1) {
-      if (!unit[start&0x0f]) {
-         start+=dir;
-         continue;
-      }
-      for (t=2;t<sqrt((double)start);t++) {
-         if (!start%t) {
-             break;
-         }
-      }
-      if (t>=sqrt((double)start)) {
-         break;
-      }
-      start+=dir;
-   }
-   return start;
-}
-
-static void _hashtable_rehash(HashTable *h,CollisionFunc cf,uint32_t newSize) {
-   HashNode **oldTable=h->table;
-   uint32_t i;
-   HashNode *n,*nn;
-   uint32_t oldSize;
-   oldSize=h->length;
-   h->table=malloc(sizeof(HashNode *)*newSize);
-   if (!h->table) {
-      h->table=oldTable;
-      return;
-   }
-   h->length=newSize;
-   h->count=0;
-   memset (h->table,0,sizeof(HashNode *)*h->length);
-   for (i=0;i<oldSize;i++) {
-      for (n=oldTable[i];n;n=nn) {
-         nn=n->next;
-         _hashtable_insert_node(h,n,0,0,cf);
-      }
-   }
-   free(oldTable);
-}
-
-static void _hashtable_resize(HashTable *h) {
-   uint32_t newSize;
-   uint32_t oldSize;
-   oldSize=h->length;
-   newSize=oldSize;
-   if (h->count*RESIZE_FACTOR<h->length) {
-      newSize=_findPrime(h->length/2-1,-1);
-   } else  if (h->length*RESIZE_FACTOR<h->count) {
-      newSize=_findPrime(h->length*2+1,+1);
-   }
-   if (newSize<MIN_LENGTH) { newSize=oldSize; }
-   if (newSize!=oldSize) {
-      _hashtable_rehash(h,NULL,newSize);
-   }
-}
-
-static int _hashtable_insert_node(HashTable *h,HashNode *node,int resize,int update,CollisionFunc cf) {
-   uint32_t hash=h->hashFunc(h,node->key)%h->length;
-   HashNode **n,*nv;
-   int i;
-
-   for (n=&(h->table[hash]);*n;n=&((*n)->next)) {
-      nv=*n;
-      i=h->cmpFunc(h,nv->key,node->key);
-      if (!i) {
-         if (cf) {
-            nv->key=node->key;
-            cf(h,&(nv->key),&(nv->value),node->key,node->value);
-            free(node);
+static int
+_hashtable_insert_node(HashTable *, HashNode *, int, int, CollisionFunc);
+
+HashTable *
+hashtable_new(HashFunc hf, HashCmpFunc cf) {
+    HashTable *h;
+    h = malloc(sizeof(HashTable));
+    if (!h) {
+        return NULL;
+    }
+    h->hashFunc = hf;
+    h->cmpFunc = cf;
+    h->length = MIN_LENGTH;
+    h->count = 0;
+    h->userData = NULL;
+    h->table = malloc(sizeof(HashNode *) * h->length);
+    if (!h->table) {
+        free(h);
+        return NULL;
+    }
+    memset(h->table, 0, sizeof(HashNode *) * h->length);
+    return h;
+}
+
+static uint32_t
+_findPrime(uint32_t start, int dir) {
+    static int unit[] = {0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0};
+    uint32_t t;
+    while (start > 1) {
+        if (!unit[start & 0x0f]) {
+            start += dir;
+            continue;
+        }
+        for (t = 2; t < sqrt((double)start); t++) {
+            if (!start % t) {
+                break;
+            }
+        }
+        if (t >= sqrt((double)start)) {
+            break;
+        }
+        start += dir;
+    }
+    return start;
+}
+
+static void
+_hashtable_rehash(HashTable *h, CollisionFunc cf, uint32_t newSize) {
+    HashNode **oldTable = h->table;
+    uint32_t i;
+    HashNode *n, *nn;
+    uint32_t oldSize;
+    oldSize = h->length;
+    h->table = malloc(sizeof(HashNode *) * newSize);
+    if (!h->table) {
+        h->table = oldTable;
+        return;
+    }
+    h->length = newSize;
+    h->count = 0;
+    memset(h->table, 0, sizeof(HashNode *) * h->length);
+    for (i = 0; i < oldSize; i++) {
+        for (n = oldTable[i]; n; n = nn) {
+            nn = n->next;
+            _hashtable_insert_node(h, n, 0, 0, cf);
+        }
+    }
+    free(oldTable);
+}
+
+static void
+_hashtable_resize(HashTable *h) {
+    uint32_t newSize;
+    uint32_t oldSize;
+    oldSize = h->length;
+    newSize = oldSize;
+    if (h->count * RESIZE_FACTOR < h->length) {
+        newSize = _findPrime(h->length / 2 - 1, -1);
+    } else if (h->length * RESIZE_FACTOR < h->count) {
+        newSize = _findPrime(h->length * 2 + 1, +1);
+    }
+    if (newSize < MIN_LENGTH) {
+        newSize = oldSize;
+    }
+    if (newSize != oldSize) {
+        _hashtable_rehash(h, NULL, newSize);
+    }
+}
+
+static int
+_hashtable_insert_node(
+    HashTable *h, HashNode *node, int resize, int update, CollisionFunc cf) {
+    uint32_t hash = h->hashFunc(h, node->key) % h->length;
+    HashNode **n, *nv;
+    int i;
+
+    for (n = &(h->table[hash]); *n; n = &((*n)->next)) {
+        nv = *n;
+        i = h->cmpFunc(h, nv->key, node->key);
+        if (!i) {
+            if (cf) {
+                nv->key = node->key;
+                cf(h, &(nv->key), &(nv->value), node->key, node->value);
+                free(node);
+                return 1;
+            } else {
+                nv->key = node->key;
+                nv->value = node->value;
+                free(node);
+                return 1;
+            }
+        } else if (i > 0) {
+            break;
+        }
+    }
+    if (!update) {
+        node->next = *n;
+        *n = node;
+        h->count++;
+        if (resize) {
+            _hashtable_resize(h);
+        }
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+static int
+_hashtable_insert(HashTable *h, HashKey_t key, HashVal_t val, int resize, int update) {
+    HashNode **n, *nv;
+    HashNode *t;
+    int i;
+    uint32_t hash = h->hashFunc(h, key) % h->length;
+
+    for (n = &(h->table[hash]); *n; n = &((*n)->next)) {
+        nv = *n;
+        i = h->cmpFunc(h, nv->key, key);
+        if (!i) {
+            nv->value = val;
             return 1;
-         } else {
-            nv->key=node->key;
-            nv->value=node->value;
-            free(node);
+        } else if (i > 0) {
+            break;
+        }
+    }
+    if (!update) {
+        t = malloc(sizeof(HashNode));
+        if (!t) {
+            return 0;
+        }
+        t->next = *n;
+        *n = t;
+        t->key = key;
+        t->value = val;
+        h->count++;
+        if (resize) {
+            _hashtable_resize(h);
+        }
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+int
+hashtable_insert_or_update_computed(
+    HashTable *h, HashKey_t key, ComputeFunc newFunc, ComputeFunc existsFunc) {
+    HashNode **n, *nv;
+    HashNode *t;
+    int i;
+    uint32_t hash = h->hashFunc(h, key) % h->length;
+
+    for (n = &(h->table[hash]); *n; n = &((*n)->next)) {
+        nv = *n;
+        i = h->cmpFunc(h, nv->key, key);
+        if (!i) {
+            if (existsFunc) {
+                existsFunc(h, nv->key, &(nv->value));
+            } else {
+                return 0;
+            }
             return 1;
-         }
-      } else if (i>0) {
-         break;
-      }
-   }
-   if (!update) {
-      node->next=*n;
-      *n=node;
-      h->count++;
-      if (resize) {
-          _hashtable_resize(h);
-      }
-      return 1;
-   } else {
-      return 0;
-   }
-}
-
-static int _hashtable_insert(HashTable *h,HashKey_t key,HashVal_t val,int resize,int update) {
-   HashNode **n,*nv;
-   HashNode *t;
-   int i;
-   uint32_t hash=h->hashFunc(h,key)%h->length;
-
-   for (n=&(h->table[hash]);*n;n=&((*n)->next)) {
-      nv=*n;
-      i=h->cmpFunc(h,nv->key,key);
-      if (!i) {
-         nv->value=val;
-         return 1;
-      } else if (i>0) {
-         break;
-      }
-   }
-   if (!update) {
-      t=malloc(sizeof(HashNode));
-      if (!t) {
-          return 0;
-      }
-      t->next=*n;
-      *n=t;
-      t->key=key;
-      t->value=val;
-      h->count++;
-      if (resize) {
-          _hashtable_resize(h);
-      }
-      return 1;
-   } else {
-      return 0;
-   }
-}
-
-int hashtable_insert_or_update_computed(HashTable *h,
-                                        HashKey_t key,
-                                        ComputeFunc newFunc,
-                                        ComputeFunc existsFunc) {
-   HashNode **n,*nv;
-   HashNode *t;
-   int i;
-   uint32_t hash=h->hashFunc(h,key)%h->length;
-
-   for (n=&(h->table[hash]);*n;n=&((*n)->next)) {
-      nv=*n;
-      i=h->cmpFunc(h,nv->key,key);
-      if (!i) {
-         if (existsFunc) {
-            existsFunc(h,nv->key,&(nv->value));
-         } else {
-            return 0;
-         }
-         return 1;
-      } else if (i>0) {
-         break;
-      }
-   }
-   t=malloc(sizeof(HashNode));
-   if (!t) {
-       return 0;
-   }
-   t->key=key;
-   t->next=*n;
-   *n=t;
-   if (newFunc) {
-      newFunc(h,t->key,&(t->value));
-   } else {
-      free(t);
-      return 0;
-   }
-   h->count++;
-   _hashtable_resize(h);
-   return 1;
-}
-
-int hashtable_insert(HashTable *h,HashKey_t key,HashVal_t val) {
-   return _hashtable_insert(h,key,val,1,0);
-}
-
-void hashtable_foreach_update(HashTable *h,IteratorUpdateFunc i,void *u) {
-   HashNode *n;
-   uint32_t x;
-
-   if (h->table) {
-      for (x=0;x<h->length;x++) {
-         for (n=h->table[x];n;n=n->next) {
-            i(h,n->key,&(n->value),u);
-         }
-      }
-   }
-}
-
-void hashtable_foreach(HashTable *h,IteratorFunc i,void *u) {
-   HashNode *n;
-   uint32_t x;
-
-   if (h->table) {
-      for (x=0;x<h->length;x++) {
-         for (n=h->table[x];n;n=n->next) {
-            i(h,n->key,n->value,u);
-         }
-      }
-   }
-}
-
-void hashtable_free(HashTable *h) {
-   HashNode *n,*nn;
-   uint32_t i;
-
-   if (h->table) {
-      for (i=0;i<h->length;i++) {
-         for (n=h->table[i];n;n=nn) {
-            nn=n->next;
-            free(n);
-         }
-      }
-      free(h->table);
-   }
-   free(h);
-}
-
-void hashtable_rehash_compute(HashTable *h,CollisionFunc cf) {
-   _hashtable_rehash(h,cf,h->length);
-}
-
-int hashtable_lookup(const HashTable *h,const HashKey_t key,HashVal_t *valp) {
-   uint32_t hash=h->hashFunc(h,key)%h->length;
-   HashNode *n;
-   int i;
-
-   for (n=h->table[hash];n;n=n->next) {
-      i=h->cmpFunc(h,n->key,key);
-      if (!i) {
-         *valp=n->value;
-         return 1;
-      } else if (i>0) {
-         break;
-      }
-   }
-   return 0;
-}
-
-uint32_t hashtable_get_count(const HashTable *h) {
-   return h->count;
-}
-
-void *hashtable_get_user_data(const HashTable *h) {
-   return h->userData;
-}
-
-void *hashtable_set_user_data(HashTable *h,void *data) {
-   void *r=h->userData;
-   h->userData=data;
-   return r;
-}
+        } else if (i > 0) {
+            break;
+        }
+    }
+    t = malloc(sizeof(HashNode));
+    if (!t) {
+        return 0;
+    }
+    t->key = key;
+    t->next = *n;
+    *n = t;
+    if (newFunc) {
+        newFunc(h, t->key, &(t->value));
+    } else {
+        free(t);
+        return 0;
+    }
+    h->count++;
+    _hashtable_resize(h);
+    return 1;
+}
+
+int
+hashtable_insert(HashTable *h, HashKey_t key, HashVal_t val) {
+    return _hashtable_insert(h, key, val, 1, 0);
+}
+
+void
+hashtable_foreach_update(HashTable *h, IteratorUpdateFunc i, void *u) {
+    HashNode *n;
+    uint32_t x;
+
+    if (h->table) {
+        for (x = 0; x < h->length; x++) {
+            for (n = h->table[x]; n; n = n->next) {
+                i(h, n->key, &(n->value), u);
+            }
+        }
+    }
+}
+
+void
+hashtable_foreach(HashTable *h, IteratorFunc i, void *u) {
+    HashNode *n;
+    uint32_t x;
+
+    if (h->table) {
+        for (x = 0; x < h->length; x++) {
+            for (n = h->table[x]; n; n = n->next) {
+                i(h, n->key, n->value, u);
+            }
+        }
+    }
+}
+
+void
+hashtable_free(HashTable *h) {
+    HashNode *n, *nn;
+    uint32_t i;
+
+    if (h->table) {
+        for (i = 0; i < h->length; i++) {
+            for (n = h->table[i]; n; n = nn) {
+                nn = n->next;
+                free(n);
+            }
+        }
+        free(h->table);
+    }
+    free(h);
+}
+
+void
+hashtable_rehash_compute(HashTable *h, CollisionFunc cf) {
+    _hashtable_rehash(h, cf, h->length);
+}
+
+int
+hashtable_lookup(const HashTable *h, const HashKey_t key, HashVal_t *valp) {
+    uint32_t hash = h->hashFunc(h, key) % h->length;
+    HashNode *n;
+    int i;
+
+    for (n = h->table[hash]; n; n = n->next) {
+        i = h->cmpFunc(h, n->key, key);
+        if (!i) {
+            *valp = n->value;
+            return 1;
+        } else if (i > 0) {
+            break;
+        }
+    }
+    return 0;
+}
+
+uint32_t
+hashtable_get_count(const HashTable *h) {
+    return h->count;
+}
+
+void *
+hashtable_get_user_data(const HashTable *h) {
+    return h->userData;
+}
+
+void *
+hashtable_set_user_data(HashTable *h, void *data) {
+    void *r = h->userData;
+    h->userData = data;
+    return r;
+}
('src/libImaging', 'Jpeg2KEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,26 +19,24 @@

 #include "Jpeg2K.h"

-#define CINEMA_24_CS_LENGTH   1302083
-#define CINEMA_48_CS_LENGTH    651041
+#define CINEMA_24_CS_LENGTH 1302083
+#define CINEMA_48_CS_LENGTH 651041
 #define COMP_24_CS_MAX_LENGTH 1041666
-#define COMP_48_CS_MAX_LENGTH  520833
+#define COMP_48_CS_MAX_LENGTH 520833

 /* -------------------------------------------------------------------- */
 /* Error handler                                                        */
 /* -------------------------------------------------------------------- */

 static void
-j2k_error(const char *msg, void *client_data)
-{
-    JPEG2KENCODESTATE *state = (JPEG2KENCODESTATE *) client_data;
+j2k_error(const char *msg, void *client_data) {
+    JPEG2KENCODESTATE *state = (JPEG2KENCODESTATE *)client_data;
     free((void *)state->error_msg);
     state->error_msg = strdup(msg);
 }

 static void
-j2k_warn(const char *msg, void *client_data)
-{
+j2k_warn(const char *msg, void *client_data) {
     // Null handler
 }

@@ -47,8 +45,7 @@
 /* -------------------------------------------------------------------- */

 static OPJ_SIZE_T
-j2k_write(void *p_buffer, OPJ_SIZE_T p_nb_bytes, void *p_user_data)
-{
+j2k_write(void *p_buffer, OPJ_SIZE_T p_nb_bytes, void *p_user_data) {
     ImagingCodecState state = (ImagingCodecState)p_user_data;
     unsigned int result;

@@ -57,16 +54,14 @@
     return result ? result : (OPJ_SIZE_T)-1;
 }

-
 static OPJ_OFF_T
-j2k_skip(OPJ_OFF_T p_nb_bytes, void *p_user_data)
-{
+j2k_skip(OPJ_OFF_T p_nb_bytes, void *p_user_data) {
     ImagingCodecState state = (ImagingCodecState)p_user_data;
     char *buffer;
     int result;

     /* Explicitly write zeros */
-    buffer = calloc(p_nb_bytes,1);
+    buffer = calloc(p_nb_bytes, 1);
     if (!buffer) {
         return (OPJ_OFF_T)-1;
     }
@@ -79,8 +74,7 @@
 }

 static OPJ_BOOL
-j2k_seek(OPJ_OFF_T p_nb_bytes, void *p_user_data)
-{
+j2k_seek(OPJ_OFF_T p_nb_bytes, void *p_user_data) {
     ImagingCodecState state = (ImagingCodecState)p_user_data;
     off_t pos = 0;

@@ -94,16 +88,13 @@
 /* Encoder                                                              */
 /* -------------------------------------------------------------------- */

-typedef void (*j2k_pack_tile_t)(Imaging im, UINT8 *buf,
-                                unsigned x0, unsigned y0,
-                                unsigned w, unsigned h);
-
-static void
-j2k_pack_l(Imaging im, UINT8 *buf,
-           unsigned x0, unsigned y0, unsigned w, unsigned h)
-{
+typedef void (*j2k_pack_tile_t)(
+    Imaging im, UINT8 *buf, unsigned x0, unsigned y0, unsigned w, unsigned h);
+
+static void
+j2k_pack_l(Imaging im, UINT8 *buf, unsigned x0, unsigned y0, unsigned w, unsigned h) {
     UINT8 *ptr = buf;
-    unsigned x,y;
+    unsigned x, y;
     for (y = 0; y < h; ++y) {
         UINT8 *data = (UINT8 *)(im->image[y + y0] + x0);
         for (x = 0; x < w; ++x) {
@@ -113,28 +104,30 @@
 }

 static void
-j2k_pack_i16(Imaging im, UINT8 *buf,
-             unsigned x0, unsigned y0, unsigned w, unsigned h)
-{
+j2k_pack_i16(Imaging im, UINT8 *buf, unsigned x0, unsigned y0, unsigned w, unsigned h) {
     UINT8 *ptr = buf;
-    unsigned x,y;
+    unsigned x, y;
     for (y = 0; y < h; ++y) {
         UINT8 *data = (UINT8 *)(im->image[y + y0] + x0);
         for (x = 0; x < w; ++x) {
-            *ptr++ = *data++;
-            *ptr++ = *data++;
-        }
-    }
-}
-
-
-static void
-j2k_pack_la(Imaging im, UINT8 *buf,
-            unsigned x0, unsigned y0, unsigned w, unsigned h)
-{
+#ifdef WORDS_BIGENDIAN
+            ptr[0] = data[1];
+            ptr[1] = data[0];
+#else
+            ptr[0] = data[0];
+            ptr[1] = data[1];
+#endif
+            ptr += 2;
+            data += 2;
+        }
+    }
+}
+
+static void
+j2k_pack_la(Imaging im, UINT8 *buf, unsigned x0, unsigned y0, unsigned w, unsigned h) {
     UINT8 *ptr = buf;
     UINT8 *ptra = buf + w * h;
-    unsigned x,y;
+    unsigned x, y;
     for (y = 0; y < h; ++y) {
         UINT8 *data = (UINT8 *)(im->image[y + y0] + 4 * x0);
         for (x = 0; x < w; ++x) {
@@ -146,13 +139,11 @@
 }

 static void
-j2k_pack_rgb(Imaging im, UINT8 *buf,
-             unsigned x0, unsigned y0, unsigned w, unsigned h)
-{
+j2k_pack_rgb(Imaging im, UINT8 *buf, unsigned x0, unsigned y0, unsigned w, unsigned h) {
     UINT8 *pr = buf;
     UINT8 *pg = pr + w * h;
     UINT8 *pb = pg + w * h;
-    unsigned x,y;
+    unsigned x, y;
     for (y = 0; y < h; ++y) {
         UINT8 *data = (UINT8 *)(im->image[y + y0] + 4 * x0);
         for (x = 0; x < w; ++x) {
@@ -165,14 +156,13 @@
 }

 static void
-j2k_pack_rgba(Imaging im, UINT8 *buf,
-              unsigned x0, unsigned y0, unsigned w, unsigned h)
-{
+j2k_pack_rgba(
+    Imaging im, UINT8 *buf, unsigned x0, unsigned y0, unsigned w, unsigned h) {
     UINT8 *pr = buf;
     UINT8 *pg = pr + w * h;
     UINT8 *pb = pg + w * h;
     UINT8 *pa = pb + w * h;
-    unsigned x,y;
+    unsigned x, y;
     for (y = 0; y < h; ++y) {
         UINT8 *data = (UINT8 *)(im->image[y + y0] + 4 * x0);
         for (x = 0; x < w; ++x) {
@@ -192,8 +182,7 @@
 };

 static void
-j2k_set_cinema_params(Imaging im, int components, opj_cparameters_t *params)
-{
+j2k_set_cinema_params(Imaging im, int components, opj_cparameters_t *params) {
     float rate;
     int n;

@@ -215,8 +204,9 @@
     params->irreversible = 1;

     if (params->cp_cinema == OPJ_CINEMA4K_24) {
-        float max_rate = ((float)(components * im->xsize * im->ysize * 8)
-                          / (CINEMA_24_CS_LENGTH * 8));
+        float max_rate =
+            ((float)(components * im->xsize * im->ysize * 8) /
+             (CINEMA_24_CS_LENGTH * 8));

         params->POC[0].tile = 1;
         params->POC[0].resno0 = 0;
@@ -239,8 +229,9 @@
             if (params->tcp_rates[0] == 0) {
                 params->tcp_rates[n] = max_rate;
             } else {
-                rate = ((float)(components * im->xsize * im->ysize * 8)
-                        / (params->tcp_rates[n] * 8));
+                rate =
+                    ((float)(components * im->xsize * im->ysize * 8) /
+                     (params->tcp_rates[n] * 8));
                 if (rate > CINEMA_24_CS_LENGTH) {
                     params->tcp_rates[n] = max_rate;
                 }
@@ -249,16 +240,18 @@

         params->max_comp_size = COMP_24_CS_MAX_LENGTH;
     } else {
-        float max_rate = ((float)(components * im->xsize * im->ysize * 8)
-                          / (CINEMA_48_CS_LENGTH * 8));
+        float max_rate =
+            ((float)(components * im->xsize * im->ysize * 8) /
+             (CINEMA_48_CS_LENGTH * 8));

         for (n = 0; n < params->tcp_numlayers; ++n) {
             rate = 0;
             if (params->tcp_rates[0] == 0) {
                 params->tcp_rates[n] = max_rate;
             } else {
-                rate = ((float)(components * im->xsize * im->ysize * 8)
-                        / (params->tcp_rates[n] * 8));
+                rate =
+                    ((float)(components * im->xsize * im->ysize * 8) /
+                     (params->tcp_rates[n] * 8));
                 if (rate > CINEMA_48_CS_LENGTH) {
                     params->tcp_rates[n] = max_rate;
                 }
@@ -270,8 +263,7 @@
 }

 static int
-j2k_encode_entry(Imaging im, ImagingCodecState state)
-{
+j2k_encode_entry(Imaging im, ImagingCodecState state) {
     JPEG2KENCODESTATE *context = (JPEG2KENCODESTATE *)state->context;
     opj_stream_t *stream = NULL;
     opj_image_t *image = NULL;
@@ -312,35 +304,29 @@
 #endif

     /* Setup an opj_image */
-    if (strcmp (im->mode, "L") == 0) {
+    if (strcmp(im->mode, "L") == 0) {
         components = 1;
         color_space = OPJ_CLRSPC_GRAY;
         pack = j2k_pack_l;
-    } else if (strcmp (im->mode, "I;16") == 0){
+    } else if (strcmp(im->mode, "I;16") == 0 || strcmp(im->mode, "I;16B") == 0) {
         components = 1;
         color_space = OPJ_CLRSPC_GRAY;
         pack = j2k_pack_i16;
         prec = 16;
         bpp = 12;
-    } else if (strcmp (im->mode, "I;16B") == 0){
-        components = 1;
-        color_space = OPJ_CLRSPC_GRAY;
-        pack = j2k_pack_i16;
-        prec = 16;
-        bpp = 12;
-    } else if (strcmp (im->mode, "LA") == 0) {
+    } else if (strcmp(im->mode, "LA") == 0) {
         components = 2;
         color_space = OPJ_CLRSPC_GRAY;
         pack = j2k_pack_la;
-    } else if (strcmp (im->mode, "RGB") == 0) {
+    } else if (strcmp(im->mode, "RGB") == 0) {
         components = 3;
         color_space = OPJ_CLRSPC_SRGB;
         pack = j2k_pack_rgb;
-    } else if (strcmp (im->mode, "YCbCr") == 0) {
+    } else if (strcmp(im->mode, "YCbCr") == 0) {
         components = 3;
         color_space = OPJ_CLRSPC_SYCC;
         pack = j2k_pack_rgb;
-    } else if (strcmp (im->mode, "RGBA") == 0) {
+    } else if (strcmp(im->mode, "RGBA") == 0) {
         components = 4;
         color_space = OPJ_CLRSPC_SRGB;
         pack = j2k_pack_rgba;
@@ -400,8 +386,9 @@
         float *pq;

         if (len > 0) {
-            if ((unsigned)len > sizeof(params.tcp_rates) / sizeof(params.tcp_rates[0])) {
-                len = sizeof(params.tcp_rates)/sizeof(params.tcp_rates[0]);
+            if ((size_t)len >
+                sizeof(params.tcp_rates) / sizeof(params.tcp_rates[0])) {
+                len = sizeof(params.tcp_rates) / sizeof(params.tcp_rates[0]);
             }

             params.tcp_numlayers = (int)len;
@@ -431,16 +418,16 @@
         params.numresolution = context->num_resolutions;
     }

-    if (context->cblk_width >= 4 && context->cblk_width <= 1024
-        && context->cblk_height >= 4 && context->cblk_height <= 1024
-        && context->cblk_width * context->cblk_height <= 4096) {
+    if (context->cblk_width >= 4 && context->cblk_width <= 1024 &&
+        context->cblk_height >= 4 && context->cblk_height <= 1024 &&
+        context->cblk_width * context->cblk_height <= 4096) {
         params.cblockw_init = context->cblk_width;
         params.cblockh_init = context->cblk_height;
     }

-    if (context->precinct_width >= 4 && context->precinct_height >= 4
-        && context->precinct_width >= context->cblk_width
-        && context->precinct_height > context->cblk_height) {
+    if (context->precinct_width >= 4 && context->precinct_height >= 4 &&
+        context->precinct_width >= context->cblk_width &&
+        context->precinct_height > context->cblk_height) {
         params.prcw_init[0] = context->precinct_width;
         params.prch_init[0] = context->precinct_height;
         params.res_spec = 1;
@@ -448,28 +435,37 @@
     }

     params.irreversible = context->irreversible;
+    if (components == 3) {
+        params.tcp_mct = context->mct;
+    }

     params.prog_order = context->progression;

     params.cp_cinema = context->cinema_mode;

     switch (params.cp_cinema) {
-    case OPJ_OFF:
-        params.cp_rsiz = OPJ_STD_RSIZ;
-        break;
-    case OPJ_CINEMA2K_24:
-    case OPJ_CINEMA2K_48:
-        params.cp_rsiz = OPJ_CINEMA2K;
-        if (params.numresolution > 6) {
-            params.numresolution = 6;
-        }
-        break;
-    case OPJ_CINEMA4K_24:
-        params.cp_rsiz = OPJ_CINEMA4K;
-        if (params.numresolution > 7) {
-            params.numresolution = 7;
-        }
-        break;
+        case OPJ_OFF:
+            params.cp_rsiz = OPJ_STD_RSIZ;
+            break;
+        case OPJ_CINEMA2K_24:
+        case OPJ_CINEMA2K_48:
+            params.cp_rsiz = OPJ_CINEMA2K;
+            if (params.numresolution > 6) {
+                params.numresolution = 6;
+            }
+            break;
+        case OPJ_CINEMA4K_24:
+            params.cp_rsiz = OPJ_CINEMA4K;
+            if (params.numresolution > 7) {
+                params.numresolution = 7;
+            }
+            break;
+    }
+
+    if (!context->num_resolutions) {
+        while (tile_width < (1 << (params.numresolution - 1U)) || tile_height < (1 << (params.numresolution - 1U))) {
+            params.numresolution -= 1;
+        }
     }

     if (context->cinema_mode != OPJ_OFF) {
@@ -504,24 +500,24 @@
     }

     /* Write each tile */
-    tiles_x = (im->xsize + (params.image_offset_x0 - params.cp_tx0)
-               + tile_width - 1) / tile_width;
-    tiles_y = (im->ysize + (params.image_offset_y0 - params.cp_ty0)
-               + tile_height - 1) / tile_height;
+    tiles_x = (im->xsize + (params.image_offset_x0 - params.cp_tx0) + tile_width - 1) /
+              tile_width;
+    tiles_y = (im->ysize + (params.image_offset_y0 - params.cp_ty0) + tile_height - 1) /
+              tile_height;

     /* check for integer overflow for the malloc line, checking any expression
        that may multiply either tile_width or tile_height */
     _overflow_scale_factor = components * prec;
-    if (( tile_width > UINT_MAX / _overflow_scale_factor ) ||
-        ( tile_height > UINT_MAX / _overflow_scale_factor ) ||
-        ( tile_width > UINT_MAX / (tile_height * _overflow_scale_factor )) ||
-        ( tile_height > UINT_MAX / (tile_width * _overflow_scale_factor ))) {
+    if ((tile_width > UINT_MAX / _overflow_scale_factor) ||
+        (tile_height > UINT_MAX / _overflow_scale_factor) ||
+        (tile_width > UINT_MAX / (tile_height * _overflow_scale_factor)) ||
+        (tile_height > UINT_MAX / (tile_width * _overflow_scale_factor))) {
         state->errcode = IMAGING_CODEC_BROKEN;
         state->state = J2K_STATE_FAILED;
         goto quick_exit;
     }
     /* malloc check ok, checked for overflow above */
-    state->buffer = malloc (tile_width * tile_height * components * prec / 8);
+    state->buffer = malloc(tile_width * tile_height * components * prec / 8);
     if (!state->buffer) {
         state->errcode = IMAGING_CODEC_BROKEN;
         state->state = J2K_STATE_FAILED;
@@ -564,8 +560,7 @@

             data_size = pixw * pixh * components * prec / 8;

-            if (!opj_write_tile(codec, tile_ndx++, state->buffer,
-                                data_size, stream)) {
+            if (!opj_write_tile(codec, tile_ndx++, state->buffer, data_size, stream)) {
                 state->errcode = IMAGING_CODEC_BROKEN;
                 state->state = J2K_STATE_FAILED;
                 goto quick_exit;
@@ -583,7 +578,7 @@
     state->state = J2K_STATE_DONE;
     ret = -1;

- quick_exit:
+quick_exit:
     if (codec) {
         opj_destroy_codec(codec);
     }
@@ -598,14 +593,12 @@
 }

 int
-ImagingJpeg2KEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes)
-{
+ImagingJpeg2KEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes) {
     if (state->state == J2K_STATE_FAILED) {
         return -1;
     }

     if (state->state == J2K_STATE_START) {
-
         state->state = J2K_STATE_ENCODING;

         return j2k_encode_entry(im, state);
@@ -628,11 +621,10 @@
     }

     if (context->error_msg) {
-        free ((void *)context->error_msg);
+        free((void *)context->error_msg);
     }

     context->error_msg = NULL;
-

     return -1;
 }
('src/libImaging', 'RankFilter.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -17,94 +17,98 @@
 /* Fast rank algorithm (due to Wirth), based on public domain code
    by Nicolas Devillard, available at http://ndevilla.free.fr */

-#define SWAP(type,a,b) { register type t=(a);(a)=(b);(b)=t; }
+#define SWAP(type, a, b)       \
+    {                          \
+        register type t = (a); \
+        (a) = (b);             \
+        (b) = t;               \
+    }

-#define MakeRankFunction(type)\
-static type Rank##type(type a[], int n, int k)\
-{\
-    register int i, j, l, m;\
-    register type x;\
-    l = 0; m = n-1;\
-    while (l < m) {\
-        x = a[k];\
-        i = l;\
-        j = m;\
-        do {\
-            while (a[i] < x) {\
-                i++;\
-            }\
-            while (x < a[j]) {\
-                j--;\
-            }\
-            if (i <= j) {\
-                SWAP(type, a[i], a[j]);\
-                i++; j--;\
-            }\
-        } while (i <= j);\
-        if (j < k) {\
-            l = i;\
-        }\
-        if (k < i) {\
-            m = j;\
-        }\
-    }\
-    return a[k];\
-}
+#define MakeRankFunction(type)                       \
+    static type Rank##type(type a[], int n, int k) { \
+        register int i, j, l, m;                     \
+        register type x;                             \
+        l = 0;                                       \
+        m = n - 1;                                   \
+        while (l < m) {                              \
+            x = a[k];                                \
+            i = l;                                   \
+            j = m;                                   \
+            do {                                     \
+                while (a[i] < x) {                   \
+                    i++;                             \
+                }                                    \
+                while (x < a[j]) {                   \
+                    j--;                             \
+                }                                    \
+                if (i <= j) {                        \
+                    SWAP(type, a[i], a[j]);          \
+                    i++;                             \
+                    j--;                             \
+                }                                    \
+            } while (i <= j);                        \
+            if (j < k) {                             \
+                l = i;                               \
+            }                                        \
+            if (k < i) {                             \
+                m = j;                               \
+            }                                        \
+        }                                            \
+        return a[k];                                 \
+    }

-MakeRankFunction(UINT8)
-MakeRankFunction(INT32)
-MakeRankFunction(FLOAT32)
+MakeRankFunction(UINT8) MakeRankFunction(INT32) MakeRankFunction(FLOAT32)

-Imaging
-ImagingRankFilter(Imaging im, int size, int rank)
-{
+    Imaging ImagingRankFilter(Imaging im, int size, int rank) {
     Imaging imOut = NULL;
     int x, y;
     int i, margin, size2;

     if (!im || im->bands != 1 || im->type == IMAGING_TYPE_SPECIAL) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (!(size & 1)) {
-        return (Imaging) ImagingError_ValueError("bad filter size");
+        return (Imaging)ImagingError_ValueError("bad filter size");
     }

     /* malloc check ok, for overflow in the define below */
-    if (size > INT_MAX / size ||
-        size > INT_MAX / (size * (int)sizeof(FLOAT32))) {
-        return (Imaging) ImagingError_ValueError("filter size too large");
+    if (size > INT_MAX / size || size > INT_MAX / (size * (int)sizeof(FLOAT32))) {
+        return (Imaging)ImagingError_ValueError("filter size too large");
     }

     size2 = size * size;
-    margin = (size-1) / 2;
+    margin = (size - 1) / 2;

     if (rank < 0 || rank >= size2) {
-        return (Imaging) ImagingError_ValueError("bad rank value");
+        return (Imaging)ImagingError_ValueError("bad rank value");
     }

-    imOut = ImagingNew(im->mode, im->xsize - 2*margin, im->ysize - 2*margin);
+    imOut = ImagingNew(im->mode, im->xsize - 2 * margin, im->ysize - 2 * margin);
     if (!imOut) {
         return NULL;
     }

     /* malloc check ok, checked above */
-#define RANK_BODY(type) do {\
-    type* buf = malloc(size2 * sizeof(type));\
-    if (!buf) {\
-        goto nomemory;\
-    }\
-    for (y = 0; y < imOut->ysize; y++) {\
-        for (x = 0; x < imOut->xsize; x++) {\
-            for (i = 0; i < size; i++) {\
-                memcpy(buf + i*size, &IMAGING_PIXEL_##type(im, x, y+i),\
-                       size * sizeof(type));\
-            }\
-            IMAGING_PIXEL_##type(imOut, x, y) = Rank##type(buf, size2, rank);\
-        }\
-    }\
-    free(buf); \
-} while (0)
+#define RANK_BODY(type)                                                           \
+    do {                                                                          \
+        type *buf = malloc(size2 * sizeof(type));                                 \
+        if (!buf) {                                                               \
+            goto nomemory;                                                        \
+        }                                                                         \
+        for (y = 0; y < imOut->ysize; y++) {                                      \
+            for (x = 0; x < imOut->xsize; x++) {                                  \
+                for (i = 0; i < size; i++) {                                      \
+                    memcpy(                                                       \
+                        buf + i * size,                                           \
+                        &IMAGING_PIXEL_##type(im, x, y + i),                      \
+                        size * sizeof(type));                                     \
+                }                                                                 \
+                IMAGING_PIXEL_##type(imOut, x, y) = Rank##type(buf, size2, rank); \
+            }                                                                     \
+        }                                                                         \
+        free(buf);                                                                \
+    } while (0)

     if (im->image8) {
         RANK_BODY(UINT8);
@@ -115,7 +119,7 @@
     } else {
         /* safety net (we shouldn't end up here) */
         ImagingDelete(imOut);
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     ImagingCopyPalette(imOut, im);
@@ -124,5 +128,5 @@

 nomemory:
     ImagingDelete(imOut);
-    return (Imaging) ImagingError_MemoryError();
+    return (Imaging)ImagingError_MemoryError();
 }
('src/libImaging', 'EpsEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -17,28 +17,24 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 int
-ImagingEpsEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)
-{
-    enum { HEXBYTE=1, NEWLINE };
+ImagingEpsEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes) {
+    enum { HEXBYTE = 1, NEWLINE };
     const char *hex = "0123456789abcdef";

-    UINT8* ptr = buf;
-    UINT8* in, i;
+    UINT8 *ptr = buf;
+    UINT8 *in, i;

     if (!state->state) {
         state->state = HEXBYTE;
         state->xsize *= im->pixelsize; /* Hack! */
     }

-    in = (UINT8*) im->image[state->y];
+    in = (UINT8 *)im->image[state->y];

     for (;;) {
-
         if (state->state == NEWLINE) {
             if (bytes < 1) {
                 break;
@@ -53,8 +49,8 @@
         }

         i = in[state->x++];
-        *ptr++ = hex[(i>>4)&15];
-        *ptr++ = hex[i&15];
+        *ptr++ = hex[(i >> 4) & 15];
+        *ptr++ = hex[i & 15];
         bytes -= 2;

         /* Skip junk bytes */
@@ -62,7 +58,7 @@
             state->x++;
         }

-        if (++state->count >= 79/2) {
+        if (++state->count >= 79 / 2) {
             state->state = NEWLINE;
             state->count = 0;
         }
@@ -73,11 +69,9 @@
                 state->errcode = IMAGING_CODEC_END;
                 break;
             }
-            in = (UINT8*) im->image[state->y];
+            in = (UINT8 *)im->image[state->y];
         }
-
     }

     return ptr - buf;
-
 }
('src/libImaging', 'GetBBox.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,13 +16,10 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 int
-ImagingGetBBox(Imaging im, int bbox[4])
-{
+ImagingGetBBox(Imaging im, int bbox[4]) {
     /* Get the bounding box for any non-zero data in the image.*/

     int x, y;
@@ -33,26 +30,26 @@
     bbox[1] = -1;
     bbox[2] = bbox[3] = 0;

-#define GETBBOX(image, mask)\
-    for (y = 0; y < im->ysize; y++) {\
-        has_data = 0;\
-        for (x = 0; x < im->xsize; x++) {\
-            if (im->image[y][x] & mask) {\
-                has_data = 1;\
-                if (x < bbox[0]) {\
-                    bbox[0] = x;\
-                }\
-                if (x >= bbox[2]) {\
-                    bbox[2] = x+1;\
-                }\
-            }\
-        }\
-        if (has_data) {\
-            if (bbox[1] < 0) {\
-                bbox[1] = y;\
-            }\
-            bbox[3] = y+1;\
-        }\
+#define GETBBOX(image, mask)              \
+    for (y = 0; y < im->ysize; y++) {     \
+        has_data = 0;                     \
+        for (x = 0; x < im->xsize; x++) { \
+            if (im->image[y][x] & mask) { \
+                has_data = 1;             \
+                if (x < bbox[0]) {        \
+                    bbox[0] = x;          \
+                }                         \
+                if (x >= bbox[2]) {       \
+                    bbox[2] = x + 1;      \
+                }                         \
+            }                             \
+        }                                 \
+        if (has_data) {                   \
+            if (bbox[1] < 0) {            \
+                bbox[1] = y;              \
+            }                             \
+            bbox[3] = y + 1;              \
+        }                                 \
     }

     if (im->image8) {
@@ -60,16 +57,15 @@
     } else {
         INT32 mask = 0xffffffff;
         if (im->bands == 3) {
-            ((UINT8*) &mask)[3] = 0;
-        } else if (strcmp(im->mode, "RGBa") == 0 ||
-                   strcmp(im->mode, "RGBA") == 0 ||
-                   strcmp(im->mode, "La") == 0 ||
-                   strcmp(im->mode, "LA") == 0 ||
-                   strcmp(im->mode, "PA") == 0) {
+            ((UINT8 *)&mask)[3] = 0;
+        } else if (
+            strcmp(im->mode, "RGBa") == 0 || strcmp(im->mode, "RGBA") == 0 ||
+            strcmp(im->mode, "La") == 0 || strcmp(im->mode, "LA") == 0 ||
+            strcmp(im->mode, "PA") == 0) {
 #ifdef WORDS_BIGENDIAN
-        mask = 0x000000ff;
+            mask = 0x000000ff;
 #else
-        mask = 0xff000000;
+            mask = 0xff000000;
 #endif
         }
         GETBBOX(image32, mask);
@@ -83,10 +79,8 @@
     return 1; /* ok */
 }

-
 int
-ImagingGetProjection(Imaging im, UINT8* xproj, UINT8* yproj)
-{
+ImagingGetProjection(Imaging im, UINT8 *xproj, UINT8 *yproj) {
     /* Get projection arrays for non-zero data in the image.*/

     int x, y;
@@ -96,26 +90,26 @@
     memset(xproj, 0, im->xsize);
     memset(yproj, 0, im->ysize);

-    #define GETPROJ(image, mask)\
-        for (y = 0; y < im->ysize; y++) {\
-            has_data = 0;\
-            for (x = 0; x < im->xsize; x++) {\
-                if (im->image[y][x] & mask) {\
-                    has_data = 1;\
-                    xproj[x] = 1;\
-                }\
-            }\
-            if (has_data) {\
-                yproj[y] = 1;\
-            }\
-        }
+#define GETPROJ(image, mask)              \
+    for (y = 0; y < im->ysize; y++) {     \
+        has_data = 0;                     \
+        for (x = 0; x < im->xsize; x++) { \
+            if (im->image[y][x] & mask) { \
+                has_data = 1;             \
+                xproj[x] = 1;             \
+            }                             \
+        }                                 \
+        if (has_data) {                   \
+            yproj[y] = 1;                 \
+        }                                 \
+    }

     if (im->image8) {
         GETPROJ(image8, 0xff);
     } else {
         INT32 mask = 0xffffffff;
         if (im->bands == 3) {
-            ((UINT8*) &mask)[3] = 0;
+            ((UINT8 *)&mask)[3] = 0;
         }
         GETPROJ(image32, mask);
     }
@@ -123,16 +117,14 @@
     return 1; /* ok */
 }

-
 int
-ImagingGetExtrema(Imaging im, void *extrema)
-{
+ImagingGetExtrema(Imaging im, void *extrema) {
     int x, y;
     INT32 imin, imax;
     FLOAT32 fmin, fmax;

     if (im->bands != 1) {
-        (void) ImagingError_ModeError();
+        (void)ImagingError_ModeError();
         return -1; /* mismatch */
     }

@@ -141,111 +133,109 @@
     }

     switch (im->type) {
-    case IMAGING_TYPE_UINT8:
-        imin = imax = im->image8[0][0];
-        for (y = 0; y < im->ysize; y++) {
-            UINT8* in = im->image8[y];
-            for (x = 0; x < im->xsize; x++) {
-                if (imin > in[x]) {
-                    imin = in[x];
-                } else if (imax < in[x]) {
-                    imax = in[x];
-                }
-            }
-        }
-        ((UINT8*) extrema)[0] = (UINT8) imin;
-        ((UINT8*) extrema)[1] = (UINT8) imax;
-        break;
-    case IMAGING_TYPE_INT32:
-        imin = imax = im->image32[0][0];
-        for (y = 0; y < im->ysize; y++) {
-            INT32* in = im->image32[y];
-            for (x = 0; x < im->xsize; x++) {
-                if (imin > in[x]) {
-                    imin = in[x];
-                } else if (imax < in[x]) {
-                    imax = in[x];
-                }
-            }
-        }
-        memcpy(extrema, &imin, sizeof(imin));
-        memcpy(((char*)extrema) + sizeof(imin), &imax, sizeof(imax));
-        break;
-    case IMAGING_TYPE_FLOAT32:
-        fmin = fmax = ((FLOAT32*) im->image32[0])[0];
-        for (y = 0; y < im->ysize; y++) {
-            FLOAT32* in = (FLOAT32*) im->image32[y];
-            for (x = 0; x < im->xsize; x++) {
-                if (fmin > in[x]) {
-                    fmin = in[x];
-                } else if (fmax < in[x]) {
-                    fmax = in[x];
-                }
-            }
-        }
-        memcpy(extrema, &fmin, sizeof(fmin));
-        memcpy(((char*)extrema) + sizeof(fmin), &fmax, sizeof(fmax));
-        break;
-    case IMAGING_TYPE_SPECIAL:
-      if (strcmp(im->mode, "I;16") == 0) {
-          UINT16 v;
-          UINT8* pixel = *im->image8;
+        case IMAGING_TYPE_UINT8:
+            imin = imax = im->image8[0][0];
+            for (y = 0; y < im->ysize; y++) {
+                UINT8 *in = im->image8[y];
+                for (x = 0; x < im->xsize; x++) {
+                    if (imin > in[x]) {
+                        imin = in[x];
+                    } else if (imax < in[x]) {
+                        imax = in[x];
+                    }
+                }
+            }
+            ((UINT8 *)extrema)[0] = (UINT8)imin;
+            ((UINT8 *)extrema)[1] = (UINT8)imax;
+            break;
+        case IMAGING_TYPE_INT32:
+            imin = imax = im->image32[0][0];
+            for (y = 0; y < im->ysize; y++) {
+                INT32 *in = im->image32[y];
+                for (x = 0; x < im->xsize; x++) {
+                    if (imin > in[x]) {
+                        imin = in[x];
+                    } else if (imax < in[x]) {
+                        imax = in[x];
+                    }
+                }
+            }
+            memcpy(extrema, &imin, sizeof(imin));
+            memcpy(((char *)extrema) + sizeof(imin), &imax, sizeof(imax));
+            break;
+        case IMAGING_TYPE_FLOAT32:
+            fmin = fmax = ((FLOAT32 *)im->image32[0])[0];
+            for (y = 0; y < im->ysize; y++) {
+                FLOAT32 *in = (FLOAT32 *)im->image32[y];
+                for (x = 0; x < im->xsize; x++) {
+                    if (fmin > in[x]) {
+                        fmin = in[x];
+                    } else if (fmax < in[x]) {
+                        fmax = in[x];
+                    }
+                }
+            }
+            memcpy(extrema, &fmin, sizeof(fmin));
+            memcpy(((char *)extrema) + sizeof(fmin), &fmax, sizeof(fmax));
+            break;
+        case IMAGING_TYPE_SPECIAL:
+            if (strcmp(im->mode, "I;16") == 0) {
+                UINT16 v;
+                UINT8 *pixel = *im->image8;
 #ifdef WORDS_BIGENDIAN
-          v = pixel[0] + (pixel[1] << 8);
+                v = pixel[0] + (pixel[1] << 8);
 #else
-          memcpy(&v, pixel, sizeof(v));
+                memcpy(&v, pixel, sizeof(v));
 #endif
-          imin = imax = v;
-          for (y = 0; y < im->ysize; y++) {
-              for (x = 0; x < im->xsize; x++) {
-                  pixel = (UINT8*)im->image[y] + x * sizeof(v);
+                imin = imax = v;
+                for (y = 0; y < im->ysize; y++) {
+                    for (x = 0; x < im->xsize; x++) {
+                        pixel = (UINT8 *)im->image[y] + x * sizeof(v);
 #ifdef WORDS_BIGENDIAN
-                  v = pixel[0] + (pixel[1] << 8);
+                        v = pixel[0] + (pixel[1] << 8);
 #else
-                  memcpy(&v, pixel, sizeof(v));
+                        memcpy(&v, pixel, sizeof(v));
 #endif
-                  if (imin > v) {
-                      imin = v;
-                  } else if (imax < v) {
-                      imax = v;
-                  }
-              }
-          }
-          v = (UINT16) imin;
-          memcpy(extrema, &v, sizeof(v));
-          v = (UINT16) imax;
-          memcpy(((char*)extrema) + sizeof(v), &v, sizeof(v));
-          break;
-      }
-      /* FALL THROUGH */
-    default:
-        (void) ImagingError_ModeError();
-        return -1;
+                        if (imin > v) {
+                            imin = v;
+                        } else if (imax < v) {
+                            imax = v;
+                        }
+                    }
+                }
+                v = (UINT16)imin;
+                memcpy(extrema, &v, sizeof(v));
+                v = (UINT16)imax;
+                memcpy(((char *)extrema) + sizeof(v), &v, sizeof(v));
+                break;
+            }
+            /* FALL THROUGH */
+        default:
+            (void)ImagingError_ModeError();
+            return -1;
     }
     return 1; /* ok */
 }

-
 /* static ImagingColorItem* getcolors8(Imaging im, int maxcolors, int* size);*/
-static ImagingColorItem* getcolors32(Imaging im, int maxcolors, int* size);
-
-ImagingColorItem*
-ImagingGetColors(Imaging im, int maxcolors, int* size)
-{
+static ImagingColorItem *
+getcolors32(Imaging im, int maxcolors, int *size);
+
+ImagingColorItem *
+ImagingGetColors(Imaging im, int maxcolors, int *size) {
     /* FIXME: add support for 8-bit images */
     return getcolors32(im, maxcolors, size);
 }

-static ImagingColorItem*
-getcolors32(Imaging im, int maxcolors, int* size)
-{
+static ImagingColorItem *
+getcolors32(Imaging im, int maxcolors, int *size) {
     unsigned int h;
     unsigned int i, incr;
     int colors;
     INT32 pixel_mask;
     int x, y;
-    ImagingColorItem* table;
-    ImagingColorItem* v;
+    ImagingColorItem *table;
+    ImagingColorItem *v;

     unsigned int code_size;
     unsigned int code_poly;
@@ -256,19 +246,19 @@
        Python's Unicode property database (written by yours truly) /F */

     static int SIZES[] = {
-        4,3, 8,3, 16,3, 32,5, 64,3, 128,3, 256,29, 512,17, 1024,9, 2048,5,
-        4096,83, 8192,27, 16384,43, 32768,3, 65536,45, 131072,9, 262144,39,
-        524288,39, 1048576,9, 2097152,5, 4194304,3, 8388608,33, 16777216,27,
-        33554432,9, 67108864,71, 134217728,39, 268435456,9, 536870912,5,
-        1073741824,83, 0
-    };
+        4,         3,  8,         3,  16,        3,  32,         5,  64,       3,
+        128,       3,  256,       29, 512,       17, 1024,       9,  2048,     5,
+        4096,      83, 8192,      27, 16384,     43, 32768,      3,  65536,    45,
+        131072,    9,  262144,    39, 524288,    39, 1048576,    9,  2097152,  5,
+        4194304,   3,  8388608,   33, 16777216,  27, 33554432,   9,  67108864, 71,
+        134217728, 39, 268435456, 9,  536870912, 5,  1073741824, 83, 0};

     code_size = code_poly = code_mask = 0;

     for (i = 0; SIZES[i]; i += 2) {
         if (SIZES[i] > maxcolors) {
             code_size = SIZES[i];
-            code_poly = SIZES[i+1];
+            code_poly = SIZES[i + 1];
             code_mask = code_size - 1;
             break;
         }
@@ -292,13 +282,13 @@

     pixel_mask = 0xffffffff;
     if (im->bands == 3) {
-        ((UINT8*) &pixel_mask)[3] = 0;
+        ((UINT8 *)&pixel_mask)[3] = 0;
     }

     colors = 0;

     for (y = 0; y < im->ysize; y++) {
-        INT32* p = im->image32[y];
+        INT32 *p = im->image32[y];
         for (x = 0; x < im->xsize; x++) {
             INT32 pixel = p[x] & pixel_mask;
             h = (pixel); /* null hashing */
@@ -309,7 +299,8 @@
                 if (colors++ == maxcolors) {
                     goto overflow;
                 }
-                v->x = x; v->y = y;
+                v->x = x;
+                v->y = y;
                 v->pixel = pixel;
                 v->count = 1;
                 continue;
@@ -329,7 +320,8 @@
                     if (colors++ == maxcolors) {
                         goto overflow;
                     }
-                    v->x = x; v->y = y;
+                    v->x = x;
+                    v->y = y;
                     v->pixel = pixel;
                     v->count = 1;
                     break;
@@ -348,7 +340,7 @@
 overflow:

     /* pack the table */
-    for (x = y = 0; x < (int) code_size; x++)
+    for (x = y = 0; x < (int)code_size; x++)
         if (table[x].count) {
             if (x != y) {
                 table[y] = table[x];
('src/libImaging', 'Paste.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,11 +23,17 @@

 #include "Imaging.h"

-
-static inline void
-paste(Imaging imOut, Imaging imIn, int dx, int dy, int sx, int sy,
-      int xsize, int ysize, int pixelsize)
-{
+static inline void
+paste(
+    Imaging imOut,
+    Imaging imIn,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* paste opaque region */

     int y;
@@ -38,25 +44,31 @@
     xsize *= pixelsize;

     for (y = 0; y < ysize; y++) {
-        memcpy(imOut->image[y+dy]+dx, imIn->image[y+sy]+sx, xsize);
-    }
-}
-
-static inline void
-paste_mask_1(Imaging imOut, Imaging imIn, Imaging imMask,
-             int dx, int dy, int sx, int sy,
-             int xsize, int ysize, int pixelsize)
-{
+        memcpy(imOut->image[y + dy] + dx, imIn->image[y + sy] + sx, xsize);
+    }
+}
+
+static inline void
+paste_mask_1(
+    Imaging imOut,
+    Imaging imIn,
+    Imaging imMask,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* paste with mode "1" mask */

     int x, y;

     if (imOut->image8) {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = imOut->image8[y+dy]+dx;
-            UINT8* in = imIn->image8[y+sy]+sx;
-            UINT8* mask = imMask->image8[y+sy]+sx;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = imOut->image8[y + dy] + dx;
+            UINT8 *in = imIn->image8[y + sy] + sx;
+            UINT8 *mask = imMask->image8[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 if (*mask++) {
                     *out = *in;
@@ -66,11 +78,10 @@
         }

     } else {
-
-        for (y = 0; y < ysize; y++) {
-            INT32* out = imOut->image32[y+dy]+dx;
-            INT32* in = imIn->image32[y+sy]+sx;
-            UINT8* mask = imMask->image8[y+sy]+sx;
+        for (y = 0; y < ysize; y++) {
+            INT32 *out = imOut->image32[y + dy] + dx;
+            INT32 *in = imIn->image32[y + sy] + sx;
+            UINT8 *mask = imMask->image8[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 if (*mask++) {
                     *out = *in;
@@ -82,21 +93,27 @@
 }

 static inline void
-paste_mask_L(Imaging imOut, Imaging imIn, Imaging imMask,
-             int dx, int dy, int sx, int sy,
-             int xsize, int ysize, int pixelsize)
-{
+paste_mask_L(
+    Imaging imOut,
+    Imaging imIn,
+    Imaging imMask,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* paste with mode "L" matte */

     int x, y;
     unsigned int tmp1;

     if (imOut->image8) {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = imOut->image8[y+dy]+dx;
-            UINT8* in = imIn->image8[y+sy]+sx;
-            UINT8* mask = imMask->image8[y+sy]+sx;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = imOut->image8[y + dy] + dx;
+            UINT8 *in = imIn->image8[y + sy] + sx;
+            UINT8 *mask = imMask->image8[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 *out = BLEND(*mask, *out, *in, tmp1);
                 out++, in++, mask++;
@@ -104,39 +121,46 @@
         }

     } else {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = (UINT8*) (imOut->image32[y + dy] + dx);
-            UINT8* in = (UINT8*) (imIn->image32[y + sy] + sx);
-            UINT8* mask = (UINT8*) (imMask->image8[y+sy] + sx);
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = (UINT8 *)(imOut->image32[y + dy] + dx);
+            UINT8 *in = (UINT8 *)(imIn->image32[y + sy] + sx);
+            UINT8 *mask = (UINT8 *)(imMask->image8[y + sy] + sx);
             for (x = 0; x < xsize; x++) {
                 UINT8 a = mask[0];
                 out[0] = BLEND(a, out[0], in[0], tmp1);
                 out[1] = BLEND(a, out[1], in[1], tmp1);
                 out[2] = BLEND(a, out[2], in[2], tmp1);
                 out[3] = BLEND(a, out[3], in[3], tmp1);
-                out += 4; in += 4; mask ++;
-            }
-        }
-    }
-}
-
-static inline void
-paste_mask_RGBA(Imaging imOut, Imaging imIn, Imaging imMask,
-                int dx, int dy, int sx, int sy,
-                int xsize, int ysize, int pixelsize)
-{
+                out += 4;
+                in += 4;
+                mask++;
+            }
+        }
+    }
+}
+
+static inline void
+paste_mask_RGBA(
+    Imaging imOut,
+    Imaging imIn,
+    Imaging imMask,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* paste with mode "RGBA" matte */

     int x, y;
     unsigned int tmp1;

     if (imOut->image8) {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = imOut->image8[y+dy]+dx;
-            UINT8* in = imIn->image8[y+sy]+sx;
-            UINT8* mask = (UINT8*) imMask->image[y+sy]+sx*4+3;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = imOut->image8[y + dy] + dx;
+            UINT8 *in = imIn->image8[y + sy] + sx;
+            UINT8 *mask = (UINT8 *)imMask->image[y + sy] + sx * 4 + 3;
             for (x = 0; x < xsize; x++) {
                 *out = BLEND(*mask, *out, *in, tmp1);
                 out++, in++, mask += 4;
@@ -144,40 +168,46 @@
         }

     } else {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = (UINT8*) (imOut->image32[y + dy] + dx);
-            UINT8* in = (UINT8*) (imIn->image32[y + sy] + sx);
-            UINT8* mask = (UINT8*) (imMask->image32[y+sy] + sx);
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = (UINT8 *)(imOut->image32[y + dy] + dx);
+            UINT8 *in = (UINT8 *)(imIn->image32[y + sy] + sx);
+            UINT8 *mask = (UINT8 *)(imMask->image32[y + sy] + sx);
             for (x = 0; x < xsize; x++) {
                 UINT8 a = mask[3];
                 out[0] = BLEND(a, out[0], in[0], tmp1);
                 out[1] = BLEND(a, out[1], in[1], tmp1);
                 out[2] = BLEND(a, out[2], in[2], tmp1);
                 out[3] = BLEND(a, out[3], in[3], tmp1);
-                out += 4; in += 4; mask += 4;
-            }
-        }
-    }
-}
-
-
-static inline void
-paste_mask_RGBa(Imaging imOut, Imaging imIn, Imaging imMask,
-                int dx, int dy, int sx, int sy,
-                int xsize, int ysize, int pixelsize)
-{
+                out += 4;
+                in += 4;
+                mask += 4;
+            }
+        }
+    }
+}
+
+static inline void
+paste_mask_RGBa(
+    Imaging imOut,
+    Imaging imIn,
+    Imaging imMask,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* paste with mode "RGBa" matte */

     int x, y;
     unsigned int tmp1;

     if (imOut->image8) {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = imOut->image8[y+dy]+dx;
-            UINT8* in = imIn->image8[y+sy]+sx;
-            UINT8* mask = (UINT8*) imMask->image[y+sy]+sx*4+3;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = imOut->image8[y + dy] + dx;
+            UINT8 *in = imIn->image8[y + sy] + sx;
+            UINT8 *mask = (UINT8 *)imMask->image[y + sy] + sx * 4 + 3;
             for (x = 0; x < xsize; x++) {
                 *out = PREBLEND(*mask, *out, *in, tmp1);
                 out++, in++, mask += 4;
@@ -185,34 +215,34 @@
         }

     } else {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = (UINT8*) (imOut->image32[y + dy] + dx);
-            UINT8* in = (UINT8*) (imIn->image32[y + sy] + sx);
-            UINT8* mask = (UINT8*) (imMask->image32[y+sy] + sx);
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = (UINT8 *)(imOut->image32[y + dy] + dx);
+            UINT8 *in = (UINT8 *)(imIn->image32[y + sy] + sx);
+            UINT8 *mask = (UINT8 *)(imMask->image32[y + sy] + sx);
             for (x = 0; x < xsize; x++) {
                 UINT8 a = mask[3];
                 out[0] = PREBLEND(a, out[0], in[0], tmp1);
                 out[1] = PREBLEND(a, out[1], in[1], tmp1);
                 out[2] = PREBLEND(a, out[2], in[2], tmp1);
                 out[3] = PREBLEND(a, out[3], in[3], tmp1);
-                out += 4; in += 4; mask += 4;
+                out += 4;
+                in += 4;
+                mask += 4;
             }
         }
     }
 }

 int
-ImagingPaste(Imaging imOut, Imaging imIn, Imaging imMask,
-             int dx0, int dy0, int dx1, int dy1)
-{
+ImagingPaste(
+    Imaging imOut, Imaging imIn, Imaging imMask, int dx0, int dy0, int dx1, int dy1) {
     int xsize, ysize;
     int pixelsize;
     int sx0, sy0;
     ImagingSectionCookie cookie;

     if (!imOut || !imIn) {
-        (void) ImagingError_ModeError();
+        (void)ImagingError_ModeError();
         return -1;
     }

@@ -221,14 +251,13 @@
     xsize = dx1 - dx0;
     ysize = dy1 - dy0;

-    if (xsize != imIn->xsize || ysize != imIn->ysize ||
-        pixelsize != imIn->pixelsize) {
-        (void) ImagingError_Mismatch();
+    if (xsize != imIn->xsize || ysize != imIn->ysize || pixelsize != imIn->pixelsize) {
+        (void)ImagingError_Mismatch();
         return -1;
     }

     if (imMask && (xsize != imMask->xsize || ysize != imMask->ysize)) {
-        (void) ImagingError_Mismatch();
+        (void)ImagingError_Mismatch();
         return -1;
     }

@@ -258,30 +287,28 @@

     } else if (strcmp(imMask->mode, "1") == 0) {
         ImagingSectionEnter(&cookie);
-        paste_mask_1(imOut, imIn, imMask, dx0, dy0, sx0, sy0,
-                     xsize, ysize, pixelsize);
+        paste_mask_1(imOut, imIn, imMask, dx0, dy0, sx0, sy0, xsize, ysize, pixelsize);
         ImagingSectionLeave(&cookie);

     } else if (strcmp(imMask->mode, "L") == 0) {
         ImagingSectionEnter(&cookie);
-        paste_mask_L(imOut, imIn, imMask, dx0, dy0, sx0, sy0,
-                     xsize, ysize, pixelsize);
-        ImagingSectionLeave(&cookie);
-
-    } else if (strcmp(imMask->mode, "RGBA") == 0) {
-        ImagingSectionEnter(&cookie);
-        paste_mask_RGBA(imOut, imIn, imMask, dx0, dy0, sx0, sy0,
-                        xsize, ysize, pixelsize);
+        paste_mask_L(imOut, imIn, imMask, dx0, dy0, sx0, sy0, xsize, ysize, pixelsize);
+        ImagingSectionLeave(&cookie);
+
+    } else if (strcmp(imMask->mode, "LA") == 0 || strcmp(imMask->mode, "RGBA") == 0) {
+        ImagingSectionEnter(&cookie);
+        paste_mask_RGBA(
+            imOut, imIn, imMask, dx0, dy0, sx0, sy0, xsize, ysize, pixelsize);
         ImagingSectionLeave(&cookie);

     } else if (strcmp(imMask->mode, "RGBa") == 0) {
         ImagingSectionEnter(&cookie);
-        paste_mask_RGBa(imOut, imIn, imMask, dx0, dy0, sx0, sy0,
-                        xsize, ysize, pixelsize);
-        ImagingSectionLeave(&cookie);
-
-    } else {
-        (void) ImagingError_ValueError("bad transparency mask");
+        paste_mask_RGBa(
+            imOut, imIn, imMask, dx0, dy0, sx0, sy0, xsize, ysize, pixelsize);
+        ImagingSectionLeave(&cookie);
+
+    } else {
+        (void)ImagingError_ValueError("bad transparency mask");
         return -1;
     }

@@ -289,9 +316,14 @@
 }

 static inline void
-fill(Imaging imOut, const void* ink_, int dx, int dy,
-     int xsize, int ysize, int pixelsize)
-{
+fill(
+    Imaging imOut,
+    const void *ink_,
+    int dx,
+    int dy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* fill opaque region */

     int x, y;
@@ -302,30 +334,34 @@
     memcpy(&ink8, ink_, sizeof(ink8));

     if (imOut->image8 || ink32 == 0L) {
-
         dx *= pixelsize;
         xsize *= pixelsize;
         for (y = 0; y < ysize; y++) {
-            memset(imOut->image[y+dy]+dx, ink8, xsize);
-        }
-
-    } else {
-
-        for (y = 0; y < ysize; y++) {
-            INT32* out = imOut->image32[y+dy]+dx;
+            memset(imOut->image[y + dy] + dx, ink8, xsize);
+        }
+
+    } else {
+        for (y = 0; y < ysize; y++) {
+            INT32 *out = imOut->image32[y + dy] + dx;
             for (x = 0; x < xsize; x++) {
                 out[x] = ink32;
             }
         }
-
-    }
-}
-
-static inline void
-fill_mask_1(Imaging imOut, const void* ink_, Imaging imMask,
-            int dx, int dy, int sx, int sy,
-            int xsize, int ysize, int pixelsize)
-{
+    }
+}
+
+static inline void
+fill_mask_1(
+    Imaging imOut,
+    const void *ink_,
+    Imaging imMask,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* fill with mode "1" mask */

     int x, y;
@@ -336,10 +372,9 @@
     memcpy(&ink8, ink_, sizeof(ink8));

     if (imOut->image8) {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = imOut->image8[y+dy]+dx;
-            UINT8* mask = imMask->image8[y+sy]+sx;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = imOut->image8[y + dy] + dx;
+            UINT8 *mask = imMask->image8[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 if (*mask++) {
                     *out = ink8;
@@ -349,10 +384,9 @@
         }

     } else {
-
-        for (y = 0; y < ysize; y++) {
-            INT32* out = imOut->image32[y+dy]+dx;
-            UINT8* mask = imMask->image8[y+sy]+sx;
+        for (y = 0; y < ysize; y++) {
+            INT32 *out = imOut->image32[y + dy] + dx;
+            UINT8 *mask = imMask->image8[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 if (*mask++) {
                     *out = ink32;
@@ -364,42 +398,54 @@
 }

 static inline void
-fill_mask_L(Imaging imOut, const UINT8* ink, Imaging imMask,
-            int dx, int dy, int sx, int sy,
-            int xsize, int ysize, int pixelsize)
-{
+fill_mask_L(
+    Imaging imOut,
+    const UINT8 *ink,
+    Imaging imMask,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* fill with mode "L" matte */

     int x, y, i;
     unsigned int tmp1;

     if (imOut->image8) {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = imOut->image8[y+dy]+dx;
-            UINT8* mask = imMask->image8[y+sy]+sx;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = imOut->image8[y + dy] + dx;
+            if (strncmp(imOut->mode, "I;16", 4) == 0) {
+                out += dx;
+            }
+            UINT8 *mask = imMask->image8[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 *out = BLEND(*mask, *out, ink[0], tmp1);
+                if (strncmp(imOut->mode, "I;16", 4) == 0) {
+                    out++;
+                    *out = BLEND(*mask, *out, ink[0], tmp1);
+                }
                 out++, mask++;
             }
         }

     } else {
-
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = (UINT8*) imOut->image[y+dy]+dx*pixelsize;
-            UINT8* mask = (UINT8*) imMask->image[y+sy]+sx;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = (UINT8 *)imOut->image[y + dy] + dx * pixelsize;
+            UINT8 *mask = (UINT8 *)imMask->image[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 for (i = 0; i < pixelsize; i++) {
                     UINT8 channel_mask = *mask;
-                    if ((
-                        strcmp(imOut->mode, "RGBa") == 0 ||
-                        strcmp(imOut->mode, "RGBA") == 0 ||
-                        strcmp(imOut->mode, "La") == 0 ||
-                        strcmp(imOut->mode, "LA") == 0 ||
-                        strcmp(imOut->mode, "PA") == 0
-                    ) && i != 3) {
-                        channel_mask = 255 - (255 - channel_mask) * (1 - (255 - out[3]) / 255);
+                    if ((strcmp(imOut->mode, "RGBa") == 0 ||
+                         strcmp(imOut->mode, "RGBA") == 0 ||
+                         strcmp(imOut->mode, "La") == 0 ||
+                         strcmp(imOut->mode, "LA") == 0 ||
+                         strcmp(imOut->mode, "PA") == 0) &&
+                        i != 3 && channel_mask != 0) {
+                        channel_mask =
+                            255 - (255 - channel_mask) * (1 - (255 - out[3]) / 255);
                     }
                     out[i] = BLEND(channel_mask, out[i], ink[i], tmp1);
                 }
@@ -411,21 +457,27 @@
 }

 static inline void
-fill_mask_RGBA(Imaging imOut, const UINT8* ink, Imaging imMask,
-               int dx, int dy, int sx, int sy,
-               int xsize, int ysize, int pixelsize)
-{
+fill_mask_RGBA(
+    Imaging imOut,
+    const UINT8 *ink,
+    Imaging imMask,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* fill with mode "RGBA" matte */

     int x, y, i;
     unsigned int tmp1;

     if (imOut->image8) {
-
-        sx = sx*4+3;
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = imOut->image8[y+dy]+dx;
-            UINT8* mask = (UINT8*) imMask->image[y+sy]+sx;
+        sx = sx * 4 + 3;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = imOut->image8[y + dy] + dx;
+            UINT8 *mask = (UINT8 *)imMask->image[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 *out = BLEND(*mask, *out, ink[0], tmp1);
                 out++, mask += 4;
@@ -433,12 +485,11 @@
         }

     } else {
-
         dx *= pixelsize;
-        sx = sx*4 + 3;
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = (UINT8*) imOut->image[y+dy]+dx;
-            UINT8* mask = (UINT8*) imMask->image[y+sy]+sx;
+        sx = sx * 4 + 3;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = (UINT8 *)imOut->image[y + dy] + dx;
+            UINT8 *mask = (UINT8 *)imMask->image[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 for (i = 0; i < pixelsize; i++) {
                     *out = BLEND(*mask, *out, ink[i], tmp1);
@@ -451,21 +502,27 @@
 }

 static inline void
-fill_mask_RGBa(Imaging imOut, const UINT8* ink, Imaging imMask,
-               int dx, int dy, int sx, int sy,
-               int xsize, int ysize, int pixelsize)
-{
+fill_mask_RGBa(
+    Imaging imOut,
+    const UINT8 *ink,
+    Imaging imMask,
+    int dx,
+    int dy,
+    int sx,
+    int sy,
+    int xsize,
+    int ysize,
+    int pixelsize) {
     /* fill with mode "RGBa" matte */

     int x, y, i;
     unsigned int tmp1;

     if (imOut->image8) {
-
-        sx = sx*4 + 3;
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = imOut->image8[y+dy]+dx;
-            UINT8* mask = (UINT8*) imMask->image[y+sy]+sx;
+        sx = sx * 4 + 3;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = imOut->image8[y + dy] + dx;
+            UINT8 *mask = (UINT8 *)imMask->image[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 *out = PREBLEND(*mask, *out, ink[0], tmp1);
                 out++, mask += 4;
@@ -473,12 +530,11 @@
         }

     } else {
-
         dx *= pixelsize;
-        sx = sx*4 + 3;
-        for (y = 0; y < ysize; y++) {
-            UINT8* out = (UINT8*) imOut->image[y+dy]+dx;
-            UINT8* mask = (UINT8*) imMask->image[y+sy]+sx;
+        sx = sx * 4 + 3;
+        for (y = 0; y < ysize; y++) {
+            UINT8 *out = (UINT8 *)imOut->image[y + dy] + dx;
+            UINT8 *mask = (UINT8 *)imMask->image[y + sy] + sx;
             for (x = 0; x < xsize; x++) {
                 for (i = 0; i < pixelsize; i++) {
                     *out = PREBLEND(*mask, *out, ink[i], tmp1);
@@ -491,16 +547,21 @@
 }

 int
-ImagingFill2(Imaging imOut, const void* ink, Imaging imMask,
-             int dx0, int dy0, int dx1, int dy1)
-{
+ImagingFill2(
+    Imaging imOut,
+    const void *ink,
+    Imaging imMask,
+    int dx0,
+    int dy0,
+    int dx1,
+    int dy1) {
     ImagingSectionCookie cookie;
     int xsize, ysize;
     int pixelsize;
     int sx0, sy0;

     if (!imOut || !ink) {
-        (void) ImagingError_ModeError();
+        (void)ImagingError_ModeError();
         return -1;
     }

@@ -510,7 +571,7 @@
     ysize = dy1 - dy0;

     if (imMask && (xsize != imMask->xsize || ysize != imMask->ysize)) {
-        (void) ImagingError_Mismatch();
+        (void)ImagingError_Mismatch();
         return -1;
     }

@@ -540,30 +601,26 @@

     } else if (strcmp(imMask->mode, "1") == 0) {
         ImagingSectionEnter(&cookie);
-        fill_mask_1(imOut, ink, imMask, dx0, dy0, sx0, sy0,
-                    xsize, ysize, pixelsize);
+        fill_mask_1(imOut, ink, imMask, dx0, dy0, sx0, sy0, xsize, ysize, pixelsize);
         ImagingSectionLeave(&cookie);

     } else if (strcmp(imMask->mode, "L") == 0) {
         ImagingSectionEnter(&cookie);
-        fill_mask_L(imOut, ink, imMask, dx0, dy0, sx0, sy0,
-                    xsize, ysize, pixelsize);
+        fill_mask_L(imOut, ink, imMask, dx0, dy0, sx0, sy0, xsize, ysize, pixelsize);
         ImagingSectionLeave(&cookie);

     } else if (strcmp(imMask->mode, "RGBA") == 0) {
         ImagingSectionEnter(&cookie);
-        fill_mask_RGBA(imOut, ink, imMask, dx0, dy0, sx0, sy0,
-                       xsize, ysize, pixelsize);
+        fill_mask_RGBA(imOut, ink, imMask, dx0, dy0, sx0, sy0, xsize, ysize, pixelsize);
         ImagingSectionLeave(&cookie);

     } else if (strcmp(imMask->mode, "RGBa") == 0) {
         ImagingSectionEnter(&cookie);
-        fill_mask_RGBa(imOut, ink, imMask, dx0, dy0, sx0, sy0,
-                       xsize, ysize, pixelsize);
-        ImagingSectionLeave(&cookie);
-
-    } else {
-        (void) ImagingError_ValueError("bad transparency mask");
+        fill_mask_RGBa(imOut, ink, imMask, dx0, dy0, sx0, sy0, xsize, ysize, pixelsize);
+        ImagingSectionLeave(&cookie);
+
+    } else {
+        (void)ImagingError_ValueError("bad transparency mask");
         return -1;
     }

('src/libImaging', 'BcnDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -11,9 +11,9 @@
  *   https://creativecommons.org/publicdomain/zero/1.0/
  */

-
 #include "Imaging.h"

+#include "Bcn.h"

 typedef struct {
     UINT8 r, g, b, a;
@@ -37,23 +37,24 @@
     UINT8 lut[6];
 } bc3_alpha;

-#define LOAD16(p) \
-    (p)[0] | ((p)[1] << 8)
-
-#define LOAD32(p) \
-    (p)[0] | ((p)[1] << 8) | ((p)[2] << 16) | ((p)[3] << 24)
-
-static void bc1_color_load(bc1_color *dst, const UINT8 *src) {
+typedef struct {
+    INT8 a0, a1;
+    UINT8 lut[6];
+} bc5s_alpha;
+
+#define LOAD16(p) (p)[0] | ((p)[1] << 8)
+
+#define LOAD32(p) (p)[0] | ((p)[1] << 8) | ((p)[2] << 16) | ((p)[3] << 24)
+
+static void
+bc1_color_load(bc1_color *dst, const UINT8 *src) {
     dst->c0 = LOAD16(src);
     dst->c1 = LOAD16(src + 2);
     dst->lut = LOAD32(src + 4);
 }

-static void bc3_alpha_load(bc3_alpha *dst, const UINT8 *src) {
-    memcpy(dst, src, sizeof(bc3_alpha));
-}
-
-static rgba decode_565(UINT16 x) {
+static rgba
+decode_565(UINT16 x) {
     rgba c;
     int r, g, b;
     r = (x & 0xf800) >> 8;
@@ -69,7 +70,8 @@
     return c;
 }

-static void decode_bc1_color(rgba *dst, const UINT8 *src) {
+static void
+decode_bc1_color(rgba *dst, const UINT8 *src, int separate_alpha) {
     bc1_color col;
     rgba p[4];
     int n, cw;
@@ -84,14 +86,17 @@
     r1 = p[1].r;
     g1 = p[1].g;
     b1 = p[1].b;
-    if (col.c0 > col.c1) {
-        p[2].r = (2*r0 + 1*r1) / 3;
-        p[2].g = (2*g0 + 1*g1) / 3;
-        p[2].b = (2*b0 + 1*b1) / 3;
+
+
+    /* NOTE: BC2 and BC3 reuse BC1 color blocks but always act like c0 > c1 */
+    if (col.c0 > col.c1 || separate_alpha) {
+        p[2].r = (2 * r0 + 1 * r1) / 3;
+        p[2].g = (2 * g0 + 1 * g1) / 3;
+        p[2].b = (2 * b0 + 1 * b1) / 3;
         p[2].a = 0xff;
-        p[3].r = (1*r0 + 2*r1) / 3;
-        p[3].g = (1*g0 + 2*g1) / 3;
-        p[3].b = (1*b0 + 2*b1) / 3;
+        p[3].r = (1 * r0 + 2 * r1) / 3;
+        p[3].g = (1 * g0 + 2 * g1) / 3;
+        p[3].b = (1 * b0 + 2 * b1) / 3;
         p[3].a = 0xff;
     } else {
         p[2].r = (r0 + r1) / 2;
@@ -109,51 +114,63 @@
     }
 }

-static void decode_bc3_alpha(char *dst, const UINT8 *src, int stride, int o) {
-    bc3_alpha b;
+static void
+decode_bc3_alpha(char *dst, const UINT8 *src, int stride, int o, int sign) {
     UINT16 a0, a1;
     UINT8 a[8];
-    int n, lut, aw;
-    bc3_alpha_load(&b, src);
-
-    a0 = b.a0;
-    a1 = b.a1;
+    int n, lut1, lut2, aw;
+    if (sign == 1) {
+        bc5s_alpha b;
+        memcpy(&b, src, sizeof(bc5s_alpha));
+        a0 = (b.a0 + 255) / 2;
+        a1 = (b.a1 + 255) / 2;
+        lut1 = b.lut[0] | (b.lut[1] << 8) | (b.lut[2] << 16);
+        lut2 = b.lut[3] | (b.lut[4] << 8) | (b.lut[5] << 16);
+    } else {
+        bc3_alpha b;
+        memcpy(&b, src, sizeof(bc3_alpha));
+        a0 = b.a0;
+        a1 = b.a1;
+        lut1 = b.lut[0] | (b.lut[1] << 8) | (b.lut[2] << 16);
+        lut2 = b.lut[3] | (b.lut[4] << 8) | (b.lut[5] << 16);
+    }
+
     a[0] = (UINT8)a0;
     a[1] = (UINT8)a1;
     if (a0 > a1) {
-        a[2] = (6*a0 + 1*a1) / 7;
-        a[3] = (5*a0 + 2*a1) / 7;
-        a[4] = (4*a0 + 3*a1) / 7;
-        a[5] = (3*a0 + 4*a1) / 7;
-        a[6] = (2*a0 + 5*a1) / 7;
-        a[7] = (1*a0 + 6*a1) / 7;
+        a[2] = (6 * a0 + 1 * a1) / 7;
+        a[3] = (5 * a0 + 2 * a1) / 7;
+        a[4] = (4 * a0 + 3 * a1) / 7;
+        a[5] = (3 * a0 + 4 * a1) / 7;
+        a[6] = (2 * a0 + 5 * a1) / 7;
+        a[7] = (1 * a0 + 6 * a1) / 7;
     } else {
-        a[2] = (4*a0 + 1*a1) / 5;
-        a[3] = (3*a0 + 2*a1) / 5;
-        a[4] = (2*a0 + 3*a1) / 5;
-        a[5] = (1*a0 + 4*a1) / 5;
+        a[2] = (4 * a0 + 1 * a1) / 5;
+        a[3] = (3 * a0 + 2 * a1) / 5;
+        a[4] = (2 * a0 + 3 * a1) / 5;
+        a[5] = (1 * a0 + 4 * a1) / 5;
         a[6] = 0;
         a[7] = 0xff;
     }
-    lut = b.lut[0] | (b.lut[1] << 8) | (b.lut[2] << 16);
     for (n = 0; n < 8; n++) {
-        aw = 7 & (lut >> (3 * n));
+        aw = 7 & (lut1 >> (3 * n));
         dst[stride * n + o] = a[aw];
     }
-    lut = b.lut[3] | (b.lut[4] << 8) | (b.lut[5] << 16);
     for (n = 0; n < 8; n++) {
-        aw = 7 & (lut >> (3 * n));
-        dst[stride * (8+n) + o] = a[aw];
-    }
-}
-
-static void decode_bc1_block(rgba *col, const UINT8* src) {
-    decode_bc1_color(col, src);
-}
-
-static void decode_bc2_block(rgba *col, const UINT8* src) {
+        aw = 7 & (lut2 >> (3 * n));
+        dst[stride * (8 + n) + o] = a[aw];
+    }
+}
+
+static void
+decode_bc1_block(rgba *col, const UINT8 *src) {
+    decode_bc1_color(col, src, 0);
+}
+
+static void
+decode_bc2_block(rgba *col, const UINT8 *src) {
     int n, bitI, byI, av;
-    decode_bc1_color(col, src + 8);
+    decode_bc1_color(col, src + 8, 1);
     for (n = 0; n < 16; n++) {
         bitI = n * 4;
         byI = bitI >> 3;
@@ -163,30 +180,36 @@
     }
 }

-static void decode_bc3_block(rgba *col, const UINT8* src) {
-    decode_bc1_color(col, src + 8);
-    decode_bc3_alpha((char *)col, src, sizeof(col[0]), 3);
-}
-
-static void decode_bc4_block(lum *col, const UINT8* src) {
-    decode_bc3_alpha((char *)col, src, sizeof(col[0]), 0);
-}
-
-static void decode_bc5_block(rgba *col, const UINT8* src) {
-    decode_bc3_alpha((char *)col, src, sizeof(col[0]), 0);
-    decode_bc3_alpha((char *)col, src + 8, sizeof(col[0]), 1);
+static void
+decode_bc3_block(rgba *col, const UINT8 *src) {
+    decode_bc1_color(col, src + 8, 1);
+    decode_bc3_alpha((char *)col, src, sizeof(col[0]), 3, 0);
+}
+
+static void
+decode_bc4_block(lum *col, const UINT8 *src) {
+    decode_bc3_alpha((char *)col, src, sizeof(col[0]), 0, 0);
+}
+
+static void
+decode_bc5_block(rgba *col, const UINT8 *src, int sign) {
+    decode_bc3_alpha((char *)col, src, sizeof(col[0]), 0, sign);
+    decode_bc3_alpha((char *)col, src + 8, sizeof(col[0]), 1, sign);
 }

 /* BC6 and BC7 are described here:
-   https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_texture_compression_bptc.txt */
-
-static UINT8 get_bit(const UINT8* src, int bit) {
+   https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_texture_compression_bptc.txt
+ */
+
+static UINT8
+get_bit(const UINT8 *src, int bit) {
     int by = bit >> 3;
     bit &= 7;
     return (src[by] >> bit) & 1;
 }

-static UINT8 get_bits(const UINT8* src, int bit, int count) {
+static UINT8
+get_bits(const UINT8 *src, int bit, int count) {
     UINT8 v;
     int x;
     int by = bit >> 3;
@@ -197,7 +220,7 @@
     if (bit + count <= 8) {
         v = (src[by] >> bit) & ((1 << count) - 1);
     } else {
-        x = src[by] | (src[by+1] << 8);
+        x = src[by] | (src[by + 1] << 8);
         v = (x >> bit) & ((1 << count) - 1);
     }
     return v;
@@ -225,73 +248,51 @@
     {1, 0, 2, 1, 5, 6, 0, 0, 2, 3},
     {1, 0, 2, 0, 7, 8, 0, 0, 2, 2},
     {1, 0, 0, 0, 7, 7, 1, 0, 4, 0},
-    {2, 6, 0, 0, 5, 5, 1, 0, 2, 0}
-};
+    {2, 6, 0, 0, 5, 5, 1, 0, 2, 0}};

 /* Subset indices:
    Table.P2, 1 bit per index */
 static const UINT16 bc7_si2[] = {
-    0xcccc, 0x8888, 0xeeee, 0xecc8, 0xc880, 0xfeec, 0xfec8, 0xec80,
-    0xc800, 0xffec, 0xfe80, 0xe800, 0xffe8, 0xff00, 0xfff0, 0xf000,
-    0xf710, 0x008e, 0x7100, 0x08ce, 0x008c, 0x7310, 0x3100, 0x8cce,
-    0x088c, 0x3110, 0x6666, 0x366c, 0x17e8, 0x0ff0, 0x718e, 0x399c,
-    0xaaaa, 0xf0f0, 0x5a5a, 0x33cc, 0x3c3c, 0x55aa, 0x9696, 0xa55a,
-    0x73ce, 0x13c8, 0x324c, 0x3bdc, 0x6996, 0xc33c, 0x9966, 0x0660,
-    0x0272, 0x04e4, 0x4e40, 0x2720, 0xc936, 0x936c, 0x39c6, 0x639c,
-    0x9336, 0x9cc6, 0x817e, 0xe718, 0xccf0, 0x0fcc, 0x7744, 0xee22};
+    0xcccc, 0x8888, 0xeeee, 0xecc8, 0xc880, 0xfeec, 0xfec8, 0xec80, 0xc800, 0xffec,
+    0xfe80, 0xe800, 0xffe8, 0xff00, 0xfff0, 0xf000, 0xf710, 0x008e, 0x7100, 0x08ce,
+    0x008c, 0x7310, 0x3100, 0x8cce, 0x088c, 0x3110, 0x6666, 0x366c, 0x17e8, 0x0ff0,
+    0x718e, 0x399c, 0xaaaa, 0xf0f0, 0x5a5a, 0x33cc, 0x3c3c, 0x55aa, 0x9696, 0xa55a,
+    0x73ce, 0x13c8, 0x324c, 0x3bdc, 0x6996, 0xc33c, 0x9966, 0x0660, 0x0272, 0x04e4,
+    0x4e40, 0x2720, 0xc936, 0x936c, 0x39c6, 0x639c, 0x9336, 0x9cc6, 0x817e, 0xe718,
+    0xccf0, 0x0fcc, 0x7744, 0xee22};

 /* Table.P3, 2 bits per index */
 static const UINT32 bc7_si3[] = {
-    0xaa685050, 0x6a5a5040, 0x5a5a4200, 0x5450a0a8,
-    0xa5a50000, 0xa0a05050, 0x5555a0a0, 0x5a5a5050,
-    0xaa550000, 0xaa555500, 0xaaaa5500, 0x90909090,
-    0x94949494, 0xa4a4a4a4, 0xa9a59450, 0x2a0a4250,
-    0xa5945040, 0x0a425054, 0xa5a5a500, 0x55a0a0a0,
-    0xa8a85454, 0x6a6a4040, 0xa4a45000, 0x1a1a0500,
-    0x0050a4a4, 0xaaa59090, 0x14696914, 0x69691400,
-    0xa08585a0, 0xaa821414, 0x50a4a450, 0x6a5a0200,
-    0xa9a58000, 0x5090a0a8, 0xa8a09050, 0x24242424,
-    0x00aa5500, 0x24924924, 0x24499224, 0x50a50a50,
-    0x500aa550, 0xaaaa4444, 0x66660000, 0xa5a0a5a0,
-    0x50a050a0, 0x69286928, 0x44aaaa44, 0x66666600,
-    0xaa444444, 0x54a854a8, 0x95809580, 0x96969600,
-    0xa85454a8, 0x80959580, 0xaa141414, 0x96960000,
-    0xaaaa1414, 0xa05050a0, 0xa0a5a5a0, 0x96000000,
-    0x40804080, 0xa9a8a9a8, 0xaaaaaa44, 0x2a4a5254};
+    0xaa685050, 0x6a5a5040, 0x5a5a4200, 0x5450a0a8, 0xa5a50000, 0xa0a05050, 0x5555a0a0,
+    0x5a5a5050, 0xaa550000, 0xaa555500, 0xaaaa5500, 0x90909090, 0x94949494, 0xa4a4a4a4,
+    0xa9a59450, 0x2a0a4250, 0xa5945040, 0x0a425054, 0xa5a5a500, 0x55a0a0a0, 0xa8a85454,
+    0x6a6a4040, 0xa4a45000, 0x1a1a0500, 0x0050a4a4, 0xaaa59090, 0x14696914, 0x69691400,
+    0xa08585a0, 0xaa821414, 0x50a4a450, 0x6a5a0200, 0xa9a58000, 0x5090a0a8, 0xa8a09050,
+    0x24242424, 0x00aa5500, 0x24924924, 0x24499224, 0x50a50a50, 0x500aa550, 0xaaaa4444,
+    0x66660000, 0xa5a0a5a0, 0x50a050a0, 0x69286928, 0x44aaaa44, 0x66666600, 0xaa444444,
+    0x54a854a8, 0x95809580, 0x96969600, 0xa85454a8, 0x80959580, 0xaa141414, 0x96960000,
+    0xaaaa1414, 0xa05050a0, 0xa0a5a5a0, 0x96000000, 0x40804080, 0xa9a8a9a8, 0xaaaaaa44,
+    0x2a4a5254};

 /* Anchor indices:
    Table.A2 */
 static const char bc7_ai0[] = {
-    15,15,15,15,15,15,15,15,
-    15,15,15,15,15,15,15,15,
-    15, 2, 8, 2, 2, 8, 8,15,
-     2, 8, 2, 2, 8, 8, 2, 2,
-    15,15, 6, 8, 2, 8,15,15,
-     2, 8, 2, 2, 2,15,15, 6,
-     6, 2, 6, 8,15,15, 2, 2,
-    15,15,15,15,15, 2, 2,15};
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 2,  8, 2, 2, 8,
+    8,  15, 2,  8,  2,  2,  8,  8,  2,  2,  15, 15, 6,  8,  2,  8,  15, 15, 2, 8, 2, 2,
+    2,  15, 15, 6,  6,  2,  6,  8,  15, 15, 2,  2,  15, 15, 15, 15, 15, 2,  2, 15};

 /* Table.A3a */
 static const char bc7_ai1[] = {
-     3, 3,15,15, 8, 3,15,15,
-     8, 8, 6, 6, 6, 5, 3, 3,
-     3, 3, 8,15, 3, 3, 6,10,
-     5, 8, 8, 6, 8, 5,15,15,
-     8,15, 3, 5, 6,10, 8,15,
-    15, 3,15, 5,15,15,15,15,
-     3,15, 5, 5, 5, 8, 5,10,
-     5,10, 8,13,15,12, 3, 3};
+    3,  3,  15, 15, 8, 3,  15, 15, 8,  8,  6, 6,  6, 5,  3, 3,  3,  3,  8,  15, 3,  3,
+    6,  10, 5,  8,  8, 6,  8,  5,  15, 15, 8, 15, 3, 5,  6, 10, 8,  15, 15, 3,  15, 5,
+    15, 15, 15, 15, 3, 15, 5,  5,  5,  8,  5, 10, 5, 10, 8, 13, 15, 12, 3,  3};

 /* Table.A3b */
-static const char bc7_ai2[] = {
-    15, 8, 8, 3,15,15, 3, 8,
-    15,15,15,15,15,15,15, 8,
-    15, 8,15, 3,15, 8,15, 8,
-     3,15, 6,10,15,15,10, 8,
-    15, 3,15,10,10, 8, 9,10,
-     6,15, 8,15, 3, 6, 6, 8,
-    15, 3,15,15,15,15,15,15,
-    15,15,15,15, 3,15,15, 8};
+static const char bc7_ai2[] = {15, 8,  8,  3,  15, 15, 3,  8,  15, 15, 15, 15, 15,
+                               15, 15, 8,  15, 8,  15, 3,  15, 8,  15, 8,  3,  15,
+                               6,  10, 15, 15, 10, 8,  15, 3,  15, 10, 10, 8,  9,
+                               10, 6,  15, 8,  15, 3,  6,  6,  8,  15, 3,  15, 15,
+                               15, 15, 15, 15, 15, 15, 15, 15, 3,  15, 15, 8};

 /* Interpolation weights */
 static const char bc7_weights2[] = {0, 21, 43, 64};
@@ -299,7 +300,8 @@
 static const char bc7_weights4[] = {
     0, 4, 9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64};

-static const char *bc7_get_weights(int n) {
+static const char *
+bc7_get_weights(int n) {
     if (n == 2) {
         return bc7_weights2;
     }
@@ -309,7 +311,8 @@
     return bc7_weights4;
 }

-static int bc7_get_subset(int ns, int partition, int n) {
+static int
+bc7_get_subset(int ns, int partition, int n) {
     if (ns == 2) {
         return 1 & (bc7_si2[partition] >> n);
     }
@@ -319,12 +322,14 @@
     return 0;
 }

-static UINT8 expand_quantized(UINT8 v, int bits) {
+static UINT8
+expand_quantized(UINT8 v, int bits) {
     v = v << (8 - bits);
     return v | (v >> bits);
 }

-static void bc7_lerp(rgba *dst, const rgba *e, int s0, int s1) {
+static void
+bc7_lerp(rgba *dst, const rgba *e, int s0, int s1) {
     int t0 = 64 - s0;
     int t1 = 64 - s1;
     dst->r = (UINT8)((t0 * e[0].r + s0 * e[1].r + 32) >> 6);
@@ -333,7 +338,8 @@
     dst->a = (UINT8)((t1 * e[0].a + s1 * e[1].a + 32) >> 6);
 }

-static void decode_bc7_block(rgba *col, const UINT8* src) {
+static void
+decode_bc7_block(rgba *col, const UINT8 *src) {
     rgba endpoints[6];
     int bit = 0, cibit, aibit;
     int mode = src[0];
@@ -352,7 +358,8 @@
         }
         return;
     }
-    while (!(mode & (1 << bit++))) ;
+    while (!(mode & (1 << bit++)))
+        ;
     mode = bit - 1;
     info = &bc7_modes[mode];
     /* color selection bits: {subset}{endpoint} */
@@ -361,7 +368,7 @@
     cw = bc7_get_weights(info->ib);
     aw = bc7_get_weights((ab && info->ib2) ? info->ib2 : info->ib);

-#define LOAD(DST, N) \
+#define LOAD(DST, N)             \
     DST = get_bits(src, bit, N); \
     bit += N;
     LOAD(partition, info->pb);
@@ -421,14 +428,14 @@
         if (ab) {
             ab++;
         }
-        for (i = 0; i < numep; i+=2) {
+        for (i = 0; i < numep; i += 2) {
             LOAD(val, 1);
             for (j = 0; j < 2; j++) {
-                ASSIGN_P(endpoints[i+j].r);
-                ASSIGN_P(endpoints[i+j].g);
-                ASSIGN_P(endpoints[i+j].b);
+                ASSIGN_P(endpoints[i + j].r);
+                ASSIGN_P(endpoints[i + j].g);
+                ASSIGN_P(endpoints[i + j].b);
                 if (ab) {
-                    ASSIGN_P(endpoints[i+j].a);
+                    ASSIGN_P(endpoints[i + j].a);
                 }
             }
         }
@@ -482,9 +489,9 @@
             bc7_lerp(&col[i], &endpoints[s], cw[i0], cw[i0]);
         }
 #define ROTATE(x, y) \
-        val = x; \
-        x = y; \
-        y = val
+    val = x;         \
+    x = y;           \
+    y = val
         if (rotation == 1) {
             ROTATE(col[i].r, col[i].a);
         } else if (rotation == 2) {
@@ -498,106 +505,102 @@

 /* BC6 */
 typedef struct {
-    char ns; /* number of subsets (also called regions) */
-    char tr; /* whether endpoints are delta-compressed */
-    char pb; /* partition bits */
+    char ns;  /* number of subsets (also called regions) */
+    char tr;  /* whether endpoints are delta-compressed */
+    char pb;  /* partition bits */
     char epb; /* endpoint bits */
-    char rb; /* red bits (delta) */
-    char gb; /* green bits (delta) */
-    char bb; /* blue bits (delta) */
+    char rb;  /* red bits (delta) */
+    char gb;  /* green bits (delta) */
+    char bb;  /* blue bits (delta) */
 } bc6_mode_info;

 static const bc6_mode_info bc6_modes[] = {
     // 00
     {2, 1, 5, 10, 5, 5, 5},
     // 01
-    {2, 1, 5,  7, 6, 6, 6},
+    {2, 1, 5, 7, 6, 6, 6},
     // 10
     {2, 1, 5, 11, 5, 4, 4},
     {2, 1, 5, 11, 4, 5, 4},
     {2, 1, 5, 11, 4, 4, 5},
-    {2, 1, 5,  9, 5, 5, 5},
-    {2, 1, 5,  8, 6, 5, 5},
-    {2, 1, 5,  8, 5, 6, 5},
-    {2, 1, 5,  8, 5, 5, 6},
-    {2, 0, 5,  6, 6, 6, 6},
+    {2, 1, 5, 9, 5, 5, 5},
+    {2, 1, 5, 8, 6, 5, 5},
+    {2, 1, 5, 8, 5, 6, 5},
+    {2, 1, 5, 8, 5, 5, 6},
+    {2, 0, 5, 6, 6, 6, 6},
     // 11
     {1, 0, 0, 10, 10, 10, 10},
-    {1, 1, 0, 11,  9,  9,  9},
-    {1, 1, 0, 12,  8,  8,  8},
-    {1, 1, 0, 16,  4,  4,  4}
-};
+    {1, 1, 0, 11, 9, 9, 9},
+    {1, 1, 0, 12, 8, 8, 8},
+    {1, 1, 0, 16, 4, 4, 4}};

 /* Table.F, encoded as a sequence of bit indices */
 static const UINT8 bc6_bit_packings[][75] = {
-    {116, 132, 176, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22,
-     23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52,
-     164, 112, 113, 114, 115, 64, 65, 66, 67, 68, 172, 160, 161, 162, 163, 80,
-     81, 82, 83, 84, 173, 128, 129, 130, 131, 96, 97, 98, 99, 100, 174, 144,
-     145, 146, 147, 148, 175},
-    {117, 164, 165, 0, 1, 2, 3, 4, 5, 6, 172, 173, 132, 16, 17, 18, 19, 20, 21,
-     22, 133, 174, 116, 32, 33, 34, 35, 36, 37, 38, 175, 177, 176, 48, 49, 50,
-     51, 52, 53, 112, 113, 114, 115, 64, 65, 66, 67, 68, 69, 160, 161, 162, 163,
-     80, 81, 82, 83, 84, 85, 128, 129, 130, 131, 96, 97, 98, 99, 100, 101, 144,
-     145, 146, 147, 148, 149},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32,
-     33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 10, 112, 113, 114,
-     115, 64, 65, 66, 67, 26, 172, 160, 161, 162, 163, 80, 81, 82, 83, 42, 173,
-     128, 129, 130, 131, 96, 97, 98, 99, 100, 174, 144, 145, 146, 147, 148,
-     175},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32,
-     33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 10, 164, 112, 113, 114,
-     115, 64, 65, 66, 67, 68, 26, 160, 161, 162, 163, 80, 81, 82, 83, 42, 173,
-     128, 129, 130, 131, 96, 97, 98, 99, 172, 174, 144, 145, 146, 147, 116,
-     175},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32,
-     33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 10, 132, 112, 113, 114,
-     115, 64, 65, 66, 67, 26, 172, 160, 161, 162, 163, 80, 81, 82, 83, 84, 42,
-     128, 129, 130, 131, 96, 97, 98, 99, 173, 174, 144, 145, 146, 147, 176,
-     175},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 132, 16, 17, 18, 19, 20, 21, 22, 23, 24, 116,
-     32, 33, 34, 35, 36, 37, 38, 39, 40, 176, 48, 49, 50, 51, 52, 164, 112, 113,
-     114, 115, 64, 65, 66, 67, 68, 172, 160, 161, 162, 163, 80, 81, 82, 83, 84,
-     173, 128, 129, 130, 131, 96, 97, 98, 99, 100, 174, 144, 145, 146, 147, 148,
-     175},
-    {0, 1, 2, 3, 4, 5, 6, 7, 164, 132, 16, 17, 18, 19, 20, 21, 22, 23, 174, 116,
-     32, 33, 34, 35, 36, 37, 38, 39, 175, 176, 48, 49, 50, 51, 52, 53, 112, 113,
-     114, 115, 64, 65, 66, 67, 68, 172, 160, 161, 162, 163, 80, 81, 82, 83, 84,
-     173, 128, 129, 130, 131, 96, 97, 98, 99, 100, 101, 144, 145, 146, 147, 148,
-     149},
-    {0, 1, 2, 3, 4, 5, 6, 7, 172, 132, 16, 17, 18, 19, 20, 21, 22, 23, 117, 116,
-     32, 33, 34, 35, 36, 37, 38, 39, 165, 176, 48, 49, 50, 51, 52, 164, 112,
-     113, 114, 115, 64, 65, 66, 67, 68, 69, 160, 161, 162, 163, 80, 81, 82, 83,
-     84, 173, 128, 129, 130, 131, 96, 97, 98, 99, 100, 174, 144, 145, 146, 147,
-     148, 175},
-    {0, 1, 2, 3, 4, 5, 6, 7, 173, 132, 16, 17, 18, 19, 20, 21, 22, 23, 133, 116,
-     32, 33, 34, 35, 36, 37, 38, 39, 177, 176, 48, 49, 50, 51, 52, 164, 112,
-     113, 114, 115, 64, 65, 66, 67, 68, 172, 160, 161, 162, 163, 80, 81, 82, 83,
-     84, 85, 128, 129, 130, 131, 96, 97, 98, 99, 100, 174, 144, 145, 146, 147,
-     148, 175},
-    {0, 1, 2, 3, 4, 5, 164, 172, 173, 132, 16, 17, 18, 19, 20, 21, 117, 133,
-     174, 116, 32, 33, 34, 35, 36, 37, 165, 175, 177, 176, 48, 49, 50, 51, 52,
-     53, 112, 113, 114, 115, 64, 65, 66, 67, 68, 69, 160, 161, 162, 163, 80, 81,
-     82, 83, 84, 85, 128, 129, 130, 131, 96, 97, 98, 99, 100, 101, 144, 145,
-     146, 147, 148, 149},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32,
-     33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
-     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 80, 81, 82, 83, 84, 85, 86, 87, 88,
-     89},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32,
-     33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 10,
-     64, 65, 66, 67, 68, 69, 70, 71, 72, 26, 80, 81, 82, 83, 84, 85, 86, 87, 88,
-     42},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32,
-     33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 11, 10,
-     64, 65, 66, 67, 68, 69, 70, 71, 27, 26, 80, 81, 82, 83, 84, 85, 86, 87, 43,
-     42},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32,
-     33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 15, 14, 13, 12, 11, 10,
-     64, 65, 66, 67, 31, 30, 29, 28, 27, 26, 80, 81, 82, 83, 47, 46, 45, 44, 43,
-     42}};
-
-static void bc6_sign_extend(UINT16 *v, int prec) {
+    {116, 132, 176, 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   16,  17,
+     18,  19,  20,  21,  22,  23,  24,  25,  32,  33,  34,  35,  36,  37,  38,
+     39,  40,  41,  48,  49,  50,  51,  52,  164, 112, 113, 114, 115, 64,  65,
+     66,  67,  68,  172, 160, 161, 162, 163, 80,  81,  82,  83,  84,  173, 128,
+     129, 130, 131, 96,  97,  98,  99,  100, 174, 144, 145, 146, 147, 148, 175},
+    {117, 164, 165, 0,  1,   2,   3,   4,   5,   6,   172, 173, 132, 16,  17,
+     18,  19,  20,  21, 22,  133, 174, 116, 32,  33,  34,  35,  36,  37,  38,
+     175, 177, 176, 48, 49,  50,  51,  52,  53,  112, 113, 114, 115, 64,  65,
+     66,  67,  68,  69, 160, 161, 162, 163, 80,  81,  82,  83,  84,  85,  128,
+     129, 130, 131, 96, 97,  98,  99,  100, 101, 144, 145, 146, 147, 148, 149},
+    {0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   16,  17,  18,  19,  20,
+     21,  22,  23,  24,  25,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,
+     48,  49,  50,  51,  52,  10,  112, 113, 114, 115, 64,  65,  66,  67,  26,
+     172, 160, 161, 162, 163, 80,  81,  82,  83,  42,  173, 128, 129, 130, 131,
+     96,  97,  98,  99,  100, 174, 144, 145, 146, 147, 148, 175},
+    {0,  1,   2,   3,   4,   5,   6,   7,   8,   9,   16,  17,  18,  19,  20,
+     21, 22,  23,  24,  25,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,
+     48, 49,  50,  51,  10,  164, 112, 113, 114, 115, 64,  65,  66,  67,  68,
+     26, 160, 161, 162, 163, 80,  81,  82,  83,  42,  173, 128, 129, 130, 131,
+     96, 97,  98,  99,  172, 174, 144, 145, 146, 147, 116, 175},
+    {0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   16,  17,  18,  19,  20,
+     21,  22,  23,  24,  25,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,
+     48,  49,  50,  51,  10,  132, 112, 113, 114, 115, 64,  65,  66,  67,  26,
+     172, 160, 161, 162, 163, 80,  81,  82,  83,  84,  42,  128, 129, 130, 131,
+     96,  97,  98,  99,  173, 174, 144, 145, 146, 147, 176, 175},
+    {0,   1,   2,   3,   4,   5,   6,   7,   8,   132, 16,  17,  18,  19,  20,
+     21,  22,  23,  24,  116, 32,  33,  34,  35,  36,  37,  38,  39,  40,  176,
+     48,  49,  50,  51,  52,  164, 112, 113, 114, 115, 64,  65,  66,  67,  68,
+     172, 160, 161, 162, 163, 80,  81,  82,  83,  84,  173, 128, 129, 130, 131,
+     96,  97,  98,  99,  100, 174, 144, 145, 146, 147, 148, 175},
+    {0,   1,   2,   3,   4,   5,   6,   7,   164, 132, 16,  17,  18,  19,  20,
+     21,  22,  23,  174, 116, 32,  33,  34,  35,  36,  37,  38,  39,  175, 176,
+     48,  49,  50,  51,  52,  53,  112, 113, 114, 115, 64,  65,  66,  67,  68,
+     172, 160, 161, 162, 163, 80,  81,  82,  83,  84,  173, 128, 129, 130, 131,
+     96,  97,  98,  99,  100, 101, 144, 145, 146, 147, 148, 149},
+    {0,  1,   2,   3,   4,   5,   6,   7,   172, 132, 16,  17,  18,  19,  20,
+     21, 22,  23,  117, 116, 32,  33,  34,  35,  36,  37,  38,  39,  165, 176,
+     48, 49,  50,  51,  52,  164, 112, 113, 114, 115, 64,  65,  66,  67,  68,
+     69, 160, 161, 162, 163, 80,  81,  82,  83,  84,  173, 128, 129, 130, 131,
+     96, 97,  98,  99,  100, 174, 144, 145, 146, 147, 148, 175},
+    {0,   1,   2,   3,   4,   5,   6,   7,   173, 132, 16,  17,  18,  19,  20,
+     21,  22,  23,  133, 116, 32,  33,  34,  35,  36,  37,  38,  39,  177, 176,
+     48,  49,  50,  51,  52,  164, 112, 113, 114, 115, 64,  65,  66,  67,  68,
+     172, 160, 161, 162, 163, 80,  81,  82,  83,  84,  85,  128, 129, 130, 131,
+     96,  97,  98,  99,  100, 174, 144, 145, 146, 147, 148, 175},
+    {0,  1,   2,   3,   4,   5,   164, 172, 173, 132, 16,  17,  18,  19,  20,
+     21, 117, 133, 174, 116, 32,  33,  34,  35,  36,  37,  165, 175, 177, 176,
+     48, 49,  50,  51,  52,  53,  112, 113, 114, 115, 64,  65,  66,  67,  68,
+     69, 160, 161, 162, 163, 80,  81,  82,  83,  84,  85,  128, 129, 130, 131,
+     96, 97,  98,  99,  100, 101, 144, 145, 146, 147, 148, 149},
+    {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
+     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
+     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89},
+    {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
+     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 10,
+     64, 65, 66, 67, 68, 69, 70, 71, 72, 26, 80, 81, 82, 83, 84, 85, 86, 87, 88, 42},
+    {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
+     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 11, 10,
+     64, 65, 66, 67, 68, 69, 70, 71, 27, 26, 80, 81, 82, 83, 84, 85, 86, 87, 43, 42},
+    {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
+     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 15, 14, 13, 12, 11, 10,
+     64, 65, 66, 67, 31, 30, 29, 28, 27, 26, 80, 81, 82, 83, 47, 46, 45, 44, 43, 42}};
+
+static void
+bc6_sign_extend(UINT16 *v, int prec) {
     int x = *v;
     if (x & (1 << (prec - 1))) {
         x |= -1 << prec;
@@ -605,7 +608,8 @@
     *v = (UINT16)x;
 }

-static int bc6_unquantize(UINT16 v, int prec, int sign) {
+static int
+bc6_unquantize(UINT16 v, int prec, int sign) {
     int s = 0;
     int x;
     if (!sign) {
@@ -645,7 +649,8 @@
     }
 }

-static float half_to_float(UINT16 h) {
+static float
+half_to_float(UINT16 h) {
     /* https://gist.github.com/rygorous/2144712 */
     union {
         UINT32 u;
@@ -662,7 +667,8 @@
     return o.f;
 }

-static float bc6_finalize(int v, int sign) {
+static float
+bc6_finalize(int v, int sign) {
     if (sign) {
         if (v < 0) {
             v = ((-v) * 31) / 32;
@@ -675,7 +681,8 @@
     }
 }

-static void bc6_lerp(rgb32f *col, int *e0, int *e1, int s, int sign) {
+static void
+bc6_lerp(rgb32f *col, int *e0, int *e1, int s, int sign) {
     int r, g, b;
     int t = 64 - s;
     r = (e0[0] * t + e1[0] * s) >> 6;
@@ -686,7 +693,8 @@
     col->b = bc6_finalize(b, sign);
 }

-static void decode_bc6_block(rgb32f *col, const UINT8* src, int sign) {
+static void
+decode_bc6_block(rgb32f *col, const UINT8 *src, int sign) {
     UINT16 endpoints[12]; /* storage for r0, g0, b0, r1, ... */
     int ueps[12];
     int i, i0, ib2, di, dw, mask, numep, s;
@@ -736,9 +744,9 @@
     }
     if (sign || info->tr) { /* sign-extend e1,2,3 if signed or deltas */
         for (i = 3; i < numep; i += 3) {
-            bc6_sign_extend(&endpoints[i+0], info->rb);
-            bc6_sign_extend(&endpoints[i+1], info->gb);
-            bc6_sign_extend(&endpoints[i+2], info->bb);
+            bc6_sign_extend(&endpoints[i + 0], info->rb);
+            bc6_sign_extend(&endpoints[i + 1], info->gb);
+            bc6_sign_extend(&endpoints[i + 2], info->bb);
         }
     }
     if (info->tr) { /* apply deltas */
@@ -747,9 +755,9 @@
         }
         if (sign) {
             for (i = 3; i < numep; i += 3) {
-                bc6_sign_extend(&endpoints[i+0], info->rb);
-                bc6_sign_extend(&endpoints[i+1], info->gb);
-                bc6_sign_extend(&endpoints[i+2], info->bb);
+                bc6_sign_extend(&endpoints[i + 0], info->rb);
+                bc6_sign_extend(&endpoints[i + 1], info->gb);
+                bc6_sign_extend(&endpoints[i + 2], info->bb);
             }
         }
     }
@@ -769,11 +777,12 @@
         i0 = get_bits(src, bit, ib2);
         bit += ib2;

-        bc6_lerp(&col[i], &ueps[s], &ueps[s+3], cw[i0], sign);
-    }
-}
-
-static void put_block(Imaging im, ImagingCodecState state, const char *col, int sz, int C) {
+        bc6_lerp(&col[i], &ueps[s], &ueps[s + 3], cw[i0], sign);
+    }
+}
+
+static void
+put_block(Imaging im, ImagingCodecState state, const char *col, int sz, int C) {
     int width = state->xsize;
     int height = state->ysize;
     int xmax = width + state->xoff;
@@ -795,15 +804,15 @@
                 if (x >= width) {
                     continue;
                 }
-                memcpy(dst + sz*x, col + sz*(j*4 + i), sz);
+                memcpy(dst + sz * x, col + sz * (j * 4 + i), sz);
             }
         } else {
             if (state->ystep < 0) {
                 y = state->yoff + ymax - y - 1;
             }
             x = state->x;
-            dst = im->image[y] + sz*x;
-            memcpy(dst, col + sz*(j*4), 4 * sz);
+            dst = im->image[y] + sz * x;
+            memcpy(dst, col + sz * (j * 4), 4 * sz);
         }
     }
     state->x += 4;
@@ -813,30 +822,44 @@
     }
 }

-static int decode_bcn(Imaging im, ImagingCodecState state, const UINT8* src, int bytes, int N, int C) {
+static int
+decode_bcn(
+    Imaging im, ImagingCodecState state, const UINT8 *src, int bytes, int N, int C, char *pixel_format) {
     int ymax = state->ysize + state->yoff;
     const UINT8 *ptr = src;
     switch (N) {
-#define DECODE_LOOP(NN, SZ, TY, ...) \
-    case NN: \
-        while (bytes >= SZ) { \
-            TY col[16]; \
-            memset(col, 0, 16 * sizeof(col[0])); \
-            decode_bc##NN##_block(col, ptr); \
+#define DECODE_LOOP(NN, SZ, TY, ...)                                    \
+    case NN:                                                            \
+        while (bytes >= SZ) {                                           \
+            TY col[16];                                                 \
+            memset(col, 0, 16 * sizeof(col[0]));                        \
+            decode_bc##NN##_block(col, ptr);                            \
             put_block(im, state, (const char *)col, sizeof(col[0]), C); \
-            ptr += SZ; \
-            bytes -= SZ; \
-            if (state->y >= ymax) {\
-                return -1; \
-            }\
-        } \
+            ptr += SZ;                                                  \
+            bytes -= SZ;                                                \
+            if (state->y >= ymax) {                                     \
+                return -1;                                              \
+            }                                                           \
+        }                                                               \
         break

         DECODE_LOOP(1, 8, rgba);
         DECODE_LOOP(2, 16, rgba);
         DECODE_LOOP(3, 16, rgba);
         DECODE_LOOP(4, 8, lum);
-        DECODE_LOOP(5, 16, rgba);
+        case 5:
+            while (bytes >= 16) {
+                rgba col[16];
+                memset(col, 0, 16 * sizeof(col[0]));
+                decode_bc5_block(col, ptr, strcmp(pixel_format, "BC5S") == 0 ? 1 : 0);
+                put_block(im, state, (const char *)col, sizeof(col[0]), C);
+                ptr += 16;
+                bytes -= 16;
+                if (state->y >= ymax) {
+                    return -1;
+                }
+            }
+            break;
         case 6:
             while (bytes >= 16) {
                 rgb32f col[16];
@@ -844,9 +867,9 @@
                 put_block(im, state, (const char *)col, sizeof(col[0]), C);
                 ptr += 16;
                 bytes -= 16;
-                if (state->y >= ymax) {\
-                    return -1; \
-                }\
+                if (state->y >= ymax) {
+                    return -1;
+                }
             }
             break;
         DECODE_LOOP(7, 16, rgba);
@@ -855,13 +878,12 @@
     return (int)(ptr - src);
 }

-int ImagingBcnDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes) {
+int
+ImagingBcnDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
     int N = state->state & 0xf;
     int width = state->xsize;
     int height = state->ysize;
-    if ((width & 3) | (height & 3)) {
-        return decode_bcn(im, state, buf, bytes, N, 1);
-    } else {
-        return decode_bcn(im, state, buf, bytes, N, 0);
-    }
-}
+    int C = (width & 3) | (height & 3) ? 1 : 0;
+    char *pixel_format = ((BCNSTATE *)state->context)->pixel_format;
+    return decode_bcn(im, state, buf, bytes, N, C, pixel_format);
+}
('src/libImaging', 'PackDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,30 +13,27 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 int
-ImagingPackbitsDecode(Imaging im, ImagingCodecState state,
-              UINT8* buf, Py_ssize_t bytes)
-{
+ImagingPackbitsDecode(
+    Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
     UINT8 n;
-    UINT8* ptr;
+    UINT8 *ptr;
     int i;

     ptr = buf;

     for (;;) {
-
         if (bytes < 1) {
             return ptr - buf;
         }

         if (ptr[0] & 0x80) {
-
             if (ptr[0] == 0x80) {
                 /* Nop */
-                ptr++; bytes--;
+                ptr++;
+                bytes--;
                 continue;
             }

@@ -53,12 +50,12 @@
                 state->buffer[state->x++] = ptr[1];
             }

-            ptr += 2; bytes -= 2;
+            ptr += 2;
+            bytes -= 2;

         } else {
-
             /* Literal */
-            n = ptr[0]+2;
+            n = ptr[0] + 2;

             if (bytes < n) {
                 return ptr - buf;
@@ -72,16 +69,17 @@
                 state->buffer[state->x++] = ptr[i];
             }

-            ptr += n; bytes -= n;
-
+            ptr += n;
+            bytes -= n;
         }

         if (state->x >= state->bytes) {
-
             /* Got a full line, unpack it */
-            state->shuffle((UINT8*) im->image[state->y + state->yoff] +
-                   state->xoff * im->pixelsize, state->buffer,
-                   state->xsize);
+            state->shuffle(
+                (UINT8 *)im->image[state->y + state->yoff] +
+                    state->xoff * im->pixelsize,
+                state->buffer,
+                state->xsize);

             state->x = 0;

@@ -90,6 +88,5 @@
                 return -1;
             }
         }
-
     }
 }
('src/libImaging', 'Storage.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -34,10 +34,8 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"
 #include <string.h>
-

 int ImagingNewCount = 0;

@@ -46,18 +44,17 @@
  */

 Imaging
-ImagingNewPrologueSubtype(const char *mode, int xsize, int ysize, int size)
-{
+ImagingNewPrologueSubtype(const char *mode, int xsize, int ysize, int size) {
     Imaging im;

     /* linesize overflow check, roughly the current largest space req'd */
     if (xsize > (INT_MAX / 4) - 1) {
-        return (Imaging) ImagingError_MemoryError();
-    }
-
-    im = (Imaging) calloc(1, size);
+        return (Imaging)ImagingError_MemoryError();
+    }
+
+    im = (Imaging)calloc(1, size);
     if (!im) {
-        return (Imaging) ImagingError_MemoryError();
+        return (Imaging)ImagingError_MemoryError();
     }

     /* Setup image descriptor */
@@ -115,8 +112,9 @@
         im->linesize = xsize * 4;
         im->type = IMAGING_TYPE_INT32;

-    } else if (strcmp(mode, "I;16") == 0 || strcmp(mode, "I;16L") == 0 \
-                           || strcmp(mode, "I;16B") == 0 || strcmp(mode, "I;16N") == 0)  {
+    } else if (
+        strcmp(mode, "I;16") == 0 || strcmp(mode, "I;16L") == 0 ||
+        strcmp(mode, "I;16B") == 0 || strcmp(mode, "I;16N") == 0) {
         /* EXPERIMENTAL */
         /* 16-bit raw integer images */
         im->bands = 1;
@@ -135,7 +133,7 @@
         /* 15-bit reversed true colour */
         im->bands = 1;
         im->pixelsize = 2;
-        im->linesize = (xsize*2 + 3) & -4;
+        im->linesize = (xsize * 2 + 3) & -4;
         im->type = IMAGING_TYPE_SPECIAL;

     } else if (strcmp(mode, "BGR;16") == 0) {
@@ -143,7 +141,7 @@
         /* 16-bit reversed true colour */
         im->bands = 1;
         im->pixelsize = 2;
-        im->linesize = (xsize*2 + 3) & -4;
+        im->linesize = (xsize * 2 + 3) & -4;
         im->type = IMAGING_TYPE_SPECIAL;

     } else if (strcmp(mode, "BGR;24") == 0) {
@@ -151,7 +149,7 @@
         /* 24-bit reversed true colour */
         im->bands = 1;
         im->pixelsize = 3;
-        im->linesize = (xsize*3 + 3) & -4;
+        im->linesize = (xsize * 3 + 3) & -4;
         im->type = IMAGING_TYPE_SPECIAL;

     } else if (strcmp(mode, "BGR;32") == 0) {
@@ -159,7 +157,7 @@
         /* 32-bit reversed true colour */
         im->bands = 1;
         im->pixelsize = 4;
-        im->linesize = (xsize*4 + 3) & -4;
+        im->linesize = (xsize * 4 + 3) & -4;
         im->type = IMAGING_TYPE_SPECIAL;

     } else if (strcmp(mode, "RGBX") == 0) {
@@ -204,7 +202,7 @@

     } else {
         free(im);
-        return (Imaging) ImagingError_ValueError("unrecognized image mode");
+        return (Imaging)ImagingError_ValueError("unrecognized image mode");
     }

     /* Setup image descriptor */
@@ -212,21 +210,23 @@

     /* Pointer array (allocate at least one line, to avoid MemoryError
        exceptions on platforms where calloc(0, x) returns NULL) */
-    im->image = (char **) calloc((ysize > 0) ? ysize : 1, sizeof(void *));
-
-    if ( ! im->image) {
+    im->image = (char **)calloc((ysize > 0) ? ysize : 1, sizeof(void *));
+
+    if (!im->image) {
         free(im);
-        return (Imaging) ImagingError_MemoryError();
+        return (Imaging)ImagingError_MemoryError();
     }

     /* Initialize alias pointers to pixel data. */
     switch (im->pixelsize) {
-    case 1: case 2: case 3:
-        im->image8 = (UINT8 **) im->image;
-        break;
-    case 4:
-        im->image32 = (INT32 **) im->image;
-        break;
+        case 1:
+        case 2:
+        case 3:
+            im->image8 = (UINT8 **)im->image;
+            break;
+        case 4:
+            im->image32 = (INT32 **)im->image;
+            break;
     }

     ImagingDefaultArena.stats_new_count += 1;
@@ -235,15 +235,13 @@
 }

 Imaging
-ImagingNewPrologue(const char *mode, int xsize, int ysize)
-{
+ImagingNewPrologue(const char *mode, int xsize, int ysize) {
     return ImagingNewPrologueSubtype(
         mode, xsize, ysize, sizeof(struct ImagingMemoryInstance));
 }

 void
-ImagingDelete(Imaging im)
-{
+ImagingDelete(Imaging im) {
     if (!im) {
         return;
     }
@@ -262,7 +260,6 @@

     free(im);
 }
-

 /* Array Storage Type */
 /* ------------------ */
@@ -271,17 +268,20 @@
 #define IMAGING_PAGE_SIZE (4096)

 struct ImagingMemoryArena ImagingDefaultArena = {
-    1,                   // alignment
-    16*1024*1024,        // block_size
-    0,                   // blocks_max
-    0,                   // blocks_cached
-    NULL,                // blocks_pool
-    0, 0, 0, 0, 0        // Stats
+    1,                 // alignment
+    16 * 1024 * 1024,  // block_size
+    0,                 // blocks_max
+    0,                 // blocks_cached
+    NULL,              // blocks_pool
+    0,
+    0,
+    0,
+    0,
+    0  // Stats
 };

 int
-ImagingMemorySetBlocksMax(ImagingMemoryArena arena, int blocks_max)
-{
+ImagingMemorySetBlocksMax(ImagingMemoryArena arena, int blocks_max) {
     void *p;
     /* Free already cached blocks */
     ImagingMemoryClearCache(arena, blocks_max);
@@ -291,14 +291,14 @@
         arena->blocks_pool = NULL;
     } else if (arena->blocks_pool != NULL) {
         p = realloc(arena->blocks_pool, sizeof(*arena->blocks_pool) * blocks_max);
-        if ( ! p) {
+        if (!p) {
             // Leave previous blocks_max value
             return 0;
         }
         arena->blocks_pool = p;
     } else {
         arena->blocks_pool = calloc(sizeof(*arena->blocks_pool), blocks_max);
-        if ( ! arena->blocks_pool) {
+        if (!arena->blocks_pool) {
             return 0;
         }
     }
@@ -308,8 +308,7 @@
 }

 void
-ImagingMemoryClearCache(ImagingMemoryArena arena, int new_size)
-{
+ImagingMemoryClearCache(ImagingMemoryArena arena, int new_size) {
     while (arena->blocks_cached > new_size) {
         arena->blocks_cached -= 1;
         free(arena->blocks_pool[arena->blocks_cached].ptr);
@@ -318,8 +317,7 @@
 }

 ImagingMemoryBlock
-memory_get_block(ImagingMemoryArena arena, int requested_size, int dirty)
-{
+memory_get_block(ImagingMemoryArena arena, int requested_size, int dirty) {
     ImagingMemoryBlock block = {NULL, 0};

     if (arena->blocks_cached > 0) {
@@ -327,16 +325,16 @@
         arena->blocks_cached -= 1;
         block = arena->blocks_pool[arena->blocks_cached];
         // Reallocate if needed
-        if (block.size != requested_size){
+        if (block.size != requested_size) {
             block.ptr = realloc(block.ptr, requested_size);
         }
-        if ( ! block.ptr) {
+        if (!block.ptr) {
             // Can't allocate, free previous pointer (it is still valid)
             free(arena->blocks_pool[arena->blocks_cached].ptr);
             arena->stats_freed_blocks += 1;
             return block;
         }
-        if ( ! dirty) {
+        if (!dirty) {
             memset(block.ptr, 0, requested_size);
         }
         arena->stats_reused_blocks += 1;
@@ -356,9 +354,8 @@
 }

 void
-memory_return_block(ImagingMemoryArena arena, ImagingMemoryBlock block)
-{
-    if (arena->blocks_cached < arena->blocks_max)  {
+memory_return_block(ImagingMemoryArena arena, ImagingMemoryBlock block) {
+    if (arena->blocks_cached < arena->blocks_max) {
         // Reduce block size
         if (block.size > arena->block_size) {
             block.size = arena->block_size;
@@ -372,15 +369,13 @@
     }
 }

-
 static void
-ImagingDestroyArray(Imaging im)
-{
+ImagingDestroyArray(Imaging im) {
     int y = 0;

     if (im->blocks) {
         while (im->blocks[y].ptr) {
-            memory_return_block(&ImagingDefaultArena,  im->blocks[y]);
+            memory_return_block(&ImagingDefaultArena, im->blocks[y]);
             y += 1;
         }
         free(im->blocks);
@@ -388,8 +383,7 @@
 }

 Imaging
-ImagingAllocateArray(Imaging im, int dirty, int block_size)
-{
+ImagingAllocateArray(Imaging im, int dirty, int block_size) {
     int y, line_in_block, current_block;
     ImagingMemoryArena arena = &ImagingDefaultArena;
     ImagingMemoryBlock block = {NULL, 0};
@@ -397,7 +391,7 @@
     char *aligned_ptr = NULL;

     /* 0-width or 0-height image. No need to do anything */
-    if ( ! im->linesize || ! im->ysize) {
+    if (!im->linesize || !im->ysize) {
         return im;
     }

@@ -412,8 +406,8 @@

     /* One extra pointer is always NULL */
     im->blocks = calloc(sizeof(*im->blocks), blocks_count + 1);
-    if ( ! im->blocks) {
-        return (Imaging) ImagingError_MemoryError();
+    if (!im->blocks) {
+        return (Imaging)ImagingError_MemoryError();
     }

     /* Allocate image as an array of lines */
@@ -428,9 +422,9 @@
             }
             required = lines_remaining * aligned_linesize + arena->alignment - 1;
             block = memory_get_block(arena, required, dirty);
-            if ( ! block.ptr) {
+            if (!block.ptr) {
                 ImagingDestroyArray(im);
-                return (Imaging) ImagingError_MemoryError();
+                return (Imaging)ImagingError_MemoryError();
             }
             im->blocks[current_block] = block;
             /* Bulletproof code from libc _int_memalign */
@@ -454,42 +448,38 @@
     return im;
 }

-
 /* Block Storage Type */
 /* ------------------ */
 /* Allocate image as a single block. */

 static void
-ImagingDestroyBlock(Imaging im)
-{
+ImagingDestroyBlock(Imaging im) {
     if (im->block) {
         free(im->block);
     }
 }

 Imaging
-ImagingAllocateBlock(Imaging im)
-{
+ImagingAllocateBlock(Imaging im) {
     Py_ssize_t y, i;

     /* overflow check for malloc */
-    if (im->linesize &&
-        im->ysize > INT_MAX / im->linesize) {
-        return (Imaging) ImagingError_MemoryError();
+    if (im->linesize && im->ysize > INT_MAX / im->linesize) {
+        return (Imaging)ImagingError_MemoryError();
     }

     if (im->ysize * im->linesize <= 0) {
         /* some platforms return NULL for malloc(0); this fix
            prevents MemoryError on zero-sized images on such
            platforms */
-        im->block = (char *) malloc(1);
+        im->block = (char *)malloc(1);
     } else {
         /* malloc check ok, overflow check above */
-        im->block = (char *) calloc(im->ysize, im->linesize);
-    }
-
-    if ( ! im->block) {
-        return (Imaging) ImagingError_MemoryError();
+        im->block = (char *)calloc(im->ysize, im->linesize);
+    }
+
+    if (!im->block) {
+        return (Imaging)ImagingError_MemoryError();
     }

     for (y = i = 0; y < im->ysize; y++) {
@@ -507,16 +497,15 @@
  */

 Imaging
-ImagingNewInternal(const char* mode, int xsize, int ysize, int dirty)
-{
+ImagingNewInternal(const char *mode, int xsize, int ysize, int dirty) {
     Imaging im;

     if (xsize < 0 || ysize < 0) {
-        return (Imaging) ImagingError_ValueError("bad image size");
+        return (Imaging)ImagingError_ValueError("bad image size");
     }

     im = ImagingNewPrologue(mode, xsize, ysize);
-    if ( ! im) {
+    if (!im) {
         return NULL;
     }

@@ -536,28 +525,25 @@
 }

 Imaging
-ImagingNew(const char* mode, int xsize, int ysize)
-{
+ImagingNew(const char *mode, int xsize, int ysize) {
     return ImagingNewInternal(mode, xsize, ysize, 0);
 }

 Imaging
-ImagingNewDirty(const char* mode, int xsize, int ysize)
-{
+ImagingNewDirty(const char *mode, int xsize, int ysize) {
     return ImagingNewInternal(mode, xsize, ysize, 1);
 }

 Imaging
-ImagingNewBlock(const char* mode, int xsize, int ysize)
-{
+ImagingNewBlock(const char *mode, int xsize, int ysize) {
     Imaging im;

     if (xsize < 0 || ysize < 0) {
-        return (Imaging) ImagingError_ValueError("bad image size");
+        return (Imaging)ImagingError_ValueError("bad image size");
     }

     im = ImagingNewPrologue(mode, xsize, ysize);
-    if ( ! im) {
+    if (!im) {
         return NULL;
     }

@@ -570,15 +556,13 @@
 }

 Imaging
-ImagingNew2Dirty(const char* mode, Imaging imOut, Imaging imIn)
-{
+ImagingNew2Dirty(const char *mode, Imaging imOut, Imaging imIn) {
     /* allocate or validate output image */

     if (imOut) {
         /* make sure images match */
-        if (strcmp(imOut->mode, mode) != 0
-            || imOut->xsize != imIn->xsize
-            || imOut->ysize != imIn->ysize) {
+        if (strcmp(imOut->mode, mode) != 0 || imOut->xsize != imIn->xsize ||
+            imOut->ysize != imIn->ysize) {
             return ImagingError_Mismatch();
         }
     } else {
@@ -593,8 +577,7 @@
 }

 void
-ImagingCopyPalette(Imaging destination, Imaging source)
-{
+ImagingCopyPalette(Imaging destination, Imaging source) {
     if (source->palette) {
         if (destination->palette) {
             ImagingPaletteDelete(destination->palette);
('src/libImaging', 'Negative.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,18 +16,15 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 Imaging
-ImagingNegative(Imaging im)
-{
+ImagingNegative(Imaging im) {
     Imaging imOut;
     int x, y;

     if (!im) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     imOut = ImagingNewDirty(im->mode, im->xsize, im->ysize);
@@ -43,4 +40,3 @@

     return imOut;
 }
-
('src/libImaging', 'Access.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -9,33 +9,34 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-/* use Tests/make_hash.py to calculate these values */
+/* use make_hash.py from the pillow-scripts repository to calculate these values */
 #define ACCESS_TABLE_SIZE 27
 #define ACCESS_TABLE_HASH 3078

 static struct ImagingAccessInstance access_table[ACCESS_TABLE_SIZE];

 static inline UINT32
-hash(const char* mode)
-{
+hash(const char *mode) {
     UINT32 i = ACCESS_TABLE_HASH;
     while (*mode) {
-        i = ((i<<5) + i) ^ (UINT8) *mode++;
+        i = ((i << 5) + i) ^ (UINT8)*mode++;
     }
     return i % ACCESS_TABLE_SIZE;
 }

 static ImagingAccess
-add_item(const char* mode)
-{
+add_item(const char *mode) {
     UINT32 i = hash(mode);
     /* printf("hash %s => %d\n", mode, i); */
     if (access_table[i].mode && strcmp(access_table[i].mode, mode) != 0) {
-        fprintf(stderr, "AccessInit: hash collision: %d for both %s and %s\n",
-                i, mode, access_table[i].mode);
+        fprintf(
+            stderr,
+            "AccessInit: hash collision: %d for both %s and %s\n",
+            i,
+            mode,
+            access_table[i].mode);
         exit(1);
     }
     access_table[i].mode = mode;
@@ -44,37 +45,33 @@

 /* fetch pointer to pixel line */

-static void*
-line_8(Imaging im, int x, int y)
-{
+static void *
+line_8(Imaging im, int x, int y) {
     return &im->image8[y][x];
 }

-static void*
-line_16(Imaging im, int x, int y)
-{
-    return &im->image8[y][x+x];
-}
-
-static void*
-line_32(Imaging im, int x, int y)
-{
+static void *
+line_16(Imaging im, int x, int y) {
+    return &im->image8[y][x + x];
+}
+
+static void *
+line_32(Imaging im, int x, int y) {
     return &im->image32[y][x];
 }

 /* fetch individual pixel */

 static void
-get_pixel(Imaging im, int x, int y, void* color)
-{
-    char* out = color;
+get_pixel(Imaging im, int x, int y, void *color) {
+    char *out = color;

     /* generic pixel access*/

     if (im->image8) {
         out[0] = im->image8[y][x];
     } else {
-        UINT8* p = (UINT8*) &im->image32[y][x];
+        UINT8 *p = (UINT8 *)&im->image32[y][x];
         if (im->type == IMAGING_TYPE_UINT8 && im->bands == 2) {
             out[0] = p[0];
             out[1] = p[3];
@@ -85,18 +82,16 @@
 }

 static void
-get_pixel_8(Imaging im, int x, int y, void* color)
-{
-    char* out = color;
+get_pixel_8(Imaging im, int x, int y, void *color) {
+    char *out = color;
     out[0] = im->image8[y][x];
 }

 static void
-get_pixel_16L(Imaging im, int x, int y, void* color)
-{
-    UINT8* in = (UINT8*) &im->image[y][x+x];
-#ifdef WORDS_BIGENDIAN
-    UINT16 out = in[0] + (in[1]<<8);
+get_pixel_16L(Imaging im, int x, int y, void *color) {
+    UINT8 *in = (UINT8 *)&im->image[y][x + x];
+#ifdef WORDS_BIGENDIAN
+    UINT16 out = in[0] + (in[1] << 8);
     memcpy(color, &out, sizeof(out));
 #else
     memcpy(color, in, sizeof(UINT16));
@@ -104,29 +99,26 @@
 }

 static void
-get_pixel_16B(Imaging im, int x, int y, void* color)
-{
-    UINT8* in = (UINT8*) &im->image[y][x+x];
+get_pixel_16B(Imaging im, int x, int y, void *color) {
+    UINT8 *in = (UINT8 *)&im->image[y][x + x];
 #ifdef WORDS_BIGENDIAN
     memcpy(color, in, sizeof(UINT16));
 #else
-    UINT16 out = in[1] + (in[0]<<8);
-    memcpy(color, &out, sizeof(out));
-#endif
-}
-
-static void
-get_pixel_32(Imaging im, int x, int y, void* color)
-{
+    UINT16 out = in[1] + (in[0] << 8);
+    memcpy(color, &out, sizeof(out));
+#endif
+}
+
+static void
+get_pixel_32(Imaging im, int x, int y, void *color) {
     memcpy(color, &im->image32[y][x], sizeof(INT32));
 }

 static void
-get_pixel_32L(Imaging im, int x, int y, void* color)
-{
-    UINT8* in = (UINT8*) &im->image[y][x*4];
-#ifdef WORDS_BIGENDIAN
-    INT32 out = in[0] + (in[1]<<8) + (in[2]<<16) + (in[3]<<24);
+get_pixel_32L(Imaging im, int x, int y, void *color) {
+    UINT8 *in = (UINT8 *)&im->image[y][x * 4];
+#ifdef WORDS_BIGENDIAN
+    INT32 out = in[0] + (in[1] << 8) + (in[2] << 16) + (in[3] << 24);
     memcpy(color, &out, sizeof(out));
 #else
     memcpy(color, in, sizeof(INT32));
@@ -134,13 +126,12 @@
 }

 static void
-get_pixel_32B(Imaging im, int x, int y, void* color)
-{
-    UINT8* in = (UINT8*) &im->image[y][x*4];
+get_pixel_32B(Imaging im, int x, int y, void *color) {
+    UINT8 *in = (UINT8 *)&im->image[y][x * 4];
 #ifdef WORDS_BIGENDIAN
     memcpy(color, in, sizeof(INT32));
 #else
-    INT32 out = in[3] + (in[2]<<8) + (in[1]<<16) + (in[0]<<24);
+    INT32 out = in[3] + (in[2] << 8) + (in[1] << 16) + (in[0] << 24);
     memcpy(color, &out, sizeof(out));
 #endif
 }
@@ -148,47 +139,41 @@
 /* store individual pixel */

 static void
-put_pixel(Imaging im, int x, int y, const void* color)
-{
+put_pixel(Imaging im, int x, int y, const void *color) {
     if (im->image8) {
-        im->image8[y][x] = *((UINT8*) color);
+        im->image8[y][x] = *((UINT8 *)color);
     } else {
         memcpy(&im->image32[y][x], color, sizeof(INT32));
     }
 }

 static void
-put_pixel_8(Imaging im, int x, int y, const void* color)
-{
-    im->image8[y][x] = *((UINT8*) color);
-}
-
-static void
-put_pixel_16L(Imaging im, int x, int y, const void* color)
-{
-    memcpy(&im->image8[y][x+x], color, 2);
-}
-
-static void
-put_pixel_16B(Imaging im, int x, int y, const void* color)
-{
-    const char* in = color;
-    UINT8* out = (UINT8*) &im->image8[y][x+x];
+put_pixel_8(Imaging im, int x, int y, const void *color) {
+    im->image8[y][x] = *((UINT8 *)color);
+}
+
+static void
+put_pixel_16L(Imaging im, int x, int y, const void *color) {
+    memcpy(&im->image8[y][x + x], color, 2);
+}
+
+static void
+put_pixel_16B(Imaging im, int x, int y, const void *color) {
+    const char *in = color;
+    UINT8 *out = (UINT8 *)&im->image8[y][x + x];
     out[0] = in[1];
     out[1] = in[0];
 }

 static void
-put_pixel_32L(Imaging im, int x, int y, const void* color)
-{
-    memcpy(&im->image8[y][x*4], color, 4);
-}
-
-static void
-put_pixel_32B(Imaging im, int x, int y, const void* color)
-{
-    const char* in = color;
-    UINT8* out = (UINT8*) &im->image8[y][x*4];
+put_pixel_32L(Imaging im, int x, int y, const void *color) {
+    memcpy(&im->image8[y][x * 4], color, 4);
+}
+
+static void
+put_pixel_32B(Imaging im, int x, int y, const void *color) {
+    const char *in = color;
+    UINT8 *out = (UINT8 *)&im->image8[y][x * 4];
     out[0] = in[3];
     out[1] = in[2];
     out[2] = in[1];
@@ -196,19 +181,18 @@
 }

 static void
-put_pixel_32(Imaging im, int x, int y, const void* color)
-{
+put_pixel_32(Imaging im, int x, int y, const void *color) {
     memcpy(&im->image32[y][x], color, sizeof(INT32));
 }

 void
-ImagingAccessInit()
-{
-#define ADD(mode_, line_, get_pixel_, put_pixel_)       \
-    { ImagingAccess access = add_item(mode_);           \
-        access->line = line_;                           \
-        access->get_pixel = get_pixel_;                 \
-        access->put_pixel = put_pixel_;                 \
+ImagingAccessInit() {
+#define ADD(mode_, line_, get_pixel_, put_pixel_) \
+    {                                             \
+        ImagingAccess access = add_item(mode_);   \
+        access->line = line_;                     \
+        access->get_pixel = get_pixel_;           \
+        access->put_pixel = put_pixel_;           \
     }

     /* populate access table */
@@ -236,8 +220,7 @@
 }

 ImagingAccess
-ImagingAccessNew(Imaging im)
-{
+ImagingAccessNew(Imaging im) {
     ImagingAccess access = &access_table[hash(im->mode)];
     if (im->mode[0] != access->mode[0] || strcmp(im->mode, access->mode) != 0) {
         return NULL;
@@ -246,7 +229,4 @@
 }

 void
-_ImagingAccessDelete(Imaging im, ImagingAccess access)
-{
-
-}
+_ImagingAccessDelete(Imaging im, ImagingAccess access) {}
('src/libImaging', 'Effects.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,14 +15,12 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #include <math.h>

 Imaging
-ImagingEffectMandelbrot(int xsize, int ysize, double extent[4], int quality)
-{
+ImagingEffectMandelbrot(int xsize, int ysize, double extent[4], int quality) {
     /* Generate a Mandelbrot set covering the given extent */

     Imaging im;
@@ -32,10 +30,10 @@
     double dr, di;

     /* Check arguments */
-    width  = extent[2] - extent[0];
+    width = extent[2] - extent[0];
     height = extent[3] - extent[1];
     if (width < 0.0 || height < 0.0 || quality < 2) {
-        return (Imaging) ImagingError_ValueError(NULL);
+        return (Imaging)ImagingError_ValueError(NULL);
     }

     im = ImagingNewDirty("L", xsize, ysize);
@@ -43,24 +41,24 @@
         return NULL;
     }

-    dr = width/(xsize-1);
-    di = height/(ysize-1);
+    dr = width / (xsize - 1);
+    di = height / (ysize - 1);

     radius = 100.0;

     for (y = 0; y < ysize; y++) {
-        UINT8* buf = im->image8[y];
+        UINT8 *buf = im->image8[y];
         for (x = 0; x < xsize; x++) {
             x1 = y1 = xi2 = yi2 = 0.0;
-            cr = x*dr + extent[0];
-            ci = y*di + extent[1];
+            cr = x * dr + extent[0];
+            ci = y * di + extent[1];
             for (k = 1;; k++) {
-                y1 = 2*x1*y1 + ci;
+                y1 = 2 * x1 * y1 + ci;
                 x1 = xi2 - yi2 + cr;
-                xi2 = x1*x1;
-                yi2 = y1*y1;
+                xi2 = x1 * x1;
+                yi2 = y1 * y1;
                 if ((xi2 + yi2) > radius) {
-                    buf[x] = k*255/quality;
+                    buf[x] = k * 255 / quality;
                     break;
                 }
                 if (k > quality) {
@@ -74,8 +72,7 @@
 }

 Imaging
-ImagingEffectNoise(int xsize, int ysize, float sigma)
-{
+ImagingEffectNoise(int xsize, int ysize, float sigma) {
     /* Generate Gaussian noise centered around 128 */

     Imaging imOut;
@@ -92,7 +89,7 @@
     nextok = 0;

     for (y = 0; y < imOut->ysize; y++) {
-        UINT8* out = imOut->image8[y];
+        UINT8 *out = imOut->image8[y];
         for (x = 0; x < imOut->xsize; x++) {
             if (nextok) {
                 this = next;
@@ -101,11 +98,11 @@
                 /* after numerical recipes */
                 double v1, v2, radius, factor;
                 do {
-                    v1 = rand()*(2.0/RAND_MAX) - 1.0;
-                    v2 = rand()*(2.0/RAND_MAX) - 1.0;
-                    radius= v1*v1 + v2*v2;
+                    v1 = rand() * (2.0 / RAND_MAX) - 1.0;
+                    v2 = rand() * (2.0 / RAND_MAX) - 1.0;
+                    radius = v1 * v1 + v2 * v2;
                 } while (radius >= 1.0);
-                factor = sqrt(-2.0*log(radius)/radius);
+                factor = sqrt(-2.0 * log(radius) / radius);
                 this = factor * v1;
                 next = factor * v2;
             }
@@ -117,8 +114,7 @@
 }

 Imaging
-ImagingEffectSpread(Imaging imIn, int distance)
-{
+ImagingEffectSpread(Imaging imIn, int distance) {
     /* Randomly spread pixels in an image */

     Imaging imOut;
@@ -130,26 +126,26 @@
         return NULL;
     }

-#define SPREAD(type, image)\
-    if (distance == 0) {\
-        for (y = 0; y < imOut->ysize; y++) {\
-            for (x = 0; x < imOut->xsize; x++) {\
-                imOut->image[y][x] = imIn->image[y][x];\
-            }\
-        }\
-    } else {\
-        for (y = 0; y < imOut->ysize; y++) {\
-            for (x = 0; x < imOut->xsize; x++) {\
-                int xx = x + (rand() % distance) - distance/2;\
-                int yy = y + (rand() % distance) - distance/2;\
-                if (xx >= 0 && xx < imIn->xsize && yy >= 0 && yy < imIn->ysize) {\
-                    imOut->image[yy][xx] = imIn->image[y][x];\
-                    imOut->image[y][x]   = imIn->image[yy][xx];\
-                } else {\
-                    imOut->image[y][x]   = imIn->image[y][x];\
-                }\
-            }\
-        }\
+#define SPREAD(type, image)                                                       \
+    if (distance == 0) {                                                          \
+        for (y = 0; y < imOut->ysize; y++) {                                      \
+            for (x = 0; x < imOut->xsize; x++) {                                  \
+                imOut->image[y][x] = imIn->image[y][x];                           \
+            }                                                                     \
+        }                                                                         \
+    } else {                                                                      \
+        for (y = 0; y < imOut->ysize; y++) {                                      \
+            for (x = 0; x < imOut->xsize; x++) {                                  \
+                int xx = x + (rand() % distance) - distance / 2;                  \
+                int yy = y + (rand() % distance) - distance / 2;                  \
+                if (xx >= 0 && xx < imIn->xsize && yy >= 0 && yy < imIn->ysize) { \
+                    imOut->image[yy][xx] = imIn->image[y][x];                     \
+                    imOut->image[y][x] = imIn->image[yy][xx];                     \
+                } else {                                                          \
+                    imOut->image[y][x] = imIn->image[y][x];                       \
+                }                                                                 \
+            }                                                                     \
+        }                                                                         \
     }

     if (imIn->image8) {
('src/libImaging', 'Reduce.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,39 +2,35 @@

 #include <math.h>

-#define ROUND_UP(f) ((int) ((f) >= 0.0 ? (f) + 0.5F : (f) - 0.5F))
-
+#define ROUND_UP(f) ((int)((f) >= 0.0 ? (f) + 0.5F : (f)-0.5F))

 UINT32
-division_UINT32(int divider, int result_bits)
-{
+division_UINT32(int divider, int result_bits) {
     UINT32 max_dividend = (1 << result_bits) * divider;
     float max_int = (1 << 30) * 4.0;
-    return (UINT32) (max_int / max_dividend);
-}
-
+    return (UINT32)(max_int / max_dividend);
+}

 void
-ImagingReduceNxN(Imaging imOut, Imaging imIn, int box[4], int xscale, int yscale)
-{
+ImagingReduceNxN(Imaging imOut, Imaging imIn, int box[4], int xscale, int yscale) {
     /* The most general implementation for any xscale and yscale
-    */
+     */
     int x, y, xx, yy;
     UINT32 multiplier = division_UINT32(yscale * xscale, 8);
     UINT32 amend = yscale * xscale / 2;

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy_from = box[1] + y*yscale;
+            int yy_from = box[1] + y * yscale;
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx_from = box[0] + x*xscale;
+                int xx_from = box[0] + x * xscale;
                 UINT32 ss = amend;
                 for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
                     UINT8 *line0 = (UINT8 *)imIn->image8[yy];
                     UINT8 *line1 = (UINT8 *)imIn->image8[yy + 1];
                     for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                        ss += line0[xx + 0] + line0[xx + 1] +
-                              line1[xx + 0] + line1[xx + 1];
+                        ss += line0[xx + 0] + line0[xx + 1] + line1[xx + 0] +
+                              line1[xx + 1];
                     }
                     if (xscale & 0x01) {
                         ss += line0[xx + 0] + line1[xx + 0];
@@ -54,138 +50,139 @@
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy_from =  box[1] + y*yscale;
+            int yy_from = box[1] + y * yscale;
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx_from = box[0] + x*xscale;
+                    int xx_from = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss3 = amend;
                     for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
                         UINT8 *line0 = (UINT8 *)imIn->image[yy];
                         UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
                         for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                            ss0 += line0[xx*4 + 0] + line0[xx*4 + 4] +
-                                   line1[xx*4 + 0] + line1[xx*4 + 4];
-                            ss3 += line0[xx*4 + 3] + line0[xx*4 + 7] +
-                                   line1[xx*4 + 3] + line1[xx*4 + 7];
+                            ss0 += line0[xx * 4 + 0] + line0[xx * 4 + 4] +
+                                   line1[xx * 4 + 0] + line1[xx * 4 + 4];
+                            ss3 += line0[xx * 4 + 3] + line0[xx * 4 + 7] +
+                                   line1[xx * 4 + 3] + line1[xx * 4 + 7];
                         }
                         if (xscale & 0x01) {
-                            ss0 += line0[xx*4 + 0] + line1[xx*4 + 0];
-                            ss3 += line0[xx*4 + 3] + line1[xx*4 + 3];
+                            ss0 += line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                            ss3 += line0[xx * 4 + 3] + line1[xx * 4 + 3];
                         }
                     }
                     if (yscale & 0x01) {
                         UINT8 *line = (UINT8 *)imIn->image[yy];
                         for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                            ss0 += line[xx*4 + 0] + line[xx*4 + 4];
-                            ss3 += line[xx*4 + 3] + line[xx*4 + 7];
+                            ss0 += line[xx * 4 + 0] + line[xx * 4 + 4];
+                            ss3 += line[xx * 4 + 3] + line[xx * 4 + 7];
                         }
                         if (xscale & 0x01) {
-                            ss0 += line[xx*4 + 0];
-                            ss3 += line[xx*4 + 3];
-                        }
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, 0,
-                        0, (ss3 * multiplier) >> 24);
+                            ss0 += line[xx * 4 + 0];
+                            ss3 += line[xx * 4 + 3];
+                        }
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24, 0, 0, (ss3 * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx_from = box[0] + x*xscale;
+                    int xx_from = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss1 = amend, ss2 = amend;
                     for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
                         UINT8 *line0 = (UINT8 *)imIn->image[yy];
                         UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
                         for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                            ss0 += line0[xx*4 + 0] + line0[xx*4 + 4] +
-                                   line1[xx*4 + 0] + line1[xx*4 + 4];
-                            ss1 += line0[xx*4 + 1] + line0[xx*4 + 5] +
-                                   line1[xx*4 + 1] + line1[xx*4 + 5];
-                            ss2 += line0[xx*4 + 2] + line0[xx*4 + 6] +
-                                   line1[xx*4 + 2] + line1[xx*4 + 6];
+                            ss0 += line0[xx * 4 + 0] + line0[xx * 4 + 4] +
+                                   line1[xx * 4 + 0] + line1[xx * 4 + 4];
+                            ss1 += line0[xx * 4 + 1] + line0[xx * 4 + 5] +
+                                   line1[xx * 4 + 1] + line1[xx * 4 + 5];
+                            ss2 += line0[xx * 4 + 2] + line0[xx * 4 + 6] +
+                                   line1[xx * 4 + 2] + line1[xx * 4 + 6];
                         }
                         if (xscale & 0x01) {
-                            ss0 += line0[xx*4 + 0] + line1[xx*4 + 0];
-                            ss1 += line0[xx*4 + 1] + line1[xx*4 + 1];
-                            ss2 += line0[xx*4 + 2] + line1[xx*4 + 2];
+                            ss0 += line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                            ss1 += line0[xx * 4 + 1] + line1[xx * 4 + 1];
+                            ss2 += line0[xx * 4 + 2] + line1[xx * 4 + 2];
                         }
                     }
                     if (yscale & 0x01) {
                         UINT8 *line = (UINT8 *)imIn->image[yy];
                         for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                            ss0 += line[xx*4 + 0] + line[xx*4 + 4];
-                            ss1 += line[xx*4 + 1] + line[xx*4 + 5];
-                            ss2 += line[xx*4 + 2] + line[xx*4 + 6];
+                            ss0 += line[xx * 4 + 0] + line[xx * 4 + 4];
+                            ss1 += line[xx * 4 + 1] + line[xx * 4 + 5];
+                            ss2 += line[xx * 4 + 2] + line[xx * 4 + 6];
                         }
                         if (xscale & 0x01) {
-                            ss0 += line[xx*4 + 0];
-                            ss1 += line[xx*4 + 1];
-                            ss2 += line[xx*4 + 2];
-                        }
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                        (ss2 * multiplier) >> 24, 0);
+                            ss0 += line[xx * 4 + 0];
+                            ss1 += line[xx * 4 + 1];
+                            ss2 += line[xx * 4 + 2];
+                        }
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24,
+                        (ss1 * multiplier) >> 24,
+                        (ss2 * multiplier) >> 24,
+                        0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx_from = box[0] + x*xscale;
+                    int xx_from = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss1 = amend, ss2 = amend, ss3 = amend;
                     for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
                         UINT8 *line0 = (UINT8 *)imIn->image[yy];
                         UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
                         for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                            ss0 += line0[xx*4 + 0] + line0[xx*4 + 4] +
-                                   line1[xx*4 + 0] + line1[xx*4 + 4];
-                            ss1 += line0[xx*4 + 1] + line0[xx*4 + 5] +
-                                   line1[xx*4 + 1] + line1[xx*4 + 5];
-                            ss2 += line0[xx*4 + 2] + line0[xx*4 + 6] +
-                                   line1[xx*4 + 2] + line1[xx*4 + 6];
-                            ss3 += line0[xx*4 + 3] + line0[xx*4 + 7] +
-                                   line1[xx*4 + 3] + line1[xx*4 + 7];
+                            ss0 += line0[xx * 4 + 0] + line0[xx * 4 + 4] +
+                                   line1[xx * 4 + 0] + line1[xx * 4 + 4];
+                            ss1 += line0[xx * 4 + 1] + line0[xx * 4 + 5] +
+                                   line1[xx * 4 + 1] + line1[xx * 4 + 5];
+                            ss2 += line0[xx * 4 + 2] + line0[xx * 4 + 6] +
+                                   line1[xx * 4 + 2] + line1[xx * 4 + 6];
+                            ss3 += line0[xx * 4 + 3] + line0[xx * 4 + 7] +
+                                   line1[xx * 4 + 3] + line1[xx * 4 + 7];
                         }
                         if (xscale & 0x01) {
-                            ss0 += line0[xx*4 + 0] + line1[xx*4 + 0];
-                            ss1 += line0[xx*4 + 1] + line1[xx*4 + 1];
-                            ss2 += line0[xx*4 + 2] + line1[xx*4 + 2];
-                            ss3 += line0[xx*4 + 3] + line1[xx*4 + 3];
+                            ss0 += line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                            ss1 += line0[xx * 4 + 1] + line1[xx * 4 + 1];
+                            ss2 += line0[xx * 4 + 2] + line1[xx * 4 + 2];
+                            ss3 += line0[xx * 4 + 3] + line1[xx * 4 + 3];
                         }
                     }
                     if (yscale & 0x01) {
                         UINT8 *line = (UINT8 *)imIn->image[yy];
                         for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                            ss0 += line[xx*4 + 0] + line[xx*4 + 4];
-                            ss1 += line[xx*4 + 1] + line[xx*4 + 5];
-                            ss2 += line[xx*4 + 2] + line[xx*4 + 6];
-                            ss3 += line[xx*4 + 3] + line[xx*4 + 7];
+                            ss0 += line[xx * 4 + 0] + line[xx * 4 + 4];
+                            ss1 += line[xx * 4 + 1] + line[xx * 4 + 5];
+                            ss2 += line[xx * 4 + 2] + line[xx * 4 + 6];
+                            ss3 += line[xx * 4 + 3] + line[xx * 4 + 7];
                         }
                         if (xscale & 0x01) {
-                            ss0 += line[xx*4 + 0];
-                            ss1 += line[xx*4 + 1];
-                            ss2 += line[xx*4 + 2];
-                            ss3 += line[xx*4 + 3];
-                        }
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                        (ss2 * multiplier) >> 24, (ss3 * multiplier) >> 24);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                            ss0 += line[xx * 4 + 0];
+                            ss1 += line[xx * 4 + 1];
+                            ss2 += line[xx * 4 + 2];
+                            ss3 += line[xx * 4 + 3];
+                        }
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24,
+                        (ss1 * multiplier) >> 24,
+                        (ss2 * multiplier) >> 24,
+                        (ss3 * multiplier) >> 24);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduce1xN(Imaging imOut, Imaging imIn, int box[4], int yscale)
-{
+ImagingReduce1xN(Imaging imOut, Imaging imIn, int box[4], int yscale) {
     /* Optimized implementation for xscale = 1.
-    */
+     */
     int x, y, yy;
     int xscale = 1;
     UINT32 multiplier = division_UINT32(yscale * xscale, 8);
@@ -193,9 +190,9 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy_from = box[1] + y*yscale;
+            int yy_from = box[1] + y * yscale;
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
+                int xx = box[0] + x * xscale;
                 UINT32 ss = amend;
                 for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
                     UINT8 *line0 = (UINT8 *)imIn->image8[yy];
@@ -211,87 +208,88 @@
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy_from =  box[1] + y*yscale;
+            int yy_from = box[1] + y * yscale;
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
+                    int xx = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss3 = amend;
                     for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
                         UINT8 *line0 = (UINT8 *)imIn->image[yy];
                         UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
-                        ss0 += line0[xx*4 + 0] + line1[xx*4 + 0];
-                        ss3 += line0[xx*4 + 3] + line1[xx*4 + 3];
+                        ss0 += line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                        ss3 += line0[xx * 4 + 3] + line1[xx * 4 + 3];
                     }
                     if (yscale & 0x01) {
                         UINT8 *line = (UINT8 *)imIn->image[yy];
-                        ss0 += line[xx*4 + 0];
-                        ss3 += line[xx*4 + 3];
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, 0,
-                        0, (ss3 * multiplier) >> 24);
+                        ss0 += line[xx * 4 + 0];
+                        ss3 += line[xx * 4 + 3];
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24, 0, 0, (ss3 * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
+                    int xx = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss1 = amend, ss2 = amend;
                     for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
                         UINT8 *line0 = (UINT8 *)imIn->image[yy];
                         UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
-                        ss0 += line0[xx*4 + 0] + line1[xx*4 + 0];
-                        ss1 += line0[xx*4 + 1] + line1[xx*4 + 1];
-                        ss2 += line0[xx*4 + 2] + line1[xx*4 + 2];
+                        ss0 += line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                        ss1 += line0[xx * 4 + 1] + line1[xx * 4 + 1];
+                        ss2 += line0[xx * 4 + 2] + line1[xx * 4 + 2];
                     }
                     if (yscale & 0x01) {
                         UINT8 *line = (UINT8 *)imIn->image[yy];
-                        ss0 += line[xx*4 + 0];
-                        ss1 += line[xx*4 + 1];
-                        ss2 += line[xx*4 + 2];
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                        (ss2 * multiplier) >> 24, 0);
+                        ss0 += line[xx * 4 + 0];
+                        ss1 += line[xx * 4 + 1];
+                        ss2 += line[xx * 4 + 2];
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24,
+                        (ss1 * multiplier) >> 24,
+                        (ss2 * multiplier) >> 24,
+                        0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
+                    int xx = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss1 = amend, ss2 = amend, ss3 = amend;
                     for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
                         UINT8 *line0 = (UINT8 *)imIn->image[yy];
                         UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
-                        ss0 += line0[xx*4 + 0] + line1[xx*4 + 0];
-                        ss1 += line0[xx*4 + 1] + line1[xx*4 + 1];
-                        ss2 += line0[xx*4 + 2] + line1[xx*4 + 2];
-                        ss3 += line0[xx*4 + 3] + line1[xx*4 + 3];
+                        ss0 += line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                        ss1 += line0[xx * 4 + 1] + line1[xx * 4 + 1];
+                        ss2 += line0[xx * 4 + 2] + line1[xx * 4 + 2];
+                        ss3 += line0[xx * 4 + 3] + line1[xx * 4 + 3];
                     }
                     if (yscale & 0x01) {
                         UINT8 *line = (UINT8 *)imIn->image[yy];
-                        ss0 += line[xx*4 + 0];
-                        ss1 += line[xx*4 + 1];
-                        ss2 += line[xx*4 + 2];
-                        ss3 += line[xx*4 + 3];
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                        (ss2 * multiplier) >> 24, (ss3 * multiplier) >> 24);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                        ss0 += line[xx * 4 + 0];
+                        ss1 += line[xx * 4 + 1];
+                        ss2 += line[xx * 4 + 2];
+                        ss3 += line[xx * 4 + 3];
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24,
+                        (ss1 * multiplier) >> 24,
+                        (ss2 * multiplier) >> 24,
+                        (ss3 * multiplier) >> 24);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduceNx1(Imaging imOut, Imaging imIn, int box[4], int xscale)
-{
+ImagingReduceNx1(Imaging imOut, Imaging imIn, int box[4], int xscale) {
     /* Optimized implementation for yscale = 1.
-    */
+     */
     int x, y, xx;
     int yscale = 1;
     UINT32 multiplier = division_UINT32(yscale * xscale, 8);
@@ -299,10 +297,10 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy =  box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line = (UINT8 *)imIn->image8[yy];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx_from = box[0] + x*xscale;
+                int xx_from = box[0] + x * xscale;
                 UINT32 ss = amend;
                 for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
                     ss += line[xx + 0] + line[xx + 1];
@@ -315,66 +313,69 @@
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy =  box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line = (UINT8 *)imIn->image[yy];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx_from = box[0] + x*xscale;
+                    int xx_from = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss3 = amend;
                     for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                        ss0 += line[xx*4 + 0] + line[xx*4 + 4];
-                        ss3 += line[xx*4 + 3] + line[xx*4 + 7];
+                        ss0 += line[xx * 4 + 0] + line[xx * 4 + 4];
+                        ss3 += line[xx * 4 + 3] + line[xx * 4 + 7];
                     }
                     if (xscale & 0x01) {
-                        ss0 += line[xx*4 + 0];
-                        ss3 += line[xx*4 + 3];
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, 0,
-                        0, (ss3 * multiplier) >> 24);
+                        ss0 += line[xx * 4 + 0];
+                        ss3 += line[xx * 4 + 3];
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24, 0, 0, (ss3 * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx_from = box[0] + x*xscale;
+                    int xx_from = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss1 = amend, ss2 = amend;
                     for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                        ss0 += line[xx*4 + 0] + line[xx*4 + 4];
-                        ss1 += line[xx*4 + 1] + line[xx*4 + 5];
-                        ss2 += line[xx*4 + 2] + line[xx*4 + 6];
+                        ss0 += line[xx * 4 + 0] + line[xx * 4 + 4];
+                        ss1 += line[xx * 4 + 1] + line[xx * 4 + 5];
+                        ss2 += line[xx * 4 + 2] + line[xx * 4 + 6];
                     }
                     if (xscale & 0x01) {
-                        ss0 += line[xx*4 + 0];
-                        ss1 += line[xx*4 + 1];
-                        ss2 += line[xx*4 + 2];
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                        (ss2 * multiplier) >> 24, 0);
+                        ss0 += line[xx * 4 + 0];
+                        ss1 += line[xx * 4 + 1];
+                        ss2 += line[xx * 4 + 2];
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24,
+                        (ss1 * multiplier) >> 24,
+                        (ss2 * multiplier) >> 24,
+                        0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx_from = box[0] + x*xscale;
+                    int xx_from = box[0] + x * xscale;
                     UINT32 v;
                     UINT32 ss0 = amend, ss1 = amend, ss2 = amend, ss3 = amend;
                     for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                        ss0 += line[xx*4 + 0] + line[xx*4 + 4];
-                        ss1 += line[xx*4 + 1] + line[xx*4 + 5];
-                        ss2 += line[xx*4 + 2] + line[xx*4 + 6];
-                        ss3 += line[xx*4 + 3] + line[xx*4 + 7];
+                        ss0 += line[xx * 4 + 0] + line[xx * 4 + 4];
+                        ss1 += line[xx * 4 + 1] + line[xx * 4 + 5];
+                        ss2 += line[xx * 4 + 2] + line[xx * 4 + 6];
+                        ss3 += line[xx * 4 + 3] + line[xx * 4 + 7];
                     }
                     if (xscale & 0x01) {
-                        ss0 += line[xx*4 + 0];
-                        ss1 += line[xx*4 + 1];
-                        ss2 += line[xx*4 + 2];
-                        ss3 += line[xx*4 + 3];
-                    }
-                    v = MAKE_UINT32(
-                        (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                        (ss2 * multiplier) >> 24, (ss3 * multiplier) >> 24);
+                        ss0 += line[xx * 4 + 0];
+                        ss1 += line[xx * 4 + 1];
+                        ss2 += line[xx * 4 + 2];
+                        ss3 += line[xx * 4 + 3];
+                    }
+                    v = MAKE_UINT32(
+                        (ss0 * multiplier) >> 24,
+                        (ss1 * multiplier) >> 24,
+                        (ss2 * multiplier) >> 24,
+                        (ss3 * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             }
@@ -383,10 +384,9 @@
 }

 void
-ImagingReduce1x2(Imaging imOut, Imaging imIn, int box[4])
-{
+ImagingReduce1x2(Imaging imOut, Imaging imIn, int box[4]) {
     /* Optimized implementation for xscale = 1 and yscale = 2.
-    */
+     */
     int xscale = 1, yscale = 2;
     int x, y;
     UINT32 ss0, ss1, ss2, ss3;
@@ -394,74 +394,64 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image8[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image8[yy + 1];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
-                ss0 = line0[xx + 0] +
-                      line1[xx + 0];
+                int xx = box[0] + x * xscale;
+                ss0 = line0[xx + 0] + line1[xx + 0];
                 imOut->image8[y][x] = (ss0 + amend) >> 1;
             }
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] +
-                          line1[xx*4 + 0];
-                    ss3 = line0[xx*4 + 3] +
-                          line1[xx*4 + 3];
-                    v = MAKE_UINT32((ss0 + amend) >> 1, 0,
-                                    0, (ss3 + amend) >> 1);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                    ss3 = line0[xx * 4 + 3] + line1[xx * 4 + 3];
+                    v = MAKE_UINT32((ss0 + amend) >> 1, 0, 0, (ss3 + amend) >> 1);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] +
-                          line1[xx*4 + 0];
-                    ss1 = line0[xx*4 + 1] +
-                          line1[xx*4 + 1];
-                    ss2 = line0[xx*4 + 2] +
-                          line1[xx*4 + 2];
-                    v = MAKE_UINT32((ss0 + amend) >> 1, (ss1 + amend) >> 1,
-                                    (ss2 + amend) >> 1, 0);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                    ss1 = line0[xx * 4 + 1] + line1[xx * 4 + 1];
+                    ss2 = line0[xx * 4 + 2] + line1[xx * 4 + 2];
+                    v = MAKE_UINT32(
+                        (ss0 + amend) >> 1, (ss1 + amend) >> 1, (ss2 + amend) >> 1, 0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] +
-                          line1[xx*4 + 0];
-                    ss1 = line0[xx*4 + 1] +
-                          line1[xx*4 + 1];
-                    ss2 = line0[xx*4 + 2] +
-                          line1[xx*4 + 2];
-                    ss3 = line0[xx*4 + 3] +
-                          line1[xx*4 + 3];
-                    v = MAKE_UINT32((ss0 + amend) >> 1, (ss1 + amend) >> 1,
-                                    (ss2 + amend) >> 1, (ss3 + amend) >> 1);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line1[xx * 4 + 0];
+                    ss1 = line0[xx * 4 + 1] + line1[xx * 4 + 1];
+                    ss2 = line0[xx * 4 + 2] + line1[xx * 4 + 2];
+                    ss3 = line0[xx * 4 + 3] + line1[xx * 4 + 3];
+                    v = MAKE_UINT32(
+                        (ss0 + amend) >> 1,
+                        (ss1 + amend) >> 1,
+                        (ss2 + amend) >> 1,
+                        (ss3 + amend) >> 1);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduce2x1(Imaging imOut, Imaging imIn, int box[4])
-{
+ImagingReduce2x1(Imaging imOut, Imaging imIn, int box[4]) {
     /* Optimized implementation for xscale = 2 and yscale = 1.
-    */
+     */
     int xscale = 2, yscale = 1;
     int x, y;
     UINT32 ss0, ss1, ss2, ss3;
@@ -469,62 +459,62 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image8[yy + 0];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
+                int xx = box[0] + x * xscale;
                 ss0 = line0[xx + 0] + line0[xx + 1];
                 imOut->image8[y][x] = (ss0 + amend) >> 1;
             }
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image[yy + 0];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7];
-                    v = MAKE_UINT32((ss0 + amend) >> 1, 0,
-                                    0, (ss3 + amend) >> 1);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7];
+                    v = MAKE_UINT32((ss0 + amend) >> 1, 0, 0, (ss3 + amend) >> 1);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6];
-                    v = MAKE_UINT32((ss0 + amend) >> 1, (ss1 + amend) >> 1,
-                                    (ss2 + amend) >> 1, 0);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6];
+                    v = MAKE_UINT32(
+                        (ss0 + amend) >> 1, (ss1 + amend) >> 1, (ss2 + amend) >> 1, 0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7];
-                    v = MAKE_UINT32((ss0 + amend) >> 1, (ss1 + amend) >> 1,
-                                    (ss2 + amend) >> 1, (ss3 + amend) >> 1);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7];
+                    v = MAKE_UINT32(
+                        (ss0 + amend) >> 1,
+                        (ss1 + amend) >> 1,
+                        (ss2 + amend) >> 1,
+                        (ss3 + amend) >> 1);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduce2x2(Imaging imOut, Imaging imIn, int box[4])
-{
+ImagingReduce2x2(Imaging imOut, Imaging imIn, int box[4]) {
     /* Optimized implementation for xscale = 2 and yscale = 2.
-    */
+     */
     int xscale = 2, yscale = 2;
     int x, y;
     UINT32 ss0, ss1, ss2, ss3;
@@ -532,74 +522,73 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image8[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image8[yy + 1];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
-                ss0 = line0[xx + 0] + line0[xx + 1] +
-                      line1[xx + 0] + line1[xx + 1];
+                int xx = box[0] + x * xscale;
+                ss0 = line0[xx + 0] + line0[xx + 1] + line1[xx + 0] + line1[xx + 1];
                 imOut->image8[y][x] = (ss0 + amend) >> 2;
             }
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] +
-                          line1[xx*4 + 3] + line1[xx*4 + 7];
-                    v = MAKE_UINT32((ss0 + amend) >> 2, 0,
-                                    0, (ss3 + amend) >> 2);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line1[xx * 4 + 0] +
+                          line1[xx * 4 + 4];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line1[xx * 4 + 3] +
+                          line1[xx * 4 + 7];
+                    v = MAKE_UINT32((ss0 + amend) >> 2, 0, 0, (ss3 + amend) >> 2);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] +
-                          line1[xx*4 + 1] + line1[xx*4 + 5];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] +
-                          line1[xx*4 + 2] + line1[xx*4 + 6];
-                    v = MAKE_UINT32((ss0 + amend) >> 2, (ss1 + amend) >> 2,
-                                    (ss2 + amend) >> 2, 0);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line1[xx * 4 + 0] +
+                          line1[xx * 4 + 4];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line1[xx * 4 + 1] +
+                          line1[xx * 4 + 5];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line1[xx * 4 + 2] +
+                          line1[xx * 4 + 6];
+                    v = MAKE_UINT32(
+                        (ss0 + amend) >> 2, (ss1 + amend) >> 2, (ss2 + amend) >> 2, 0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] +
-                          line1[xx*4 + 1] + line1[xx*4 + 5];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] +
-                          line1[xx*4 + 2] + line1[xx*4 + 6];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] +
-                          line1[xx*4 + 3] + line1[xx*4 + 7];
-                    v = MAKE_UINT32((ss0 + amend) >> 2, (ss1 + amend) >> 2,
-                                    (ss2 + amend) >> 2, (ss3 + amend) >> 2);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line1[xx * 4 + 0] +
+                          line1[xx * 4 + 4];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line1[xx * 4 + 1] +
+                          line1[xx * 4 + 5];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line1[xx * 4 + 2] +
+                          line1[xx * 4 + 6];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line1[xx * 4 + 3] +
+                          line1[xx * 4 + 7];
+                    v = MAKE_UINT32(
+                        (ss0 + amend) >> 2,
+                        (ss1 + amend) >> 2,
+                        (ss2 + amend) >> 2,
+                        (ss3 + amend) >> 2);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduce1x3(Imaging imOut, Imaging imIn, int box[4])
-{
+ImagingReduce1x3(Imaging imOut, Imaging imIn, int box[4]) {
     /* Optimized implementation for xscale = 1 and yscale = 3.
-    */
+     */
     int xscale = 1, yscale = 3;
     int x, y;
     UINT32 ss0, ss1, ss2, ss3;
@@ -608,89 +597,73 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image8[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image8[yy + 1];
             UINT8 *line2 = (UINT8 *)imIn->image8[yy + 2];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
-                ss0 = line0[xx + 0] +
-                      line1[xx + 0] +
-                      line2[xx + 0];
+                int xx = box[0] + x * xscale;
+                ss0 = line0[xx + 0] + line1[xx + 0] + line2[xx + 0];
                 imOut->image8[y][x] = ((ss0 + amend) * multiplier) >> 24;
             }
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
             UINT8 *line2 = (UINT8 *)imIn->image[yy + 2];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] +
-                          line1[xx*4 + 0] +
-                          line2[xx*4 + 0];
-                    ss3 = line0[xx*4 + 3] +
-                          line1[xx*4 + 3] +
-                          line2[xx*4 + 3];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, 0,
-                        0, ((ss3 + amend) * multiplier) >> 24);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line1[xx * 4 + 0] + line2[xx * 4 + 0];
+                    ss3 = line0[xx * 4 + 3] + line1[xx * 4 + 3] + line2[xx * 4 + 3];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        0,
+                        0,
+                        ((ss3 + amend) * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] +
-                          line1[xx*4 + 0] +
-                          line2[xx*4 + 0];
-                    ss1 = line0[xx*4 + 1] +
-                          line1[xx*4 + 1] +
-                          line2[xx*4 + 1];
-                    ss2 = line0[xx*4 + 2] +
-                          line1[xx*4 + 2] +
-                          line2[xx*4 + 2];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, ((ss1 + amend) * multiplier) >> 24,
-                        ((ss2 + amend) * multiplier) >> 24, 0);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line1[xx * 4 + 0] + line2[xx * 4 + 0];
+                    ss1 = line0[xx * 4 + 1] + line1[xx * 4 + 1] + line2[xx * 4 + 1];
+                    ss2 = line0[xx * 4 + 2] + line1[xx * 4 + 2] + line2[xx * 4 + 2];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        ((ss1 + amend) * multiplier) >> 24,
+                        ((ss2 + amend) * multiplier) >> 24,
+                        0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] +
-                          line1[xx*4 + 0] +
-                          line2[xx*4 + 0];
-                    ss1 = line0[xx*4 + 1] +
-                          line1[xx*4 + 1] +
-                          line2[xx*4 + 1];
-                    ss2 = line0[xx*4 + 2] +
-                          line1[xx*4 + 2] +
-                          line2[xx*4 + 2];
-                    ss3 = line0[xx*4 + 3] +
-                          line1[xx*4 + 3] +
-                          line2[xx*4 + 3];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, ((ss1 + amend) * multiplier) >> 24,
-                        ((ss2 + amend) * multiplier) >> 24, ((ss3 + amend) * multiplier) >> 24);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line1[xx * 4 + 0] + line2[xx * 4 + 0];
+                    ss1 = line0[xx * 4 + 1] + line1[xx * 4 + 1] + line2[xx * 4 + 1];
+                    ss2 = line0[xx * 4 + 2] + line1[xx * 4 + 2] + line2[xx * 4 + 2];
+                    ss3 = line0[xx * 4 + 3] + line1[xx * 4 + 3] + line2[xx * 4 + 3];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        ((ss1 + amend) * multiplier) >> 24,
+                        ((ss2 + amend) * multiplier) >> 24,
+                        ((ss3 + amend) * multiplier) >> 24);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduce3x1(Imaging imOut, Imaging imIn, int box[4])
-{
+ImagingReduce3x1(Imaging imOut, Imaging imIn, int box[4]) {
     /* Optimized implementation for xscale = 3 and yscale = 1.
-    */
+     */
     int xscale = 3, yscale = 1;
     int x, y;
     UINT32 ss0, ss1, ss2, ss3;
@@ -699,65 +672,69 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image8[yy + 0];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
+                int xx = box[0] + x * xscale;
                 ss0 = line0[xx + 0] + line0[xx + 1] + line0[xx + 2];
                 imOut->image8[y][x] = ((ss0 + amend) * multiplier) >> 24;
             }
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image[yy + 0];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] + line0[xx*4 + 11];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, 0,
-                        0, ((ss3 + amend) * multiplier) >> 24);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line0[xx * 4 + 11];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        0,
+                        0,
+                        ((ss3 + amend) * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] + line0[xx*4 + 9];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] + line0[xx*4 + 10];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, ((ss1 + amend) * multiplier) >> 24,
-                        ((ss2 + amend) * multiplier) >> 24, 0);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line0[xx * 4 + 9];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line0[xx * 4 + 10];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        ((ss1 + amend) * multiplier) >> 24,
+                        ((ss2 + amend) * multiplier) >> 24,
+                        0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] + line0[xx*4 + 9];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] + line0[xx*4 + 10];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] + line0[xx*4 + 11];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, ((ss1 + amend) * multiplier) >> 24,
-                        ((ss2 + amend) * multiplier) >> 24, ((ss3 + amend) * multiplier) >> 24);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line0[xx * 4 + 9];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line0[xx * 4 + 10];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line0[xx * 4 + 11];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        ((ss1 + amend) * multiplier) >> 24,
+                        ((ss2 + amend) * multiplier) >> 24,
+                        ((ss3 + amend) * multiplier) >> 24);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduce3x3(Imaging imOut, Imaging imIn, int box[4])
-{
+ImagingReduce3x3(Imaging imOut, Imaging imIn, int box[4]) {
     /* Optimized implementation for xscale = 3 and yscale = 3.
-    */
+     */
     int xscale = 3, yscale = 3;
     int x, y;
     UINT32 ss0, ss1, ss2, ss3;
@@ -766,76 +743,82 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image8[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image8[yy + 1];
             UINT8 *line2 = (UINT8 *)imIn->image8[yy + 2];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
-                ss0 = line0[xx + 0] + line0[xx + 1] + line0[xx + 2] +
-                      line1[xx + 0] + line1[xx + 1] + line1[xx + 2] +
-                      line2[xx + 0] + line2[xx + 1] + line2[xx + 2];
+                int xx = box[0] + x * xscale;
+                ss0 = line0[xx + 0] + line0[xx + 1] + line0[xx + 2] + line1[xx + 0] +
+                      line1[xx + 1] + line1[xx + 2] + line2[xx + 0] + line2[xx + 1] +
+                      line2[xx + 2];
                 imOut->image8[y][x] = ((ss0 + amend) * multiplier) >> 24;
             }
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
             UINT8 *line2 = (UINT8 *)imIn->image[yy + 2];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] + line0[xx*4 + 11] +
-                          line1[xx*4 + 3] + line1[xx*4 + 7] + line1[xx*4 + 11] +
-                          line2[xx*4 + 3] + line2[xx*4 + 7] + line2[xx*4 + 11];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, 0,
-                        0, ((ss3 + amend) * multiplier) >> 24);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line1[xx * 4 + 0] + line1[xx * 4 + 4] + line1[xx * 4 + 8] +
+                          line2[xx * 4 + 0] + line2[xx * 4 + 4] + line2[xx * 4 + 8];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line0[xx * 4 + 11] +
+                          line1[xx * 4 + 3] + line1[xx * 4 + 7] + line1[xx * 4 + 11] +
+                          line2[xx * 4 + 3] + line2[xx * 4 + 7] + line2[xx * 4 + 11];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        0,
+                        0,
+                        ((ss3 + amend) * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] + line0[xx*4 + 9] +
-                          line1[xx*4 + 1] + line1[xx*4 + 5] + line1[xx*4 + 9] +
-                          line2[xx*4 + 1] + line2[xx*4 + 5] + line2[xx*4 + 9];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] + line0[xx*4 + 10] +
-                          line1[xx*4 + 2] + line1[xx*4 + 6] + line1[xx*4 + 10] +
-                          line2[xx*4 + 2] + line2[xx*4 + 6] + line2[xx*4 + 10];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, ((ss1 + amend) * multiplier) >> 24,
-                        ((ss2 + amend) * multiplier) >> 24, 0);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line1[xx * 4 + 0] + line1[xx * 4 + 4] + line1[xx * 4 + 8] +
+                          line2[xx * 4 + 0] + line2[xx * 4 + 4] + line2[xx * 4 + 8];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line0[xx * 4 + 9] +
+                          line1[xx * 4 + 1] + line1[xx * 4 + 5] + line1[xx * 4 + 9] +
+                          line2[xx * 4 + 1] + line2[xx * 4 + 5] + line2[xx * 4 + 9];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line0[xx * 4 + 10] +
+                          line1[xx * 4 + 2] + line1[xx * 4 + 6] + line1[xx * 4 + 10] +
+                          line2[xx * 4 + 2] + line2[xx * 4 + 6] + line2[xx * 4 + 10];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        ((ss1 + amend) * multiplier) >> 24,
+                        ((ss2 + amend) * multiplier) >> 24,
+                        0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] + line0[xx*4 + 9] +
-                          line1[xx*4 + 1] + line1[xx*4 + 5] + line1[xx*4 + 9] +
-                          line2[xx*4 + 1] + line2[xx*4 + 5] + line2[xx*4 + 9];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] + line0[xx*4 + 10] +
-                          line1[xx*4 + 2] + line1[xx*4 + 6] + line1[xx*4 + 10] +
-                          line2[xx*4 + 2] + line2[xx*4 + 6] + line2[xx*4 + 10];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] + line0[xx*4 + 11] +
-                          line1[xx*4 + 3] + line1[xx*4 + 7] + line1[xx*4 + 11] +
-                          line2[xx*4 + 3] + line2[xx*4 + 7] + line2[xx*4 + 11];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, ((ss1 + amend) * multiplier) >> 24,
-                        ((ss2 + amend) * multiplier) >> 24, ((ss3 + amend) * multiplier) >> 24);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line1[xx * 4 + 0] + line1[xx * 4 + 4] + line1[xx * 4 + 8] +
+                          line2[xx * 4 + 0] + line2[xx * 4 + 4] + line2[xx * 4 + 8];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line0[xx * 4 + 9] +
+                          line1[xx * 4 + 1] + line1[xx * 4 + 5] + line1[xx * 4 + 9] +
+                          line2[xx * 4 + 1] + line2[xx * 4 + 5] + line2[xx * 4 + 9];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line0[xx * 4 + 10] +
+                          line1[xx * 4 + 2] + line1[xx * 4 + 6] + line1[xx * 4 + 10] +
+                          line2[xx * 4 + 2] + line2[xx * 4 + 6] + line2[xx * 4 + 10];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line0[xx * 4 + 11] +
+                          line1[xx * 4 + 3] + line1[xx * 4 + 7] + line1[xx * 4 + 11] +
+                          line2[xx * 4 + 3] + line2[xx * 4 + 7] + line2[xx * 4 + 11];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        ((ss1 + amend) * multiplier) >> 24,
+                        ((ss2 + amend) * multiplier) >> 24,
+                        ((ss3 + amend) * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             }
@@ -844,10 +827,9 @@
 }

 void
-ImagingReduce4x4(Imaging imOut, Imaging imIn, int box[4])
-{
+ImagingReduce4x4(Imaging imOut, Imaging imIn, int box[4]) {
     /* Optimized implementation for xscale = 4 and yscale = 4.
-    */
+     */
     int xscale = 4, yscale = 4;
     int x, y;
     UINT32 ss0, ss1, ss2, ss3;
@@ -855,13 +837,13 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image8[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image8[yy + 1];
             UINT8 *line2 = (UINT8 *)imIn->image8[yy + 2];
             UINT8 *line3 = (UINT8 *)imIn->image8[yy + 3];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
+                int xx = box[0] + x * xscale;
                 ss0 = line0[xx + 0] + line0[xx + 1] + line0[xx + 2] + line0[xx + 3] +
                       line1[xx + 0] + line1[xx + 1] + line1[xx + 2] + line1[xx + 3] +
                       line2[xx + 0] + line2[xx + 1] + line2[xx + 2] + line2[xx + 3] +
@@ -871,82 +853,100 @@
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
             UINT8 *line2 = (UINT8 *)imIn->image[yy + 2];
             UINT8 *line3 = (UINT8 *)imIn->image[yy + 3];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] + line0[xx*4 + 12] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] + line1[xx*4 + 12] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8] + line2[xx*4 + 12] +
-                          line3[xx*4 + 0] + line3[xx*4 + 4] + line3[xx*4 + 8] + line3[xx*4 + 12];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] + line0[xx*4 + 11] + line0[xx*4 + 15] +
-                          line1[xx*4 + 3] + line1[xx*4 + 7] + line1[xx*4 + 11] + line1[xx*4 + 15] +
-                          line2[xx*4 + 3] + line2[xx*4 + 7] + line2[xx*4 + 11] + line2[xx*4 + 15] +
-                          line3[xx*4 + 3] + line3[xx*4 + 7] + line3[xx*4 + 11] + line3[xx*4 + 15];
-                    v = MAKE_UINT32((ss0 + amend) >> 4, 0,
-                                    0, (ss3 + amend) >> 4);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line0[xx * 4 + 12] + line1[xx * 4 + 0] + line1[xx * 4 + 4] +
+                          line1[xx * 4 + 8] + line1[xx * 4 + 12] + line2[xx * 4 + 0] +
+                          line2[xx * 4 + 4] + line2[xx * 4 + 8] + line2[xx * 4 + 12] +
+                          line3[xx * 4 + 0] + line3[xx * 4 + 4] + line3[xx * 4 + 8] +
+                          line3[xx * 4 + 12];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line0[xx * 4 + 11] +
+                          line0[xx * 4 + 15] + line1[xx * 4 + 3] + line1[xx * 4 + 7] +
+                          line1[xx * 4 + 11] + line1[xx * 4 + 15] + line2[xx * 4 + 3] +
+                          line2[xx * 4 + 7] + line2[xx * 4 + 11] + line2[xx * 4 + 15] +
+                          line3[xx * 4 + 3] + line3[xx * 4 + 7] + line3[xx * 4 + 11] +
+                          line3[xx * 4 + 15];
+                    v = MAKE_UINT32((ss0 + amend) >> 4, 0, 0, (ss3 + amend) >> 4);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] + line0[xx*4 + 12] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] + line1[xx*4 + 12] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8] + line2[xx*4 + 12] +
-                          line3[xx*4 + 0] + line3[xx*4 + 4] + line3[xx*4 + 8] + line3[xx*4 + 12];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] + line0[xx*4 + 9] + line0[xx*4 + 13] +
-                          line1[xx*4 + 1] + line1[xx*4 + 5] + line1[xx*4 + 9] + line1[xx*4 + 13] +
-                          line2[xx*4 + 1] + line2[xx*4 + 5] + line2[xx*4 + 9] + line2[xx*4 + 13] +
-                          line3[xx*4 + 1] + line3[xx*4 + 5] + line3[xx*4 + 9] + line3[xx*4 + 13];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] + line0[xx*4 + 10] + line0[xx*4 + 14] +
-                          line1[xx*4 + 2] + line1[xx*4 + 6] + line1[xx*4 + 10] + line1[xx*4 + 14] +
-                          line2[xx*4 + 2] + line2[xx*4 + 6] + line2[xx*4 + 10] + line2[xx*4 + 14] +
-                          line3[xx*4 + 2] + line3[xx*4 + 6] + line3[xx*4 + 10] + line3[xx*4 + 14];
-                    v = MAKE_UINT32((ss0 + amend) >> 4, (ss1 + amend) >> 4,
-                                    (ss2 + amend) >> 4, 0);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line0[xx * 4 + 12] + line1[xx * 4 + 0] + line1[xx * 4 + 4] +
+                          line1[xx * 4 + 8] + line1[xx * 4 + 12] + line2[xx * 4 + 0] +
+                          line2[xx * 4 + 4] + line2[xx * 4 + 8] + line2[xx * 4 + 12] +
+                          line3[xx * 4 + 0] + line3[xx * 4 + 4] + line3[xx * 4 + 8] +
+                          line3[xx * 4 + 12];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line0[xx * 4 + 9] +
+                          line0[xx * 4 + 13] + line1[xx * 4 + 1] + line1[xx * 4 + 5] +
+                          line1[xx * 4 + 9] + line1[xx * 4 + 13] + line2[xx * 4 + 1] +
+                          line2[xx * 4 + 5] + line2[xx * 4 + 9] + line2[xx * 4 + 13] +
+                          line3[xx * 4 + 1] + line3[xx * 4 + 5] + line3[xx * 4 + 9] +
+                          line3[xx * 4 + 13];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line0[xx * 4 + 10] +
+                          line0[xx * 4 + 14] + line1[xx * 4 + 2] + line1[xx * 4 + 6] +
+                          line1[xx * 4 + 10] + line1[xx * 4 + 14] + line2[xx * 4 + 2] +
+                          line2[xx * 4 + 6] + line2[xx * 4 + 10] + line2[xx * 4 + 14] +
+                          line3[xx * 4 + 2] + line3[xx * 4 + 6] + line3[xx * 4 + 10] +
+                          line3[xx * 4 + 14];
+                    v = MAKE_UINT32(
+                        (ss0 + amend) >> 4, (ss1 + amend) >> 4, (ss2 + amend) >> 4, 0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] + line0[xx*4 + 12] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] + line1[xx*4 + 12] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8] + line2[xx*4 + 12] +
-                          line3[xx*4 + 0] + line3[xx*4 + 4] + line3[xx*4 + 8] + line3[xx*4 + 12];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] + line0[xx*4 + 9] + line0[xx*4 + 13] +
-                          line1[xx*4 + 1] + line1[xx*4 + 5] + line1[xx*4 + 9] + line1[xx*4 + 13] +
-                          line2[xx*4 + 1] + line2[xx*4 + 5] + line2[xx*4 + 9] + line2[xx*4 + 13] +
-                          line3[xx*4 + 1] + line3[xx*4 + 5] + line3[xx*4 + 9] + line3[xx*4 + 13];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] + line0[xx*4 + 10] + line0[xx*4 + 14] +
-                          line1[xx*4 + 2] + line1[xx*4 + 6] + line1[xx*4 + 10] + line1[xx*4 + 14] +
-                          line2[xx*4 + 2] + line2[xx*4 + 6] + line2[xx*4 + 10] + line2[xx*4 + 14] +
-                          line3[xx*4 + 2] + line3[xx*4 + 6] + line3[xx*4 + 10] + line3[xx*4 + 14];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] + line0[xx*4 + 11] + line0[xx*4 + 15] +
-                          line1[xx*4 + 3] + line1[xx*4 + 7] + line1[xx*4 + 11] + line1[xx*4 + 15] +
-                          line2[xx*4 + 3] + line2[xx*4 + 7] + line2[xx*4 + 11] + line2[xx*4 + 15] +
-                          line3[xx*4 + 3] + line3[xx*4 + 7] + line3[xx*4 + 11] + line3[xx*4 + 15];
-                    v = MAKE_UINT32((ss0 + amend) >> 4, (ss1 + amend) >> 4,
-                                    (ss2 + amend) >> 4, (ss3 + amend) >> 4);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line0[xx * 4 + 12] + line1[xx * 4 + 0] + line1[xx * 4 + 4] +
+                          line1[xx * 4 + 8] + line1[xx * 4 + 12] + line2[xx * 4 + 0] +
+                          line2[xx * 4 + 4] + line2[xx * 4 + 8] + line2[xx * 4 + 12] +
+                          line3[xx * 4 + 0] + line3[xx * 4 + 4] + line3[xx * 4 + 8] +
+                          line3[xx * 4 + 12];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line0[xx * 4 + 9] +
+                          line0[xx * 4 + 13] + line1[xx * 4 + 1] + line1[xx * 4 + 5] +
+                          line1[xx * 4 + 9] + line1[xx * 4 + 13] + line2[xx * 4 + 1] +
+                          line2[xx * 4 + 5] + line2[xx * 4 + 9] + line2[xx * 4 + 13] +
+                          line3[xx * 4 + 1] + line3[xx * 4 + 5] + line3[xx * 4 + 9] +
+                          line3[xx * 4 + 13];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line0[xx * 4 + 10] +
+                          line0[xx * 4 + 14] + line1[xx * 4 + 2] + line1[xx * 4 + 6] +
+                          line1[xx * 4 + 10] + line1[xx * 4 + 14] + line2[xx * 4 + 2] +
+                          line2[xx * 4 + 6] + line2[xx * 4 + 10] + line2[xx * 4 + 14] +
+                          line3[xx * 4 + 2] + line3[xx * 4 + 6] + line3[xx * 4 + 10] +
+                          line3[xx * 4 + 14];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line0[xx * 4 + 11] +
+                          line0[xx * 4 + 15] + line1[xx * 4 + 3] + line1[xx * 4 + 7] +
+                          line1[xx * 4 + 11] + line1[xx * 4 + 15] + line2[xx * 4 + 3] +
+                          line2[xx * 4 + 7] + line2[xx * 4 + 11] + line2[xx * 4 + 15] +
+                          line3[xx * 4 + 3] + line3[xx * 4 + 7] + line3[xx * 4 + 11] +
+                          line3[xx * 4 + 15];
+                    v = MAKE_UINT32(
+                        (ss0 + amend) >> 4,
+                        (ss1 + amend) >> 4,
+                        (ss2 + amend) >> 4,
+                        (ss3 + amend) >> 4);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduce5x5(Imaging imOut, Imaging imIn, int box[4])
-{
+ImagingReduce5x5(Imaging imOut, Imaging imIn, int box[4]) {
     /* Fast special case for xscale = 5 and yscale = 5.
-    */
+     */
     int xscale = 5, yscale = 5;
     int x, y;
     UINT32 ss0, ss1, ss2, ss3;
@@ -955,25 +955,27 @@

     if (imIn->image8) {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image8[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image8[yy + 1];
             UINT8 *line2 = (UINT8 *)imIn->image8[yy + 2];
             UINT8 *line3 = (UINT8 *)imIn->image8[yy + 3];
             UINT8 *line4 = (UINT8 *)imIn->image8[yy + 4];
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx = box[0] + x*xscale;
-                ss0 = line0[xx + 0] + line0[xx + 1] + line0[xx + 2] + line0[xx + 3] + line0[xx + 4] +
-                      line1[xx + 0] + line1[xx + 1] + line1[xx + 2] + line1[xx + 3] + line1[xx + 4] +
-                      line2[xx + 0] + line2[xx + 1] + line2[xx + 2] + line2[xx + 3] + line2[xx + 4] +
-                      line3[xx + 0] + line3[xx + 1] + line3[xx + 2] + line3[xx + 3] + line3[xx + 4] +
-                      line4[xx + 0] + line4[xx + 1] + line4[xx + 2] + line4[xx + 3] + line4[xx + 4];
+                int xx = box[0] + x * xscale;
+                ss0 = line0[xx + 0] + line0[xx + 1] + line0[xx + 2] + line0[xx + 3] +
+                      line0[xx + 4] + line1[xx + 0] + line1[xx + 1] + line1[xx + 2] +
+                      line1[xx + 3] + line1[xx + 4] + line2[xx + 0] + line2[xx + 1] +
+                      line2[xx + 2] + line2[xx + 3] + line2[xx + 4] + line3[xx + 0] +
+                      line3[xx + 1] + line3[xx + 2] + line3[xx + 3] + line3[xx + 4] +
+                      line4[xx + 0] + line4[xx + 1] + line4[xx + 2] + line4[xx + 3] +
+                      line4[xx + 4];
                 imOut->image8[y][x] = ((ss0 + amend) * multiplier) >> 24;
             }
         }
     } else {
         for (y = 0; y < box[3] / yscale; y++) {
-            int yy = box[1] + y*yscale;
+            int yy = box[1] + y * yscale;
             UINT8 *line0 = (UINT8 *)imIn->image[yy + 0];
             UINT8 *line1 = (UINT8 *)imIn->image[yy + 1];
             UINT8 *line2 = (UINT8 *)imIn->image[yy + 2];
@@ -981,87 +983,127 @@
             UINT8 *line4 = (UINT8 *)imIn->image[yy + 4];
             if (imIn->bands == 2) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] + line0[xx*4 + 12] + line0[xx*4 + 16] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] + line1[xx*4 + 12] + line1[xx*4 + 16] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8] + line2[xx*4 + 12] + line2[xx*4 + 16] +
-                          line3[xx*4 + 0] + line3[xx*4 + 4] + line3[xx*4 + 8] + line3[xx*4 + 12] + line3[xx*4 + 16] +
-                          line4[xx*4 + 0] + line4[xx*4 + 4] + line4[xx*4 + 8] + line4[xx*4 + 12] + line4[xx*4 + 16];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] + line0[xx*4 + 11] + line0[xx*4 + 15] + line0[xx*4 + 19] +
-                          line1[xx*4 + 3] + line1[xx*4 + 7] + line1[xx*4 + 11] + line1[xx*4 + 15] + line1[xx*4 + 19] +
-                          line2[xx*4 + 3] + line2[xx*4 + 7] + line2[xx*4 + 11] + line2[xx*4 + 15] + line2[xx*4 + 19] +
-                          line3[xx*4 + 3] + line3[xx*4 + 7] + line3[xx*4 + 11] + line3[xx*4 + 15] + line3[xx*4 + 19] +
-                          line4[xx*4 + 3] + line4[xx*4 + 7] + line4[xx*4 + 11] + line4[xx*4 + 15] + line4[xx*4 + 19];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, 0,
-                        0, ((ss3 + amend) * multiplier) >> 24);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line0[xx * 4 + 12] + line0[xx * 4 + 16] + line1[xx * 4 + 0] +
+                          line1[xx * 4 + 4] + line1[xx * 4 + 8] + line1[xx * 4 + 12] +
+                          line1[xx * 4 + 16] + line2[xx * 4 + 0] + line2[xx * 4 + 4] +
+                          line2[xx * 4 + 8] + line2[xx * 4 + 12] + line2[xx * 4 + 16] +
+                          line3[xx * 4 + 0] + line3[xx * 4 + 4] + line3[xx * 4 + 8] +
+                          line3[xx * 4 + 12] + line3[xx * 4 + 16] + line4[xx * 4 + 0] +
+                          line4[xx * 4 + 4] + line4[xx * 4 + 8] + line4[xx * 4 + 12] +
+                          line4[xx * 4 + 16];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line0[xx * 4 + 11] +
+                          line0[xx * 4 + 15] + line0[xx * 4 + 19] + line1[xx * 4 + 3] +
+                          line1[xx * 4 + 7] + line1[xx * 4 + 11] + line1[xx * 4 + 15] +
+                          line1[xx * 4 + 19] + line2[xx * 4 + 3] + line2[xx * 4 + 7] +
+                          line2[xx * 4 + 11] + line2[xx * 4 + 15] + line2[xx * 4 + 19] +
+                          line3[xx * 4 + 3] + line3[xx * 4 + 7] + line3[xx * 4 + 11] +
+                          line3[xx * 4 + 15] + line3[xx * 4 + 19] + line4[xx * 4 + 3] +
+                          line4[xx * 4 + 7] + line4[xx * 4 + 11] + line4[xx * 4 + 15] +
+                          line4[xx * 4 + 19];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        0,
+                        0,
+                        ((ss3 + amend) * multiplier) >> 24);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (imIn->bands == 3) {
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] + line0[xx*4 + 12] + line0[xx*4 + 16] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] + line1[xx*4 + 12] + line1[xx*4 + 16] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8] + line2[xx*4 + 12] + line2[xx*4 + 16] +
-                          line3[xx*4 + 0] + line3[xx*4 + 4] + line3[xx*4 + 8] + line3[xx*4 + 12] + line3[xx*4 + 16] +
-                          line4[xx*4 + 0] + line4[xx*4 + 4] + line4[xx*4 + 8] + line4[xx*4 + 12] + line4[xx*4 + 16];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] + line0[xx*4 + 9] + line0[xx*4 + 13] + line0[xx*4 + 17] +
-                          line1[xx*4 + 1] + line1[xx*4 + 5] + line1[xx*4 + 9] + line1[xx*4 + 13] + line1[xx*4 + 17] +
-                          line2[xx*4 + 1] + line2[xx*4 + 5] + line2[xx*4 + 9] + line2[xx*4 + 13] + line2[xx*4 + 17] +
-                          line3[xx*4 + 1] + line3[xx*4 + 5] + line3[xx*4 + 9] + line3[xx*4 + 13] + line3[xx*4 + 17] +
-                          line4[xx*4 + 1] + line4[xx*4 + 5] + line4[xx*4 + 9] + line4[xx*4 + 13] + line4[xx*4 + 17];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] + line0[xx*4 + 10] + line0[xx*4 + 14] + line0[xx*4 + 18] +
-                          line1[xx*4 + 2] + line1[xx*4 + 6] + line1[xx*4 + 10] + line1[xx*4 + 14] + line1[xx*4 + 18] +
-                          line2[xx*4 + 2] + line2[xx*4 + 6] + line2[xx*4 + 10] + line2[xx*4 + 14] + line2[xx*4 + 18] +
-                          line3[xx*4 + 2] + line3[xx*4 + 6] + line3[xx*4 + 10] + line3[xx*4 + 14] + line3[xx*4 + 18] +
-                          line4[xx*4 + 2] + line4[xx*4 + 6] + line4[xx*4 + 10] + line4[xx*4 + 14] + line4[xx*4 + 18];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, ((ss1 + amend) * multiplier) >> 24,
-                        ((ss2 + amend) * multiplier) >> 24, 0);
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line0[xx * 4 + 12] + line0[xx * 4 + 16] + line1[xx * 4 + 0] +
+                          line1[xx * 4 + 4] + line1[xx * 4 + 8] + line1[xx * 4 + 12] +
+                          line1[xx * 4 + 16] + line2[xx * 4 + 0] + line2[xx * 4 + 4] +
+                          line2[xx * 4 + 8] + line2[xx * 4 + 12] + line2[xx * 4 + 16] +
+                          line3[xx * 4 + 0] + line3[xx * 4 + 4] + line3[xx * 4 + 8] +
+                          line3[xx * 4 + 12] + line3[xx * 4 + 16] + line4[xx * 4 + 0] +
+                          line4[xx * 4 + 4] + line4[xx * 4 + 8] + line4[xx * 4 + 12] +
+                          line4[xx * 4 + 16];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line0[xx * 4 + 9] +
+                          line0[xx * 4 + 13] + line0[xx * 4 + 17] + line1[xx * 4 + 1] +
+                          line1[xx * 4 + 5] + line1[xx * 4 + 9] + line1[xx * 4 + 13] +
+                          line1[xx * 4 + 17] + line2[xx * 4 + 1] + line2[xx * 4 + 5] +
+                          line2[xx * 4 + 9] + line2[xx * 4 + 13] + line2[xx * 4 + 17] +
+                          line3[xx * 4 + 1] + line3[xx * 4 + 5] + line3[xx * 4 + 9] +
+                          line3[xx * 4 + 13] + line3[xx * 4 + 17] + line4[xx * 4 + 1] +
+                          line4[xx * 4 + 5] + line4[xx * 4 + 9] + line4[xx * 4 + 13] +
+                          line4[xx * 4 + 17];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line0[xx * 4 + 10] +
+                          line0[xx * 4 + 14] + line0[xx * 4 + 18] + line1[xx * 4 + 2] +
+                          line1[xx * 4 + 6] + line1[xx * 4 + 10] + line1[xx * 4 + 14] +
+                          line1[xx * 4 + 18] + line2[xx * 4 + 2] + line2[xx * 4 + 6] +
+                          line2[xx * 4 + 10] + line2[xx * 4 + 14] + line2[xx * 4 + 18] +
+                          line3[xx * 4 + 2] + line3[xx * 4 + 6] + line3[xx * 4 + 10] +
+                          line3[xx * 4 + 14] + line3[xx * 4 + 18] + line4[xx * 4 + 2] +
+                          line4[xx * 4 + 6] + line4[xx * 4 + 10] + line4[xx * 4 + 14] +
+                          line4[xx * 4 + 18];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        ((ss1 + amend) * multiplier) >> 24,
+                        ((ss2 + amend) * multiplier) >> 24,
+                        0);
                     memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
                 }
             } else {  // bands == 4
                 for (x = 0; x < box[2] / xscale; x++) {
-                    int xx = box[0] + x*xscale;
-                    UINT32 v;
-                    ss0 = line0[xx*4 + 0] + line0[xx*4 + 4] + line0[xx*4 + 8] + line0[xx*4 + 12] + line0[xx*4 + 16] +
-                          line1[xx*4 + 0] + line1[xx*4 + 4] + line1[xx*4 + 8] + line1[xx*4 + 12] + line1[xx*4 + 16] +
-                          line2[xx*4 + 0] + line2[xx*4 + 4] + line2[xx*4 + 8] + line2[xx*4 + 12] + line2[xx*4 + 16] +
-                          line3[xx*4 + 0] + line3[xx*4 + 4] + line3[xx*4 + 8] + line3[xx*4 + 12] + line3[xx*4 + 16] +
-                          line4[xx*4 + 0] + line4[xx*4 + 4] + line4[xx*4 + 8] + line4[xx*4 + 12] + line4[xx*4 + 16];
-                    ss1 = line0[xx*4 + 1] + line0[xx*4 + 5] + line0[xx*4 + 9] + line0[xx*4 + 13] + line0[xx*4 + 17] +
-                          line1[xx*4 + 1] + line1[xx*4 + 5] + line1[xx*4 + 9] + line1[xx*4 + 13] + line1[xx*4 + 17] +
-                          line2[xx*4 + 1] + line2[xx*4 + 5] + line2[xx*4 + 9] + line2[xx*4 + 13] + line2[xx*4 + 17] +
-                          line3[xx*4 + 1] + line3[xx*4 + 5] + line3[xx*4 + 9] + line3[xx*4 + 13] + line3[xx*4 + 17] +
-                          line4[xx*4 + 1] + line4[xx*4 + 5] + line4[xx*4 + 9] + line4[xx*4 + 13] + line4[xx*4 + 17];
-                    ss2 = line0[xx*4 + 2] + line0[xx*4 + 6] + line0[xx*4 + 10] + line0[xx*4 + 14] + line0[xx*4 + 18] +
-                          line1[xx*4 + 2] + line1[xx*4 + 6] + line1[xx*4 + 10] + line1[xx*4 + 14] + line1[xx*4 + 18] +
-                          line2[xx*4 + 2] + line2[xx*4 + 6] + line2[xx*4 + 10] + line2[xx*4 + 14] + line2[xx*4 + 18] +
-                          line3[xx*4 + 2] + line3[xx*4 + 6] + line3[xx*4 + 10] + line3[xx*4 + 14] + line3[xx*4 + 18] +
-                          line4[xx*4 + 2] + line4[xx*4 + 6] + line4[xx*4 + 10] + line4[xx*4 + 14] + line4[xx*4 + 18];
-                    ss3 = line0[xx*4 + 3] + line0[xx*4 + 7] + line0[xx*4 + 11] + line0[xx*4 + 15] + line0[xx*4 + 19] +
-                          line1[xx*4 + 3] + line1[xx*4 + 7] + line1[xx*4 + 11] + line1[xx*4 + 15] + line1[xx*4 + 19] +
-                          line2[xx*4 + 3] + line2[xx*4 + 7] + line2[xx*4 + 11] + line2[xx*4 + 15] + line2[xx*4 + 19] +
-                          line3[xx*4 + 3] + line3[xx*4 + 7] + line3[xx*4 + 11] + line3[xx*4 + 15] + line3[xx*4 + 19] +
-                          line4[xx*4 + 3] + line4[xx*4 + 7] + line4[xx*4 + 11] + line4[xx*4 + 15] + line4[xx*4 + 19];
-                    v = MAKE_UINT32(
-                        ((ss0 + amend) * multiplier) >> 24, ((ss1 + amend) * multiplier) >> 24,
-                        ((ss2 + amend) * multiplier) >> 24, ((ss3 + amend) * multiplier) >> 24);
-                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
-                }
-            }
-        }
-    }
-}
-
+                    int xx = box[0] + x * xscale;
+                    UINT32 v;
+                    ss0 = line0[xx * 4 + 0] + line0[xx * 4 + 4] + line0[xx * 4 + 8] +
+                          line0[xx * 4 + 12] + line0[xx * 4 + 16] + line1[xx * 4 + 0] +
+                          line1[xx * 4 + 4] + line1[xx * 4 + 8] + line1[xx * 4 + 12] +
+                          line1[xx * 4 + 16] + line2[xx * 4 + 0] + line2[xx * 4 + 4] +
+                          line2[xx * 4 + 8] + line2[xx * 4 + 12] + line2[xx * 4 + 16] +
+                          line3[xx * 4 + 0] + line3[xx * 4 + 4] + line3[xx * 4 + 8] +
+                          line3[xx * 4 + 12] + line3[xx * 4 + 16] + line4[xx * 4 + 0] +
+                          line4[xx * 4 + 4] + line4[xx * 4 + 8] + line4[xx * 4 + 12] +
+                          line4[xx * 4 + 16];
+                    ss1 = line0[xx * 4 + 1] + line0[xx * 4 + 5] + line0[xx * 4 + 9] +
+                          line0[xx * 4 + 13] + line0[xx * 4 + 17] + line1[xx * 4 + 1] +
+                          line1[xx * 4 + 5] + line1[xx * 4 + 9] + line1[xx * 4 + 13] +
+                          line1[xx * 4 + 17] + line2[xx * 4 + 1] + line2[xx * 4 + 5] +
+                          line2[xx * 4 + 9] + line2[xx * 4 + 13] + line2[xx * 4 + 17] +
+                          line3[xx * 4 + 1] + line3[xx * 4 + 5] + line3[xx * 4 + 9] +
+                          line3[xx * 4 + 13] + line3[xx * 4 + 17] + line4[xx * 4 + 1] +
+                          line4[xx * 4 + 5] + line4[xx * 4 + 9] + line4[xx * 4 + 13] +
+                          line4[xx * 4 + 17];
+                    ss2 = line0[xx * 4 + 2] + line0[xx * 4 + 6] + line0[xx * 4 + 10] +
+                          line0[xx * 4 + 14] + line0[xx * 4 + 18] + line1[xx * 4 + 2] +
+                          line1[xx * 4 + 6] + line1[xx * 4 + 10] + line1[xx * 4 + 14] +
+                          line1[xx * 4 + 18] + line2[xx * 4 + 2] + line2[xx * 4 + 6] +
+                          line2[xx * 4 + 10] + line2[xx * 4 + 14] + line2[xx * 4 + 18] +
+                          line3[xx * 4 + 2] + line3[xx * 4 + 6] + line3[xx * 4 + 10] +
+                          line3[xx * 4 + 14] + line3[xx * 4 + 18] + line4[xx * 4 + 2] +
+                          line4[xx * 4 + 6] + line4[xx * 4 + 10] + line4[xx * 4 + 14] +
+                          line4[xx * 4 + 18];
+                    ss3 = line0[xx * 4 + 3] + line0[xx * 4 + 7] + line0[xx * 4 + 11] +
+                          line0[xx * 4 + 15] + line0[xx * 4 + 19] + line1[xx * 4 + 3] +
+                          line1[xx * 4 + 7] + line1[xx * 4 + 11] + line1[xx * 4 + 15] +
+                          line1[xx * 4 + 19] + line2[xx * 4 + 3] + line2[xx * 4 + 7] +
+                          line2[xx * 4 + 11] + line2[xx * 4 + 15] + line2[xx * 4 + 19] +
+                          line3[xx * 4 + 3] + line3[xx * 4 + 7] + line3[xx * 4 + 11] +
+                          line3[xx * 4 + 15] + line3[xx * 4 + 19] + line4[xx * 4 + 3] +
+                          line4[xx * 4 + 7] + line4[xx * 4 + 11] + line4[xx * 4 + 15] +
+                          line4[xx * 4 + 19];
+                    v = MAKE_UINT32(
+                        ((ss0 + amend) * multiplier) >> 24,
+                        ((ss1 + amend) * multiplier) >> 24,
+                        ((ss2 + amend) * multiplier) >> 24,
+                        ((ss3 + amend) * multiplier) >> 24);
+                    memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
+                }
+            }
+        }
+    }
+}

 void
-ImagingReduceCorners(Imaging imOut, Imaging imIn, int box[4], int xscale, int yscale)
-{
+ImagingReduceCorners(Imaging imOut, Imaging imIn, int box[4], int xscale, int yscale) {
     /* Fill the last row and the last column for any xscale and yscale.
-    */
+     */
     int x, y, xx, yy;

     if (imIn->image8) {
@@ -1070,13 +1112,13 @@
             UINT32 multiplier = division_UINT32(scale, 8);
             UINT32 amend = scale / 2;
             for (y = 0; y < box[3] / yscale; y++) {
-                int yy_from = box[1] + y*yscale;
+                int yy_from = box[1] + y * yscale;
                 UINT32 ss = amend;
                 x = box[2] / xscale;

                 for (yy = yy_from; yy < yy_from + yscale; yy++) {
                     UINT8 *line = (UINT8 *)imIn->image8[yy];
-                    for (xx = box[0] + x*xscale; xx < box[0] + box[2]; xx++) {
+                    for (xx = box[0] + x * xscale; xx < box[0] + box[2]; xx++) {
                         ss += line[xx + 0];
                     }
                 }
@@ -1089,9 +1131,9 @@
             UINT32 amend = scale / 2;
             y = box[3] / yscale;
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx_from = box[0] + x*xscale;
+                int xx_from = box[0] + x * xscale;
                 UINT32 ss = amend;
-                for (yy = box[1] + y*yscale; yy < box[1] + box[3]; yy++) {
+                for (yy = box[1] + y * yscale; yy < box[1] + box[3]; yy++) {
                     UINT8 *line = (UINT8 *)imIn->image8[yy];
                     for (xx = xx_from; xx < xx_from + xscale; xx++) {
                         ss += line[xx + 0];
@@ -1107,9 +1149,9 @@
             UINT32 ss = amend;
             x = box[2] / xscale;
             y = box[3] / yscale;
-            for (yy = box[1] + y*yscale; yy < box[1] + box[3]; yy++) {
+            for (yy = box[1] + y * yscale; yy < box[1] + box[3]; yy++) {
                 UINT8 *line = (UINT8 *)imIn->image8[yy];
-                for (xx = box[0] + x*xscale; xx < box[0] + box[2]; xx++) {
+                for (xx = box[0] + x * xscale; xx < box[0] + box[2]; xx++) {
                     ss += line[xx + 0];
                 }
             }
@@ -1121,23 +1163,25 @@
             UINT32 multiplier = division_UINT32(scale, 8);
             UINT32 amend = scale / 2;
             for (y = 0; y < box[3] / yscale; y++) {
-                int yy_from = box[1] + y*yscale;
+                int yy_from = box[1] + y * yscale;
                 UINT32 v;
                 UINT32 ss0 = amend, ss1 = amend, ss2 = amend, ss3 = amend;
                 x = box[2] / xscale;

                 for (yy = yy_from; yy < yy_from + yscale; yy++) {
                     UINT8 *line = (UINT8 *)imIn->image[yy];
-                    for (xx = box[0] + x*xscale; xx < box[0] + box[2]; xx++) {
-                        ss0 += line[xx*4 + 0];
-                        ss1 += line[xx*4 + 1];
-                        ss2 += line[xx*4 + 2];
-                        ss3 += line[xx*4 + 3];
+                    for (xx = box[0] + x * xscale; xx < box[0] + box[2]; xx++) {
+                        ss0 += line[xx * 4 + 0];
+                        ss1 += line[xx * 4 + 1];
+                        ss2 += line[xx * 4 + 2];
+                        ss3 += line[xx * 4 + 3];
                     }
                 }
                 v = MAKE_UINT32(
-                    (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                    (ss2 * multiplier) >> 24, (ss3 * multiplier) >> 24);
+                    (ss0 * multiplier) >> 24,
+                    (ss1 * multiplier) >> 24,
+                    (ss2 * multiplier) >> 24,
+                    (ss3 * multiplier) >> 24);
                 memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
             }
         }
@@ -1147,21 +1191,23 @@
             UINT32 amend = scale / 2;
             y = box[3] / yscale;
             for (x = 0; x < box[2] / xscale; x++) {
-                int xx_from = box[0] + x*xscale;
+                int xx_from = box[0] + x * xscale;
                 UINT32 v;
                 UINT32 ss0 = amend, ss1 = amend, ss2 = amend, ss3 = amend;
-                for (yy = box[1] + y*yscale; yy < box[1] + box[3]; yy++) {
+                for (yy = box[1] + y * yscale; yy < box[1] + box[3]; yy++) {
                     UINT8 *line = (UINT8 *)imIn->image[yy];
                     for (xx = xx_from; xx < xx_from + xscale; xx++) {
-                        ss0 += line[xx*4 + 0];
-                        ss1 += line[xx*4 + 1];
-                        ss2 += line[xx*4 + 2];
-                        ss3 += line[xx*4 + 3];
+                        ss0 += line[xx * 4 + 0];
+                        ss1 += line[xx * 4 + 1];
+                        ss2 += line[xx * 4 + 2];
+                        ss3 += line[xx * 4 + 3];
                     }
                 }
                 v = MAKE_UINT32(
-                    (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                    (ss2 * multiplier) >> 24, (ss3 * multiplier) >> 24);
+                    (ss0 * multiplier) >> 24,
+                    (ss1 * multiplier) >> 24,
+                    (ss2 * multiplier) >> 24,
+                    (ss3 * multiplier) >> 24);
                 memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
             }
         }
@@ -1173,265 +1219,262 @@
             UINT32 ss0 = amend, ss1 = amend, ss2 = amend, ss3 = amend;
             x = box[2] / xscale;
             y = box[3] / yscale;
-            for (yy = box[1] + y*yscale; yy < box[1] + box[3]; yy++) {
+            for (yy = box[1] + y * yscale; yy < box[1] + box[3]; yy++) {
                 UINT8 *line = (UINT8 *)imIn->image[yy];
-                for (xx = box[0] + x*xscale; xx < box[0] + box[2]; xx++) {
-                    ss0 += line[xx*4 + 0];
-                    ss1 += line[xx*4 + 1];
-                    ss2 += line[xx*4 + 2];
-                    ss3 += line[xx*4 + 3];
+                for (xx = box[0] + x * xscale; xx < box[0] + box[2]; xx++) {
+                    ss0 += line[xx * 4 + 0];
+                    ss1 += line[xx * 4 + 1];
+                    ss2 += line[xx * 4 + 2];
+                    ss3 += line[xx * 4 + 3];
                 }
             }
             v = MAKE_UINT32(
-                (ss0 * multiplier) >> 24, (ss1 * multiplier) >> 24,
-                (ss2 * multiplier) >> 24, (ss3 * multiplier) >> 24);
+                (ss0 * multiplier) >> 24,
+                (ss1 * multiplier) >> 24,
+                (ss2 * multiplier) >> 24,
+                (ss3 * multiplier) >> 24);
             memcpy(imOut->image[y] + x * sizeof(v), &v, sizeof(v));
         }
     }
 }

-
 void
-ImagingReduceNxN_32bpc(Imaging imOut, Imaging imIn, int box[4], int xscale, int yscale)
-{
+ImagingReduceNxN_32bpc(
+    Imaging imOut, Imaging imIn, int box[4], int xscale, int yscale) {
     /* The most general implementation for any xscale and yscale
-    */
+     */
     int x, y, xx, yy;
     double multiplier = 1.0 / (yscale * xscale);

-    switch(imIn->type) {
-    case IMAGING_TYPE_INT32:
-        for (y = 0; y < box[3] / yscale; y++) {
-            int yy_from = box[1] + y*yscale;
-            for (x = 0; x < box[2] / xscale; x++) {
-                int xx_from = box[0] + x*xscale;
-                double ss = 0;
-                for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
-                    INT32 *line0 = (INT32 *)imIn->image32[yy];
-                    INT32 *line1 = (INT32 *)imIn->image32[yy + 1];
-                    for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                        ss += line0[xx + 0] + line0[xx + 1] +
-                              line1[xx + 0] + line1[xx + 1];
-                    }
-                    if (xscale & 0x01) {
-                        ss += line0[xx + 0] + line1[xx + 0];
-                    }
-                }
-                if (yscale & 0x01) {
-                    INT32 *line = (INT32 *)imIn->image32[yy];
-                    for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                        ss += line[xx + 0] + line[xx + 1];
-                    }
-                    if (xscale & 0x01) {
-                        ss += line[xx + 0];
-                    }
-                }
-                IMAGING_PIXEL_I(imOut, x, y) = ROUND_UP(ss * multiplier);
-            }
-        }
-        break;
-
-    case IMAGING_TYPE_FLOAT32:
-        for (y = 0; y < box[3] / yscale; y++) {
-            int yy_from = box[1] + y*yscale;
-            for (x = 0; x < box[2] / xscale; x++) {
-                int xx_from = box[0] + x*xscale;
-                double ss = 0;
-                for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
-                    FLOAT32 *line0 = (FLOAT32 *)imIn->image32[yy];
-                    FLOAT32 *line1 = (FLOAT32 *)imIn->image32[yy + 1];
-                    for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                        ss += line0[xx + 0] + line0[xx + 1] +
-                              line1[xx + 0] + line1[xx + 1];
-                    }
-                    if (xscale & 0x01) {
-                        ss += line0[xx + 0] + line1[xx + 0];
-                    }
-                }
-                if (yscale & 0x01) {
-                    FLOAT32 *line = (FLOAT32 *)imIn->image32[yy];
-                    for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
-                        ss += line[xx + 0] + line[xx + 1];
-                    }
-                    if (xscale & 0x01) {
-                        ss += line[xx + 0];
-                    }
-                }
-                IMAGING_PIXEL_F(imOut, x, y) = ss * multiplier;
-            }
-        }
-        break;
-    }
-}
-
+    switch (imIn->type) {
+        case IMAGING_TYPE_INT32:
+            for (y = 0; y < box[3] / yscale; y++) {
+                int yy_from = box[1] + y * yscale;
+                for (x = 0; x < box[2] / xscale; x++) {
+                    int xx_from = box[0] + x * xscale;
+                    double ss = 0;
+                    for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
+                        INT32 *line0 = (INT32 *)imIn->image32[yy];
+                        INT32 *line1 = (INT32 *)imIn->image32[yy + 1];
+                        for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
+                            ss += line0[xx + 0] + line0[xx + 1] + line1[xx + 0] +
+                                  line1[xx + 1];
+                        }
+                        if (xscale & 0x01) {
+                            ss += line0[xx + 0] + line1[xx + 0];
+                        }
+                    }
+                    if (yscale & 0x01) {
+                        INT32 *line = (INT32 *)imIn->image32[yy];
+                        for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
+                            ss += line[xx + 0] + line[xx + 1];
+                        }
+                        if (xscale & 0x01) {
+                            ss += line[xx + 0];
+                        }
+                    }
+                    IMAGING_PIXEL_I(imOut, x, y) = ROUND_UP(ss * multiplier);
+                }
+            }
+            break;
+
+        case IMAGING_TYPE_FLOAT32:
+            for (y = 0; y < box[3] / yscale; y++) {
+                int yy_from = box[1] + y * yscale;
+                for (x = 0; x < box[2] / xscale; x++) {
+                    int xx_from = box[0] + x * xscale;
+                    double ss = 0;
+                    for (yy = yy_from; yy < yy_from + yscale - 1; yy += 2) {
+                        FLOAT32 *line0 = (FLOAT32 *)imIn->image32[yy];
+                        FLOAT32 *line1 = (FLOAT32 *)imIn->image32[yy + 1];
+                        for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
+                            ss += line0[xx + 0] + line0[xx + 1] + line1[xx + 0] +
+                                  line1[xx + 1];
+                        }
+                        if (xscale & 0x01) {
+                            ss += line0[xx + 0] + line1[xx + 0];
+                        }
+                    }
+                    if (yscale & 0x01) {
+                        FLOAT32 *line = (FLOAT32 *)imIn->image32[yy];
+                        for (xx = xx_from; xx < xx_from + xscale - 1; xx += 2) {
+                            ss += line[xx + 0] + line[xx + 1];
+                        }
+                        if (xscale & 0x01) {
+                            ss += line[xx + 0];
+                        }
+                    }
+                    IMAGING_PIXEL_F(imOut, x, y) = ss * multiplier;
+                }
+            }
+            break;
+    }
+}

 void
-ImagingReduceCorners_32bpc(Imaging imOut, Imaging imIn, int box[4], int xscale, int yscale)
-{
+ImagingReduceCorners_32bpc(
+    Imaging imOut, Imaging imIn, int box[4], int xscale, int yscale) {
     /* Fill the last row and the last column for any xscale and yscale.
-    */
+     */
     int x, y, xx, yy;

-    switch(imIn->type) {
-    case IMAGING_TYPE_INT32:
-        if (box[2] % xscale) {
-            double multiplier = 1.0 / ((box[2] % xscale) * yscale);
-            for (y = 0; y < box[3] / yscale; y++) {
-                int yy_from = box[1] + y*yscale;
+    switch (imIn->type) {
+        case IMAGING_TYPE_INT32:
+            if (box[2] % xscale) {
+                double multiplier = 1.0 / ((box[2] % xscale) * yscale);
+                for (y = 0; y < box[3] / yscale; y++) {
+                    int yy_from = box[1] + y * yscale;
+                    double ss = 0;
+                    x = box[2] / xscale;
+                    for (yy = yy_from; yy < yy_from + yscale; yy++) {
+                        INT32 *line = (INT32 *)imIn->image32[yy];
+                        for (xx = box[0] + x * xscale; xx < box[0] + box[2]; xx++) {
+                            ss += line[xx + 0];
+                        }
+                    }
+                    IMAGING_PIXEL_I(imOut, x, y) = ROUND_UP(ss * multiplier);
+                }
+            }
+            if (box[3] % yscale) {
+                double multiplier = 1.0 / (xscale * (box[3] % yscale));
+                y = box[3] / yscale;
+                for (x = 0; x < box[2] / xscale; x++) {
+                    int xx_from = box[0] + x * xscale;
+                    double ss = 0;
+                    for (yy = box[1] + y * yscale; yy < box[1] + box[3]; yy++) {
+                        INT32 *line = (INT32 *)imIn->image32[yy];
+                        for (xx = xx_from; xx < xx_from + xscale; xx++) {
+                            ss += line[xx + 0];
+                        }
+                    }
+                    IMAGING_PIXEL_I(imOut, x, y) = ROUND_UP(ss * multiplier);
+                }
+            }
+            if (box[2] % xscale && box[3] % yscale) {
+                double multiplier = 1.0 / ((box[2] % xscale) * (box[3] % yscale));
                 double ss = 0;
                 x = box[2] / xscale;
-                for (yy = yy_from; yy < yy_from + yscale; yy++) {
+                y = box[3] / yscale;
+                for (yy = box[1] + y * yscale; yy < box[1] + box[3]; yy++) {
                     INT32 *line = (INT32 *)imIn->image32[yy];
-                    for (xx = box[0] + x*xscale; xx < box[0] + box[2]; xx++) {
+                    for (xx = box[0] + x * xscale; xx < box[0] + box[2]; xx++) {
                         ss += line[xx + 0];
                     }
                 }
                 IMAGING_PIXEL_I(imOut, x, y) = ROUND_UP(ss * multiplier);
             }
-        }
-        if (box[3] % yscale) {
-            double multiplier = 1.0 / (xscale * (box[3] % yscale));
-            y = box[3] / yscale;
-            for (x = 0; x < box[2] / xscale; x++) {
-                int xx_from = box[0] + x*xscale;
-                double ss = 0;
-                for (yy = box[1] + y*yscale; yy < box[1] + box[3]; yy++) {
-                    INT32 *line = (INT32 *)imIn->image32[yy];
-                    for (xx = xx_from; xx < xx_from + xscale; xx++) {
-                        ss += line[xx + 0];
-                    }
-                }
-                IMAGING_PIXEL_I(imOut, x, y) = ROUND_UP(ss * multiplier);
-            }
-        }
-        if (box[2] % xscale && box[3] % yscale) {
-            double multiplier = 1.0 / ((box[2] % xscale) * (box[3] % yscale));
-            double ss = 0;
-            x = box[2] / xscale;
-            y = box[3] / yscale;
-            for (yy = box[1] + y*yscale; yy < box[1] + box[3]; yy++) {
-                INT32 *line = (INT32 *)imIn->image32[yy];
-                for (xx = box[0] + x*xscale; xx < box[0] + box[2]; xx++) {
-                    ss += line[xx + 0];
-                }
-            }
-            IMAGING_PIXEL_I(imOut, x, y) = ROUND_UP(ss * multiplier);
-        }
-        break;
-
-    case IMAGING_TYPE_FLOAT32:
-        if (box[2] % xscale) {
-            double multiplier = 1.0 / ((box[2] % xscale) * yscale);
-            for (y = 0; y < box[3] / yscale; y++) {
-                int yy_from = box[1] + y*yscale;
+            break;
+
+        case IMAGING_TYPE_FLOAT32:
+            if (box[2] % xscale) {
+                double multiplier = 1.0 / ((box[2] % xscale) * yscale);
+                for (y = 0; y < box[3] / yscale; y++) {
+                    int yy_from = box[1] + y * yscale;
+                    double ss = 0;
+                    x = box[2] / xscale;
+                    for (yy = yy_from; yy < yy_from + yscale; yy++) {
+                        FLOAT32 *line = (FLOAT32 *)imIn->image32[yy];
+                        for (xx = box[0] + x * xscale; xx < box[0] + box[2]; xx++) {
+                            ss += line[xx + 0];
+                        }
+                    }
+                    IMAGING_PIXEL_F(imOut, x, y) = ss * multiplier;
+                }
+            }
+            if (box[3] % yscale) {
+                double multiplier = 1.0 / (xscale * (box[3] % yscale));
+                y = box[3] / yscale;
+                for (x = 0; x < box[2] / xscale; x++) {
+                    int xx_from = box[0] + x * xscale;
+                    double ss = 0;
+                    for (yy = box[1] + y * yscale; yy < box[1] + box[3]; yy++) {
+                        FLOAT32 *line = (FLOAT32 *)imIn->image32[yy];
+                        for (xx = xx_from; xx < xx_from + xscale; xx++) {
+                            ss += line[xx + 0];
+                        }
+                    }
+                    IMAGING_PIXEL_F(imOut, x, y) = ss * multiplier;
+                }
+            }
+            if (box[2] % xscale && box[3] % yscale) {
+                double multiplier = 1.0 / ((box[2] % xscale) * (box[3] % yscale));
                 double ss = 0;
                 x = box[2] / xscale;
-                for (yy = yy_from; yy < yy_from + yscale; yy++) {
+                y = box[3] / yscale;
+                for (yy = box[1] + y * yscale; yy < box[1] + box[3]; yy++) {
                     FLOAT32 *line = (FLOAT32 *)imIn->image32[yy];
-                    for (xx = box[0] + x*xscale; xx < box[0] + box[2]; xx++) {
+                    for (xx = box[0] + x * xscale; xx < box[0] + box[2]; xx++) {
                         ss += line[xx + 0];
                     }
                 }
                 IMAGING_PIXEL_F(imOut, x, y) = ss * multiplier;
             }
-        }
-        if (box[3] % yscale) {
-            double multiplier = 1.0 / (xscale * (box[3] % yscale));
-            y = box[3] / yscale;
-            for (x = 0; x < box[2] / xscale; x++) {
-                int xx_from = box[0] + x*xscale;
-                double ss = 0;
-                for (yy = box[1] + y*yscale; yy < box[1] + box[3]; yy++) {
-                    FLOAT32 *line = (FLOAT32 *)imIn->image32[yy];
-                    for (xx = xx_from; xx < xx_from + xscale; xx++) {
-                        ss += line[xx + 0];
-                    }
-                }
-                IMAGING_PIXEL_F(imOut, x, y) = ss * multiplier;
-            }
-        }
-        if (box[2] % xscale && box[3] % yscale) {
-            double multiplier = 1.0 / ((box[2] % xscale) * (box[3] % yscale));
-            double ss = 0;
-            x = box[2] / xscale;
-            y = box[3] / yscale;
-            for (yy = box[1] + y*yscale; yy < box[1] + box[3]; yy++) {
-                FLOAT32 *line = (FLOAT32 *)imIn->image32[yy];
-                for (xx = box[0] + x*xscale; xx < box[0] + box[2]; xx++) {
-                    ss += line[xx + 0];
-                }
-            }
-            IMAGING_PIXEL_F(imOut, x, y) = ss * multiplier;
-        }
-        break;
-    }
-}
-
+            break;
+    }
+}

 Imaging
-ImagingReduce(Imaging imIn, int xscale, int yscale, int box[4])
-{
+ImagingReduce(Imaging imIn, int xscale, int yscale, int box[4]) {
     ImagingSectionCookie cookie;
     Imaging imOut = NULL;

     if (strcmp(imIn->mode, "P") == 0 || strcmp(imIn->mode, "1") == 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (imIn->type == IMAGING_TYPE_SPECIAL) {
-        return (Imaging) ImagingError_ModeError();
-    }
-
-    imOut = ImagingNewDirty(imIn->mode,
-                            (box[2] + xscale - 1) / xscale,
-                            (box[3] + yscale - 1) / yscale);
-    if ( ! imOut) {
+        return (Imaging)ImagingError_ModeError();
+    }
+
+    imOut = ImagingNewDirty(
+        imIn->mode, (box[2] + xscale - 1) / xscale, (box[3] + yscale - 1) / yscale);
+    if (!imOut) {
         return NULL;
     }

     ImagingSectionEnter(&cookie);

-    switch(imIn->type) {
-    case IMAGING_TYPE_UINT8:
-        if (xscale == 1) {
-            if (yscale == 2) {
-                ImagingReduce1x2(imOut, imIn, box);
-            } else if (yscale == 3) {
-                ImagingReduce1x3(imOut, imIn, box);
+    switch (imIn->type) {
+        case IMAGING_TYPE_UINT8:
+            if (xscale == 1) {
+                if (yscale == 2) {
+                    ImagingReduce1x2(imOut, imIn, box);
+                } else if (yscale == 3) {
+                    ImagingReduce1x3(imOut, imIn, box);
+                } else {
+                    ImagingReduce1xN(imOut, imIn, box, yscale);
+                }
+            } else if (yscale == 1) {
+                if (xscale == 2) {
+                    ImagingReduce2x1(imOut, imIn, box);
+                } else if (xscale == 3) {
+                    ImagingReduce3x1(imOut, imIn, box);
+                } else {
+                    ImagingReduceNx1(imOut, imIn, box, xscale);
+                }
+            } else if (xscale == yscale && xscale <= 5) {
+                if (xscale == 2) {
+                    ImagingReduce2x2(imOut, imIn, box);
+                } else if (xscale == 3) {
+                    ImagingReduce3x3(imOut, imIn, box);
+                } else if (xscale == 4) {
+                    ImagingReduce4x4(imOut, imIn, box);
+                } else {
+                    ImagingReduce5x5(imOut, imIn, box);
+                }
             } else {
-                ImagingReduce1xN(imOut, imIn, box, yscale);
-            }
-        } else if (yscale == 1) {
-            if (xscale == 2) {
-                ImagingReduce2x1(imOut, imIn, box);
-            } else if (xscale == 3) {
-                ImagingReduce3x1(imOut, imIn, box);
-            } else {
-                ImagingReduceNx1(imOut, imIn, box, xscale);
-            }
-        } else if (xscale == yscale && xscale <= 5) {
-            if (xscale == 2) {
-                ImagingReduce2x2(imOut, imIn, box);
-            } else if (xscale == 3) {
-                ImagingReduce3x3(imOut, imIn, box);
-            } else if (xscale == 4) {
-                ImagingReduce4x4(imOut, imIn, box);
-            } else {
-                ImagingReduce5x5(imOut, imIn, box);
-            }
-        } else {
-            ImagingReduceNxN(imOut, imIn, box, xscale, yscale);
-        }
-
-        ImagingReduceCorners(imOut, imIn, box, xscale, yscale);
-        break;
-
-    case IMAGING_TYPE_INT32:
-    case IMAGING_TYPE_FLOAT32:
-        ImagingReduceNxN_32bpc(imOut, imIn, box, xscale, yscale);
-
-        ImagingReduceCorners_32bpc(imOut, imIn, box, xscale, yscale);
-        break;
+                ImagingReduceNxN(imOut, imIn, box, xscale, yscale);
+            }
+
+            ImagingReduceCorners(imOut, imIn, box, xscale, yscale);
+            break;
+
+        case IMAGING_TYPE_INT32:
+        case IMAGING_TYPE_FLOAT32:
+            ImagingReduceNxN_32bpc(imOut, imIn, box, xscale, yscale);
+
+            ImagingReduceCorners_32bpc(imOut, imIn, box, xscale, yscale);
+            break;
     }

     ImagingSectionLeave(&cookie);
('src/libImaging', 'QuantHeap.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -25,10 +25,10 @@
 #include "QuantHeap.h"

 struct _Heap {
-   void **heap;
-   unsigned int heapsize;
-   unsigned int heapcount;
-   HeapCmpFunc cf;
+    void **heap;
+    unsigned int heapsize;
+    unsigned int heapcount;
+    HeapCmpFunc cf;
 };

 #define INITIAL_SIZE 256
@@ -36,127 +36,141 @@
 // #define DEBUG

 #ifdef DEBUG
-static int _heap_test(Heap *);
+static int
+_heap_test(Heap *);
 #endif

-void ImagingQuantHeapFree(Heap *h) {
-   free(h->heap);
-   free(h);
+void
+ImagingQuantHeapFree(Heap *h) {
+    free(h->heap);
+    free(h);
 }

-static int _heap_grow(Heap *h,unsigned int newsize) {
-   void *newheap;
-   if (!newsize) {
-       newsize=h->heapsize<<1;
-   }
-   if (newsize<h->heapsize) {
-       return 0;
-   }
-   if (newsize > INT_MAX / sizeof(void *)){
-       return 0;
-   }
-   /* malloc check ok, using calloc for overflow, also checking
-      above due to memcpy below*/
-   newheap=calloc(newsize, sizeof(void *));
-   if (!newheap) {
-       return 0;
-   }
-   memcpy(newheap,h->heap,sizeof(void *)*h->heapsize);
-   free(h->heap);
-   h->heap=newheap;
-   h->heapsize=newsize;
-   return 1;
+static int
+_heap_grow(Heap *h, unsigned int newsize) {
+    void *newheap;
+    if (!newsize) {
+        newsize = h->heapsize << 1;
+    }
+    if (newsize < h->heapsize) {
+        return 0;
+    }
+    if (newsize > INT_MAX / sizeof(void *)) {
+        return 0;
+    }
+    /* malloc check ok, using calloc for overflow, also checking
+       above due to memcpy below*/
+    newheap = calloc(newsize, sizeof(void *));
+    if (!newheap) {
+        return 0;
+    }
+    memcpy(newheap, h->heap, sizeof(void *) * h->heapsize);
+    free(h->heap);
+    h->heap = newheap;
+    h->heapsize = newsize;
+    return 1;
 }

 #ifdef DEBUG
-static int _heap_test(Heap *h) {
-   unsigned int k;
-   for (k=1;k*2<=h->heapcount;k++) {
-      if (h->cf(h,h->heap[k],h->heap[k*2])<0) {
-         printf ("heap is bad\n");
-         return 0;
-      }
-      if (k*2+1<=h->heapcount && h->cf(h,h->heap[k],h->heap[k*2+1])<0) {
-         printf ("heap is bad\n");
-         return 0;
-      }
-   }
-   return 1;
+static int
+_heap_test(Heap *h) {
+    unsigned int k;
+    for (k = 1; k * 2 <= h->heapcount; k++) {
+        if (h->cf(h, h->heap[k], h->heap[k * 2]) < 0) {
+            printf("heap is bad\n");
+            return 0;
+        }
+        if (k * 2 + 1 <= h->heapcount && h->cf(h, h->heap[k], h->heap[k * 2 + 1]) < 0) {
+            printf("heap is bad\n");
+            return 0;
+        }
+    }
+    return 1;
 }
 #endif

-int ImagingQuantHeapRemove(Heap* h,void **r) {
-   unsigned int k,l;
-   void *v;
+int
+ImagingQuantHeapRemove(Heap *h, void **r) {
+    unsigned int k, l;
+    void *v;

-   if (!h->heapcount) {
-      return 0;
-   }
-   *r=h->heap[1];
-   v=h->heap[h->heapcount--];
-   for (k=1;k*2<=h->heapcount;k=l) {
-      l=k*2;
-      if (l<h->heapcount) {
-         if (h->cf(h,h->heap[l],h->heap[l+1])<0) {
-            l++;
-         }
-      }
-      if (h->cf(h,v,h->heap[l])>0) {
-         break;
-      }
-      h->heap[k]=h->heap[l];
-   }
-   h->heap[k]=v;
+    if (!h->heapcount) {
+        return 0;
+    }
+    *r = h->heap[1];
+    v = h->heap[h->heapcount--];
+    for (k = 1; k * 2 <= h->heapcount; k = l) {
+        l = k * 2;
+        if (l < h->heapcount) {
+            if (h->cf(h, h->heap[l], h->heap[l + 1]) < 0) {
+                l++;
+            }
+        }
+        if (h->cf(h, v, h->heap[l]) > 0) {
+            break;
+        }
+        h->heap[k] = h->heap[l];
+    }
+    h->heap[k] = v;
 #ifdef DEBUG
-   if (!_heap_test(h)) { printf ("oops - heap_remove messed up the heap\n"); exit(1); }
+    if (!_heap_test(h)) {
+        printf("oops - heap_remove messed up the heap\n");
+        exit(1);
+    }
 #endif
-   return 1;
+    return 1;
 }

-int ImagingQuantHeapAdd(Heap *h,void *val) {
-   int k;
-   if (h->heapcount==h->heapsize-1) {
-      _heap_grow(h,0);
-   }
-   k=++h->heapcount;
-   while (k!=1) {
-      if (h->cf(h,val,h->heap[k/2])<=0) {
-         break;
-      }
-      h->heap[k]=h->heap[k/2];
-      k>>=1;
-   }
-   h->heap[k]=val;
+int
+ImagingQuantHeapAdd(Heap *h, void *val) {
+    int k;
+    if (h->heapcount == h->heapsize - 1) {
+        _heap_grow(h, 0);
+    }
+    k = ++h->heapcount;
+    while (k != 1) {
+        if (h->cf(h, val, h->heap[k / 2]) <= 0) {
+            break;
+        }
+        h->heap[k] = h->heap[k / 2];
+        k >>= 1;
+    }
+    h->heap[k] = val;
 #ifdef DEBUG
-   if (!_heap_test(h)) { printf ("oops - heap_add messed up the heap\n"); exit(1); }
+    if (!_heap_test(h)) {
+        printf("oops - heap_add messed up the heap\n");
+        exit(1);
+    }
 #endif
-   return 1;
+    return 1;
 }

-int ImagingQuantHeapTop(Heap *h,void **r) {
-   if (!h->heapcount) {
-      return 0;
-   }
-   *r=h->heap[1];
-   return 1;
+int
+ImagingQuantHeapTop(Heap *h, void **r) {
+    if (!h->heapcount) {
+        return 0;
+    }
+    *r = h->heap[1];
+    return 1;
 }

-Heap *ImagingQuantHeapNew(HeapCmpFunc cf) {
-   Heap *h;
+Heap *
+ImagingQuantHeapNew(HeapCmpFunc cf) {
+    Heap *h;

-   /* malloc check ok, small constant allocation */
-   h=malloc(sizeof(Heap));
-   if (!h) {
-       return NULL;
-   }
-   h->heapsize=INITIAL_SIZE;
-   /* malloc check ok, using calloc for overflow */
-   h->heap=calloc(h->heapsize, sizeof(void *));
-   if (!h->heap) {
-       free(h);
-       return NULL;
-   }
-   h->heapcount=0;
-   h->cf=cf;
-   return h;
+    /* malloc check ok, small constant allocation */
+    h = malloc(sizeof(Heap));
+    if (!h) {
+        return NULL;
+    }
+    h->heapsize = INITIAL_SIZE;
+    /* malloc check ok, using calloc for overflow */
+    h->heap = calloc(h->heapsize, sizeof(void *));
+    if (!h->heap) {
+        free(h);
+        return NULL;
+    }
+    h->heapcount = 0;
+    h->cf = cf;
+    return h;
 }
('src/libImaging', 'BoxBlur.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,37 +1,40 @@
 #include "Imaging.h"
-

 #define MAX(x, y) (((x) > (y)) ? (x) : (y))
 #define MIN(x, y) (((x) < (y)) ? (x) : (y))

-
 typedef UINT8 pixel[4];

-void static inline
-ImagingLineBoxBlur32(pixel *lineOut, pixel *lineIn, int lastx, int radius, int edgeA,
-    int edgeB, UINT32 ww, UINT32 fw)
-{
+void static inline ImagingLineBoxBlur32(
+    pixel *lineOut,
+    pixel *lineIn,
+    int lastx,
+    int radius,
+    int edgeA,
+    int edgeB,
+    UINT32 ww,
+    UINT32 fw) {
     int x;
     UINT32 acc[4];
     UINT32 bulk[4];

-    #define MOVE_ACC(acc, subtract, add) \
-        acc[0] += lineIn[add][0] - lineIn[subtract][0]; \
-        acc[1] += lineIn[add][1] - lineIn[subtract][1]; \
-        acc[2] += lineIn[add][2] - lineIn[subtract][2]; \
-        acc[3] += lineIn[add][3] - lineIn[subtract][3];
-
-    #define ADD_FAR(bulk, acc, left, right) \
-        bulk[0] = (acc[0] * ww) + (lineIn[left][0] + lineIn[right][0]) * fw; \
-        bulk[1] = (acc[1] * ww) + (lineIn[left][1] + lineIn[right][1]) * fw; \
-        bulk[2] = (acc[2] * ww) + (lineIn[left][2] + lineIn[right][2]) * fw; \
-        bulk[3] = (acc[3] * ww) + (lineIn[left][3] + lineIn[right][3]) * fw;
-
-    #define SAVE(x, bulk) \
-        lineOut[x][0] = (UINT8)((bulk[0] + (1 << 23)) >> 24); \
-        lineOut[x][1] = (UINT8)((bulk[1] + (1 << 23)) >> 24); \
-        lineOut[x][2] = (UINT8)((bulk[2] + (1 << 23)) >> 24); \
-        lineOut[x][3] = (UINT8)((bulk[3] + (1 << 23)) >> 24);
+#define MOVE_ACC(acc, subtract, add)                \
+    acc[0] += lineIn[add][0] - lineIn[subtract][0]; \
+    acc[1] += lineIn[add][1] - lineIn[subtract][1]; \
+    acc[2] += lineIn[add][2] - lineIn[subtract][2]; \
+    acc[3] += lineIn[add][3] - lineIn[subtract][3];
+
+#define ADD_FAR(bulk, acc, left, right)                                  \
+    bulk[0] = (acc[0] * ww) + (lineIn[left][0] + lineIn[right][0]) * fw; \
+    bulk[1] = (acc[1] * ww) + (lineIn[left][1] + lineIn[right][1]) * fw; \
+    bulk[2] = (acc[2] * ww) + (lineIn[left][2] + lineIn[right][2]) * fw; \
+    bulk[3] = (acc[3] * ww) + (lineIn[left][3] + lineIn[right][3]) * fw;
+
+#define SAVE(x, bulk)                                     \
+    lineOut[x][0] = (UINT8)((bulk[0] + (1 << 23)) >> 24); \
+    lineOut[x][1] = (UINT8)((bulk[1] + (1 << 23)) >> 24); \
+    lineOut[x][2] = (UINT8)((bulk[2] + (1 << 23)) >> 24); \
+    lineOut[x][3] = (UINT8)((bulk[3] + (1 << 23)) >> 24);

     /* Compute acc for -1 pixel (outside of image):
        From "-radius-1" to "-1" get first pixel,
@@ -53,8 +56,7 @@
     acc[2] += lineIn[lastx][2] * (radius - edgeA + 1);
     acc[3] += lineIn[lastx][3] * (radius - edgeA + 1);

-    if (edgeA <= edgeB)
-    {
+    if (edgeA <= edgeB) {
         /* Subtract pixel from left ("0").
            Add pixels from radius. */
         for (x = 0; x < edgeA; x++) {
@@ -76,9 +78,7 @@
             ADD_FAR(bulk, acc, x - radius - 1, lastx);
             SAVE(x, bulk);
         }
-    }
-    else
-    {
+    } else {
         for (x = 0; x < edgeB; x++) {
             MOVE_ACC(acc, 0, x + radius);
             ADD_FAR(bulk, acc, 0, x + radius + 1);
@@ -96,28 +96,30 @@
         }
     }

-    #undef MOVE_ACC
-    #undef ADD_FAR
-    #undef SAVE
-}
-
-
-void static inline
-ImagingLineBoxBlur8(UINT8 *lineOut, UINT8 *lineIn, int lastx, int radius, int edgeA,
-    int edgeB, UINT32 ww, UINT32 fw)
-{
+#undef MOVE_ACC
+#undef ADD_FAR
+#undef SAVE
+}
+
+void static inline ImagingLineBoxBlur8(
+    UINT8 *lineOut,
+    UINT8 *lineIn,
+    int lastx,
+    int radius,
+    int edgeA,
+    int edgeB,
+    UINT32 ww,
+    UINT32 fw) {
     int x;
     UINT32 acc;
     UINT32 bulk;

-    #define MOVE_ACC(acc, subtract, add) \
-        acc += lineIn[add] - lineIn[subtract];
-
-    #define ADD_FAR(bulk, acc, left, right) \
-        bulk = (acc * ww) + (lineIn[left] + lineIn[right]) * fw;
-
-    #define SAVE(x, bulk) \
-        lineOut[x] = (UINT8)((bulk + (1 << 23)) >> 24)
+#define MOVE_ACC(acc, subtract, add) acc += lineIn[add] - lineIn[subtract];
+
+#define ADD_FAR(bulk, acc, left, right) \
+    bulk = (acc * ww) + (lineIn[left] + lineIn[right]) * fw;
+
+#define SAVE(x, bulk) lineOut[x] = (UINT8)((bulk + (1 << 23)) >> 24)

     acc = lineIn[0] * (radius + 1);
     for (x = 0; x < edgeA - 1; x++) {
@@ -125,8 +127,7 @@
     }
     acc += lineIn[lastx] * (radius - edgeA + 1);

-    if (edgeA <= edgeB)
-    {
+    if (edgeA <= edgeB) {
         for (x = 0; x < edgeA; x++) {
             MOVE_ACC(acc, 0, x + radius);
             ADD_FAR(bulk, acc, 0, x + radius + 1);
@@ -142,9 +143,7 @@
             ADD_FAR(bulk, acc, x - radius - 1, lastx);
             SAVE(x, bulk);
         }
-    }
-    else
-    {
+    } else {
         for (x = 0; x < edgeB; x++) {
             MOVE_ACC(acc, 0, x + radius);
             ADD_FAR(bulk, acc, 0, x + radius + 1);
@@ -162,22 +161,19 @@
         }
     }

-    #undef MOVE_ACC
-    #undef ADD_FAR
-    #undef SAVE
-}
-
-
+#undef MOVE_ACC
+#undef ADD_FAR
+#undef SAVE
+}

 Imaging
-ImagingHorizontalBoxBlur(Imaging imOut, Imaging imIn, float floatRadius)
-{
+ImagingHorizontalBoxBlur(Imaging imOut, Imaging imIn, float floatRadius) {
     ImagingSectionCookie cookie;

     int y;

-    int radius = (int) floatRadius;
-    UINT32 ww = (UINT32) (1 << 24) / (floatRadius * 2 + 1);
+    int radius = (int)floatRadius;
+    UINT32 ww = (UINT32)(1 << 24) / (floatRadius * 2 + 1);
     UINT32 fw = ((1 << 24) - (radius * 2 + 1) * ww) / 2;

     int edgeA = MIN(radius + 1, imIn->xsize);
@@ -192,32 +188,33 @@

     ImagingSectionEnter(&cookie);

-    if (imIn->image8)
-    {
+    if (imIn->image8) {
         for (y = 0; y < imIn->ysize; y++) {
             ImagingLineBoxBlur8(
-                (imIn == imOut ? (UINT8 *) lineOut : imOut->image8[y]),
+                (imIn == imOut ? (UINT8 *)lineOut : imOut->image8[y]),
                 imIn->image8[y],
                 imIn->xsize - 1,
-                radius, edgeA, edgeB,
-                ww, fw
-            );
+                radius,
+                edgeA,
+                edgeB,
+                ww,
+                fw);
             if (imIn == imOut) {
                 // Commit.
                 memcpy(imOut->image8[y], lineOut, imIn->xsize);
             }
         }
-    }
-    else
-    {
+    } else {
         for (y = 0; y < imIn->ysize; y++) {
             ImagingLineBoxBlur32(
-                imIn == imOut ? (pixel *) lineOut : (pixel *) imOut->image32[y],
-                (pixel *) imIn->image32[y],
+                imIn == imOut ? (pixel *)lineOut : (pixel *)imOut->image32[y],
+                (pixel *)imIn->image32[y],
                 imIn->xsize - 1,
-                radius, edgeA, edgeB,
-                ww, fw
-            );
+                radius,
+                edgeA,
+                edgeB,
+                ww,
+                fw);
             if (imIn == imOut) {
                 // Commit.
                 memcpy(imOut->image32[y], lineOut, imIn->xsize * 4);
@@ -232,23 +229,17 @@
     return imOut;
 }

-
 Imaging
-ImagingBoxBlur(Imaging imOut, Imaging imIn, float radius, int n)
-{
+ImagingBoxBlur(Imaging imOut, Imaging imIn, float radius, int n) {
     int i;
     Imaging imTransposed;

     if (n < 1) {
-        return ImagingError_ValueError(
-            "number of passes must be greater than zero"
-        );
-    }
-
-    if (strcmp(imIn->mode, imOut->mode) ||
-        imIn->type  != imOut->type  ||
-        imIn->bands != imOut->bands ||
-        imIn->xsize != imOut->xsize ||
+        return ImagingError_ValueError("number of passes must be greater than zero");
+    }
+
+    if (strcmp(imIn->mode, imOut->mode) || imIn->type != imOut->type ||
+        imIn->bands != imOut->bands || imIn->xsize != imOut->xsize ||
         imIn->ysize != imOut->ysize) {
         return ImagingError_Mismatch();
     }
@@ -257,14 +248,10 @@
         return ImagingError_ModeError();
     }

-    if (!(strcmp(imIn->mode, "RGB") == 0 ||
-          strcmp(imIn->mode, "RGBA") == 0 ||
-          strcmp(imIn->mode, "RGBa") == 0 ||
-          strcmp(imIn->mode, "RGBX") == 0 ||
-          strcmp(imIn->mode, "CMYK") == 0 ||
-          strcmp(imIn->mode, "L") == 0 ||
-          strcmp(imIn->mode, "LA") == 0 ||
-          strcmp(imIn->mode, "La") == 0)) {
+    if (!(strcmp(imIn->mode, "RGB") == 0 || strcmp(imIn->mode, "RGBA") == 0 ||
+          strcmp(imIn->mode, "RGBa") == 0 || strcmp(imIn->mode, "RGBX") == 0 ||
+          strcmp(imIn->mode, "CMYK") == 0 || strcmp(imIn->mode, "L") == 0 ||
+          strcmp(imIn->mode, "LA") == 0 || strcmp(imIn->mode, "La") == 0)) {
         return ImagingError_ModeError();
     }

@@ -277,14 +264,14 @@
        Use imOut as a destination at first pass,
        then use imOut as a source too. */
     ImagingHorizontalBoxBlur(imOut, imIn, radius);
-    for (i = 1; i < n; i ++) {
+    for (i = 1; i < n; i++) {
         ImagingHorizontalBoxBlur(imOut, imOut, radius);
     }
     /* Transpose result for blur in another direction. */
     ImagingTranspose(imTransposed, imOut);

     /* Reuse imTransposed as a source and destination there. */
-    for (i = 0; i < n; i ++) {
+    for (i = 0; i < n; i++) {
         ImagingHorizontalBoxBlur(imTransposed, imTransposed, radius);
     }
     /* Restore original orientation. */
@@ -295,14 +282,12 @@
     return imOut;
 }

-
-Imaging ImagingGaussianBlur(Imaging imOut, Imaging imIn, float radius,
-    int passes)
-{
+Imaging
+ImagingGaussianBlur(Imaging imOut, Imaging imIn, float radius, int passes) {
     float sigma2, L, l, a;

     sigma2 = radius * radius / passes;
-    // from http://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf
+    // from https://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf
     // [7] Box length.
     L = sqrt(12.0 * sigma2 + 1.0);
     // [11] Integer part of box radius.
('src/libImaging', 'Gif.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -7,7 +7,6 @@
  * Copyright (c) Fredrik Lundh 1995-96.
  */

-
 /* Max size for a LZW code word. */

 #define GIFBITS     12
@@ -15,9 +14,7 @@
 #define GIFTABLE    (1<<GIFBITS)
 #define GIFBUFFER   (1<<GIFBITS)

-
 typedef struct {
-
     /* CONFIGURATION */

     /* Initial number of bits. The caller should clear all fields in
@@ -32,6 +29,9 @@
      * 4th pass: start at line 1, lines are 1 pixels high, step 2 pixels
      */
     int interlace;
+
+    /* The transparent palette index, or -1 for no transparency */
+    int transparency;

     /* PRIVATE CONTEXT (set by decoder) */

@@ -65,15 +65,10 @@

 } GIFDECODERSTATE;

-typedef struct GIFENCODERBLOCK_T
-{
-    struct GIFENCODERBLOCK_T *next;
-    int size;
-    UINT8 data[255];
-} GIFENCODERBLOCK;
+/* For GIF LZW encoder. */
+#define TABLE_SIZE  8192

 typedef struct {
-
     /* CONFIGURATION */

     /* Initial number of bits. The caller should clear all fields in
@@ -89,21 +84,17 @@
     /* PRIVATE CONTEXT (set by encoder) */

     /* Interlace parameters */
-    int step, repeat;
+    int step;

-    /* Output bit buffer */
-    INT32 bitbuffer;
-    int bitcount;
-
-    /* Output buffer list (linked list) */
-    GIFENCODERBLOCK* block; /* current block */
-    GIFENCODERBLOCK* flush; /* output queue */
-    GIFENCODERBLOCK* free; /* if not null, use this */
-
-    /* Fields used for run-length encoding */
-    int first; /* true if we haven't read the first pixel */
-    int last; /* last byte value seen */
-    int count; /* how many bytes with that value we've seen */
-    int lastcode;
+    /* For GIF LZW encoder. */
+    UINT32 put_state;
+    UINT32 entry_state;
+    UINT32 clear_code, end_code, next_code, max_code;
+    UINT32 code_width, code_bits_left, buf_bits_left;
+    UINT32 code_buffer;
+    UINT32 head, tail;
+    int probe;
+    UINT32 code;
+    UINT32 codes[TABLE_SIZE];

 } GIFENCODERSTATE;
('src/libImaging', 'Unpack.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -46,20 +46,28 @@

 /* byte-swapping macros */

-#define C16N\
-        (tmp[0]=in[0], tmp[1]=in[1]);
-#define C16S\
-        (tmp[1]=in[0], tmp[0]=in[1]);
-#define C32N\
-        (tmp[0]=in[0], tmp[1]=in[1], tmp[2]=in[2], tmp[3]=in[3]);
-#define C32S\
-        (tmp[3]=in[0], tmp[2]=in[1], tmp[1]=in[2], tmp[0]=in[3]);
-#define C64N\
-        (tmp[0]=in[0], tmp[1]=in[1], tmp[2]=in[2], tmp[3]=in[3],\
-         tmp[4]=in[4], tmp[5]=in[5], tmp[6]=in[6], tmp[7]=in[7]);
-#define C64S\
-        (tmp[7]=in[0], tmp[6]=in[1], tmp[5]=in[2], tmp[4]=in[3],\
-         tmp[3]=in[4], tmp[2]=in[5], tmp[1]=in[6], tmp[0]=in[7]);
+#define C16N (tmp[0] = in[0], tmp[1] = in[1]);
+#define C16S (tmp[1] = in[0], tmp[0] = in[1]);
+#define C32N (tmp[0] = in[0], tmp[1] = in[1], tmp[2] = in[2], tmp[3] = in[3]);
+#define C32S (tmp[3] = in[0], tmp[2] = in[1], tmp[1] = in[2], tmp[0] = in[3]);
+#define C64N         \
+    (tmp[0] = in[0], \
+     tmp[1] = in[1], \
+     tmp[2] = in[2], \
+     tmp[3] = in[3], \
+     tmp[4] = in[4], \
+     tmp[5] = in[5], \
+     tmp[6] = in[6], \
+     tmp[7] = in[7]);
+#define C64S         \
+    (tmp[7] = in[0], \
+     tmp[6] = in[1], \
+     tmp[5] = in[2], \
+     tmp[4] = in[3], \
+     tmp[3] = in[4], \
+     tmp[2] = in[5], \
+     tmp[1] = in[6], \
+     tmp[0] = in[7]);

 #ifdef WORDS_BIGENDIAN
 #define C16B C16N
@@ -80,111 +88,163 @@
 /* bit-swapping */

 static UINT8 BITFLIP[] = {
-    0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112,
-    240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184,
-    120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52,
-    180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220,
-    60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82,
-    210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154,
-    90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22,
-    150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238,
-    30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97,
-    225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169,
-    105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37,
-    165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205,
-    45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67,
-    195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139,
-    75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7,
-    135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
-    15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127,
-    255
-};
+    0,  128, 64, 192, 32, 160, 96,  224, 16, 144, 80, 208, 48, 176, 112, 240,
+    8,  136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248,
+    4,  132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244,
+    12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252,
+    2,  130, 66, 194, 34, 162, 98,  226, 18, 146, 82, 210, 50, 178, 114, 242,
+    10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250,
+    6,  134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246,
+    14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254,
+    1,  129, 65, 193, 33, 161, 97,  225, 17, 145, 81, 209, 49, 177, 113, 241,
+    9,  137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249,
+    5,  133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245,
+    13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253,
+    3,  131, 67, 195, 35, 163, 99,  227, 19, 147, 83, 211, 51, 179, 115, 243,
+    11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251,
+    7,  135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
+    15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255};

 /* Unpack to "1" image */

 static void
-unpack1(UINT8* out, const UINT8* in, int pixels)
-{
+unpack1(UINT8 *out, const UINT8 *in, int pixels) {
     /* bits (msb first, white is non-zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = (byte & 128) ? 255 : 0; byte <<= 1;
-        case 7:     *out++ = (byte & 128) ? 255 : 0; byte <<= 1;
-        case 6:     *out++ = (byte & 128) ? 255 : 0; byte <<= 1;
-        case 5:     *out++ = (byte & 128) ? 255 : 0; byte <<= 1;
-        case 4:     *out++ = (byte & 128) ? 255 : 0; byte <<= 1;
-        case 3:     *out++ = (byte & 128) ? 255 : 0; byte <<= 1;
-        case 2:     *out++ = (byte & 128) ? 255 : 0; byte <<= 1;
-        case 1:     *out++ = (byte & 128) ? 255 : 0;
+            default:
+                *out++ = (byte & 128) ? 255 : 0;
+                byte <<= 1;
+            case 7:
+                *out++ = (byte & 128) ? 255 : 0;
+                byte <<= 1;
+            case 6:
+                *out++ = (byte & 128) ? 255 : 0;
+                byte <<= 1;
+            case 5:
+                *out++ = (byte & 128) ? 255 : 0;
+                byte <<= 1;
+            case 4:
+                *out++ = (byte & 128) ? 255 : 0;
+                byte <<= 1;
+            case 3:
+                *out++ = (byte & 128) ? 255 : 0;
+                byte <<= 1;
+            case 2:
+                *out++ = (byte & 128) ? 255 : 0;
+                byte <<= 1;
+            case 1:
+                *out++ = (byte & 128) ? 255 : 0;
         }
         pixels -= 8;
     }
 }

 static void
-unpack1I(UINT8* out, const UINT8* in, int pixels)
-{
+unpack1I(UINT8 *out, const UINT8 *in, int pixels) {
     /* bits (msb first, white is zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = (byte & 128) ? 0 : 255; byte <<= 1;
-        case 7:     *out++ = (byte & 128) ? 0 : 255; byte <<= 1;
-        case 6:     *out++ = (byte & 128) ? 0 : 255; byte <<= 1;
-        case 5:     *out++ = (byte & 128) ? 0 : 255; byte <<= 1;
-        case 4:     *out++ = (byte & 128) ? 0 : 255; byte <<= 1;
-        case 3:     *out++ = (byte & 128) ? 0 : 255; byte <<= 1;
-        case 2:     *out++ = (byte & 128) ? 0 : 255; byte <<= 1;
-        case 1:     *out++ = (byte & 128) ? 0 : 255;
+            default:
+                *out++ = (byte & 128) ? 0 : 255;
+                byte <<= 1;
+            case 7:
+                *out++ = (byte & 128) ? 0 : 255;
+                byte <<= 1;
+            case 6:
+                *out++ = (byte & 128) ? 0 : 255;
+                byte <<= 1;
+            case 5:
+                *out++ = (byte & 128) ? 0 : 255;
+                byte <<= 1;
+            case 4:
+                *out++ = (byte & 128) ? 0 : 255;
+                byte <<= 1;
+            case 3:
+                *out++ = (byte & 128) ? 0 : 255;
+                byte <<= 1;
+            case 2:
+                *out++ = (byte & 128) ? 0 : 255;
+                byte <<= 1;
+            case 1:
+                *out++ = (byte & 128) ? 0 : 255;
         }
         pixels -= 8;
     }
 }

 static void
-unpack1R(UINT8* out, const UINT8* in, int pixels)
-{
+unpack1R(UINT8 *out, const UINT8 *in, int pixels) {
     /* bits (lsb first, white is non-zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = (byte & 1) ? 255 : 0; byte >>= 1;
-        case 7:     *out++ = (byte & 1) ? 255 : 0; byte >>= 1;
-        case 6:     *out++ = (byte & 1) ? 255 : 0; byte >>= 1;
-        case 5:     *out++ = (byte & 1) ? 255 : 0; byte >>= 1;
-        case 4:     *out++ = (byte & 1) ? 255 : 0; byte >>= 1;
-        case 3:     *out++ = (byte & 1) ? 255 : 0; byte >>= 1;
-        case 2:     *out++ = (byte & 1) ? 255 : 0; byte >>= 1;
-        case 1:     *out++ = (byte & 1) ? 255 : 0;
+            default:
+                *out++ = (byte & 1) ? 255 : 0;
+                byte >>= 1;
+            case 7:
+                *out++ = (byte & 1) ? 255 : 0;
+                byte >>= 1;
+            case 6:
+                *out++ = (byte & 1) ? 255 : 0;
+                byte >>= 1;
+            case 5:
+                *out++ = (byte & 1) ? 255 : 0;
+                byte >>= 1;
+            case 4:
+                *out++ = (byte & 1) ? 255 : 0;
+                byte >>= 1;
+            case 3:
+                *out++ = (byte & 1) ? 255 : 0;
+                byte >>= 1;
+            case 2:
+                *out++ = (byte & 1) ? 255 : 0;
+                byte >>= 1;
+            case 1:
+                *out++ = (byte & 1) ? 255 : 0;
         }
         pixels -= 8;
     }
 }

 static void
-unpack1IR(UINT8* out, const UINT8* in, int pixels)
-{
+unpack1IR(UINT8 *out, const UINT8 *in, int pixels) {
     /* bits (lsb first, white is zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = (byte & 1) ? 0 : 255; byte >>= 1;
-        case 7:     *out++ = (byte & 1) ? 0 : 255; byte >>= 1;
-        case 6:     *out++ = (byte & 1) ? 0 : 255; byte >>= 1;
-        case 5:     *out++ = (byte & 1) ? 0 : 255; byte >>= 1;
-        case 4:     *out++ = (byte & 1) ? 0 : 255; byte >>= 1;
-        case 3:     *out++ = (byte & 1) ? 0 : 255; byte >>= 1;
-        case 2:     *out++ = (byte & 1) ? 0 : 255; byte >>= 1;
-        case 1:     *out++ = (byte & 1) ? 0 : 255;
+            default:
+                *out++ = (byte & 1) ? 0 : 255;
+                byte >>= 1;
+            case 7:
+                *out++ = (byte & 1) ? 0 : 255;
+                byte >>= 1;
+            case 6:
+                *out++ = (byte & 1) ? 0 : 255;
+                byte >>= 1;
+            case 5:
+                *out++ = (byte & 1) ? 0 : 255;
+                byte >>= 1;
+            case 4:
+                *out++ = (byte & 1) ? 0 : 255;
+                byte >>= 1;
+            case 3:
+                *out++ = (byte & 1) ? 0 : 255;
+                byte >>= 1;
+            case 2:
+                *out++ = (byte & 1) ? 0 : 255;
+                byte >>= 1;
+            case 1:
+                *out++ = (byte & 1) ? 0 : 255;
         }
         pixels -= 8;
     }
 }

 static void
-unpack18(UINT8* out, const UINT8* in, int pixels)
-{
+unpack18(UINT8 *out, const UINT8 *in, int pixels) {
     /* Unpack a '|b1' image, which is a numpy boolean.
        1 == true, 0==false, in bytes */

@@ -194,160 +254,188 @@
     }
 }

-
-
 /* Unpack to "L" image */

 static void
-unpackL2(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL2(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles (msb first, white is non-zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = ((byte >> 6) & 0x03U) * 0x55U; byte <<= 2;
-        case 3:     *out++ = ((byte >> 6) & 0x03U) * 0x55U; byte <<= 2;
-        case 2:     *out++ = ((byte >> 6) & 0x03U) * 0x55U; byte <<= 2;
-        case 1:     *out++ = ((byte >> 6) & 0x03U) * 0x55U;
+            default:
+                *out++ = ((byte >> 6) & 0x03U) * 0x55U;
+                byte <<= 2;
+            case 3:
+                *out++ = ((byte >> 6) & 0x03U) * 0x55U;
+                byte <<= 2;
+            case 2:
+                *out++ = ((byte >> 6) & 0x03U) * 0x55U;
+                byte <<= 2;
+            case 1:
+                *out++ = ((byte >> 6) & 0x03U) * 0x55U;
         }
         pixels -= 4;
     }
 }

 static void
-unpackL2I(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL2I(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles (msb first, white is zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U); byte <<= 2;
-        case 3:     *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U); byte <<= 2;
-        case 2:     *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U); byte <<= 2;
-        case 1:     *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
+            default:
+                *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
+                byte <<= 2;
+            case 3:
+                *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
+                byte <<= 2;
+            case 2:
+                *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
+                byte <<= 2;
+            case 1:
+                *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
         }
         pixels -= 4;
     }
 }

 static void
-unpackL2R(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL2R(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles (bit order reversed, white is non-zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         byte = BITFLIP[byte];
         switch (pixels) {
-        default:    *out++ = ((byte >> 6) & 0x03U) * 0x55U; byte <<= 2;
-        case 3:     *out++ = ((byte >> 6) & 0x03U) * 0x55U; byte <<= 2;
-        case 2:     *out++ = ((byte >> 6) & 0x03U) * 0x55U; byte <<= 2;
-        case 1:     *out++ = ((byte >> 6) & 0x03U) * 0x55U;
+            default:
+                *out++ = ((byte >> 6) & 0x03U) * 0x55U;
+                byte <<= 2;
+            case 3:
+                *out++ = ((byte >> 6) & 0x03U) * 0x55U;
+                byte <<= 2;
+            case 2:
+                *out++ = ((byte >> 6) & 0x03U) * 0x55U;
+                byte <<= 2;
+            case 1:
+                *out++ = ((byte >> 6) & 0x03U) * 0x55U;
         }
         pixels -= 4;
     }
 }

 static void
-unpackL2IR(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL2IR(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles (bit order reversed, white is zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         byte = BITFLIP[byte];
         switch (pixels) {
-        default:    *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U); byte <<= 2;
-        case 3:     *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U); byte <<= 2;
-        case 2:     *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U); byte <<= 2;
-        case 1:     *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
+            default:
+                *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
+                byte <<= 2;
+            case 3:
+                *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
+                byte <<= 2;
+            case 2:
+                *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
+                byte <<= 2;
+            case 1:
+                *out++ = 0xFFU - (UINT8)(((byte >> 6) & 0x03U) * 0x55U);
         }
         pixels -= 4;
     }
 }

 static void
-unpackL4(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL4(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles (msb first, white is non-zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = ((byte >> 4) & 0x0FU) * 0x11U; byte <<= 4;
-        case 1:     *out++ = ((byte >> 4) & 0x0FU) * 0x11U;
+            default:
+                *out++ = ((byte >> 4) & 0x0FU) * 0x11U;
+                byte <<= 4;
+            case 1:
+                *out++ = ((byte >> 4) & 0x0FU) * 0x11U;
         }
         pixels -= 2;
     }
 }

 static void
-unpackL4I(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL4I(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles (msb first, white is zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = 0xFFU - (UINT8)(((byte >> 4) & 0x0FU) * 0x11U); byte <<= 4;
-        case 1:     *out++ = 0xFFU - (UINT8)(((byte >> 4) & 0x0FU) * 0x11U);
+            default:
+                *out++ = 0xFFU - (UINT8)(((byte >> 4) & 0x0FU) * 0x11U);
+                byte <<= 4;
+            case 1:
+                *out++ = 0xFFU - (UINT8)(((byte >> 4) & 0x0FU) * 0x11U);
         }
         pixels -= 2;
     }
 }

 static void
-unpackL4R(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL4R(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles (bit order reversed, white is non-zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         byte = BITFLIP[byte];
         switch (pixels) {
-        default:    *out++ = ((byte >> 4) & 0x0FU) * 0x11U; byte <<= 4;
-        case 1:     *out++ = ((byte >> 4) & 0x0FU) * 0x11U;
+            default:
+                *out++ = ((byte >> 4) & 0x0FU) * 0x11U;
+                byte <<= 4;
+            case 1:
+                *out++ = ((byte >> 4) & 0x0FU) * 0x11U;
         }
         pixels -= 2;
     }
 }

 static void
-unpackL4IR(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL4IR(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles (bit order reversed, white is zero) */
     while (pixels > 0) {
         UINT8 byte = *in++;
         byte = BITFLIP[byte];
         switch (pixels) {
-        default:    *out++ = 0xFFU - (UINT8)(((byte >> 4) & 0x0FU) * 0x11U); byte <<= 4;
-        case 1:     *out++ = 0xFFU - (UINT8)(((byte >> 4) & 0x0FU) * 0x11U);
+            default:
+                *out++ = 0xFFU - (UINT8)(((byte >> 4) & 0x0FU) * 0x11U);
+                byte <<= 4;
+            case 1:
+                *out++ = 0xFFU - (UINT8)(((byte >> 4) & 0x0FU) * 0x11U);
         }
         pixels -= 2;
     }
 }

 static void
-unpackLA(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackLA(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* LA, pixel interleaved */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[0], in[0], in[0], in[1]);
         memcpy(_out, &iv, sizeof(iv));
-        in += 2; _out += 4;
-    }
-}
-
-static void
-unpackLAL(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 2;
+        _out += 4;
+    }
+}
+
+static void
+unpackLAL(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* LA, line interleaved */
-    for (i = 0; i < pixels; i++, _out+=4) {
-        UINT32 iv = MAKE_UINT32(in[i], in[i], in[i], in[i+pixels]);
-        memcpy(_out, &iv, sizeof(iv));
-    }
-}
-
-static void
-unpackLI(UINT8* out, const UINT8* in, int pixels)
-{
+    for (i = 0; i < pixels; i++, _out += 4) {
+        UINT32 iv = MAKE_UINT32(in[i], in[i], in[i], in[i + pixels]);
+        memcpy(_out, &iv, sizeof(iv));
+    }
+}
+
+static void
+unpackLI(UINT8 *out, const UINT8 *in, int pixels) {
     /* negative */
     int i;
     for (i = 0; i < pixels; i++) {
@@ -356,8 +444,7 @@
 }

 static void
-unpackLR(UINT8* out, const UINT8* in, int pixels)
-{
+unpackLR(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, bit reversed */
     for (i = 0; i < pixels; i++) {
@@ -366,8 +453,7 @@
 }

 static void
-unpackL16(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL16(UINT8 *out, const UINT8 *in, int pixels) {
     /* int16 (upper byte, little endian) */
     int i;
     for (i = 0; i < pixels; i++) {
@@ -377,8 +463,7 @@
 }

 static void
-unpackL16B(UINT8* out, const UINT8* in, int pixels)
-{
+unpackL16B(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* int16 (upper byte, big endian) */
     for (i = 0; i < pixels; i++) {
@@ -387,66 +472,86 @@
     }
 }

-
 /* Unpack to "P" image */

 static void
-unpackP1(UINT8* out, const UINT8* in, int pixels)
-{
+unpackP1(UINT8 *out, const UINT8 *in, int pixels) {
     /* bits */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = (byte >> 7) & 1; byte <<= 1;
-        case 7:     *out++ = (byte >> 7) & 1; byte <<= 1;
-        case 6:     *out++ = (byte >> 7) & 1; byte <<= 1;
-        case 5:     *out++ = (byte >> 7) & 1; byte <<= 1;
-        case 4:     *out++ = (byte >> 7) & 1; byte <<= 1;
-        case 3:     *out++ = (byte >> 7) & 1; byte <<= 1;
-        case 2:     *out++ = (byte >> 7) & 1; byte <<= 1;
-        case 1:     *out++ = (byte >> 7) & 1;
+            default:
+                *out++ = (byte >> 7) & 1;
+                byte <<= 1;
+            case 7:
+                *out++ = (byte >> 7) & 1;
+                byte <<= 1;
+            case 6:
+                *out++ = (byte >> 7) & 1;
+                byte <<= 1;
+            case 5:
+                *out++ = (byte >> 7) & 1;
+                byte <<= 1;
+            case 4:
+                *out++ = (byte >> 7) & 1;
+                byte <<= 1;
+            case 3:
+                *out++ = (byte >> 7) & 1;
+                byte <<= 1;
+            case 2:
+                *out++ = (byte >> 7) & 1;
+                byte <<= 1;
+            case 1:
+                *out++ = (byte >> 7) & 1;
         }
         pixels -= 8;
     }
 }

 static void
-unpackP2(UINT8* out, const UINT8* in, int pixels)
-{
+unpackP2(UINT8 *out, const UINT8 *in, int pixels) {
     /* bit pairs */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = (byte >> 6) & 3; byte <<= 2;
-        case 3:     *out++ = (byte >> 6) & 3; byte <<= 2;
-        case 2:     *out++ = (byte >> 6) & 3; byte <<= 2;
-        case 1:     *out++ = (byte >> 6) & 3;
+            default:
+                *out++ = (byte >> 6) & 3;
+                byte <<= 2;
+            case 3:
+                *out++ = (byte >> 6) & 3;
+                byte <<= 2;
+            case 2:
+                *out++ = (byte >> 6) & 3;
+                byte <<= 2;
+            case 1:
+                *out++ = (byte >> 6) & 3;
         }
         pixels -= 4;
     }
 }

 static void
-unpackP4(UINT8* out, const UINT8* in, int pixels)
-{
+unpackP4(UINT8 *out, const UINT8 *in, int pixels) {
     /* nibbles */
     while (pixels > 0) {
         UINT8 byte = *in++;
         switch (pixels) {
-        default:    *out++ = (byte >> 4) & 15; byte <<= 4;
-        case 1:     *out++ = (byte >> 4) & 15;
+            default:
+                *out++ = (byte >> 4) & 15;
+                byte <<= 4;
+            case 1:
+                *out++ = (byte >> 4) & 15;
         }
         pixels -= 2;
     }
 }

 static void
-unpackP2L(UINT8* out, const UINT8* in, int pixels)
-{
+unpackP2L(UINT8 *out, const UINT8 *in, int pixels) {
     int i, j, m, s;
     /* bit layers */
     m = 128;
-    s = (pixels+7)/8;
+    s = (pixels + 7) / 8;
     for (i = j = 0; i < pixels; i++) {
         out[i] = ((in[j] & m) ? 1 : 0) + ((in[j + s] & m) ? 2 : 0);
         if ((m >>= 1) == 0) {
@@ -457,15 +562,14 @@
 }

 static void
-unpackP4L(UINT8* out, const UINT8* in, int pixels)
-{
+unpackP4L(UINT8 *out, const UINT8 *in, int pixels) {
     int i, j, m, s;
     /* bit layers (trust the optimizer ;-) */
     m = 128;
-    s = (pixels+7)/8;
+    s = (pixels + 7) / 8;
     for (i = j = 0; i < pixels; i++) {
         out[i] = ((in[j] & m) ? 1 : 0) + ((in[j + s] & m) ? 2 : 0) +
-                 ((in[j + 2*s] & m) ? 4 : 0) + ((in[j + 3*s] & m) ? 8 : 0);
+                 ((in[j + 2 * s] & m) ? 4 : 0) + ((in[j + 3 * s] & m) ? 8 : 0);
         if ((m >>= 1) == 0) {
             m = 128;
             j++;
@@ -473,403 +577,410 @@
     }
 }

-
 /* Unpack to "RGB" image */

 void
-ImagingUnpackRGB(UINT8* _out, const UINT8* in, int pixels)
-{
+ImagingUnpackRGB(UINT8 *_out, const UINT8 *in, int pixels) {
     int i = 0;
     /* RGB triplets */
-    for (; i < pixels-1; i++) {
+    for (; i < pixels - 1; i++) {
         UINT32 iv;
         memcpy(&iv, in, sizeof(iv));
         iv |= MASK_UINT32_CHANNEL_3;
         memcpy(_out, &iv, sizeof(iv));
-        in += 3; _out += 4;
+        in += 3;
+        _out += 4;
     }
     for (; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[0], in[1], in[2], 255);
         memcpy(_out, &iv, sizeof(iv));
-        in += 3; _out += 4;
+        in += 3;
+        _out += 4;
     }
 }

 void
-unpackRGB16L(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackRGB16L(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* 16-bit RGB triplets, little-endian order */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[1], in[3], in[5], 255);
         memcpy(_out, &iv, sizeof(iv));
-        in += 6; _out += 4;
+        in += 6;
+        _out += 4;
     }
 }

 void
-unpackRGB16B(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackRGB16B(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* 16-bit RGB triplets, big-endian order */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[0], in[2], in[4], 255);
         memcpy(_out, &iv, sizeof(iv));
-        in += 6; _out += 4;
-    }
-}
-
-static void
-unpackRGBL(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 6;
+        _out += 4;
+    }
+}
+
+static void
+unpackRGBL(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, line interleaved */
-    for (i = 0; i < pixels; i++, _out+=4) {
-        UINT32 iv = MAKE_UINT32(in[i], in[i+pixels], in[i+pixels+pixels], 255);
-        memcpy(_out, &iv, sizeof(iv));
-    }
-}
-
-static void
-unpackRGBR(UINT8* _out, const UINT8* in, int pixels)
-{
+    for (i = 0; i < pixels; i++, _out += 4) {
+        UINT32 iv = MAKE_UINT32(in[i], in[i + pixels], in[i + pixels + pixels], 255);
+        memcpy(_out, &iv, sizeof(iv));
+    }
+}
+
+static void
+unpackRGBR(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, bit reversed */
     for (i = 0; i < pixels; i++) {
-        UINT32 iv = MAKE_UINT32(BITFLIP[in[0]], BITFLIP[in[1]],
-                                BITFLIP[in[2]], 255);
-        memcpy(_out, &iv, sizeof(iv));
-        in += 3; _out += 4;
+        UINT32 iv = MAKE_UINT32(BITFLIP[in[0]], BITFLIP[in[1]], BITFLIP[in[2]], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 3;
+        _out += 4;
     }
 }

 void
-ImagingUnpackBGR(UINT8* _out, const UINT8* in, int pixels)
-{
+ImagingUnpackBGR(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, reversed bytes */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[2], in[1], in[0], 255);
         memcpy(_out, &iv, sizeof(iv));
-        in += 3; _out += 4;
+        in += 3;
+        _out += 4;
     }
 }

 void
-ImagingUnpackRGB15(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackRGB15(UINT8 *out, const UINT8 *in, int pixels) {
     int i, pixel;
     /* RGB, 5 bits per pixel */
     for (i = 0; i < pixels; i++) {
         pixel = in[0] + (in[1] << 8);
         out[R] = (pixel & 31) * 255 / 31;
-        out[G] = ((pixel>>5) & 31) * 255 / 31;
-        out[B] = ((pixel>>10) & 31) * 255 / 31;
+        out[G] = ((pixel >> 5) & 31) * 255 / 31;
+        out[B] = ((pixel >> 10) & 31) * 255 / 31;
         out[A] = 255;
-        out += 4; in += 2;
+        out += 4;
+        in += 2;
     }
 }

 void
-ImagingUnpackRGBA15(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackRGBA15(UINT8 *out, const UINT8 *in, int pixels) {
     int i, pixel;
     /* RGB, 5/5/5/1 bits per pixel */
     for (i = 0; i < pixels; i++) {
         pixel = in[0] + (in[1] << 8);
         out[R] = (pixel & 31) * 255 / 31;
-        out[G] = ((pixel>>5) & 31) * 255 / 31;
-        out[B] = ((pixel>>10) & 31) * 255 / 31;
-        out[A] = (pixel>>15) * 255;
-        out += 4; in += 2;
+        out[G] = ((pixel >> 5) & 31) * 255 / 31;
+        out[B] = ((pixel >> 10) & 31) * 255 / 31;
+        out[A] = (pixel >> 15) * 255;
+        out += 4;
+        in += 2;
     }
 }

 void
-ImagingUnpackBGR15(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackBGR15(UINT8 *out, const UINT8 *in, int pixels) {
     int i, pixel;
     /* RGB, reversed bytes, 5 bits per pixel */
     for (i = 0; i < pixels; i++) {
         pixel = in[0] + (in[1] << 8);
         out[B] = (pixel & 31) * 255 / 31;
-        out[G] = ((pixel>>5) & 31) * 255 / 31;
-        out[R] = ((pixel>>10) & 31) * 255 / 31;
+        out[G] = ((pixel >> 5) & 31) * 255 / 31;
+        out[R] = ((pixel >> 10) & 31) * 255 / 31;
         out[A] = 255;
-        out += 4; in += 2;
+        out += 4;
+        in += 2;
     }
 }

 void
-ImagingUnpackBGRA15(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackBGRA15(UINT8 *out, const UINT8 *in, int pixels) {
     int i, pixel;
     /* RGB, reversed bytes, 5/5/5/1 bits per pixel */
     for (i = 0; i < pixels; i++) {
         pixel = in[0] + (in[1] << 8);
         out[B] = (pixel & 31) * 255 / 31;
-        out[G] = ((pixel>>5) & 31) * 255 / 31;
-        out[R] = ((pixel>>10) & 31) * 255 / 31;
-        out[A] = (pixel>>15) * 255;
-        out += 4; in += 2;
+        out[G] = ((pixel >> 5) & 31) * 255 / 31;
+        out[R] = ((pixel >> 10) & 31) * 255 / 31;
+        out[A] = (pixel >> 15) * 255;
+        out += 4;
+        in += 2;
     }
 }

 void
-ImagingUnpackRGB16(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackRGB16(UINT8 *out, const UINT8 *in, int pixels) {
     int i, pixel;
     /* RGB, 5/6/5 bits per pixel */
     for (i = 0; i < pixels; i++) {
         pixel = in[0] + (in[1] << 8);
         out[R] = (pixel & 31) * 255 / 31;
-        out[G] = ((pixel>>5) & 63) * 255 / 63;
-        out[B] = ((pixel>>11) & 31) * 255 / 31;
+        out[G] = ((pixel >> 5) & 63) * 255 / 63;
+        out[B] = ((pixel >> 11) & 31) * 255 / 31;
         out[A] = 255;
-        out += 4; in += 2;
+        out += 4;
+        in += 2;
     }
 }

 void
-ImagingUnpackBGR16(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackBGR16(UINT8 *out, const UINT8 *in, int pixels) {
     int i, pixel;
     /* RGB, reversed bytes, 5/6/5 bits per pixel */
     for (i = 0; i < pixels; i++) {
         pixel = in[0] + (in[1] << 8);
         out[B] = (pixel & 31) * 255 / 31;
-        out[G] = ((pixel>>5) & 63) * 255 / 63;
-        out[R] = ((pixel>>11) & 31) * 255 / 31;
+        out[G] = ((pixel >> 5) & 63) * 255 / 63;
+        out[R] = ((pixel >> 11) & 31) * 255 / 31;
         out[A] = 255;
-        out += 4; in += 2;
+        out += 4;
+        in += 2;
     }
 }

 void
-ImagingUnpackRGB4B(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackRGB4B(UINT8 *out, const UINT8 *in, int pixels) {
     int i, pixel;
     /* RGB, 4 bits per pixel */
     for (i = 0; i < pixels; i++) {
         pixel = in[0] + (in[1] << 8);
         out[R] = (pixel & 15) * 17;
-        out[G] = ((pixel>>4) & 15) * 17;
-        out[B] = ((pixel>>8) & 15) * 17;
+        out[G] = ((pixel >> 4) & 15) * 17;
+        out[B] = ((pixel >> 8) & 15) * 17;
         out[A] = 255;
-        out += 4; in += 2;
+        out += 4;
+        in += 2;
     }
 }

 void
-ImagingUnpackRGBA4B(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackRGBA4B(UINT8 *out, const UINT8 *in, int pixels) {
     int i, pixel;
     /* RGBA, 4 bits per pixel */
     for (i = 0; i < pixels; i++) {
         pixel = in[0] + (in[1] << 8);
         out[R] = (pixel & 15) * 17;
-        out[G] = ((pixel>>4) & 15) * 17;
-        out[B] = ((pixel>>8) & 15) * 17;
-        out[A] = ((pixel>>12) & 15) * 17;
-        out += 4; in += 2;
-    }
-}
-
-static void
-ImagingUnpackBGRX(UINT8* _out, const UINT8* in, int pixels)
-{
+        out[G] = ((pixel >> 4) & 15) * 17;
+        out[B] = ((pixel >> 8) & 15) * 17;
+        out[A] = ((pixel >> 12) & 15) * 17;
+        out += 4;
+        in += 2;
+    }
+}
+
+static void
+ImagingUnpackBGRX(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, reversed bytes with padding */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[2], in[1], in[0], 255);
         memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
-    }
-}
-
-static void
-ImagingUnpackXRGB(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 4;
+        _out += 4;
+    }
+}
+
+static void
+ImagingUnpackXRGB(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, leading pad */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[1], in[2], in[3], 255);
         memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
-    }
-}
-
-static void
-ImagingUnpackXBGR(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 4;
+        _out += 4;
+    }
+}
+
+static void
+ImagingUnpackXBGR(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, reversed bytes, leading pad */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[3], in[2], in[1], 255);
         memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
+        in += 4;
+        _out += 4;
     }
 }

 /* Unpack to "RGBA" image */

 static void
-unpackRGBALA(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackRGBALA(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* greyscale with alpha */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[0], in[0], in[0], in[1]);
         memcpy(_out, &iv, sizeof(iv));
-        in += 2; _out += 4;
-    }
-}
-
-static void
-unpackRGBALA16B(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 2;
+        _out += 4;
+    }
+}
+
+static void
+unpackRGBALA16B(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* 16-bit greyscale with alpha, big-endian */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[0], in[0], in[0], in[2]);
         memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
-    }
-}
-
-static void
-unpackRGBa16L(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 4;
+        _out += 4;
+    }
+}
+
+static void
+unpackRGBa16L(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* premultiplied 16-bit RGBA, little-endian */
     for (i = 0; i < pixels; i++) {
         int a = in[7];
         UINT32 iv;
-        if ( ! a) {
+        if (!a) {
             iv = 0;
         } else if (a == 255) {
             iv = MAKE_UINT32(in[1], in[3], in[5], a);
         } else {
-            iv = MAKE_UINT32(CLIP8(in[1] * 255 / a),
-                             CLIP8(in[3] * 255 / a),
-                             CLIP8(in[5] * 255 / a), a);
-        }
-        memcpy(_out, &iv, sizeof(iv));
-        in += 8; _out += 4;
-    }
-}
-
-static void
-unpackRGBa16B(UINT8* _out, const UINT8* in, int pixels)
-{
+            iv = MAKE_UINT32(
+                CLIP8(in[1] * 255 / a),
+                CLIP8(in[3] * 255 / a),
+                CLIP8(in[5] * 255 / a),
+                a);
+        }
+        memcpy(_out, &iv, sizeof(iv));
+        in += 8;
+        _out += 4;
+    }
+}
+
+static void
+unpackRGBa16B(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* premultiplied 16-bit RGBA, big-endian */
     for (i = 0; i < pixels; i++) {
         int a = in[6];
         UINT32 iv;
-        if ( ! a) {
+        if (!a) {
             iv = 0;
         } else if (a == 255) {
             iv = MAKE_UINT32(in[0], in[2], in[4], a);
         } else {
-            iv = MAKE_UINT32(CLIP8(in[0] * 255 / a),
-                             CLIP8(in[2] * 255 / a),
-                             CLIP8(in[4] * 255 / a), a);
-        }
-        memcpy(_out, &iv, sizeof(iv));
-        in += 8; _out += 4;
-    }
-}
-
-static void
-unpackRGBa(UINT8* _out, const UINT8* in, int pixels)
-{
+            iv = MAKE_UINT32(
+                CLIP8(in[0] * 255 / a),
+                CLIP8(in[2] * 255 / a),
+                CLIP8(in[4] * 255 / a),
+                a);
+        }
+        memcpy(_out, &iv, sizeof(iv));
+        in += 8;
+        _out += 4;
+    }
+}
+
+static void
+unpackRGBa(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* premultiplied RGBA */
     for (i = 0; i < pixels; i++) {
         int a = in[3];
         UINT32 iv;
-        if ( ! a) {
+        if (!a) {
             iv = 0;
         } else if (a == 255) {
             iv = MAKE_UINT32(in[0], in[1], in[2], a);
         } else {
-            iv = MAKE_UINT32(CLIP8(in[0] * 255 / a),
-                             CLIP8(in[1] * 255 / a),
-                             CLIP8(in[2] * 255 / a), a);
-        }
-        memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
-    }
-}
-
-static void
-unpackRGBaskip1(UINT8* _out, const UINT8* in, int pixels)
-{
-    int i;
-    UINT32* out = (UINT32*) _out;
+            iv = MAKE_UINT32(
+                CLIP8(in[0] * 255 / a),
+                CLIP8(in[1] * 255 / a),
+                CLIP8(in[2] * 255 / a),
+                a);
+        }
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4;
+        _out += 4;
+    }
+}
+
+static void
+unpackRGBaskip1(UINT8 *_out, const UINT8 *in, int pixels) {
+    int i;
+    UINT32 *out = (UINT32 *)_out;
     /* premultiplied RGBA */
     for (i = 0; i < pixels; i++) {
         int a = in[3];
-        if ( ! a) {
+        if (!a) {
             out[i] = 0;
         } else if (a == 255) {
             out[i] = MAKE_UINT32(in[0], in[1], in[2], a);
         } else {
-            out[i] = MAKE_UINT32(CLIP8(in[0] * 255 / a),
-                                 CLIP8(in[1] * 255 / a),
-                                 CLIP8(in[2] * 255 / a), a);
+            out[i] = MAKE_UINT32(
+                CLIP8(in[0] * 255 / a),
+                CLIP8(in[1] * 255 / a),
+                CLIP8(in[2] * 255 / a),
+                a);
         }
         in += 5;
     }
 }

 static void
-unpackRGBaskip2(UINT8* _out, const UINT8* in, int pixels)
-{
-    int i;
-    UINT32* out = (UINT32*) _out;
+unpackRGBaskip2(UINT8 *_out, const UINT8 *in, int pixels) {
+    int i;
+    UINT32 *out = (UINT32 *)_out;
     /* premultiplied RGBA */
     for (i = 0; i < pixels; i++) {
         int a = in[3];
-        if ( ! a) {
+        if (!a) {
             out[i] = 0;
         } else if (a == 255) {
             out[i] = MAKE_UINT32(in[0], in[1], in[2], a);
         } else {
-            out[i] = MAKE_UINT32(CLIP8(in[0] * 255 / a),
-                                 CLIP8(in[1] * 255 / a),
-                                 CLIP8(in[2] * 255 / a), a);
+            out[i] = MAKE_UINT32(
+                CLIP8(in[0] * 255 / a),
+                CLIP8(in[1] * 255 / a),
+                CLIP8(in[2] * 255 / a),
+                a);
         }
         in += 6;
     }
 }

 static void
-unpackBGRa(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackBGRa(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* premultiplied BGRA */
     for (i = 0; i < pixels; i++) {
         int a = in[3];
         UINT32 iv;
-        if ( ! a) {
+        if (!a) {
             iv = 0;
         } else if (a == 255) {
             iv = MAKE_UINT32(in[2], in[1], in[0], a);
         } else {
-            iv = MAKE_UINT32(CLIP8(in[2] * 255 / a),
-                             CLIP8(in[1] * 255 / a),
-                             CLIP8(in[0] * 255 / a), a);
-        }
-        memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
-    }
-}
-
-static void
-unpackRGBAI(UINT8* out, const UINT8* in, int pixels)
-{
+            iv = MAKE_UINT32(
+                CLIP8(in[2] * 255 / a),
+                CLIP8(in[1] * 255 / a),
+                CLIP8(in[0] * 255 / a),
+                a);
+        }
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4;
+        _out += 4;
+    }
+}
+
+static void
+unpackRGBAI(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* RGBA, inverted RGB bytes (FlashPix) */
     for (i = 0; i < pixels; i++) {
@@ -877,28 +988,30 @@
         out[G] = ~in[1];
         out[B] = ~in[2];
         out[A] = in[3];
-        out += 4; in += 4;
-    }
-}
-
-static void
-unpackRGBAL(UINT8* _out, const UINT8* in, int pixels)
-{
+        out += 4;
+        in += 4;
+    }
+}
+
+static void
+unpackRGBAL(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGBA, line interleaved */
-    for (i = 0; i < pixels; i++, _out+=4) {
-        UINT32 iv = MAKE_UINT32(in[i], in[i+pixels], in[i+pixels+pixels],
-                                in[i+pixels+pixels+pixels]);
+    for (i = 0; i < pixels; i++, _out += 4) {
+        UINT32 iv = MAKE_UINT32(
+            in[i],
+            in[i + pixels],
+            in[i + pixels + pixels],
+            in[i + pixels + pixels + pixels]);
         memcpy(_out, &iv, sizeof(iv));
     }
 }

 void
-unpackRGBA16L(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackRGBA16L(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* 16-bit RGBA, little-endian order */
-    for (i = 0; i < pixels; i++, _out+=4) {
+    for (i = 0; i < pixels; i++, _out += 4) {
         UINT32 iv = MAKE_UINT32(in[1], in[3], in[5], in[7]);
         memcpy(_out, &iv, sizeof(iv));
         in += 8;
@@ -906,11 +1019,10 @@
 }

 void
-unpackRGBA16B(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackRGBA16B(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* 16-bit RGBA, big-endian order */
-    for (i = 0; i < pixels; i++, _out+=4) {
+    for (i = 0; i < pixels; i++, _out += 4) {
         UINT32 iv = MAKE_UINT32(in[0], in[2], in[4], in[6]);
         memcpy(_out, &iv, sizeof(iv));
         in += 8;
@@ -918,53 +1030,52 @@
 }

 static void
-unpackARGB(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackARGB(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGBA, leading pad */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[1], in[2], in[3], in[0]);
         memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
-    }
-}
-
-static void
-unpackABGR(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 4;
+        _out += 4;
+    }
+}
+
+static void
+unpackABGR(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGBA, reversed bytes */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[3], in[2], in[1], in[0]);
         memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
-    }
-}
-
-static void
-unpackBGRA(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 4;
+        _out += 4;
+    }
+}
+
+static void
+unpackBGRA(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* RGBA, reversed bytes */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = MAKE_UINT32(in[2], in[1], in[0], in[3]);
         memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
-    }
-}
-
+        in += 4;
+        _out += 4;
+    }
+}

 /* Unpack to "CMYK" image */

 static void
-unpackCMYKI(UINT8* _out, const UINT8* in, int pixels)
-{
+unpackCMYKI(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     /* CMYK, inverted bytes (Photoshop 2.5) */
     for (i = 0; i < pixels; i++) {
         UINT32 iv = ~MAKE_UINT32(in[0], in[1], in[2], in[3]);
         memcpy(_out, &iv, sizeof(iv));
-        in += 4; _out += 4;
+        in += 4;
+        _out += 4;
     }
 }

@@ -980,8 +1091,7 @@
    internally, and we'll unshift for saving and whatnot.
 */
 void
-ImagingUnpackLAB(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackLAB(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* LAB triplets */
     for (i = 0; i < pixels; i++) {
@@ -989,32 +1099,44 @@
         out[1] = in[1] ^ 128; /* signed in outside world */
         out[2] = in[2] ^ 128;
         out[3] = 255;
-        out += 4; in += 3;
-    }
-}
-
-static void
-unpackI16N_I16B(UINT8* out, const UINT8* in, int pixels){
-    int i;
-    UINT8* tmp = (UINT8*) out;
+        out += 4;
+        in += 3;
+    }
+}
+
+static void
+unpackI16N_I16B(UINT8 *out, const UINT8 *in, int pixels) {
+    int i;
+    UINT8 *tmp = (UINT8 *)out;
     for (i = 0; i < pixels; i++) {
         C16B;
-        in += 2; tmp += 2;
-    }
-
-}
-static void
-unpackI16N_I16(UINT8* out, const UINT8* in, int pixels){
-    int i;
-    UINT8* tmp = (UINT8*) out;
+        in += 2;
+        tmp += 2;
+    }
+}
+static void
+unpackI16N_I16(UINT8 *out, const UINT8 *in, int pixels) {
+    int i;
+    UINT8 *tmp = (UINT8 *)out;
     for (i = 0; i < pixels; i++) {
         C16L;
-        in += 2; tmp += 2;
-    }
-}
-
-static void
-unpackI12_I16(UINT8* out, const UINT8* in, int pixels){
+        in += 2;
+        tmp += 2;
+    }
+}
+static void
+unpackI16R_I16(UINT8 *out, const UINT8 *in, int pixels) {
+    int i;
+    for (i = 0; i < pixels; i++) {
+        out[0] = BITFLIP[in[0]];
+        out[1] = BITFLIP[in[1]];
+        in += 2;
+        out += 2;
+    }
+}
+
+static void
+unpackI12_I16(UINT8 *out, const UINT8 *in, int pixels) {
     /*  Fillorder 1/MSB -> LittleEndian, for 12bit integer greyscale tiffs.

         According to the TIFF spec:
@@ -1036,103 +1158,100 @@
     int i;
     UINT16 pixel;
 #ifdef WORDS_BIGENDIAN
-    UINT8* tmp = (UINT8 *)&pixel;
+    UINT8 *tmp = (UINT8 *)&pixel;
 #endif
-    for (i = 0; i < pixels-1; i+=2) {
-        pixel = (((UINT16) in[0]) << 4 ) + (in[1] >>4);
+    for (i = 0; i < pixels - 1; i += 2) {
+        pixel = (((UINT16)in[0]) << 4) + (in[1] >> 4);
 #ifdef WORDS_BIGENDIAN
-        out[0] = tmp[1];  out[1] = tmp[0];
+        out[0] = tmp[1];
+        out[1] = tmp[0];
 #else
         memcpy(out, &pixel, sizeof(pixel));
 #endif

-        out+=2;
-        pixel = (((UINT16) (in[1] & 0x0F)) << 8) + in[2];
+        out += 2;
+        pixel = (((UINT16)(in[1] & 0x0F)) << 8) + in[2];
 #ifdef WORDS_BIGENDIAN
-        out[0] = tmp[1];  out[1] = tmp[0];
+        out[0] = tmp[1];
+        out[1] = tmp[0];
 #else
         memcpy(out, &pixel, sizeof(pixel));
 #endif

-        in += 3; out+=2;
-    }
-    if (i == pixels-1) {
-        pixel = (((UINT16) in[0]) << 4 ) + (in[1] >>4);
+        in += 3;
+        out += 2;
+    }
+    if (i == pixels - 1) {
+        pixel = (((UINT16)in[0]) << 4) + (in[1] >> 4);
 #ifdef WORDS_BIGENDIAN
-        out[0] = tmp[1];  out[1] = tmp[0];
+        out[0] = tmp[1];
+        out[1] = tmp[0];
 #else
         memcpy(out, &pixel, sizeof(pixel));
 #endif
     }
 }

-
-static void
-copy1(UINT8* out, const UINT8* in, int pixels)
-{
+static void
+copy1(UINT8 *out, const UINT8 *in, int pixels) {
     /* L, P */
     memcpy(out, in, pixels);
 }

 static void
-copy2(UINT8* out, const UINT8* in, int pixels)
-{
+copy2(UINT8 *out, const UINT8 *in, int pixels) {
     /* I;16 */
-    memcpy(out, in, pixels*2);
-}
-
-static void
-copy4(UINT8* out, const UINT8* in, int pixels)
-{
+    memcpy(out, in, pixels * 2);
+}
+
+static void
+copy4(UINT8 *out, const UINT8 *in, int pixels) {
     /* RGBA, CMYK quadruples */
     memcpy(out, in, 4 * pixels);
 }

 static void
-copy4skip1(UINT8* _out, const UINT8* in, int pixels)
-{
+copy4skip1(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     for (i = 0; i < pixels; i++) {
         memcpy(_out, in, 4);
-        in += 5; _out += 4;
-    }
-}
-
-static void
-copy4skip2(UINT8* _out, const UINT8* in, int pixels)
-{
+        in += 5;
+        _out += 4;
+    }
+}
+
+static void
+copy4skip2(UINT8 *_out, const UINT8 *in, int pixels) {
     int i;
     for (i = 0; i < pixels; i++) {
         memcpy(_out, in, 4);
-        in += 6; _out += 4;
-    }
-}
-
+        in += 6;
+        _out += 4;
+    }
+}

 /* Unpack to "I" and "F" images */

-#define UNPACK_RAW(NAME, GET, INTYPE, OUTTYPE)\
-static void NAME(UINT8* out_, const UINT8* in, int pixels)\
-{\
-    int i;\
-    OUTTYPE* out = (OUTTYPE*) out_;\
-    for (i = 0; i < pixels; i++, in += sizeof(INTYPE)) {\
-        out[i] = (OUTTYPE) ((INTYPE) GET);\
-    }\
-}
-
-#define UNPACK(NAME, COPY, INTYPE, OUTTYPE)\
-static void NAME(UINT8* out_, const UINT8* in, int pixels)\
-{\
-    int i;\
-    OUTTYPE* out = (OUTTYPE*) out_;\
-    INTYPE tmp_;\
-    UINT8* tmp = (UINT8*) &tmp_;\
-    for (i = 0; i < pixels; i++, in += sizeof(INTYPE)) {\
-        COPY;\
-        out[i] = (OUTTYPE) tmp_;\
-    }\
-}
+#define UNPACK_RAW(NAME, GET, INTYPE, OUTTYPE)                   \
+    static void NAME(UINT8 *out_, const UINT8 *in, int pixels) { \
+        int i;                                                   \
+        OUTTYPE *out = (OUTTYPE *)out_;                          \
+        for (i = 0; i < pixels; i++, in += sizeof(INTYPE)) {     \
+            out[i] = (OUTTYPE)((INTYPE)GET);                     \
+        }                                                        \
+    }
+
+#define UNPACK(NAME, COPY, INTYPE, OUTTYPE)                      \
+    static void NAME(UINT8 *out_, const UINT8 *in, int pixels) { \
+        int i;                                                   \
+        OUTTYPE *out = (OUTTYPE *)out_;                          \
+        INTYPE tmp_;                                             \
+        UINT8 *tmp = (UINT8 *)&tmp_;                             \
+        for (i = 0; i < pixels; i++, in += sizeof(INTYPE)) {     \
+            COPY;                                                \
+            out[i] = (OUTTYPE)tmp_;                              \
+        }                                                        \
+    }

 UNPACK_RAW(unpackI8, in[0], UINT8, INT32)
 UNPACK_RAW(unpackI8S, in[0], INT8, INT32)
@@ -1172,12 +1291,10 @@
 UNPACK(unpackF64NF, C64N, FLOAT64, FLOAT32)
 #endif

-
 /* Misc. unpackers */

 static void
-band0(UINT8* out, const UINT8* in, int pixels)
-{
+band0(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* band 0 only */
     for (i = 0; i < pixels; i++) {
@@ -1187,8 +1304,7 @@
 }

 static void
-band1(UINT8* out, const UINT8* in, int pixels)
-{
+band1(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* band 1 only */
     for (i = 0; i < pixels; i++) {
@@ -1198,8 +1314,7 @@
 }

 static void
-band2(UINT8* out, const UINT8* in, int pixels)
-{
+band2(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* band 2 only */
     for (i = 0; i < pixels; i++) {
@@ -1209,8 +1324,7 @@
 }

 static void
-band3(UINT8* out, const UINT8* in, int pixels)
-{
+band3(UINT8 *out, const UINT8 *in, int pixels) {
     /* band 3 only */
     int i;
     for (i = 0; i < pixels; i++) {
@@ -1220,8 +1334,7 @@
 }

 static void
-band0I(UINT8* out, const UINT8* in, int pixels)
-{
+band0I(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* band 0 only */
     for (i = 0; i < pixels; i++) {
@@ -1231,8 +1344,7 @@
 }

 static void
-band1I(UINT8* out, const UINT8* in, int pixels)
-{
+band1I(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* band 1 only */
     for (i = 0; i < pixels; i++) {
@@ -1242,8 +1354,7 @@
 }

 static void
-band2I(UINT8* out, const UINT8* in, int pixels)
-{
+band2I(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* band 2 only */
     for (i = 0; i < pixels; i++) {
@@ -1253,8 +1364,7 @@
 }

 static void
-band3I(UINT8* out, const UINT8* in, int pixels)
-{
+band3I(UINT8 *out, const UINT8 *in, int pixels) {
     /* band 3 only */
     int i;
     for (i = 0; i < pixels; i++) {
@@ -1263,9 +1373,97 @@
     }
 }

+static void
+band016B(UINT8* out, const UINT8* in, int pixels)
+{
+    int i;
+    /* band 0 only, big endian */
+    for (i = 0; i < pixels; i++) {
+        out[0] = in[0];
+        out += 4; in += 2;
+    }
+}
+
+static void
+band116B(UINT8* out, const UINT8* in, int pixels)
+{
+    int i;
+    /* band 1 only, big endian */
+    for (i = 0; i < pixels; i++) {
+        out[1] = in[0];
+        out += 4; in += 2;
+    }
+}
+
+static void
+band216B(UINT8* out, const UINT8* in, int pixels)
+{
+    int i;
+    /* band 2 only, big endian */
+    for (i = 0; i < pixels; i++) {
+        out[2] = in[0];
+        out += 4; in += 2;
+    }
+}
+
+static void
+band316B(UINT8* out, const UINT8* in, int pixels)
+{
+    int i;
+    /* band 3 only, big endian */
+    for (i = 0; i < pixels; i++) {
+        out[3] = in[0];
+        out += 4; in += 2;
+    }
+}
+
+static void
+band016L(UINT8* out, const UINT8* in, int pixels)
+{
+    int i;
+    /* band 0 only, little endian */
+    for (i = 0; i < pixels; i++) {
+        out[0] = in[1];
+        out += 4; in += 2;
+    }
+}
+
+static void
+band116L(UINT8* out, const UINT8* in, int pixels)
+{
+    int i;
+    /* band 1 only, little endian */
+    for (i = 0; i < pixels; i++) {
+        out[1] = in[1];
+        out += 4; in += 2;
+    }
+}
+
+static void
+band216L(UINT8* out, const UINT8* in, int pixels)
+{
+    int i;
+    /* band 2 only, little endian */
+    for (i = 0; i < pixels; i++) {
+        out[2] = in[1];
+        out += 4; in += 2;
+    }
+}
+
+static void
+band316L(UINT8* out, const UINT8* in, int pixels)
+{
+    int i;
+    /* band 3 only, little endian */
+    for (i = 0; i < pixels; i++) {
+        out[3] = in[1];
+        out += 4; in += 2;
+    }
+}
+
 static struct {
-    const char* mode;
-    const char* rawmode;
+    const char *mode;
+    const char *rawmode;
     int bits;
     ImagingShuffler unpack;
 } unpackers[] = {
@@ -1282,244 +1480,276 @@
     /* exception: rawmodes "I" and "F" are always native endian byte order */

     /* bilevel */
-    {"1",       "1",            1,      unpack1},
-    {"1",       "1;I",          1,      unpack1I},
-    {"1",       "1;R",          1,      unpack1R},
-    {"1",       "1;IR",         1,      unpack1IR},
-    {"1",       "1;8",          8,      unpack18},
+    {"1", "1", 1, unpack1},
+    {"1", "1;I", 1, unpack1I},
+    {"1", "1;R", 1, unpack1R},
+    {"1", "1;IR", 1, unpack1IR},
+    {"1", "1;8", 8, unpack18},

     /* greyscale */
-    {"L",       "L;2",          2,      unpackL2},
-    {"L",       "L;2I",         2,      unpackL2I},
-    {"L",       "L;2R",         2,      unpackL2R},
-    {"L",       "L;2IR",        2,      unpackL2IR},
-
-    {"L",       "L;4",          4,      unpackL4},
-    {"L",       "L;4I",         4,      unpackL4I},
-    {"L",       "L;4R",         4,      unpackL4R},
-    {"L",       "L;4IR",        4,      unpackL4IR},
-
-    {"L",       "L",            8,      copy1},
-    {"L",       "L;I",          8,      unpackLI},
-    {"L",       "L;R",          8,      unpackLR},
-    {"L",       "L;16",         16,     unpackL16},
-    {"L",       "L;16B",        16,     unpackL16B},
+    {"L", "L;2", 2, unpackL2},
+    {"L", "L;2I", 2, unpackL2I},
+    {"L", "L;2R", 2, unpackL2R},
+    {"L", "L;2IR", 2, unpackL2IR},
+
+    {"L", "L;4", 4, unpackL4},
+    {"L", "L;4I", 4, unpackL4I},
+    {"L", "L;4R", 4, unpackL4R},
+    {"L", "L;4IR", 4, unpackL4IR},
+
+    {"L", "L", 8, copy1},
+    {"L", "L;I", 8, unpackLI},
+    {"L", "L;R", 8, unpackLR},
+    {"L", "L;16", 16, unpackL16},
+    {"L", "L;16B", 16, unpackL16B},

     /* greyscale w. alpha */
-    {"LA",      "LA",           16,     unpackLA},
-    {"LA",      "LA;L",         16,     unpackLAL},
+    {"LA", "LA", 16, unpackLA},
+    {"LA", "LA;L", 16, unpackLAL},

     /* greyscale w. alpha premultiplied */
-    {"La",      "La",           16,     unpackLA},
+    {"La", "La", 16, unpackLA},

     /* palette */
-    {"P",       "P;1",          1,      unpackP1},
-    {"P",       "P;2",          2,      unpackP2},
-    {"P",       "P;2L",         2,      unpackP2L},
-    {"P",       "P;4",          4,      unpackP4},
-    {"P",       "P;4L",         4,      unpackP4L},
-    {"P",       "P",            8,      copy1},
-    {"P",       "P;R",          8,      unpackLR},
+    {"P", "P;1", 1, unpackP1},
+    {"P", "P;2", 2, unpackP2},
+    {"P", "P;2L", 2, unpackP2L},
+    {"P", "P;4", 4, unpackP4},
+    {"P", "P;4L", 4, unpackP4L},
+    {"P", "P", 8, copy1},
+    {"P", "P;R", 8, unpackLR},

     /* palette w. alpha */
-    {"PA",      "PA",           16,     unpackLA},
-    {"PA",      "PA;L",         16,     unpackLAL},
+    {"PA", "PA", 16, unpackLA},
+    {"PA", "PA;L", 16, unpackLAL},

     /* true colour */
-    {"RGB",     "RGB",          24,     ImagingUnpackRGB},
-    {"RGB",     "RGB;L",        24,     unpackRGBL},
-    {"RGB",     "RGB;R",        24,     unpackRGBR},
-    {"RGB",     "RGB;16L",      48,     unpackRGB16L},
-    {"RGB",     "RGB;16B",      48,     unpackRGB16B},
-    {"RGB",     "BGR",          24,     ImagingUnpackBGR},
-    {"RGB",     "RGB;15",       16,     ImagingUnpackRGB15},
-    {"RGB",     "BGR;15",       16,     ImagingUnpackBGR15},
-    {"RGB",     "RGB;16",       16,     ImagingUnpackRGB16},
-    {"RGB",     "BGR;16",       16,     ImagingUnpackBGR16},
-    {"RGB",     "RGB;4B",       16,     ImagingUnpackRGB4B},
-    {"RGB",     "BGR;5",        16,     ImagingUnpackBGR15}, /* compat */
-    {"RGB",     "RGBX",         32,     copy4},
-    {"RGB",     "RGBX;L",       32,     unpackRGBAL},
-    {"RGB",     "RGBA;L",       32,     unpackRGBAL},
-    {"RGB",     "BGRX",         32,     ImagingUnpackBGRX},
-    {"RGB",     "XRGB",         32,     ImagingUnpackXRGB},
-    {"RGB",     "XBGR",         32,     ImagingUnpackXBGR},
-    {"RGB",     "YCC;P",        24,     ImagingUnpackYCC},
-    {"RGB",     "R",            8,      band0},
-    {"RGB",     "G",            8,      band1},
-    {"RGB",     "B",            8,      band2},
+    {"RGB", "RGB", 24, ImagingUnpackRGB},
+    {"RGB", "RGB;L", 24, unpackRGBL},
+    {"RGB", "RGB;R", 24, unpackRGBR},
+    {"RGB", "RGB;16L", 48, unpackRGB16L},
+    {"RGB", "RGB;16B", 48, unpackRGB16B},
+    {"RGB", "BGR", 24, ImagingUnpackBGR},
+    {"RGB", "RGB;15", 16, ImagingUnpackRGB15},
+    {"RGB", "BGR;15", 16, ImagingUnpackBGR15},
+    {"RGB", "RGB;16", 16, ImagingUnpackRGB16},
+    {"RGB", "BGR;16", 16, ImagingUnpackBGR16},
+    {"RGB", "RGB;4B", 16, ImagingUnpackRGB4B},
+    {"RGB", "BGR;5", 16, ImagingUnpackBGR15}, /* compat */
+    {"RGB", "RGBX", 32, copy4},
+    {"RGB", "RGBX;L", 32, unpackRGBAL},
+    {"RGB", "RGBA;L", 32, unpackRGBAL},
+    {"RGB", "RGBA;15", 16, ImagingUnpackRGBA15},
+    {"RGB", "BGRX", 32, ImagingUnpackBGRX},
+    {"RGB", "XRGB", 32, ImagingUnpackXRGB},
+    {"RGB", "XBGR", 32, ImagingUnpackXBGR},
+    {"RGB", "YCC;P", 24, ImagingUnpackYCC},
+    {"RGB", "R", 8, band0},
+    {"RGB", "G", 8, band1},
+    {"RGB", "B", 8, band2},
+    {"RGB", "R;16L", 16, band016L},
+    {"RGB", "G;16L", 16, band116L},
+    {"RGB", "B;16L", 16, band216L},
+    {"RGB", "R;16B", 16, band016B},
+    {"RGB", "G;16B", 16, band116B},
+    {"RGB", "B;16B", 16, band216B},

     /* true colour w. alpha */
-    {"RGBA",    "LA",           16,     unpackRGBALA},
-    {"RGBA",    "LA;16B",       32,     unpackRGBALA16B},
-    {"RGBA",    "RGBA",         32,     copy4},
-    {"RGBA",    "RGBAX",        40,     copy4skip1},
-    {"RGBA",    "RGBAXX",       48,     copy4skip2},
-    {"RGBA",    "RGBa",         32,     unpackRGBa},
-    {"RGBA",    "RGBaX",        40,     unpackRGBaskip1},
-    {"RGBA",    "RGBaXX",       48,     unpackRGBaskip2},
-    {"RGBA",    "RGBa;16L",     64,     unpackRGBa16L},
-    {"RGBA",    "RGBa;16B",     64,     unpackRGBa16B},
-    {"RGBA",    "BGRa",         32,     unpackBGRa},
-    {"RGBA",    "RGBA;I",       32,     unpackRGBAI},
-    {"RGBA",    "RGBA;L",       32,     unpackRGBAL},
-    {"RGBA",    "RGBA;15",      16,     ImagingUnpackRGBA15},
-    {"RGBA",    "BGRA;15",      16,     ImagingUnpackBGRA15},
-    {"RGBA",    "RGBA;4B",      16,     ImagingUnpackRGBA4B},
-    {"RGBA",    "RGBA;16L",     64,     unpackRGBA16L},
-    {"RGBA",    "RGBA;16B",     64,     unpackRGBA16B},
-    {"RGBA",    "BGRA",         32,     unpackBGRA},
-    {"RGBA",    "ARGB",         32,     unpackARGB},
-    {"RGBA",    "ABGR",         32,     unpackABGR},
-    {"RGBA",    "YCCA;P",       32,     ImagingUnpackYCCA},
-    {"RGBA",    "R",            8,      band0},
-    {"RGBA",    "G",            8,      band1},
-    {"RGBA",    "B",            8,      band2},
-    {"RGBA",    "A",            8,      band3},
+    {"RGBA", "LA", 16, unpackRGBALA},
+    {"RGBA", "LA;16B", 32, unpackRGBALA16B},
+    {"RGBA", "RGBA", 32, copy4},
+    {"RGBA", "RGBAX", 40, copy4skip1},
+    {"RGBA", "RGBAXX", 48, copy4skip2},
+    {"RGBA", "RGBa", 32, unpackRGBa},
+    {"RGBA", "RGBaX", 40, unpackRGBaskip1},
+    {"RGBA", "RGBaXX", 48, unpackRGBaskip2},
+    {"RGBA", "RGBa;16L", 64, unpackRGBa16L},
+    {"RGBA", "RGBa;16B", 64, unpackRGBa16B},
+    {"RGBA", "BGRa", 32, unpackBGRa},
+    {"RGBA", "RGBA;I", 32, unpackRGBAI},
+    {"RGBA", "RGBA;L", 32, unpackRGBAL},
+    {"RGBA", "RGBA;15", 16, ImagingUnpackRGBA15},
+    {"RGBA", "BGRA;15", 16, ImagingUnpackBGRA15},
+    {"RGBA", "RGBA;4B", 16, ImagingUnpackRGBA4B},
+    {"RGBA", "RGBA;16L", 64, unpackRGBA16L},
+    {"RGBA", "RGBA;16B", 64, unpackRGBA16B},
+    {"RGBA", "BGRA", 32, unpackBGRA},
+    {"RGBA", "ARGB", 32, unpackARGB},
+    {"RGBA", "ABGR", 32, unpackABGR},
+    {"RGBA", "YCCA;P", 32, ImagingUnpackYCCA},
+    {"RGBA", "R", 8, band0},
+    {"RGBA", "G", 8, band1},
+    {"RGBA", "B", 8, band2},
+    {"RGBA", "A", 8, band3},
+    {"RGBA", "R;16L", 16, band016L},
+    {"RGBA", "G;16L", 16, band116L},
+    {"RGBA", "B;16L", 16, band216L},
+    {"RGBA", "A;16L", 16, band316L},
+    {"RGBA", "R;16B", 16, band016B},
+    {"RGBA", "G;16B", 16, band116B},
+    {"RGBA", "B;16B", 16, band216B},
+    {"RGBA", "A;16B", 16, band316B},

 #ifdef WORDS_BIGENDIAN
-    {"RGB",     "RGB;16N",      48,     unpackRGB16B},
-    {"RGBA",    "RGBa;16N",     64,     unpackRGBa16B},
-    {"RGBA",    "RGBA;16N",     64,     unpackRGBA16B},
-    {"RGBX",    "RGBX;16N",     64,     unpackRGBA16B},
+    {"RGB", "RGB;16N", 48, unpackRGB16B},
+    {"RGBA", "RGBa;16N", 64, unpackRGBa16B},
+    {"RGBA", "RGBA;16N", 64, unpackRGBA16B},
+    {"RGBX", "RGBX;16N", 64, unpackRGBA16B},
+    {"RGB", "R;16N", 16, band016B},
+    {"RGB", "G;16N", 16, band116B},
+    {"RGB", "B;16N", 16, band216B},
+
+    {"RGBA", "R;16N", 16, band016B},
+    {"RGBA", "G;16N", 16, band116B},
+    {"RGBA", "B;16N", 16, band216B},
+    {"RGBA", "A;16N", 16, band316B},
 #else
-    {"RGB",     "RGB;16N",      48,     unpackRGB16L},
-    {"RGBA",    "RGBa;16N",     64,     unpackRGBa16L},
-    {"RGBA",    "RGBA;16N",     64,     unpackRGBA16L},
-    {"RGBX",    "RGBX;16N",     64,     unpackRGBA16B},
+    {"RGB", "RGB;16N", 48, unpackRGB16L},
+    {"RGBA", "RGBa;16N", 64, unpackRGBa16L},
+    {"RGBA", "RGBA;16N", 64, unpackRGBA16L},
+    {"RGBX", "RGBX;16N", 64, unpackRGBA16L},
+    {"RGB", "R;16N", 16, band016L},
+    {"RGB", "G;16N", 16, band116L},
+    {"RGB", "B;16N", 16, band216L},
+
+
+    {"RGBA", "R;16N", 16, band016L},
+    {"RGBA", "G;16N", 16, band116L},
+    {"RGBA", "B;16N", 16, band216L},
+    {"RGBA", "A;16N", 16, band316L},
 #endif

     /* true colour w. alpha premultiplied */
-    {"RGBa",    "RGBa",         32,     copy4},
-    {"RGBa",    "BGRa",         32,     unpackBGRA},
-    {"RGBa",    "aRGB",         32,     unpackARGB},
-    {"RGBa",    "aBGR",         32,     unpackABGR},
+    {"RGBa", "RGBa", 32, copy4},
+    {"RGBa", "BGRa", 32, unpackBGRA},
+    {"RGBa", "aRGB", 32, unpackARGB},
+    {"RGBa", "aBGR", 32, unpackABGR},

     /* true colour w. padding */
-    {"RGBX",    "RGB",          24,     ImagingUnpackRGB},
-    {"RGBX",    "RGB;L",        24,     unpackRGBL},
-    {"RGBX",    "RGB;16B",      48,     unpackRGB16B},
-    {"RGBX",    "BGR",          24,     ImagingUnpackBGR},
-    {"RGBX",    "RGB;15",       16,     ImagingUnpackRGB15},
-    {"RGBX",    "BGR;15",       16,     ImagingUnpackBGR15},
-    {"RGBX",    "RGB;4B",       16,     ImagingUnpackRGB4B},
-    {"RGBX",    "BGR;5",        16,     ImagingUnpackBGR15}, /* compat */
-    {"RGBX",    "RGBX",         32,     copy4},
-    {"RGBX",    "RGBXX",        40,     copy4skip1},
-    {"RGBX",    "RGBXXX",       48,     copy4skip2},
-    {"RGBX",    "RGBX;L",       32,     unpackRGBAL},
-    {"RGBX",    "RGBX;16L",     64,     unpackRGBA16L},
-    {"RGBX",    "RGBX;16B",     64,     unpackRGBA16B},
-    {"RGBX",    "BGRX",         32,     ImagingUnpackBGRX},
-    {"RGBX",    "XRGB",         32,     ImagingUnpackXRGB},
-    {"RGBX",    "XBGR",         32,     ImagingUnpackXBGR},
-    {"RGBX",    "YCC;P",        24,     ImagingUnpackYCC},
-    {"RGBX",    "R",            8,      band0},
-    {"RGBX",    "G",            8,      band1},
-    {"RGBX",    "B",            8,      band2},
-    {"RGBX",    "X",            8,      band3},
+    {"RGBX", "RGB", 24, ImagingUnpackRGB},
+    {"RGBX", "RGB;L", 24, unpackRGBL},
+    {"RGBX", "RGB;16B", 48, unpackRGB16B},
+    {"RGBX", "BGR", 24, ImagingUnpackBGR},
+    {"RGBX", "RGB;15", 16, ImagingUnpackRGB15},
+    {"RGBX", "BGR;15", 16, ImagingUnpackBGR15},
+    {"RGBX", "RGB;4B", 16, ImagingUnpackRGB4B},
+    {"RGBX", "BGR;5", 16, ImagingUnpackBGR15}, /* compat */
+    {"RGBX", "RGBX", 32, copy4},
+    {"RGBX", "RGBXX", 40, copy4skip1},
+    {"RGBX", "RGBXXX", 48, copy4skip2},
+    {"RGBX", "RGBX;L", 32, unpackRGBAL},
+    {"RGBX", "RGBX;16L", 64, unpackRGBA16L},
+    {"RGBX", "RGBX;16B", 64, unpackRGBA16B},
+    {"RGBX", "BGRX", 32, ImagingUnpackBGRX},
+    {"RGBX", "XRGB", 32, ImagingUnpackXRGB},
+    {"RGBX", "XBGR", 32, ImagingUnpackXBGR},
+    {"RGBX", "YCC;P", 24, ImagingUnpackYCC},
+    {"RGBX", "R", 8, band0},
+    {"RGBX", "G", 8, band1},
+    {"RGBX", "B", 8, band2},
+    {"RGBX", "X", 8, band3},

     /* colour separation */
-    {"CMYK",    "CMYK",         32,     copy4},
-    {"CMYK",    "CMYKX",        40,     copy4skip1},
-    {"CMYK",    "CMYKXX",       48,     copy4skip2},
-    {"CMYK",    "CMYK;I",       32,     unpackCMYKI},
-    {"CMYK",    "CMYK;L",       32,     unpackRGBAL},
-    {"CMYK",    "CMYK;16L",     64,     unpackRGBA16L},
-    {"CMYK",    "CMYK;16B",     64,     unpackRGBA16B},
-    {"CMYK",    "C",            8,      band0},
-    {"CMYK",    "M",            8,      band1},
-    {"CMYK",    "Y",            8,      band2},
-    {"CMYK",    "K",            8,      band3},
-    {"CMYK",    "C;I",          8,      band0I},
-    {"CMYK",    "M;I",          8,      band1I},
-    {"CMYK",    "Y;I",          8,      band2I},
-    {"CMYK",    "K;I",          8,      band3I},
+    {"CMYK", "CMYK", 32, copy4},
+    {"CMYK", "CMYKX", 40, copy4skip1},
+    {"CMYK", "CMYKXX", 48, copy4skip2},
+    {"CMYK", "CMYK;I", 32, unpackCMYKI},
+    {"CMYK", "CMYK;L", 32, unpackRGBAL},
+    {"CMYK", "CMYK;16L", 64, unpackRGBA16L},
+    {"CMYK", "CMYK;16B", 64, unpackRGBA16B},
+    {"CMYK", "C", 8, band0},
+    {"CMYK", "M", 8, band1},
+    {"CMYK", "Y", 8, band2},
+    {"CMYK", "K", 8, band3},
+    {"CMYK", "C;I", 8, band0I},
+    {"CMYK", "M;I", 8, band1I},
+    {"CMYK", "Y;I", 8, band2I},
+    {"CMYK", "K;I", 8, band3I},

 #ifdef WORDS_BIGENDIAN
-    {"CMYK",    "CMYK;16N",     64,     unpackRGBA16B},
+    {"CMYK", "CMYK;16N", 64, unpackRGBA16B},
 #else
-    {"CMYK",    "CMYK;16N",     64,     unpackRGBA16L},
+    {"CMYK", "CMYK;16N", 64, unpackRGBA16L},
 #endif

     /* video (YCbCr) */
-    {"YCbCr",   "YCbCr",        24,     ImagingUnpackRGB},
-    {"YCbCr",   "YCbCr;L",      24,     unpackRGBL},
-    {"YCbCr",   "YCbCrX",       32,     copy4},
-    {"YCbCr",   "YCbCrK",       32,     copy4},
+    {"YCbCr", "YCbCr", 24, ImagingUnpackRGB},
+    {"YCbCr", "YCbCr;L", 24, unpackRGBL},
+    {"YCbCr", "YCbCrX", 32, copy4},
+    {"YCbCr", "YCbCrK", 32, copy4},

     /* LAB Color */
-    {"LAB",     "LAB",          24,     ImagingUnpackLAB},
-    {"LAB",     "L",            8,      band0},
-    {"LAB",     "A",            8,      band1},
-    {"LAB",     "B",            8,      band2},
+    {"LAB", "LAB", 24, ImagingUnpackLAB},
+    {"LAB", "L", 8, band0},
+    {"LAB", "A", 8, band1},
+    {"LAB", "B", 8, band2},

     /* HSV Color */
-    {"HSV",     "HSV",          24,     ImagingUnpackRGB},
-    {"HSV",     "H",            8,      band0},
-    {"HSV",     "S",            8,      band1},
-    {"HSV",     "V",            8,      band2},
+    {"HSV", "HSV", 24, ImagingUnpackRGB},
+    {"HSV", "H", 8, band0},
+    {"HSV", "S", 8, band1},
+    {"HSV", "V", 8, band2},

     /* integer variations */
-    {"I",       "I",            32,     copy4},
-    {"I",       "I;8",          8,      unpackI8},
-    {"I",       "I;8S",         8,      unpackI8S},
-    {"I",       "I;16",         16,     unpackI16},
-    {"I",       "I;16S",        16,     unpackI16S},
-    {"I",       "I;16B",        16,     unpackI16B},
-    {"I",       "I;16BS",       16,     unpackI16BS},
-    {"I",       "I;16N",        16,     unpackI16N},
-    {"I",       "I;16NS",       16,     unpackI16NS},
-    {"I",       "I;32",         32,     unpackI32},
-    {"I",       "I;32S",        32,     unpackI32S},
-    {"I",       "I;32B",        32,     unpackI32B},
-    {"I",       "I;32BS",       32,     unpackI32BS},
-    {"I",       "I;32N",        32,     unpackI32N},
-    {"I",       "I;32NS",       32,     unpackI32NS},
+    {"I", "I", 32, copy4},
+    {"I", "I;8", 8, unpackI8},
+    {"I", "I;8S", 8, unpackI8S},
+    {"I", "I;16", 16, unpackI16},
+    {"I", "I;16S", 16, unpackI16S},
+    {"I", "I;16B", 16, unpackI16B},
+    {"I", "I;16BS", 16, unpackI16BS},
+    {"I", "I;16N", 16, unpackI16N},
+    {"I", "I;16NS", 16, unpackI16NS},
+    {"I", "I;32", 32, unpackI32},
+    {"I", "I;32S", 32, unpackI32S},
+    {"I", "I;32B", 32, unpackI32B},
+    {"I", "I;32BS", 32, unpackI32BS},
+    {"I", "I;32N", 32, unpackI32N},
+    {"I", "I;32NS", 32, unpackI32NS},

     /* floating point variations */
-    {"F",       "F",            32,     copy4},
-    {"F",       "F;8",          8,      unpackF8},
-    {"F",       "F;8S",         8,      unpackF8S},
-    {"F",       "F;16",         16,     unpackF16},
-    {"F",       "F;16S",        16,     unpackF16S},
-    {"F",       "F;16B",        16,     unpackF16B},
-    {"F",       "F;16BS",       16,     unpackF16BS},
-    {"F",       "F;16N",        16,     unpackF16N},
-    {"F",       "F;16NS",       16,     unpackF16NS},
-    {"F",       "F;32",         32,     unpackF32},
-    {"F",       "F;32S",        32,     unpackF32S},
-    {"F",       "F;32B",        32,     unpackF32B},
-    {"F",       "F;32BS",       32,     unpackF32BS},
-    {"F",       "F;32N",        32,     unpackF32N},
-    {"F",       "F;32NS",       32,     unpackF32NS},
-    {"F",       "F;32F",        32,     unpackF32F},
-    {"F",       "F;32BF",       32,     unpackF32BF},
-    {"F",       "F;32NF",       32,     unpackF32NF},
+    {"F", "F", 32, copy4},
+    {"F", "F;8", 8, unpackF8},
+    {"F", "F;8S", 8, unpackF8S},
+    {"F", "F;16", 16, unpackF16},
+    {"F", "F;16S", 16, unpackF16S},
+    {"F", "F;16B", 16, unpackF16B},
+    {"F", "F;16BS", 16, unpackF16BS},
+    {"F", "F;16N", 16, unpackF16N},
+    {"F", "F;16NS", 16, unpackF16NS},
+    {"F", "F;32", 32, unpackF32},
+    {"F", "F;32S", 32, unpackF32S},
+    {"F", "F;32B", 32, unpackF32B},
+    {"F", "F;32BS", 32, unpackF32BS},
+    {"F", "F;32N", 32, unpackF32N},
+    {"F", "F;32NS", 32, unpackF32NS},
+    {"F", "F;32F", 32, unpackF32F},
+    {"F", "F;32BF", 32, unpackF32BF},
+    {"F", "F;32NF", 32, unpackF32NF},
 #ifdef FLOAT64
-    {"F",       "F;64F",        64,     unpackF64F},
-    {"F",       "F;64BF",       64,     unpackF64BF},
-    {"F",       "F;64NF",       64,     unpackF64NF},
+    {"F", "F;64F", 64, unpackF64F},
+    {"F", "F;64BF", 64, unpackF64BF},
+    {"F", "F;64NF", 64, unpackF64NF},
 #endif

     /* storage modes */
-    {"I;16",    "I;16",         16,     copy2},
-    {"I;16B",   "I;16B",        16,     copy2},
-    {"I;16L",   "I;16L",        16,     copy2},
-
-    {"I;16",    "I;16N",        16,     unpackI16N_I16}, // LibTiff native->image endian.
-    {"I;16L",   "I;16N",        16,     unpackI16N_I16}, // LibTiff native->image endian.
-    {"I;16B",   "I;16N",        16,     unpackI16N_I16B},
-
-    {"I;16",    "I;12",         12,     unpackI12_I16}, // 12 bit Tiffs stored in 16bits.
+    {"I;16", "I;16", 16, copy2},
+    {"I;16B", "I;16B", 16, copy2},
+    {"I;16L", "I;16L", 16, copy2},
+
+    {"I;16", "I;16N", 16, unpackI16N_I16},   // LibTiff native->image endian.
+    {"I;16L", "I;16N", 16, unpackI16N_I16},  // LibTiff native->image endian.
+    {"I;16B", "I;16N", 16, unpackI16N_I16B},
+
+    {"I;16", "I;16R", 16, unpackI16R_I16},
+
+    {"I;16", "I;12", 12, unpackI12_I16},  // 12 bit Tiffs stored in 16bits.

     {NULL} /* sentinel */
 };

-
 ImagingShuffler
-ImagingFindUnpacker(const char* mode, const char* rawmode, int* bits_out)
-{
+ImagingFindUnpacker(const char *mode, const char *rawmode, int *bits_out) {
     int i;

     /* find a suitable pixel unpacker */
('src/libImaging', 'ZipDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,23 +15,22 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-#ifdef  HAVE_LIBZ
+#ifdef HAVE_LIBZ

 #include "ZipCodecs.h"

-static const int OFFSET[] = { 7, 3, 3, 1, 1, 0, 0 };
-static const int STARTING_COL[] = { 0, 4, 0, 2, 0, 1, 0 };
-static const int STARTING_ROW[] = { 0, 0, 4, 0, 2, 0, 1 };
-static const int COL_INCREMENT[] = { 8, 8, 4, 4, 2, 2, 1 };
-static const int ROW_INCREMENT[] = { 8, 8, 8, 4, 4, 2, 2 };
+static const int OFFSET[] = {7, 3, 3, 1, 1, 0, 0};
+static const int STARTING_COL[] = {0, 4, 0, 2, 0, 1, 0};
+static const int STARTING_ROW[] = {0, 0, 4, 0, 2, 0, 1};
+static const int COL_INCREMENT[] = {8, 8, 4, 4, 2, 2, 1};
+static const int ROW_INCREMENT[] = {8, 8, 8, 4, 4, 2, 2};

 /* Get the length in bytes of a scanline in the pass specified,
  * for interlaced images */
-static int get_row_len(ImagingCodecState state, int pass)
-{
+static int
+get_row_len(ImagingCodecState state, int pass) {
     int row_len = (state->xsize + OFFSET[pass]) / COL_INCREMENT[pass];
     return ((row_len * state->bits) + 7) / 8;
 }
@@ -41,17 +40,15 @@
 /* -------------------------------------------------------------------- */

 int
-ImagingZipDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
-    ZIPSTATE* context = (ZIPSTATE*) state->context;
+ImagingZipDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
+    ZIPSTATE *context = (ZIPSTATE *)state->context;
     int err;
     int n;
-    UINT8* ptr;
+    UINT8 *ptr;
     int i, bpp;
     int row_len;

     if (!state->state) {
-
         /* Initialization */
         if (context->mode == ZIP_PNG || context->mode == ZIP_PNG_PALETTE) {
             context->prefix = 1; /* PNG */
@@ -66,8 +63,8 @@
            prefix, and allocate a buffer to hold the previous line */
         free(state->buffer);
         /* malloc check ok, overflow checked above */
-        state->buffer = (UINT8*) malloc(state->bytes+1);
-        context->previous = (UINT8*) malloc(state->bytes+1);
+        state->buffer = (UINT8 *)malloc(state->bytes + 1);
+        context->previous = (UINT8 *)malloc(state->bytes + 1);
         if (!state->buffer || !context->previous) {
             state->errcode = IMAGING_CODEC_MEMORY;
             return -1;
@@ -76,12 +73,12 @@
         context->last_output = 0;

         /* Initialize to black */
-        memset(context->previous, 0, state->bytes+1);
+        memset(context->previous, 0, state->bytes + 1);

         /* Setup decompression context */
-        context->z_stream.zalloc = (alloc_func) NULL;
-        context->z_stream.zfree = (free_func) NULL;
-        context->z_stream.opaque = (voidpf) NULL;
+        context->z_stream.zalloc = (alloc_func)NULL;
+        context->z_stream.zfree = (free_func)NULL;
+        context->z_stream.opaque = (voidpf)NULL;

         err = inflateInit(&context->z_stream);
         if (err < 0) {
@@ -98,7 +95,6 @@

         /* Ready to decode */
         state->state = 1;
-
     }

     if (context->interlaced) {
@@ -113,10 +109,8 @@

     /* Decompress what we've got this far */
     while (context->z_stream.avail_in > 0) {
-
         context->z_stream.next_out = state->buffer + context->last_output;
-        context->z_stream.avail_out =
-            row_len + context->prefix - context->last_output;
+        context->z_stream.avail_out = row_len + context->prefix - context->last_output;

         err = inflate(&context->z_stream, Z_NO_FLUSH);

@@ -144,74 +138,74 @@

         /* Apply predictor */
         switch (context->mode) {
-        case ZIP_PNG:
-            switch (state->buffer[0]) {
-            case 0:
+            case ZIP_PNG:
+                switch (state->buffer[0]) {
+                    case 0:
+                        break;
+                    case 1:
+                        /* prior */
+                        bpp = (state->bits + 7) / 8;
+                        for (i = bpp + 1; i <= row_len; i++) {
+                            state->buffer[i] += state->buffer[i - bpp];
+                        }
+                        break;
+                    case 2:
+                        /* up */
+                        for (i = 1; i <= row_len; i++) {
+                            state->buffer[i] += context->previous[i];
+                        }
+                        break;
+                    case 3:
+                        /* average */
+                        bpp = (state->bits + 7) / 8;
+                        for (i = 1; i <= bpp; i++) {
+                            state->buffer[i] += context->previous[i] / 2;
+                        }
+                        for (; i <= row_len; i++) {
+                            state->buffer[i] +=
+                                (state->buffer[i - bpp] + context->previous[i]) / 2;
+                        }
+                        break;
+                    case 4:
+                        /* paeth filtering */
+                        bpp = (state->bits + 7) / 8;
+                        for (i = 1; i <= bpp; i++) {
+                            state->buffer[i] += context->previous[i];
+                        }
+                        for (; i <= row_len; i++) {
+                            int a, b, c;
+                            int pa, pb, pc;
+
+                            /* fetch pixels */
+                            a = state->buffer[i - bpp];
+                            b = context->previous[i];
+                            c = context->previous[i - bpp];
+
+                            /* distances to surrounding pixels */
+                            pa = abs(b - c);
+                            pb = abs(a - c);
+                            pc = abs(a + b - 2 * c);
+
+                            /* pick predictor with the shortest distance */
+                            state->buffer[i] += (pa <= pb && pa <= pc) ? a
+                                                : (pb <= pc)           ? b
+                                                                       : c;
+                        }
+                        break;
+                    default:
+                        state->errcode = IMAGING_CODEC_UNKNOWN;
+                        free(context->previous);
+                        context->previous = NULL;
+                        inflateEnd(&context->z_stream);
+                        return -1;
+                }
                 break;
-            case 1:
-                /* prior */
+            case ZIP_TIFF_PREDICTOR:
                 bpp = (state->bits + 7) / 8;
-                for (i = bpp+1; i <= row_len; i++) {
-                    state->buffer[i] += state->buffer[i-bpp];
+                for (i = bpp + 1; i <= row_len; i++) {
+                    state->buffer[i] += state->buffer[i - bpp];
                 }
                 break;
-            case 2:
-                /* up */
-                for (i = 1; i <= row_len; i++) {
-                    state->buffer[i] += context->previous[i];
-                }
-                break;
-            case 3:
-                /* average */
-                bpp = (state->bits + 7) / 8;
-                for (i = 1; i <= bpp; i++) {
-                    state->buffer[i] += context->previous[i]/2;
-                }
-                for (; i <= row_len; i++) {
-                    state->buffer[i] +=
-                        (state->buffer[i-bpp] + context->previous[i])/2;
-                }
-                break;
-            case 4:
-                /* paeth filtering */
-                bpp = (state->bits + 7) / 8;
-                for (i = 1; i <= bpp; i++) {
-                    state->buffer[i] += context->previous[i];
-                }
-                for (; i <= row_len; i++) {
-                    int a, b, c;
-                    int pa, pb, pc;
-
-                    /* fetch pixels */
-                    a = state->buffer[i-bpp];
-                    b = context->previous[i];
-                    c = context->previous[i-bpp];
-
-                    /* distances to surrounding pixels */
-                    pa = abs(b - c);
-                    pb = abs(a - c);
-                    pc = abs(a + b - 2*c);
-
-                    /* pick predictor with the shortest distance */
-                    state->buffer[i] +=
-                        (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;
-
-                }
-                break;
-            default:
-                state->errcode = IMAGING_CODEC_UNKNOWN;
-                free(context->previous);
-                context->previous = NULL;
-                inflateEnd(&context->z_stream);
-                return -1;
-            }
-            break;
-        case ZIP_TIFF_PREDICTOR:
-            bpp = (state->bits + 7) / 8;
-            for (i = bpp+1; i <= row_len; i++) {
-                state->buffer[i] += state->buffer[i-bpp];
-            }
-            break;
         }

         /* Stuff data into the image */
@@ -220,20 +214,22 @@
             if (state->bits >= 8) {
                 /* Stuff pixels in their correct location, one by one */
                 for (i = 0; i < row_len; i += ((state->bits + 7) / 8)) {
-                    state->shuffle((UINT8*) im->image[state->y] +
-                                   col * im->pixelsize,
-                                   state->buffer + context->prefix + i, 1);
+                    state->shuffle(
+                        (UINT8 *)im->image[state->y] + col * im->pixelsize,
+                        state->buffer + context->prefix + i,
+                        1);
                     col += COL_INCREMENT[context->pass];
                 }
             } else {
                 /* Handle case with more than a pixel in each byte */
-                int row_bits = ((state->xsize + OFFSET[context->pass])
-                        / COL_INCREMENT[context->pass]) * state->bits;
+                int row_bits = ((state->xsize + OFFSET[context->pass]) /
+                                COL_INCREMENT[context->pass]) *
+                               state->bits;
                 for (i = 0; i < row_bits; i += state->bits) {
                     UINT8 byte = *(state->buffer + context->prefix + (i / 8));
                     byte <<= (i % 8);
-                    state->shuffle((UINT8*) im->image[state->y] +
-                                   col * im->pixelsize, &byte, 1);
+                    state->shuffle(
+                        (UINT8 *)im->image[state->y] + col * im->pixelsize, &byte, 1);
                     col += COL_INCREMENT[context->pass];
                 }
             }
@@ -250,13 +246,14 @@
                 row_len = get_row_len(state, context->pass);
                 /* Since we're moving to the "first" line, the previous line
                  * should be black to make filters work correctly */
-                memset(state->buffer, 0, state->bytes+1);
+                memset(state->buffer, 0, state->bytes + 1);
             }
         } else {
-            state->shuffle((UINT8*) im->image[state->y + state->yoff] +
-                           state->xoff * im->pixelsize,
-                           state->buffer + context->prefix,
-                           state->xsize);
+            state->shuffle(
+                (UINT8 *)im->image[state->y + state->yoff] +
+                    state->xoff * im->pixelsize,
+                state->buffer + context->prefix,
+                state->xsize);
             state->y++;
         }

@@ -264,7 +261,6 @@
         context->last_output = 0;

         if (state->y >= state->ysize || err == Z_STREAM_END) {
-
             /* The image and the data should end simultaneously */
             /* if (state->y < state->ysize || err != Z_STREAM_END)
                 state->errcode = IMAGING_CODEC_BROKEN; */
@@ -273,26 +269,23 @@
             context->previous = NULL;
             inflateEnd(&context->z_stream);
             return -1; /* end of file (errcode=0) */
-
         }

         /* Swap buffer pointers */
         ptr = state->buffer;
         state->buffer = context->previous;
         context->previous = ptr;
-
     }

     return bytes; /* consumed all of it */
-
 }

-
-int ImagingZipDecodeCleanup(ImagingCodecState state){
+int
+ImagingZipDecodeCleanup(ImagingCodecState state) {
     /* called to free the decompression engine when the decode terminates
        due to a corrupt or truncated image
     */
-    ZIPSTATE* context = (ZIPSTATE*) state->context;
+    ZIPSTATE *context = (ZIPSTATE *)state->context;

     /* Clean up */
     if (context->previous) {
('src/libImaging', 'Convert.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -32,24 +32,21 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

-#define MAX(a, b) (a)>(b) ? (a) : (b)
-#define MIN(a, b) (a)<(b) ? (a) : (b)
-
-#define CLIP16(v) ((v) <= -32768 ? -32768 : (v) >= 32767 ? 32767 : (v))
+#define MAX(a, b) (a) > (b) ? (a) : (b)
+#define MIN(a, b) (a) < (b) ? (a) : (b)
+
+#define CLIP16(v) ((v) <= 0 ? 0 : (v) >= 65535 ? 65535 : (v))

 /* ITU-R Recommendation 601-2 (assuming nonlinear RGB) */
-#define L(rgb)\
-    ((INT32) (rgb)[0]*299 + (INT32) (rgb)[1]*587 + (INT32) (rgb)[2]*114)
-#define L24(rgb)\
-    ((rgb)[0]*19595 + (rgb)[1]*38470 + (rgb)[2]*7471 + 0x8000)
-
+#define L(rgb) ((INT32)(rgb)[0] * 299 + (INT32)(rgb)[1] * 587 + (INT32)(rgb)[2] * 114)
+#define L24(rgb) ((rgb)[0] * 19595 + (rgb)[1] * 38470 + (rgb)[2] * 7471 + 0x8000)

 #ifndef round
-double round(double x) {
-  return floor(x+0.5);
+double
+round(double x) {
+    return floor(x + 0.5);
 }
 #endif

@@ -58,16 +55,13 @@
 /* ------------------- */

 static void
-bit2l(UINT8* out, const UINT8* in, int xsize)
-{
-    int x;
-    for (x = 0; x < xsize; x++)
-        *out++ = (*in++ != 0) ? 255 : 0;
-}
-
-static void
-bit2rgb(UINT8* out, const UINT8* in, int xsize)
-{
+bit2l(UINT8 *out, const UINT8 *in, int xsize) {
+    int x;
+    for (x = 0; x < xsize; x++) *out++ = (*in++ != 0) ? 255 : 0;
+}
+
+static void
+bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         UINT8 v = (*in++ != 0) ? 255 : 0;
@@ -79,8 +73,7 @@
 }

 static void
-bit2cmyk(UINT8* out, const UINT8* in, int xsize)
-{
+bit2cmyk(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         *out++ = 0;
@@ -91,8 +84,7 @@
 }

 static void
-bit2ycbcr(UINT8* out, const UINT8* in, int xsize)
-{
+bit2ycbcr(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         *out++ = (*in++ != 0) ? 255 : 0;
@@ -103,8 +95,7 @@
 }

 static void
-bit2hsv(UINT8* out, const UINT8* in, int xsize)
-{
+bit2hsv(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, out += 4) {
         UINT8 v = (*in++ != 0) ? 255 : 0;
@@ -120,8 +111,7 @@
 /* ----------------- */

 static void
-l2bit(UINT8* out, const UINT8* in, int xsize)
-{
+l2bit(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         *out++ = (*in++ >= 128) ? 255 : 0;
@@ -129,44 +119,41 @@
 }

 static void
-lA2la(UINT8* out, const UINT8* in, int xsize)
-{
+lA2la(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     unsigned int alpha, pixel, tmp;
     for (x = 0; x < xsize; x++, in += 4) {
         alpha = in[3];
         pixel = MULDIV255(in[0], alpha, tmp);
-        *out++ = (UINT8) pixel;
-        *out++ = (UINT8) pixel;
-        *out++ = (UINT8) pixel;
-        *out++ = (UINT8) alpha;
+        *out++ = (UINT8)pixel;
+        *out++ = (UINT8)pixel;
+        *out++ = (UINT8)pixel;
+        *out++ = (UINT8)alpha;
     }
 }

 /* RGBa -> RGBA conversion to remove premultiplication
    Needed for correct transforms/resizing on RGBA images */
 static void
-la2lA(UINT8* out, const UINT8* in, int xsize)
-{
+la2lA(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     unsigned int alpha, pixel;
-    for (x = 0; x < xsize; x++, in+=4) {
+    for (x = 0; x < xsize; x++, in += 4) {
         alpha = in[3];
         if (alpha == 255 || alpha == 0) {
             pixel = in[0];
         } else {
             pixel = CLIP8((255 * in[0]) / alpha);
         }
-        *out++ = (UINT8) pixel;
-        *out++ = (UINT8) pixel;
-        *out++ = (UINT8) pixel;
-        *out++ = (UINT8) alpha;
-    }
-}
-
-static void
-l2la(UINT8* out, const UINT8* in, int xsize)
-{
+        *out++ = (UINT8)pixel;
+        *out++ = (UINT8)pixel;
+        *out++ = (UINT8)pixel;
+        *out++ = (UINT8)alpha;
+    }
+}
+
+static void
+l2la(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         UINT8 v = *in++;
@@ -178,8 +165,7 @@
 }

 static void
-l2rgb(UINT8* out, const UINT8* in, int xsize)
-{
+l2rgb(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         UINT8 v = *in++;
@@ -191,8 +177,7 @@
 }

 static void
-l2hsv(UINT8* out, const UINT8* in, int xsize)
-{
+l2hsv(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, out += 4) {
         UINT8 v = *in++;
@@ -204,8 +189,7 @@
 }

 static void
-la2l(UINT8* out, const UINT8* in, int xsize)
-{
+la2l(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
         *out++ = in[0];
@@ -213,8 +197,7 @@
 }

 static void
-la2rgb(UINT8* out, const UINT8* in, int xsize)
-{
+la2rgb(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
         UINT8 v = in[0];
@@ -226,8 +209,7 @@
 }

 static void
-la2hsv(UINT8* out, const UINT8* in, int xsize)
-{
+la2hsv(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out += 4) {
         UINT8 v = in[0];
@@ -239,8 +221,7 @@
 }

 static void
-rgb2bit(UINT8* out, const UINT8* in, int xsize)
-{
+rgb2bit(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
         /* ITU-R Recommendation 601-2 (assuming nonlinear RGB) */
@@ -249,8 +230,7 @@
 }

 static void
-rgb2l(UINT8* out, const UINT8* in, int xsize)
-{
+rgb2l(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
         /* ITU-R Recommendation 601-2 (assuming nonlinear RGB) */
@@ -259,8 +239,7 @@
 }

 static void
-rgb2la(UINT8* out, const UINT8* in, int xsize)
-{
+rgb2la(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out += 4) {
         /* ITU-R Recommendation 601-2 (assuming nonlinear RGB) */
@@ -270,8 +249,7 @@
 }

 static void
-rgb2i(UINT8* out_, const UINT8* in, int xsize)
-{
+rgb2i(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out_ += 4) {
         INT32 v = L24(in) >> 16;
@@ -280,44 +258,38 @@
 }

 static void
-rgb2f(UINT8* out_, const UINT8* in, int xsize)
-{
+rgb2f(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out_ += 4) {
-        FLOAT32 v = (float) L(in) / 1000.0F;
+        FLOAT32 v = (float)L(in) / 1000.0F;
         memcpy(out_, &v, sizeof(v));
     }
 }

 static void
-rgb2bgr15(UINT8* out_, const UINT8* in, int xsize)
-{
+rgb2bgr15(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out_ += 2) {
-        UINT16 v =
-            ((((UINT16)in[0])<<7)&0x7c00) +
-            ((((UINT16)in[1])<<2)&0x03e0) +
-            ((((UINT16)in[2])>>3)&0x001f);
+        UINT16 v = ((((UINT16)in[0]) << 7) & 0x7c00) +
+                   ((((UINT16)in[1]) << 2) & 0x03e0) +
+                   ((((UINT16)in[2]) >> 3) & 0x001f);
         memcpy(out_, &v, sizeof(v));
     }
 }

 static void
-rgb2bgr16(UINT8* out_, const UINT8* in, int xsize)
-{
+rgb2bgr16(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out_ += 2) {
-        UINT16 v =
-            ((((UINT16)in[0])<<8)&0xf800) +
-            ((((UINT16)in[1])<<3)&0x07e0) +
-            ((((UINT16)in[2])>>3)&0x001f);
+        UINT16 v = ((((UINT16)in[0]) << 8) & 0xf800) +
+                   ((((UINT16)in[1]) << 3) & 0x07e0) +
+                   ((((UINT16)in[2]) >> 3) & 0x001f);
         memcpy(out_, &v, sizeof(v));
     }
 }

 static void
-rgb2bgr24(UINT8* out, const UINT8* in, int xsize)
-{
+rgb2bgr24(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
         *out++ = in[2];
@@ -327,40 +299,39 @@
 }

 static void
-rgb2hsv_row(UINT8* out, const UINT8* in)
-{ // following colorsys.py
-    float h,s,rc,gc,bc,cr;
-    UINT8 maxc,minc;
+rgb2hsv_row(UINT8 *out, const UINT8 *in) {  // following colorsys.py
+    float h, s, rc, gc, bc, cr;
+    UINT8 maxc, minc;
     UINT8 r, g, b;
-    UINT8 uh,us,uv;
+    UINT8 uh, us, uv;

     r = in[0];
     g = in[1];
     b = in[2];
-    maxc = MAX(r,MAX(g,b));
-    minc = MIN(r,MIN(g,b));
+    maxc = MAX(r, MAX(g, b));
+    minc = MIN(r, MIN(g, b));
     uv = maxc;
-    if (minc == maxc){
+    if (minc == maxc) {
         uh = 0;
         us = 0;
     } else {
-        cr = (float)(maxc-minc);
-        s = cr/(float)maxc;
-        rc = ((float)(maxc-r))/cr;
-        gc = ((float)(maxc-g))/cr;
-        bc = ((float)(maxc-b))/cr;
+        cr = (float)(maxc - minc);
+        s = cr / (float)maxc;
+        rc = ((float)(maxc - r)) / cr;
+        gc = ((float)(maxc - g)) / cr;
+        bc = ((float)(maxc - b)) / cr;
         if (r == maxc) {
-            h = bc-gc;
+            h = bc - gc;
         } else if (g == maxc) {
-            h = 2.0 + rc-bc;
+            h = 2.0 + rc - bc;
         } else {
-            h = 4.0 + gc-rc;
+            h = 4.0 + gc - rc;
         }
         // incorrect hue happens if h/6 is negative.
-        h = fmod((h/6.0 + 1.0), 1.0);
-
-        uh = (UINT8)CLIP8((int)(h*255.0));
-        us = (UINT8)CLIP8((int)(s*255.0));
+        h = fmod((h / 6.0 + 1.0), 1.0);
+
+        uh = (UINT8)CLIP8((int)(h * 255.0));
+        us = (UINT8)CLIP8((int)(s * 255.0));
     }
     out[0] = uh;
     out[1] = us;
@@ -368,8 +339,7 @@
 }

 static void
-rgb2hsv(UINT8* out, const UINT8* in, int xsize)
-{
+rgb2hsv(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out += 4) {
         rgb2hsv_row(out, in);
@@ -377,98 +347,91 @@
     }
 }

-
-
-static void
-hsv2rgb(UINT8* out, const UINT8* in, int xsize)
-{ // following colorsys.py
-
-    int p,q,t;
-    UINT8 up,uq,ut;
+static void
+hsv2rgb(UINT8 *out, const UINT8 *in, int xsize) {  // following colorsys.py
+
+    int p, q, t;
+    UINT8 up, uq, ut;
     int i, x;
     float f, fs;
-    UINT8 h,s,v;
+    UINT8 h, s, v;

     for (x = 0; x < xsize; x++, in += 4) {
         h = in[0];
         s = in[1];
         v = in[2];

-        if (s==0){
+        if (s == 0) {
             *out++ = v;
             *out++ = v;
             *out++ = v;
         } else {
-            i = floor((float)h * 6.0 / 255.0); // 0 - 6
-            f = (float)h * 6.0 / 255.0 - (float)i; // 0-1 : remainder.
-            fs = ((float)s)/255.0;
-
-            p = round((float)v * (1.0-fs));
-            q = round((float)v * (1.0-fs*f));
-            t = round((float)v * (1.0-fs*(1.0-f)));
+            i = floor((float)h * 6.0 / 255.0);      // 0 - 6
+            f = (float)h * 6.0 / 255.0 - (float)i;  // 0-1 : remainder.
+            fs = ((float)s) / 255.0;
+
+            p = round((float)v * (1.0 - fs));
+            q = round((float)v * (1.0 - fs * f));
+            t = round((float)v * (1.0 - fs * (1.0 - f)));
             up = (UINT8)CLIP8(p);
             uq = (UINT8)CLIP8(q);
             ut = (UINT8)CLIP8(t);

-            switch (i%6) {
-            case 0:
-                *out++ = v;
-                *out++ = ut;
-                *out++ = up;
-                break;
-            case 1:
-                *out++ = uq;
-                *out++ = v;
-                *out++ = up;
-                break;
-            case 2:
-                *out++ = up;
-                *out++ = v;
-                *out++ = ut;
-                break;
-            case 3:
-                *out++ = up;
-                *out++ = uq;
-                *out++ = v;
-                break;
-            case 4:
-                *out++ = ut;
-                *out++ = up;
-                *out++ = v;
-                break;
-            case 5:
-                *out++ = v;
-                *out++ = up;
-                *out++ = uq;
-                break;
-
+            switch (i % 6) {
+                case 0:
+                    *out++ = v;
+                    *out++ = ut;
+                    *out++ = up;
+                    break;
+                case 1:
+                    *out++ = uq;
+                    *out++ = v;
+                    *out++ = up;
+                    break;
+                case 2:
+                    *out++ = up;
+                    *out++ = v;
+                    *out++ = ut;
+                    break;
+                case 3:
+                    *out++ = up;
+                    *out++ = uq;
+                    *out++ = v;
+                    break;
+                case 4:
+                    *out++ = ut;
+                    *out++ = up;
+                    *out++ = v;
+                    break;
+                case 5:
+                    *out++ = v;
+                    *out++ = up;
+                    *out++ = uq;
+                    break;
             }
         }
         *out++ = in[3];
     }
 }
-
-

 /* ---------------- */
 /* RGBA conversions */
 /* ---------------- */

 static void
-rgb2rgba(UINT8* out, const UINT8* in, int xsize)
-{
+rgb2rgba(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         *out++ = *in++;
         *out++ = *in++;
         *out++ = *in++;
-        *out++ = 255; in++;
-    }
-}
-
-static void
-rgba2la(UINT8* out, const UINT8* in, int xsize)
-{
+        *out++ = 255;
+        in++;
+    }
+}
+
+static void
+rgba2la(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out += 4) {
         /* ITU-R Recommendation 601-2 (assuming nonlinear RGB) */
@@ -478,20 +441,19 @@
 }

 static void
-rgba2rgb(UINT8* out, const UINT8* in, int xsize)
-{
+rgba2rgb(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         *out++ = *in++;
         *out++ = *in++;
         *out++ = *in++;
-        *out++ = 255; in++;
-    }
-}
-
-static void
-rgbA2rgba(UINT8* out, const UINT8* in, int xsize)
-{
+        *out++ = 255;
+        in++;
+    }
+}
+
+static void
+rgbA2rgba(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     unsigned int alpha, tmp;
     for (x = 0; x < xsize; x++) {
@@ -506,11 +468,10 @@
 /* RGBa -> RGBA conversion to remove premultiplication
    Needed for correct transforms/resizing on RGBA images */
 static void
-rgba2rgbA(UINT8* out, const UINT8* in, int xsize)
-{
+rgba2rgbA(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     unsigned int alpha;
-    for (x = 0; x < xsize; x++, in+=4) {
+    for (x = 0; x < xsize; x++, in += 4) {
         alpha = in[3];
         if (alpha == 255 || alpha == 0) {
             *out++ = in[0];
@@ -532,35 +493,32 @@
  */

 static void
-rgbT2rgba(UINT8* out, int xsize, int r, int g, int b)
-{
+rgbT2rgba(UINT8 *out, int xsize, int r, int g, int b) {
 #ifdef WORDS_BIGENDIAN
-    UINT32 trns = ((r & 0xff)<<24) | ((g & 0xff)<<16) | ((b & 0xff)<<8) | 0xff;
+    UINT32 trns = ((r & 0xff) << 24) | ((g & 0xff) << 16) | ((b & 0xff) << 8) | 0xff;
     UINT32 repl = trns & 0xffffff00;
 #else
-    UINT32 trns = (0xff <<24) | ((b & 0xff)<<16) | ((g & 0xff)<<8) | (r & 0xff);
+    UINT32 trns = (0xff << 24) | ((b & 0xff) << 16) | ((g & 0xff) << 8) | (r & 0xff);
     UINT32 repl = trns & 0x00ffffff;
 #endif

     int i;

-    for (i=0; i < xsize; i++ ,out += sizeof(trns)) {
+    for (i = 0; i < xsize; i++, out += sizeof(trns)) {
         UINT32 v;
         memcpy(&v, out, sizeof(v));
-        if (v==trns) {
+        if (v == trns) {
             memcpy(out, &repl, sizeof(repl));
         }
     }
 }
-

 /* ---------------- */
 /* CMYK conversions */
 /* ---------------- */

 static void
-l2cmyk(UINT8* out, const UINT8* in, int xsize)
-{
+l2cmyk(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         *out++ = 0;
@@ -571,8 +529,7 @@
 }

 static void
-la2cmyk(UINT8* out, const UINT8* in, int xsize)
-{
+la2cmyk(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
         *out++ = 0;
@@ -583,21 +540,20 @@
 }

 static void
-rgb2cmyk(UINT8* out, const UINT8* in, int xsize)
-{
+rgb2cmyk(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         /* Note: no undercolour removal */
         *out++ = ~(*in++);
         *out++ = ~(*in++);
         *out++ = ~(*in++);
-        *out++ = 0; in++;
-    }
-}
-
-static void
-cmyk2rgb(UINT8* out, const UINT8* in, int xsize)
-{
+        *out++ = 0;
+        in++;
+    }
+}
+
+static void
+cmyk2rgb(UINT8 *out, const UINT8 *in, int xsize) {
     int x, nk, tmp;
     for (x = 0; x < xsize; x++) {
         nk = 255 - in[3];
@@ -611,8 +567,7 @@
 }

 static void
-cmyk2hsv(UINT8* out, const UINT8* in, int xsize)
-{
+cmyk2hsv(UINT8 *out, const UINT8 *in, int xsize) {
     int x, nk, tmp;
     for (x = 0; x < xsize; x++) {
         nk = 255 - in[3];
@@ -631,8 +586,7 @@
 /* ------------- */

 static void
-bit2i(UINT8* out_, const UINT8* in, int xsize)
-{
+bit2i(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, out_ += 4) {
         INT32 v = (*in++ != 0) ? 255 : 0;
@@ -641,8 +595,7 @@
 }

 static void
-l2i(UINT8* out_, const UINT8* in, int xsize)
-{
+l2i(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, out_ += 4) {
         INT32 v = *in++;
@@ -651,8 +604,7 @@
 }

 static void
-i2l(UINT8* out, const UINT8* in_, int xsize)
-{
+i2l(UINT8 *out, const UINT8 *in_, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, out++, in_ += 4) {
         INT32 v;
@@ -662,14 +614,13 @@
         } else if (v >= 255) {
             *out = 255;
         } else {
-            *out = (UINT8) v;
-        }
-    }
-}
-
-static void
-i2f(UINT8* out_, const UINT8* in_, int xsize)
-{
+            *out = (UINT8)v;
+        }
+    }
+}
+
+static void
+i2f(UINT8 *out_, const UINT8 *in_, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in_ += 4, out_ += 4) {
         INT32 i;
@@ -681,28 +632,26 @@
 }

 static void
-i2rgb(UINT8* out, const UINT8* in_, int xsize)
-{
-    int x;
-    INT32* in = (INT32*) in_;
-    for (x = 0; x < xsize; x++, in++, out+=4) {
+i2rgb(UINT8 *out, const UINT8 *in_, int xsize) {
+    int x;
+    INT32 *in = (INT32 *)in_;
+    for (x = 0; x < xsize; x++, in++, out += 4) {
         if (*in <= 0) {
             out[0] = out[1] = out[2] = 0;
         } else if (*in >= 255) {
             out[0] = out[1] = out[2] = 255;
         } else {
-            out[0] = out[1] = out[2] = (UINT8) *in;
+            out[0] = out[1] = out[2] = (UINT8)*in;
         }
         out[3] = 255;
     }
 }

 static void
-i2hsv(UINT8* out, const UINT8* in_, int xsize)
-{
-    int x;
-    INT32* in = (INT32*) in_;
-    for (x = 0; x < xsize; x++, in++, out+=4) {
+i2hsv(UINT8 *out, const UINT8 *in_, int xsize) {
+    int x;
+    INT32 *in = (INT32 *)in_;
+    for (x = 0; x < xsize; x++, in++, out += 4) {
         out[0] = 0;
         out[1] = 0;
         if (*in <= 0) {
@@ -710,7 +659,7 @@
         } else if (*in >= 255) {
             out[2] = 255;
         } else {
-            out[2] = (UINT8) *in;
+            out[2] = (UINT8)*in;
         }
         out[3] = 255;
     }
@@ -721,8 +670,7 @@
 /* ------------- */

 static void
-bit2f(UINT8* out_, const UINT8* in, int xsize)
-{
+bit2f(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, out_ += 4) {
         FLOAT32 f = (*in++ != 0) ? 255.0F : 0.0F;
@@ -731,18 +679,16 @@
 }

 static void
-l2f(UINT8* out_, const UINT8* in, int xsize)
-{
+l2f(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, out_ += 4) {
-        FLOAT32 f = (FLOAT32) *in++;
+        FLOAT32 f = (FLOAT32)*in++;
         memcpy(out_, &f, sizeof(f));
     }
 }

 static void
-f2l(UINT8* out, const UINT8* in_, int xsize)
-{
+f2l(UINT8 *out, const UINT8 *in_, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, out++, in_ += 4) {
         FLOAT32 v;
@@ -752,14 +698,13 @@
         } else if (v >= 255.0) {
             *out = 255;
         } else {
-            *out = (UINT8) v;
-        }
-    }
-}
-
-static void
-f2i(UINT8* out_, const UINT8* in_, int xsize)
-{
+            *out = (UINT8)v;
+        }
+    }
+}
+
+static void
+f2i(UINT8 *out_, const UINT8 *in_, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in_ += 4, out_ += 4) {
         FLOAT32 f;
@@ -777,8 +722,7 @@
 /* See ConvertYCbCr.c for RGB/YCbCr tables */

 static void
-l2ycbcr(UINT8* out, const UINT8* in, int xsize)
-{
+l2ycbcr(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++) {
         *out++ = *in++;
@@ -789,8 +733,7 @@
 }

 static void
-la2ycbcr(UINT8* out, const UINT8* in, int xsize)
-{
+la2ycbcr(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
         *out++ = in[0];
@@ -801,8 +744,7 @@
 }

 static void
-ycbcr2l(UINT8* out, const UINT8* in, int xsize)
-{
+ycbcr2l(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
         *out++ = in[0];
@@ -810,8 +752,7 @@
 }

 static void
-ycbcr2la(UINT8* out, const UINT8* in, int xsize)
-{
+ycbcr2la(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out += 4) {
         out[0] = out[1] = out[2] = in[0];
@@ -824,77 +765,67 @@
 /* ------------------------- */

 static void
-I_I16L(UINT8* out, const UINT8* in_, int xsize)
-{
+I_I16L(UINT8 *out, const UINT8 *in_, int xsize) {
     int x, v;
     for (x = 0; x < xsize; x++, in_ += 4) {
         INT32 i;
         memcpy(&i, in_, sizeof(i));
         v = CLIP16(i);
-        *out++ = (UINT8) v;
-        *out++ = (UINT8) (v >> 8);
-    }
-}
-
-static void
-I_I16B(UINT8* out, const UINT8* in_, int xsize)
-{
+        *out++ = (UINT8)v;
+        *out++ = (UINT8)(v >> 8);
+    }
+}
+
+static void
+I_I16B(UINT8 *out, const UINT8 *in_, int xsize) {
     int x, v;
     for (x = 0; x < xsize; x++, in_ += 4) {
         INT32 i;
         memcpy(&i, in_, sizeof(i));
         v = CLIP16(i);
-        *out++ = (UINT8) (v >> 8);
-        *out++ = (UINT8) v;
-    }
-}
-
-
-static void
-I16L_I(UINT8* out_, const UINT8* in, int xsize)
-{
+        *out++ = (UINT8)(v >> 8);
+        *out++ = (UINT8)v;
+    }
+}
+
+static void
+I16L_I(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
-        INT32 v = in[0] + ((int) in[1] << 8);
+        INT32 v = in[0] + ((int)in[1] << 8);
         memcpy(out_, &v, sizeof(v));
     }
 }

-
-static void
-I16B_I(UINT8* out_, const UINT8* in, int xsize)
-{
+static void
+I16B_I(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
-        INT32 v = in[1] + ((int) in[0] << 8);
+        INT32 v = in[1] + ((int)in[0] << 8);
         memcpy(out_, &v, sizeof(v));
     }
 }

 static void
-I16L_F(UINT8* out_, const UINT8* in, int xsize)
-{
+I16L_F(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
-        FLOAT32 v = in[0] + ((int) in[1] << 8);
+        FLOAT32 v = in[0] + ((int)in[1] << 8);
         memcpy(out_, &v, sizeof(v));
     }
 }

-
-static void
-I16B_F(UINT8* out_, const UINT8* in, int xsize)
-{
+static void
+I16B_F(UINT8 *out_, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
-        FLOAT32 v = in[1] + ((int) in[0] << 8);
+        FLOAT32 v = in[1] + ((int)in[0] << 8);
         memcpy(out_, &v, sizeof(v));
     }
 }

 static void
-L_I16L(UINT8* out, const UINT8* in, int xsize)
-{
+L_I16L(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in++) {
         *out++ = *in;
@@ -903,8 +834,7 @@
 }

 static void
-L_I16B(UINT8* out, const UINT8* in, int xsize)
-{
+L_I16B(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in++) {
         *out++ = 0;
@@ -913,8 +843,7 @@
 }

 static void
-I16L_L(UINT8* out, const UINT8* in, int xsize)
-{
+I16L_L(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 2) {
         if (in[1] != 0) {
@@ -926,8 +855,7 @@
 }

 static void
-I16B_L(UINT8* out, const UINT8* in, int xsize)
-{
+I16B_L(UINT8 *out, const UINT8 *in, int xsize) {
     int x;
     for (x = 0; x < xsize; x++, in += 2) {
         if (in[0] != 0) {
@@ -939,123 +867,122 @@
 }

 static struct {
-    const char* from;
-    const char* to;
+    const char *from;
+    const char *to;
     ImagingShuffler convert;
 } converters[] = {

-    { "1", "L", bit2l },
-    { "1", "I", bit2i },
-    { "1", "F", bit2f },
-    { "1", "RGB", bit2rgb },
-    { "1", "RGBA", bit2rgb },
-    { "1", "RGBX", bit2rgb },
-    { "1", "CMYK", bit2cmyk },
-    { "1", "YCbCr", bit2ycbcr },
-    { "1", "HSV", bit2hsv },
-
-    { "L", "1", l2bit },
-    { "L", "LA", l2la },
-    { "L", "I", l2i },
-    { "L", "F", l2f },
-    { "L", "RGB", l2rgb },
-    { "L", "RGBA", l2rgb },
-    { "L", "RGBX", l2rgb },
-    { "L", "CMYK", l2cmyk },
-    { "L", "YCbCr", l2ycbcr },
-    { "L", "HSV", l2hsv },
-
-    { "LA", "L", la2l },
-    { "LA", "La", lA2la },
-    { "LA", "RGB", la2rgb },
-    { "LA", "RGBA", la2rgb },
-    { "LA", "RGBX", la2rgb },
-    { "LA", "CMYK", la2cmyk },
-    { "LA", "YCbCr", la2ycbcr },
-    { "LA", "HSV", la2hsv },
-
-    { "La", "LA", la2lA },
-
-    { "I", "L", i2l },
-    { "I", "F", i2f },
-    { "I", "RGB", i2rgb },
-    { "I", "RGBA", i2rgb },
-    { "I", "RGBX", i2rgb },
-    { "I", "HSV", i2hsv },
-
-    { "F", "L", f2l },
-    { "F", "I", f2i },
-
-    { "RGB", "1", rgb2bit },
-    { "RGB", "L", rgb2l },
-    { "RGB", "LA", rgb2la },
-    { "RGB", "I", rgb2i },
-    { "RGB", "F", rgb2f },
-    { "RGB", "BGR;15", rgb2bgr15 },
-    { "RGB", "BGR;16", rgb2bgr16 },
-    { "RGB", "BGR;24", rgb2bgr24 },
-    { "RGB", "RGBA", rgb2rgba },
-    { "RGB", "RGBX", rgb2rgba },
-    { "RGB", "CMYK", rgb2cmyk },
-    { "RGB", "YCbCr", ImagingConvertRGB2YCbCr },
-    { "RGB", "HSV", rgb2hsv },
-
-    { "RGBA", "1", rgb2bit },
-    { "RGBA", "L", rgb2l },
-    { "RGBA", "LA", rgba2la },
-    { "RGBA", "I", rgb2i },
-    { "RGBA", "F", rgb2f },
-    { "RGBA", "RGB", rgba2rgb },
-    { "RGBA", "RGBa", rgbA2rgba },
-    { "RGBA", "RGBX", rgb2rgba },
-    { "RGBA", "CMYK", rgb2cmyk },
-    { "RGBA", "YCbCr", ImagingConvertRGB2YCbCr },
-    { "RGBA", "HSV", rgb2hsv },
-
-    { "RGBa", "RGBA", rgba2rgbA },
-
-    { "RGBX", "1", rgb2bit },
-    { "RGBX", "L", rgb2l },
-    { "RGBX", "LA", rgb2la },
-    { "RGBX", "I", rgb2i },
-    { "RGBX", "F", rgb2f },
-    { "RGBX", "RGB", rgba2rgb },
-    { "RGBX", "CMYK", rgb2cmyk },
-    { "RGBX", "YCbCr", ImagingConvertRGB2YCbCr },
-    { "RGBX", "HSV", rgb2hsv },
-
-    { "CMYK", "RGB",  cmyk2rgb },
-    { "CMYK", "RGBA", cmyk2rgb },
-    { "CMYK", "RGBX", cmyk2rgb },
-    { "CMYK", "HSV", cmyk2hsv },
-
-    { "YCbCr", "L", ycbcr2l },
-    { "YCbCr", "LA", ycbcr2la },
-    { "YCbCr", "RGB", ImagingConvertYCbCr2RGB },
-
-    { "HSV", "RGB", hsv2rgb },
-
-    { "I", "I;16", I_I16L },
-    { "I;16", "I", I16L_I },
-    { "L", "I;16", L_I16L },
-    { "I;16", "L", I16L_L },
-
-    { "I", "I;16L", I_I16L },
-    { "I;16L", "I", I16L_I },
-    { "I", "I;16B", I_I16B },
-    { "I;16B", "I", I16B_I },
-
-    { "L", "I;16L", L_I16L },
-    { "I;16L", "L", I16L_L },
-    { "L", "I;16B", L_I16B },
-    { "I;16B", "L", I16B_L },
-
-    { "I;16", "F", I16L_F },
-    { "I;16L", "F", I16L_F },
-    { "I;16B", "F", I16B_F },
-
-    { NULL }
-};
+    {"1", "L", bit2l},
+    {"1", "I", bit2i},
+    {"1", "F", bit2f},
+    {"1", "RGB", bit2rgb},
+    {"1", "RGBA", bit2rgb},
+    {"1", "RGBX", bit2rgb},
+    {"1", "CMYK", bit2cmyk},
+    {"1", "YCbCr", bit2ycbcr},
+    {"1", "HSV", bit2hsv},
+
+    {"L", "1", l2bit},
+    {"L", "LA", l2la},
+    {"L", "I", l2i},
+    {"L", "F", l2f},
+    {"L", "RGB", l2rgb},
+    {"L", "RGBA", l2rgb},
+    {"L", "RGBX", l2rgb},
+    {"L", "CMYK", l2cmyk},
+    {"L", "YCbCr", l2ycbcr},
+    {"L", "HSV", l2hsv},
+
+    {"LA", "L", la2l},
+    {"LA", "La", lA2la},
+    {"LA", "RGB", la2rgb},
+    {"LA", "RGBA", la2rgb},
+    {"LA", "RGBX", la2rgb},
+    {"LA", "CMYK", la2cmyk},
+    {"LA", "YCbCr", la2ycbcr},
+    {"LA", "HSV", la2hsv},
+
+    {"La", "LA", la2lA},
+
+    {"I", "L", i2l},
+    {"I", "F", i2f},
+    {"I", "RGB", i2rgb},
+    {"I", "RGBA", i2rgb},
+    {"I", "RGBX", i2rgb},
+    {"I", "HSV", i2hsv},
+
+    {"F", "L", f2l},
+    {"F", "I", f2i},
+
+    {"RGB", "1", rgb2bit},
+    {"RGB", "L", rgb2l},
+    {"RGB", "LA", rgb2la},
+    {"RGB", "I", rgb2i},
+    {"RGB", "F", rgb2f},
+    {"RGB", "BGR;15", rgb2bgr15},
+    {"RGB", "BGR;16", rgb2bgr16},
+    {"RGB", "BGR;24", rgb2bgr24},
+    {"RGB", "RGBA", rgb2rgba},
+    {"RGB", "RGBX", rgb2rgba},
+    {"RGB", "CMYK", rgb2cmyk},
+    {"RGB", "YCbCr", ImagingConvertRGB2YCbCr},
+    {"RGB", "HSV", rgb2hsv},
+
+    {"RGBA", "1", rgb2bit},
+    {"RGBA", "L", rgb2l},
+    {"RGBA", "LA", rgba2la},
+    {"RGBA", "I", rgb2i},
+    {"RGBA", "F", rgb2f},
+    {"RGBA", "RGB", rgba2rgb},
+    {"RGBA", "RGBa", rgbA2rgba},
+    {"RGBA", "RGBX", rgb2rgba},
+    {"RGBA", "CMYK", rgb2cmyk},
+    {"RGBA", "YCbCr", ImagingConvertRGB2YCbCr},
+    {"RGBA", "HSV", rgb2hsv},
+
+    {"RGBa", "RGBA", rgba2rgbA},
+
+    {"RGBX", "1", rgb2bit},
+    {"RGBX", "L", rgb2l},
+    {"RGBX", "LA", rgb2la},
+    {"RGBX", "I", rgb2i},
+    {"RGBX", "F", rgb2f},
+    {"RGBX", "RGB", rgba2rgb},
+    {"RGBX", "CMYK", rgb2cmyk},
+    {"RGBX", "YCbCr", ImagingConvertRGB2YCbCr},
+    {"RGBX", "HSV", rgb2hsv},
+
+    {"CMYK", "RGB", cmyk2rgb},
+    {"CMYK", "RGBA", cmyk2rgb},
+    {"CMYK", "RGBX", cmyk2rgb},
+    {"CMYK", "HSV", cmyk2hsv},
+
+    {"YCbCr", "L", ycbcr2l},
+    {"YCbCr", "LA", ycbcr2la},
+    {"YCbCr", "RGB", ImagingConvertYCbCr2RGB},
+
+    {"HSV", "RGB", hsv2rgb},
+
+    {"I", "I;16", I_I16L},
+    {"I;16", "I", I16L_I},
+    {"L", "I;16", L_I16L},
+    {"I;16", "L", I16L_L},
+
+    {"I", "I;16L", I_I16L},
+    {"I;16L", "I", I16L_I},
+    {"I", "I;16B", I_I16B},
+    {"I;16B", "I", I16B_I},
+
+    {"L", "I;16L", L_I16L},
+    {"I;16L", "L", I16L_L},
+    {"L", "I;16B", L_I16B},
+    {"I;16B", "L", I16B_L},
+
+    {"I;16", "F", I16L_F},
+    {"I;16L", "F", I16L_F},
+    {"I;16B", "F", I16B_F},
+
+    {NULL}};

 /* FIXME: translate indexed versions to pointer versions below this line */

@@ -1064,127 +991,116 @@
 /* ------------------- */

 static void
-p2bit(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+p2bit(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     /* FIXME: precalculate greyscale palette? */
     for (x = 0; x < xsize; x++) {
-        *out++ = (L(&palette[in[x]*4]) >= 128000) ? 255 : 0;
-    }
-}
-
-static void
-pa2bit(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+        *out++ = (L(&palette->palette[in[x] * 4]) >= 128000) ? 255 : 0;
+    }
+}
+
+static void
+pa2bit(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     /* FIXME: precalculate greyscale palette? */
     for (x = 0; x < xsize; x++, in += 4) {
-        *out++ = (L(&palette[in[0]*4]) >= 128000) ? 255 : 0;
-    }
-}
-
-static void
-p2l(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+        *out++ = (L(&palette->palette[in[0] * 4]) >= 128000) ? 255 : 0;
+    }
+}
+
+static void
+p2l(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     /* FIXME: precalculate greyscale palette? */
     for (x = 0; x < xsize; x++) {
-        *out++ = L(&palette[in[x]*4]) / 1000;
-    }
-}
-
-static void
-pa2l(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+        *out++ = L24(&palette->palette[in[x] * 4]) >> 16;
+    }
+}
+
+static void
+pa2l(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     /* FIXME: precalculate greyscale palette? */
     for (x = 0; x < xsize; x++, in += 4) {
-        *out++ = L(&palette[in[0]*4]) / 1000;
-    }
-}
-
-static void
-p2pa(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
-    int x;
+        *out++ = L24(&palette->palette[in[0] * 4]) >> 16;
+    }
+}
+
+static void
+p2pa(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
+    int x;
+    int rgb = strcmp(palette->mode, "RGB");
     for (x = 0; x < xsize; x++, in++) {
-        const UINT8* rgba = &palette[in[0]];
+        const UINT8 *rgba = &palette->palette[in[0]];
         *out++ = in[0];
         *out++ = in[0];
         *out++ = in[0];
-        *out++ = rgba[3];
-    }
-}
-
-static void
-p2la(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+        *out++ = rgb == 0 ? 255 : rgba[3];
+    }
+}
+
+static void
+p2la(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     /* FIXME: precalculate greyscale palette? */
-    for (x = 0; x < xsize; x++, out+=4) {
-        const UINT8* rgba = &palette[*in++ * 4];
-        out[0] = out[1] = out[2] = L(rgba) / 1000;
+    for (x = 0; x < xsize; x++, out += 4) {
+        const UINT8 *rgba = &palette->palette[*in++ * 4];
+        out[0] = out[1] = out[2] = L24(rgba) >> 16;
         out[3] = rgba[3];
     }
 }

 static void
-pa2la(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+pa2la(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     /* FIXME: precalculate greyscale palette? */
     for (x = 0; x < xsize; x++, in += 4, out += 4) {
-        out[0] = out[1] = out[2] = L(&palette[in[0]*4]) / 1000;
+        out[0] = out[1] = out[2] = L24(&palette->palette[in[0] * 4]) >> 16;
         out[3] = in[3];
     }
 }

 static void
-p2i(UINT8* out_, const UINT8* in, int xsize, const UINT8* palette)
-{
+p2i(UINT8 *out_, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     for (x = 0; x < xsize; x++, out_ += 4) {
-        INT32 v = L(&palette[in[x]*4]) / 1000;
+        INT32 v = L24(&palette->palette[in[x] * 4]) >> 16;
         memcpy(out_, &v, sizeof(v));
     }
 }

 static void
-pa2i(UINT8* out_, const UINT8* in, int xsize, const UINT8* palette)
-{
-    int x;
-    INT32* out = (INT32*) out_;
+pa2i(UINT8 *out_, const UINT8 *in, int xsize, ImagingPalette palette) {
+    int x;
+    INT32 *out = (INT32 *)out_;
     for (x = 0; x < xsize; x++, in += 4) {
-        *out++ = L(&palette[in[0]*4]) / 1000;
-    }
-}
-
-static void
-p2f(UINT8* out_, const UINT8* in, int xsize, const UINT8* palette)
-{
+        *out++ = L24(&palette->palette[in[0] * 4]) >> 16;
+    }
+}
+
+static void
+p2f(UINT8 *out_, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     for (x = 0; x < xsize; x++, out_ += 4) {
-        FLOAT32 v = L(&palette[in[x]*4]) / 1000.0F;
+        FLOAT32 v = L(&palette->palette[in[x] * 4]) / 1000.0F;
         memcpy(out_, &v, sizeof(v));
     }
 }

 static void
-pa2f(UINT8* out_, const UINT8* in, int xsize, const UINT8* palette)
-{
-    int x;
-    FLOAT32* out = (FLOAT32*) out_;
+pa2f(UINT8 *out_, const UINT8 *in, int xsize, ImagingPalette palette) {
+    int x;
+    FLOAT32 *out = (FLOAT32 *)out_;
     for (x = 0; x < xsize; x++, in += 4) {
-        *out++ = (float) L(&palette[in[0]*4]) / 1000.0F;
-    }
-}
-
-static void
-p2rgb(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+        *out++ = (float)L(&palette->palette[in[0] * 4]) / 1000.0F;
+    }
+}
+
+static void
+p2rgb(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     for (x = 0; x < xsize; x++) {
-        const UINT8* rgb = &palette[*in++ * 4];
+        const UINT8 *rgb = &palette->palette[*in++ * 4];
         *out++ = rgb[0];
         *out++ = rgb[1];
         *out++ = rgb[2];
@@ -1193,11 +1109,10 @@
 }

 static void
-pa2rgb(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+pa2rgb(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
-        const UINT8* rgb = &palette[in[0] * 4];
+        const UINT8 *rgb = &palette->palette[in[0] * 4];
         *out++ = rgb[0];
         *out++ = rgb[1];
         *out++ = rgb[2];
@@ -1206,33 +1121,30 @@
 }

 static void
-p2hsv(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+p2hsv(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     for (x = 0; x < xsize; x++, out += 4) {
-        const UINT8* rgb = &palette[*in++ * 4];
+        const UINT8 *rgb = &palette->palette[*in++ * 4];
         rgb2hsv_row(out, rgb);
         out[3] = 255;
     }
 }

 static void
-pa2hsv(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+pa2hsv(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     for (x = 0; x < xsize; x++, in += 4, out += 4) {
-        const UINT8* rgb = &palette[in[0] * 4];
+        const UINT8 *rgb = &palette->palette[in[0] * 4];
         rgb2hsv_row(out, rgb);
         out[3] = 255;
     }
 }

 static void
-p2rgba(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+p2rgba(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     for (x = 0; x < xsize; x++) {
-        const UINT8* rgba = &palette[*in++ * 4];
+        const UINT8 *rgba = &palette->palette[*in++ * 4];
         *out++ = rgba[0];
         *out++ = rgba[1];
         *out++ = rgba[2];
@@ -1241,11 +1153,10 @@
 }

 static void
-pa2rgba(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+pa2rgba(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     int x;
     for (x = 0; x < xsize; x++, in += 4) {
-        const UINT8* rgb = &palette[in[0] * 4];
+        const UINT8 *rgb = &palette->palette[in[0] * 4];
         *out++ = rgb[0];
         *out++ = rgb[1];
         *out++ = rgb[2];
@@ -1254,45 +1165,40 @@
 }

 static void
-p2cmyk(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+p2cmyk(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     p2rgb(out, in, xsize, palette);
     rgb2cmyk(out, out, xsize);
 }

 static void
-pa2cmyk(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+pa2cmyk(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     pa2rgb(out, in, xsize, palette);
     rgb2cmyk(out, out, xsize);
 }

 static void
-p2ycbcr(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+p2ycbcr(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     p2rgb(out, in, xsize, palette);
     ImagingConvertRGB2YCbCr(out, out, xsize);
 }

 static void
-pa2ycbcr(UINT8* out, const UINT8* in, int xsize, const UINT8* palette)
-{
+pa2ycbcr(UINT8 *out, const UINT8 *in, int xsize, ImagingPalette palette) {
     pa2rgb(out, in, xsize, palette);
     ImagingConvertRGB2YCbCr(out, out, xsize);
 }

 static Imaging
-frompalette(Imaging imOut, Imaging imIn, const char *mode)
-{
+frompalette(Imaging imOut, Imaging imIn, const char *mode) {
     ImagingSectionCookie cookie;
     int alpha;
     int y;
-    void (*convert)(UINT8*, const UINT8*, int, const UINT8*);
+    void (*convert)(UINT8 *, const UINT8 *, int, ImagingPalette);

     /* Map palette image to L, RGB, RGBA, or CMYK */

     if (!imIn->palette) {
-        return (Imaging) ImagingError_ValueError("no palette");
+        return (Imaging)ImagingError_ValueError("no palette");
     }

     alpha = !strcmp(imIn->mode, "PA");
@@ -1311,9 +1217,7 @@
         convert = alpha ? pa2f : p2f;
     } else if (strcmp(mode, "RGB") == 0) {
         convert = alpha ? pa2rgb : p2rgb;
-    } else if (strcmp(mode, "RGBA") == 0) {
-        convert = alpha ? pa2rgba : p2rgba;
-    } else if (strcmp(mode, "RGBX") == 0) {
+    } else if (strcmp(mode, "RGBA") == 0 || strcmp(mode, "RGBX") == 0) {
         convert = alpha ? pa2rgba : p2rgba;
     } else if (strcmp(mode, "CMYK") == 0) {
         convert = alpha ? pa2cmyk : p2cmyk;
@@ -1322,7 +1226,7 @@
     } else if (strcmp(mode, "HSV") == 0) {
         convert = alpha ? pa2hsv : p2hsv;
     } else {
-        return (Imaging) ImagingError_ValueError("conversion not supported");
+        return (Imaging)ImagingError_ValueError("conversion not supported");
     }

     imOut = ImagingNew2Dirty(mode, imOut, imIn);
@@ -1332,8 +1236,11 @@

     ImagingSectionEnter(&cookie);
     for (y = 0; y < imIn->ysize; y++) {
-        (*convert)((UINT8*) imOut->image[y], (UINT8*) imIn->image[y],
-                   imIn->xsize, imIn->palette->palette);
+        (*convert)(
+            (UINT8 *)imOut->image[y],
+            (UINT8 *)imIn->image[y],
+            imIn->xsize,
+            imIn->palette);
     }
     ImagingSectionLeave(&cookie);

@@ -1344,39 +1251,44 @@
 #pragma optimize("", off)
 #endif
 static Imaging
-topalette(Imaging imOut, Imaging imIn, const char *mode, ImagingPalette inpalette, int dither)
-{
+topalette(
+    Imaging imOut,
+    Imaging imIn,
+    const char *mode,
+    ImagingPalette inpalette,
+    int dither) {
     ImagingSectionCookie cookie;
     int alpha;
     int x, y;
-    ImagingPalette palette = inpalette;;
+    ImagingPalette palette = inpalette;
+    ;

     /* Map L or RGB/RGBX/RGBA to palette image */
     if (strcmp(imIn->mode, "L") != 0 && strncmp(imIn->mode, "RGB", 3) != 0) {
-        return (Imaging) ImagingError_ValueError("conversion not supported");
+        return (Imaging)ImagingError_ValueError("conversion not supported");
     }

     alpha = !strcmp(mode, "PA");

     if (palette == NULL) {
-      /* FIXME: make user configurable */
-      if (imIn->bands == 1) {
-        palette = ImagingPaletteNew("RGB"); /* Initialised to grey ramp */
-      } else {
-        palette = ImagingPaletteNewBrowser(); /* Standard colour cube */
-      }
+        /* FIXME: make user configurable */
+        if (imIn->bands == 1) {
+            palette = ImagingPaletteNew("RGB"); /* Initialised to grey ramp */
+        } else {
+            palette = ImagingPaletteNewBrowser(); /* Standard colour cube */
+        }
     }

     if (!palette) {
-        return (Imaging) ImagingError_ValueError("no palette");
+        return (Imaging)ImagingError_ValueError("no palette");
     }

     imOut = ImagingNew2Dirty(mode, imOut, imIn);
     if (!imOut) {
-      if (palette != inpalette) {
-        ImagingPaletteDelete(palette);
-      }
-      return NULL;
+        if (palette != inpalette) {
+            ImagingPaletteDelete(palette);
+        }
+        return NULL;
     }

     ImagingPaletteDelete(imOut->palette);
@@ -1389,7 +1301,7 @@
         ImagingSectionEnter(&cookie);
         for (y = 0; y < imIn->ysize; y++) {
             if (alpha) {
-                l2la((UINT8*) imOut->image[y], (UINT8*) imIn->image[y], imIn->xsize);
+                l2la((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);
             } else {
                 memcpy(imOut->image[y], imIn->image[y], imIn->linesize);
             }
@@ -1403,7 +1315,7 @@
         if (ImagingPaletteCachePrepare(palette) < 0) {
             ImagingDelete(imOut);
             if (palette != inpalette) {
-              ImagingPaletteDelete(palette);
+                ImagingPaletteDelete(palette);
             }
             return NULL;
         }
@@ -1411,7 +1323,7 @@
         if (dither) {
             /* floyd-steinberg dither */

-            int* errors;
+            int *errors;
             errors = calloc(imIn->xsize + 1, sizeof(int) * 3);
             if (!errors) {
                 ImagingDelete(imOut);
@@ -1424,9 +1336,9 @@
                 int r, r0, r1, r2;
                 int g, g0, g1, g2;
                 int b, b0, b1, b2;
-                UINT8* in  = (UINT8*) imIn->image[y];
-                UINT8* out = alpha ? (UINT8*) imOut->image32[y] : imOut->image8[y];
-                int* e = errors;
+                UINT8 *in = (UINT8 *)imIn->image[y];
+                UINT8 *out = alpha ? (UINT8 *)imOut->image32[y] : imOut->image8[y];
+                int *e = errors;

                 r = r0 = r1 = 0;
                 g = g0 = g1 = 0;
@@ -1434,11 +1346,11 @@

                 for (x = 0; x < imIn->xsize; x++, in += 4) {
                     int d2;
-                    INT16* cache;
-
-                    r = CLIP8(in[0] + (r + e[3+0])/16);
-                    g = CLIP8(in[1] + (g + e[3+1])/16);
-                    b = CLIP8(in[2] + (b + e[3+2])/16);
+                    INT16 *cache;
+
+                    r = CLIP8(in[0] + (r + e[3 + 0]) / 16);
+                    g = CLIP8(in[1] + (g + e[3 + 1]) / 16);
+                    b = CLIP8(in[2] + (b + e[3 + 2]) / 16);

                     /* get closest colour */
                     cache = &ImagingPaletteCache(palette, r, g, b);
@@ -1446,49 +1358,66 @@
                         ImagingPaletteCacheUpdate(palette, r, g, b);
                     }
                     if (alpha) {
-                        out[x*4] = out[x*4+1] = out[x*4+2] = (UINT8) cache[0];
-                        out[x*4+3] = 255;
+                        out[x * 4] = out[x * 4 + 1] = out[x * 4 + 2] = (UINT8)cache[0];
+                        out[x * 4 + 3] = 255;
                     } else {
-                        out[x] = (UINT8) cache[0];
+                        out[x] = (UINT8)cache[0];
                     }

-                    r -= (int) palette->palette[cache[0]*4];
-                    g -= (int) palette->palette[cache[0]*4+1];
-                    b -= (int) palette->palette[cache[0]*4+2];
+                    r -= (int)palette->palette[cache[0] * 4];
+                    g -= (int)palette->palette[cache[0] * 4 + 1];
+                    b -= (int)palette->palette[cache[0] * 4 + 2];

                     /* propagate errors (don't ask ;-) */
-                    r2 = r; d2 = r + r; r += d2; e[0] = r + r0;
-                    r += d2; r0 = r + r1; r1 = r2; r += d2;
-                    g2 = g; d2 = g + g; g += d2; e[1] = g + g0;
-                    g += d2; g0 = g + g1; g1 = g2; g += d2;
-                    b2 = b; d2 = b + b; b += d2; e[2] = b + b0;
-                    b += d2; b0 = b + b1; b1 = b2; b += d2;
+                    r2 = r;
+                    d2 = r + r;
+                    r += d2;
+                    e[0] = r + r0;
+                    r += d2;
+                    r0 = r + r1;
+                    r1 = r2;
+                    r += d2;
+                    g2 = g;
+                    d2 = g + g;
+                    g += d2;
+                    e[1] = g + g0;
+                    g += d2;
+                    g0 = g + g1;
+                    g1 = g2;
+                    g += d2;
+                    b2 = b;
+                    d2 = b + b;
+                    b += d2;
+                    e[2] = b + b0;
+                    b += d2;
+                    b0 = b + b1;
+                    b1 = b2;
+                    b += d2;

                     e += 3;
-
                 }

                 e[0] = b0;
                 e[1] = b1;
                 e[2] = b2;
-
             }
             ImagingSectionLeave(&cookie);
             free(errors);

         } else {
-
             /* closest colour */
             ImagingSectionEnter(&cookie);
             for (y = 0; y < imIn->ysize; y++) {
                 int r, g, b;
-                UINT8* in  = (UINT8*) imIn->image[y];
-                UINT8* out = alpha ? (UINT8*) imOut->image32[y] : imOut->image8[y];
+                UINT8 *in = (UINT8 *)imIn->image[y];
+                UINT8 *out = alpha ? (UINT8 *)imOut->image32[y] : imOut->image8[y];

                 for (x = 0; x < imIn->xsize; x++, in += 4) {
-                    INT16* cache;
-
-                    r = in[0]; g = in[1]; b = in[2];
+                    INT16 *cache;
+
+                    r = in[0];
+                    g = in[1];
+                    b = in[2];

                     /* get closest colour */
                     cache = &ImagingPaletteCache(palette, r, g, b);
@@ -1496,38 +1425,36 @@
                         ImagingPaletteCacheUpdate(palette, r, g, b);
                     }
                     if (alpha) {
-                        out[x*4] = out[x*4+1] = out[x*4+2] = (UINT8) cache[0];
-                        out[x*4+3] = 255;
+                        out[x * 4] = out[x * 4 + 1] = out[x * 4 + 2] = (UINT8)cache[0];
+                        out[x * 4 + 3] = 255;
                     } else {
-                        out[x] = (UINT8) cache[0];
+                        out[x] = (UINT8)cache[0];
                     }
                 }
             }
             ImagingSectionLeave(&cookie);
-
         }
         if (inpalette != palette) {
-          ImagingPaletteCacheDelete(palette);
+            ImagingPaletteCacheDelete(palette);
         }
     }

     if (inpalette != palette) {
-      ImagingPaletteDelete(palette);
+        ImagingPaletteDelete(palette);
     }

     return imOut;
 }

 static Imaging
-tobilevel(Imaging imOut, Imaging imIn, int dither)
-{
+tobilevel(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int x, y;
-    int* errors;
+    int *errors;

     /* Map L or RGB to dithered 1 image */
     if (strcmp(imIn->mode, "L") != 0 && strcmp(imIn->mode, "RGB") != 0) {
-        return (Imaging) ImagingError_ValueError("conversion not supported");
+        return (Imaging)ImagingError_ValueError("conversion not supported");
     }

     imOut = ImagingNew2Dirty("1", imOut, imIn);
@@ -1542,59 +1469,64 @@
     }

     if (imIn->bands == 1) {
-
         /* map each pixel to black or white, using error diffusion */
         ImagingSectionEnter(&cookie);
         for (y = 0; y < imIn->ysize; y++) {
             int l, l0, l1, l2, d2;
-            UINT8* in  = (UINT8*) imIn->image[y];
-            UINT8* out = imOut->image8[y];
+            UINT8 *in = (UINT8 *)imIn->image[y];
+            UINT8 *out = imOut->image8[y];

             l = l0 = l1 = 0;

             for (x = 0; x < imIn->xsize; x++) {
-
                 /* pick closest colour */
-                l = CLIP8(in[x] + (l + errors[x+1])/16);
+                l = CLIP8(in[x] + (l + errors[x + 1]) / 16);
                 out[x] = (l > 128) ? 255 : 0;

                 /* propagate errors */
-                l -= (int) out[x];
-                l2 = l; d2 = l + l; l += d2; errors[x] = l + l0;
-                l += d2; l0 = l + l1; l1 = l2; l += d2;
+                l -= (int)out[x];
+                l2 = l;
+                d2 = l + l;
+                l += d2;
+                errors[x] = l + l0;
+                l += d2;
+                l0 = l + l1;
+                l1 = l2;
+                l += d2;
             }

             errors[x] = l0;
-
         }
         ImagingSectionLeave(&cookie);

     } else {
-
         /* map each pixel to black or white, using error diffusion */
         ImagingSectionEnter(&cookie);
         for (y = 0; y < imIn->ysize; y++) {
             int l, l0, l1, l2, d2;
-            UINT8* in  = (UINT8*) imIn->image[y];
-            UINT8* out = imOut->image8[y];
+            UINT8 *in = (UINT8 *)imIn->image[y];
+            UINT8 *out = imOut->image8[y];

             l = l0 = l1 = 0;

             for (x = 0; x < imIn->xsize; x++, in += 4) {
-
                 /* pick closest colour */
-                l = CLIP8(L(in)/1000 + (l + errors[x+1])/16);
+                l = CLIP8(L(in) / 1000 + (l + errors[x + 1]) / 16);
                 out[x] = (l > 128) ? 255 : 0;

                 /* propagate errors */
-                l -= (int) out[x];
-                l2 = l; d2 = l + l; l += d2; errors[x] = l + l0;
-                l += d2; l0 = l + l1; l1 = l2; l += d2;
-
+                l -= (int)out[x];
+                l2 = l;
+                d2 = l + l;
+                l += d2;
+                errors[x] = l + l0;
+                l += d2;
+                l0 = l + l1;
+                l1 = l2;
+                l += d2;
             }

             errors[x] = l0;
-
         }
         ImagingSectionLeave(&cookie);
     }
@@ -1608,21 +1540,20 @@
 #endif

 static Imaging
-convert(Imaging imOut, Imaging imIn, const char *mode,
-        ImagingPalette palette, int dither)
-{
+convert(
+    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {
     ImagingSectionCookie cookie;
     ImagingShuffler convert;
     int y;

     if (!imIn) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (!mode) {
         /* Map palette image to full depth */
         if (!imIn->palette) {
-            return (Imaging) ImagingError_ModeError();
+            return (Imaging)ImagingError_ModeError();
         }
         mode = imIn->palette->mode;
     } else {
@@ -1632,7 +1563,6 @@
         }
     }

-
     /* test for special conversions */

     if (strcmp(imIn->mode, "P") == 0 || strcmp(imIn->mode, "PA") == 0) {
@@ -1644,9 +1574,8 @@
     }

     if (dither && strcmp(mode, "1") == 0) {
-        return tobilevel(imOut, imIn, dither);
-    }
-
+        return tobilevel(imOut, imIn);
+    }

     /* standard conversion machinery */

@@ -1662,12 +1591,11 @@

     if (!convert) {
 #ifdef notdef
-        return (Imaging) ImagingError_ValueError("conversion not supported");
+        return (Imaging)ImagingError_ValueError("conversion not supported");
 #else
-        static char buf[256];
-        /* FIXME: may overflow if mode is too large */
-        sprintf(buf, "conversion from %s to %s not supported", imIn->mode, mode);
-        return (Imaging) ImagingError_ValueError(buf);
+        static char buf[100];
+        snprintf(buf, 100, "conversion from %.10s to %.10s not supported", imIn->mode, mode);
+        return (Imaging)ImagingError_ValueError(buf);
 #endif
     }

@@ -1678,8 +1606,7 @@

     ImagingSectionEnter(&cookie);
     for (y = 0; y < imIn->ysize; y++) {
-        (*convert)((UINT8*) imOut->image[y], (UINT8*) imIn->image[y],
-                   imIn->xsize);
+        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);
     }
     ImagingSectionLeave(&cookie);

@@ -1687,53 +1614,35 @@
 }

 Imaging
-ImagingConvert(Imaging imIn, const char *mode,
-               ImagingPalette palette, int dither)
-{
+ImagingConvert(Imaging imIn, const char *mode, ImagingPalette palette, int dither) {
     return convert(NULL, imIn, mode, palette, dither);
 }

 Imaging
-ImagingConvert2(Imaging imOut, Imaging imIn)
-{
+ImagingConvert2(Imaging imOut, Imaging imIn) {
     return convert(imOut, imIn, imOut->mode, NULL, 0);
 }

-
 Imaging
-ImagingConvertTransparent(Imaging imIn, const char *mode,
-                          int r, int g, int b)
-{
+ImagingConvertTransparent(Imaging imIn, const char *mode, int r, int g, int b) {
     ImagingSectionCookie cookie;
     ImagingShuffler convert;
     Imaging imOut = NULL;
     int y;

-    if (!imIn){
-        return (Imaging) ImagingError_ModeError();
-    }
-
-    if (!((strcmp(imIn->mode, "RGB") == 0 ||
-           strcmp(imIn->mode, "1") == 0 ||
-           strcmp(imIn->mode, "I") == 0 ||
-           strcmp(imIn->mode, "L") == 0)
-          && strcmp(mode, "RGBA") == 0))
-#ifdef notdef
-    {
-        return (Imaging) ImagingError_ValueError("conversion not supported");
-    }
-#else
-    {
-      static char buf[256];
-      /* FIXME: may overflow if mode is too large */
-      sprintf(buf, "conversion from %s to %s not supported in convert_transparent", imIn->mode, mode);
-      return (Imaging) ImagingError_ValueError(buf);
-    }
-#endif
-
-    if (strcmp(imIn->mode, "RGB") == 0) {
+    if (!imIn) {
+        return (Imaging)ImagingError_ModeError();
+    }
+
+    if (strcmp(imIn->mode, "RGB") == 0 && strcmp(mode, "RGBA") == 0) {
         convert = rgb2rgba;
-    } else {
+    } else if ((strcmp(imIn->mode, "1") == 0 ||
+                strcmp(imIn->mode, "I") == 0 ||
+                strcmp(imIn->mode, "L") == 0
+               ) && (
+                strcmp(mode, "RGBA") == 0 ||
+                strcmp(mode, "LA") == 0
+               )) {
         if (strcmp(imIn->mode, "1") == 0) {
             convert = bit2rgb;
         } else if (strcmp(imIn->mode, "I") == 0) {
@@ -1742,28 +1651,34 @@
             convert = l2rgb;
         }
         g = b = r;
+    } else {
+        static char buf[100];
+        snprintf(
+            buf,
+            100,
+            "conversion from %.10s to %.10s not supported in convert_transparent",
+            imIn->mode,
+            mode);
+        return (Imaging)ImagingError_ValueError(buf);
     }

     imOut = ImagingNew2Dirty(mode, imOut, imIn);
-    if (!imOut){
+    if (!imOut) {
         return NULL;
     }

     ImagingSectionEnter(&cookie);
     for (y = 0; y < imIn->ysize; y++) {
-        (*convert)((UINT8*) imOut->image[y], (UINT8*) imIn->image[y],
-                   imIn->xsize);
-        rgbT2rgba((UINT8*) imOut->image[y], imIn->xsize, r, g, b);
+        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);
+        rgbT2rgba((UINT8 *)imOut->image[y], imIn->xsize, r, g, b);
     }
     ImagingSectionLeave(&cookie);

     return imOut;
-
 }

 Imaging
-ImagingConvertInPlace(Imaging imIn, const char* mode)
-{
+ImagingConvertInPlace(Imaging imIn, const char *mode) {
     ImagingSectionCookie cookie;
     ImagingShuffler convert;
     int y;
@@ -1779,8 +1694,7 @@

     ImagingSectionEnter(&cookie);
     for (y = 0; y < imIn->ysize; y++) {
-        (*convert)((UINT8*) imIn->image[y], (UINT8*) imIn->image[y],
-                   imIn->xsize);
+        (*convert)((UINT8 *)imIn->image[y], (UINT8 *)imIn->image[y], imIn->xsize);
     }
     ImagingSectionLeave(&cookie);

('src/libImaging', 'ImagingUtils.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,47 +1,42 @@
 #ifdef WORDS_BIGENDIAN
-    #define MAKE_UINT32(u0, u1, u2, u3) ((UINT32)(u3) | ((UINT32)(u2)<<8) | ((UINT32)(u1)<<16) | ((UINT32)(u0)<<24))
-    #define MASK_UINT32_CHANNEL_0 0xff000000
-    #define MASK_UINT32_CHANNEL_1 0x00ff0000
-    #define MASK_UINT32_CHANNEL_2 0x0000ff00
-    #define MASK_UINT32_CHANNEL_3 0x000000ff
+#define MAKE_UINT32(u0, u1, u2, u3) \
+    ((UINT32)(u3) | ((UINT32)(u2) << 8) | ((UINT32)(u1) << 16) | ((UINT32)(u0) << 24))
+#define MASK_UINT32_CHANNEL_0 0xff000000
+#define MASK_UINT32_CHANNEL_1 0x00ff0000
+#define MASK_UINT32_CHANNEL_2 0x0000ff00
+#define MASK_UINT32_CHANNEL_3 0x000000ff
 #else
-    #define MAKE_UINT32(u0, u1, u2, u3) ((UINT32)(u0) | ((UINT32)(u1)<<8) | ((UINT32)(u2)<<16) | ((UINT32)(u3)<<24))
-    #define MASK_UINT32_CHANNEL_0 0x000000ff
-    #define MASK_UINT32_CHANNEL_1 0x0000ff00
-    #define MASK_UINT32_CHANNEL_2 0x00ff0000
-    #define MASK_UINT32_CHANNEL_3 0xff000000
+#define MAKE_UINT32(u0, u1, u2, u3) \
+    ((UINT32)(u0) | ((UINT32)(u1) << 8) | ((UINT32)(u2) << 16) | ((UINT32)(u3) << 24))
+#define MASK_UINT32_CHANNEL_0 0x000000ff
+#define MASK_UINT32_CHANNEL_1 0x0000ff00
+#define MASK_UINT32_CHANNEL_2 0x00ff0000
+#define MASK_UINT32_CHANNEL_3 0xff000000
 #endif

-
-#define SHIFTFORDIV255(a)\
-    ((((a) >> 8) + a) >> 8)
+#define SHIFTFORDIV255(a) ((((a) >> 8) + a) >> 8)

 /* like (a * b + 127) / 255), but much faster on most platforms */
-#define MULDIV255(a, b, tmp)\
-    (tmp = (a) * (b) + 128, SHIFTFORDIV255(tmp))
+#define MULDIV255(a, b, tmp) (tmp = (a) * (b) + 128, SHIFTFORDIV255(tmp))

-#define DIV255(a, tmp)\
-    (tmp = (a) + 128, SHIFTFORDIV255(tmp))
+#define DIV255(a, tmp) (tmp = (a) + 128, SHIFTFORDIV255(tmp))

-#define BLEND(mask, in1, in2, tmp1)\
-    DIV255(in1 * (255 - mask) + in2 * mask, tmp1)
+#define BLEND(mask, in1, in2, tmp1) DIV255(in1 *(255 - mask) + in2 * mask, tmp1)

-#define PREBLEND(mask, in1, in2, tmp1)\
-    (MULDIV255(in1, (255 - mask), tmp1) + in2)
-
+#define PREBLEND(mask, in1, in2, tmp1) (MULDIV255(in1, (255 - mask), tmp1) + in2)

 #define CLIP8(v) ((v) <= 0 ? 0 : (v) < 256 ? (v) : 255)

 /* This is to work around a bug in GCC prior 4.9 in 64 bit mode.
    GCC generates code with partial dependency which is 3 times slower.
-   See: http://stackoverflow.com/a/26588074/253146 */
-#if defined(__x86_64__) && defined(__SSE__) &&  ! defined(__NO_INLINE__) && \
-    ! defined(__clang__) && defined(GCC_VERSION) && (GCC_VERSION < 40900)
+   See: https://stackoverflow.com/a/26588074/253146 */
+#if defined(__x86_64__) && defined(__SSE__) && !defined(__NO_INLINE__) && \
+    !defined(__clang__) && defined(GCC_VERSION) && (GCC_VERSION < 40900)
 static float __attribute__((always_inline)) inline _i2f(int v) {
     float x;
-    __asm__("xorps %0, %0; cvtsi2ss %1, %0" : "=x"(x) : "r"(v) );
+    __asm__("xorps %0, %0; cvtsi2ss %1, %0" : "=x"(x) : "r"(v));
     return x;
 }
 #else
-static float inline _i2f(int v) { return (float) v; }
+static float inline _i2f(int v) { return (float)v; }
 #endif
('src/libImaging', 'codec_fd.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,10 +1,8 @@
 #include "Python.h"
 #include "Imaging.h"

-
 Py_ssize_t
-_imaging_read_pyFd(PyObject *fd, char* dest, Py_ssize_t bytes)
-{
+_imaging_read_pyFd(PyObject *fd, char *dest, Py_ssize_t bytes) {
     /* dest should be a buffer bytes long, returns length of read
        -1 on error */

@@ -29,16 +27,13 @@
     Py_DECREF(result);
     return length;

- err:
+err:
     Py_DECREF(result);
     return -1;
-
 }

 Py_ssize_t
-_imaging_write_pyFd(PyObject *fd, char* src, Py_ssize_t bytes)
-{
-
+_imaging_write_pyFd(PyObject *fd, char *src, Py_ssize_t bytes) {
     PyObject *result;
     PyObject *byteObj;

@@ -49,24 +44,20 @@
     Py_DECREF(result);

     return bytes;
-
 }

 int
-_imaging_seek_pyFd(PyObject *fd, Py_ssize_t offset, int whence)
-{
+_imaging_seek_pyFd(PyObject *fd, Py_ssize_t offset, int whence) {
     PyObject *result;

     result = PyObject_CallMethod(fd, "seek", "ni", offset, whence);

     Py_DECREF(result);
     return 0;
-
 }

 Py_ssize_t
-_imaging_tell_pyFd(PyObject *fd)
-{
+_imaging_tell_pyFd(PyObject *fd) {
     PyObject *result;
     Py_ssize_t location;

('src/libImaging', 'TiffDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,7 +23,8 @@
 /* Convert C file descriptor to WinApi HFILE if LibTiff was compiled with tif_win32.c
  *
  * This cast is safe, as the top 32-bits of HFILE are guaranteed to be zero,
- * see https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication
+ * see
+ * https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication
  */
 #ifndef USE_WIN32_FILEIO
 #define fd_to_tiff_fd(fd) (fd)
@@ -31,33 +32,45 @@
 #define fd_to_tiff_fd(fd) ((int)_get_osfhandle(fd))
 #endif

-void dump_state(const TIFFSTATE *state){
-    TRACE(("State: Location %u size %d eof %d data: %p ifd: %d\n", (uint)state->loc,
-           (int)state->size, (uint)state->eof, state->data, state->ifd));
+void
+dump_state(const TIFFSTATE *state) {
+    TRACE(
+        ("State: Location %u size %d eof %d data: %p ifd: %d\n",
+         (uint)state->loc,
+         (int)state->size,
+         (uint)state->eof,
+         state->data,
+         state->ifd));
 }

 /*
   procs for TIFFOpenClient
 */

-tsize_t _tiffReadProc(thandle_t hdata, tdata_t buf, tsize_t size) {
+tsize_t
+_tiffReadProc(thandle_t hdata, tdata_t buf, tsize_t size) {
     TIFFSTATE *state = (TIFFSTATE *)hdata;
     tsize_t to_read;

     TRACE(("_tiffReadProc: %d \n", (int)size));
     dump_state(state);

+    if (state->loc > state->eof) {
+        TIFFError("_tiffReadProc", "Invalid Read at loc %" PRIu64 ", eof: %" PRIu64, state->loc, state->eof);
+        return 0;
+    }
     to_read = min(size, min(state->size, (tsize_t)state->eof) - (tsize_t)state->loc);
     TRACE(("to_read: %d\n", (int)to_read));

     _TIFFmemcpy(buf, (UINT8 *)state->data + state->loc, to_read);
     state->loc += (toff_t)to_read;

-    TRACE( ("location: %u\n", (uint)state->loc));
+    TRACE(("location: %u\n", (uint)state->loc));
     return to_read;
 }

-tsize_t _tiffWriteProc(thandle_t hdata, tdata_t buf, tsize_t size) {
+tsize_t
+_tiffWriteProc(thandle_t hdata, tdata_t buf, tsize_t size) {
     TIFFSTATE *state = (TIFFSTATE *)hdata;
     tsize_t to_write;

@@ -65,14 +78,14 @@
     dump_state(state);

     to_write = min(size, state->size - (tsize_t)state->loc);
-    if (state->flrealloc && size>to_write) {
+    if (state->flrealloc && size > to_write) {
         tdata_t new_data;
-        tsize_t newsize=state->size;
+        tsize_t newsize = state->size;
         while (newsize < (size + state->size)) {
-            if (newsize > INT_MAX - 64*1024){
+            if (newsize > INT_MAX - 64 * 1024) {
                 return 0;
             }
-            newsize += 64*1024;
+            newsize += 64 * 1024;
             // newsize*=2; // UNDONE, by 64k chunks?
         }
         TRACE(("Reallocing in write to %d bytes\n", (int)newsize));
@@ -97,27 +110,29 @@
     return to_write;
 }

-toff_t _tiffSeekProc(thandle_t hdata, toff_t off, int whence) {
+toff_t
+_tiffSeekProc(thandle_t hdata, toff_t off, int whence) {
     TIFFSTATE *state = (TIFFSTATE *)hdata;

     TRACE(("_tiffSeekProc: off: %u whence: %d \n", (uint)off, whence));
     dump_state(state);
     switch (whence) {
-    case 0:
-        state->loc = off;
-        break;
-    case 1:
-        state->loc += off;
-        break;
-    case 2:
-        state->loc = state->eof + off;
-        break;
+        case 0:
+            state->loc = off;
+            break;
+        case 1:
+            state->loc += off;
+            break;
+        case 2:
+            state->loc = state->eof + off;
+            break;
     }
     dump_state(state);
     return state->loc;
 }

-int _tiffCloseProc(thandle_t hdata) {
+int
+_tiffCloseProc(thandle_t hdata) {
     TIFFSTATE *state = (TIFFSTATE *)hdata;

     TRACE(("_tiffCloseProc \n"));
@@ -126,8 +141,8 @@
     return 0;
 }

-
-toff_t _tiffSizeProc(thandle_t hdata) {
+toff_t
+_tiffSizeProc(thandle_t hdata) {
     TIFFSTATE *state = (TIFFSTATE *)hdata;

     TRACE(("_tiffSizeProc \n"));
@@ -136,7 +151,8 @@
     return (toff_t)state->size;
 }

-int _tiffMapProc(thandle_t hdata, tdata_t* pbase, toff_t* psize) {
+int
+_tiffMapProc(thandle_t hdata, tdata_t *pbase, toff_t *psize) {
     TIFFSTATE *state = (TIFFSTATE *)hdata;

     TRACE(("_tiffMapProc input size: %u, data: %p\n", (uint)*psize, *pbase));
@@ -148,25 +164,41 @@
     return (1);
 }

-int _tiffNullMapProc(thandle_t hdata, tdata_t* pbase, toff_t* psize) {
-    (void) hdata; (void) pbase; (void) psize;
+int
+_tiffNullMapProc(thandle_t hdata, tdata_t *pbase, toff_t *psize) {
+    (void)hdata;
+    (void)pbase;
+    (void)psize;
     return (0);
 }

-void _tiffUnmapProc(thandle_t hdata, tdata_t base, toff_t size) {
+void
+_tiffUnmapProc(thandle_t hdata, tdata_t base, toff_t size) {
     TRACE(("_tiffUnMapProc\n"));
-    (void) hdata; (void) base; (void) size;
-}
-
-int ImagingLibTiffInit(ImagingCodecState state, int fp, uint32 offset) {
+    (void)hdata;
+    (void)base;
+    (void)size;
+}
+
+int
+ImagingLibTiffInit(ImagingCodecState state, int fp, uint32_t offset) {
     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;

     TRACE(("initing libtiff\n"));
-    TRACE(("filepointer: %d \n",  fp));
-    TRACE(("State: count %d, state %d, x %d, y %d, ystep %d\n", state->count, state->state,
-           state->x, state->y, state->ystep));
-    TRACE(("State: xsize %d, ysize %d, xoff %d, yoff %d \n", state->xsize, state->ysize,
-           state->xoff, state->yoff));
+    TRACE(("filepointer: %d \n", fp));
+    TRACE(
+        ("State: count %d, state %d, x %d, y %d, ystep %d\n",
+         state->count,
+         state->state,
+         state->x,
+         state->y,
+         state->ystep));
+    TRACE(
+        ("State: xsize %d, ysize %d, xoff %d, yoff %d \n",
+         state->xsize,
+         state->ysize,
+         state->xoff,
+         state->yoff));
     TRACE(("State: bits %d, bytes %d \n", state->bits, state->bytes));
     TRACE(("State: context %p \n", state->context));

@@ -180,25 +212,64 @@
     return 1;
 }

-
-int _decodeStripYCbCr(Imaging im, ImagingCodecState state, TIFF *tiff) {
-    // To avoid dealing with YCbCr subsampling, let libtiff handle it
+int
+_pickUnpackers(Imaging im, ImagingCodecState state, TIFF *tiff, uint16_t planarconfig, ImagingShuffler *unpackers) {
+    // if number of bands is 1, there is no difference with contig case
+    if (planarconfig == PLANARCONFIG_SEPARATE && im->bands > 1) {
+        uint16_t bits_per_sample = 8;
+
+        TIFFGetFieldDefaulted(tiff, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);
+        if (bits_per_sample != 8 && bits_per_sample != 16) {
+            TRACE(("Invalid value for bits per sample: %d\n", bits_per_sample));
+            state->errcode = IMAGING_CODEC_BROKEN;
+            return -1;
+        }
+
+        // We'll pick appropriate set of unpackers depending on planar_configuration
+        // It does not matter if data is RGB(A), CMYK or LUV really,
+        // we just copy it plane by plane
+        unpackers[0] = ImagingFindUnpacker("RGBA", bits_per_sample == 16 ? "R;16N" : "R", NULL);
+        unpackers[1] = ImagingFindUnpacker("RGBA", bits_per_sample == 16 ? "G;16N" : "G", NULL);
+        unpackers[2] = ImagingFindUnpacker("RGBA", bits_per_sample == 16 ? "B;16N" : "B", NULL);
+        unpackers[3] = ImagingFindUnpacker("RGBA", bits_per_sample == 16 ? "A;16N" : "A", NULL);
+
+        return im->bands;
+    } else {
+        unpackers[0] = state->shuffle;
+
+        return 1;
+    }
+}
+
+int
+_decodeAsRGBA(Imaging im, ImagingCodecState state, TIFF *tiff) {
+    // To avoid dealing with YCbCr subsampling and other complications, let libtiff handle it
     // Use a TIFFRGBAImage wrapping the tiff image, and let libtiff handle
     // all of the conversion. Metadata read from the TIFFRGBAImage could
-    // be different from the metadata that the base tiff returns.
-
-    INT32 strip_row;
+    // be different from the metadata that the base tiff returns.
+
+    INT32 current_row;
     UINT8 *new_data;
-    UINT32 rows_per_strip, row_byte_size, rows_to_read;
+    UINT32 rows_per_block, row_byte_size, rows_to_read;
     int ret;
     TIFFRGBAImage img;
     char emsg[1024] = "";

-    ret = TIFFGetFieldDefaulted(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);
-    if (ret != 1) {
-        rows_per_strip = state->ysize;
-    }
-    TRACE(("RowsPerStrip: %u \n", rows_per_strip));
+    // Since using TIFFRGBAImage* functions, we can read whole tiff into rastrr in one call
+    // Let's select smaller block size. Multiplying image width by (tile length OR rows per strip)
+    // gives us manageable block size in pixels
+    if (TIFFIsTiled(tiff)) {
+        ret = TIFFGetFieldDefaulted(tiff, TIFFTAG_TILELENGTH, &rows_per_block);
+    }
+    else {
+        ret = TIFFGetFieldDefaulted(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_block);
+    }
+
+    if (ret != 1 || rows_per_block==(UINT32)(-1)) {
+        rows_per_block = state->ysize;
+    }
+
+    TRACE(("RowsPerBlock: %u \n", rows_per_block));

     if (!(TIFFRGBAImageOK(tiff, emsg) && TIFFRGBAImageBegin(&img, tiff, 0, emsg))) {
         TRACE(("Decode error, msg: %s", emsg));
@@ -210,69 +281,70 @@
     img.req_orientation = ORIENTATION_TOPLEFT;
     img.col_offset = 0;

-    if (state->xsize != img.width || state->ysize != img.height) {
-        TRACE(("Inconsistent Image Error: %d =? %d, %d =? %d",
-               state->xsize, img.width, state->ysize, img.height));
-        state->errcode = IMAGING_CODEC_BROKEN;
-        goto decodeycbcr_err;
-    }
-
     /* overflow check for row byte size */
     if (INT_MAX / 4 < img.width) {
         state->errcode = IMAGING_CODEC_MEMORY;
-        goto decodeycbcr_err;
-    }
-
-    // TiffRGBAImages are 32bits/pixel.
+        goto decodergba_err;
+    }
+
+    // TiffRGBAImages are 32bits/pixel.
     row_byte_size = img.width * 4;

     /* overflow check for realloc */
-    if (INT_MAX / row_byte_size < rows_per_strip) {
+    if (INT_MAX / row_byte_size < rows_per_block) {
         state->errcode = IMAGING_CODEC_MEMORY;
-        goto decodeycbcr_err;
-    }
-
-    state->bytes = rows_per_strip * row_byte_size;
-
-    TRACE(("StripSize: %d \n", state->bytes));
+        goto decodergba_err;
+    }
+
+    state->bytes = rows_per_block * row_byte_size;
+
+    TRACE(("BlockSize: %d \n", state->bytes));

     /* realloc to fit whole strip */
     /* malloc check above */
-    new_data = realloc (state->buffer, state->bytes);
+    new_data = realloc(state->buffer, state->bytes);
     if (!new_data) {
         state->errcode = IMAGING_CODEC_MEMORY;
-        goto decodeycbcr_err;
+        goto decodergba_err;
     }

     state->buffer = new_data;

-    for (; state->y < state->ysize; state->y += rows_per_strip) {
-        img.row_offset = state->y;
-        rows_to_read = min(rows_per_strip, img.height - state->y);
-
-        if (TIFFRGBAImageGet(&img, (UINT32 *)state->buffer, img.width, rows_to_read) == -1) {
-            TRACE(("Decode Error, y: %d\n", state->y ));
+    for (; state->y < state->ysize; state->y += rows_per_block) {
+        img.row_offset = state->y;
+        rows_to_read = min(rows_per_block, img.height - state->y);
+
+        if (!TIFFRGBAImageGet(&img, (UINT32 *)state->buffer, img.width, rows_to_read)) {
+            TRACE(("Decode Error, y: %d\n", state->y));
             state->errcode = IMAGING_CODEC_BROKEN;
-            goto decodeycbcr_err;
-        }
+            goto decodergba_err;
+        }
+
+#if WORDS_BIGENDIAN
+        TIFFSwabArrayOfLong((UINT32 *)state->buffer, img.width * rows_to_read);
+#endif

         TRACE(("Decoded strip for row %d \n", state->y));

         // iterate over each row in the strip and stuff data into image
-        for (strip_row = 0; strip_row < min((INT32) rows_per_strip, state->ysize - state->y); strip_row++) {
-            TRACE(("Writing data into line %d ; \n", state->y + strip_row));
-
-            // UINT8 * bbb = state->buffer + strip_row * (state->bytes / rows_per_strip);
-            // TRACE(("chars: %x %x %x %x\n", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));
-
-            state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +
-                           state->xoff * im->pixelsize,
-                           state->buffer + strip_row * row_byte_size,
-                           state->xsize);
-        }
-    }
-
- decodeycbcr_err:
+        for (current_row = 0;
+             current_row < min((INT32)rows_per_block, state->ysize - state->y);
+             current_row++) {
+            TRACE(("Writing data into line %d ; \n", state->y + current_row));
+
+            // UINT8 * bbb = state->buffer + current_row * (state->bytes /
+            // rows_per_block); TRACE(("chars: %x %x %x %x\n", ((UINT8 *)bbb)[0],
+            // ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));
+
+            state->shuffle(
+                (UINT8 *)im->image[state->y + state->yoff + current_row] +
+                    state->xoff * im->pixelsize,
+                state->buffer + current_row * row_byte_size,
+                state->xsize);
+        }
+    }
+
+decodergba_err:
     TIFFRGBAImageEnd(&img);
     if (state->errcode != 0) {
         return -1;
@@ -280,43 +352,152 @@
     return 0;
 }

-int _decodeStrip(Imaging im, ImagingCodecState state, TIFF *tiff) {
-    INT32 strip_row;
+int
+_decodeTile(Imaging im, ImagingCodecState state, TIFF *tiff, int planes, ImagingShuffler *unpackers) {
+    INT32 x, y, tile_y, current_tile_length, current_tile_width;
+    UINT32 tile_width, tile_length;
+    tsize_t tile_bytes_size, row_byte_size;
     UINT8 *new_data;
-    UINT32 rows_per_strip, row_byte_size;
+
+    tile_bytes_size = TIFFTileSize(tiff);
+
+    if (tile_bytes_size == 0) {
+        TRACE(("Decode Error, Can not calculate TileSize\n"));
+        state->errcode = IMAGING_CODEC_BROKEN;
+        return -1;
+    }
+
+    row_byte_size = TIFFTileRowSize(tiff);
+
+    if (row_byte_size == 0 || row_byte_size > tile_bytes_size) {
+        TRACE(("Decode Error, Can not calculate TileRowSize\n"));
+        state->errcode = IMAGING_CODEC_BROKEN;
+        return -1;
+    }
+
+    /* overflow check for realloc */
+    if (tile_bytes_size > INT_MAX - 1) {
+        state->errcode = IMAGING_CODEC_MEMORY;
+        return -1;
+    }
+
+    TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);
+    TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);
+
+    if (tile_width > INT_MAX || tile_length > INT_MAX) {
+        // state->x and state->y are ints
+        state->errcode = IMAGING_CODEC_MEMORY;
+        return -1;
+    }
+
+    if (tile_bytes_size > ((tile_length * state->bits / planes + 7) / 8) * tile_width) {
+        // If the tile size as expected by LibTiff isn't what we're expecting, abort.
+        // man:   TIFFTileSize returns the equivalent size for a tile of data as it would be returned in a
+        //        call to TIFFReadTile ...
+        state->errcode = IMAGING_CODEC_BROKEN;
+        return -1;
+    }
+
+    state->bytes = tile_bytes_size;
+
+    TRACE(("TIFFTileSize: %d\n", state->bytes));
+
+    /* realloc to fit whole tile */
+    /* malloc check above */
+    new_data = realloc(state->buffer, state->bytes);
+    if (!new_data) {
+        state->errcode = IMAGING_CODEC_MEMORY;
+        return -1;
+    }
+    state->buffer = new_data;
+
+    for (y = state->yoff; y < state->ysize; y += tile_length) {
+        int plane;
+        for (plane = 0; plane < planes; plane++) {
+            ImagingShuffler shuffler = unpackers[plane];
+            for (x = state->xoff; x < state->xsize; x += tile_width) {
+                if (TIFFReadTile(tiff, (tdata_t)state->buffer, x, y, 0, plane) == -1) {
+                    TRACE(("Decode Error, Tile at %dx%d\n", x, y));
+                    state->errcode = IMAGING_CODEC_BROKEN;
+                    return -1;
+                }
+
+                TRACE(("Read tile at %dx%d; \n\n", x, y));
+
+                current_tile_width = min((INT32) tile_width, state->xsize - x);
+                current_tile_length =  min((INT32) tile_length, state->ysize - y);
+                // iterate over each line in the tile and stuff data into image
+                for (tile_y = 0; tile_y < current_tile_length; tile_y++) {
+                    TRACE(("Writing tile data at %dx%d using tile_width: %d; \n", tile_y + y, x, current_tile_width));
+
+                    // UINT8 * bbb = state->buffer + tile_y * row_byte_size;
+                    // TRACE(("chars: %x%x%x%x\n", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));
+
+                    shuffler((UINT8*) im->image[tile_y + y] + x * im->pixelsize,
+                             state->buffer + tile_y * row_byte_size,
+                             current_tile_width
+                             );
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+int
+_decodeStrip(Imaging im, ImagingCodecState state, TIFF *tiff, int planes, ImagingShuffler *unpackers) {
+    INT32 strip_row = 0;
+    UINT8 *new_data;
+    UINT32 rows_per_strip;
     int ret;
+    tsize_t strip_size, row_byte_size, unpacker_row_byte_size;

     ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);
-    if (ret != 1) {
+    if (ret != 1 || rows_per_strip==(UINT32)(-1)) {
         rows_per_strip = state->ysize;
     }
-    TRACE(("RowsPerStrip: %u \n", rows_per_strip));
-
-    // We could use TIFFStripSize, but for YCbCr data it returns subsampled data size
-    row_byte_size = (state->xsize * state->bits + 7) / 8;
-
-    /* overflow check for realloc */
-    if (INT_MAX / row_byte_size < rows_per_strip) {
+
+    if (rows_per_strip > INT_MAX) {
         state->errcode = IMAGING_CODEC_MEMORY;
         return -1;
     }

-    state->bytes = rows_per_strip * row_byte_size;
-
-    TRACE(("StripSize: %d \n", state->bytes));
-
-    if (TIFFStripSize(tiff) > state->bytes) {
+    TRACE(("RowsPerStrip: %u\n", rows_per_strip));
+
+    strip_size = TIFFStripSize(tiff);
+    if (strip_size > INT_MAX - 1) {
+        state->errcode = IMAGING_CODEC_MEMORY;
+        return -1;
+    }
+
+    unpacker_row_byte_size = (state->xsize * state->bits / planes + 7) / 8;
+    if (strip_size > (unpacker_row_byte_size * rows_per_strip)) {
         // If the strip size as expected by LibTiff isn't what we're expecting, abort.
         // man:   TIFFStripSize returns the equivalent size for a strip of data as it would be returned in a
         //        call to TIFFReadEncodedStrip ...
-
-        state->errcode = IMAGING_CODEC_MEMORY;
-        return -1;
-    }
+        state->errcode = IMAGING_CODEC_BROKEN;
+        return -1;
+    }
+
+    state->bytes = strip_size;
+
+    TRACE(("StripSize: %d \n", state->bytes));
+
+    row_byte_size = TIFFScanlineSize(tiff);
+
+    // if the unpacker calculated row size is > row byte size, (at least) the last
+    // row of the strip will have a read buffer overflow.
+    if (row_byte_size == 0 || unpacker_row_byte_size > row_byte_size) {
+        state->errcode = IMAGING_CODEC_BROKEN;
+        return -1;
+    }
+
+    TRACE(("RowsByteSize: %u \n", row_byte_size));

     /* realloc to fit whole strip */
     /* malloc check above */
-    new_data = realloc (state->buffer, state->bytes);
+    new_data = realloc(state->buffer, state->bytes);
     if (!new_data) {
         state->errcode = IMAGING_CODEC_MEMORY;
         return -1;
@@ -325,55 +506,100 @@
     state->buffer = new_data;

     for (; state->y < state->ysize; state->y += rows_per_strip) {
-        if (TIFFReadEncodedStrip(tiff, TIFFComputeStrip(tiff, state->y, 0), (tdata_t)state->buffer, -1) == -1) {
-            TRACE(("Decode Error, strip %d\n", TIFFComputeStrip(tiff, state->y, 0)));
-            state->errcode = IMAGING_CODEC_BROKEN;
-            return -1;
-        }
-
-        TRACE(("Decoded strip for row %d \n", state->y));
-
-        // iterate over each row in the strip and stuff data into image
-        for (strip_row = 0; strip_row < min((INT32) rows_per_strip, state->ysize - state->y); strip_row++) {
-            TRACE(("Writing data into line %d ; \n", state->y + strip_row));
-
-            // UINT8 * bbb = state->buffer + strip_row * (state->bytes / rows_per_strip);
-            // TRACE(("chars: %x %x %x %x\n", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));
-
-            state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +
-                           state->xoff * im->pixelsize,
-                           state->buffer + strip_row * row_byte_size,
-                           state->xsize);
-        }
-    }
+        int plane;
+        for (plane = 0; plane < planes; plane++) {
+            ImagingShuffler shuffler = unpackers[plane];
+            if (TIFFReadEncodedStrip(tiff, TIFFComputeStrip(tiff, state->y, plane), (tdata_t)state->buffer, strip_size) == -1) {
+                TRACE(("Decode Error, strip %d\n", TIFFComputeStrip(tiff, state->y, 0)));
+                state->errcode = IMAGING_CODEC_BROKEN;
+                return -1;
+            }
+
+            TRACE(("Decoded strip for row %d \n", state->y));
+
+            // iterate over each row in the strip and stuff data into image
+            for (strip_row = 0;
+                 strip_row < min((INT32) rows_per_strip, state->ysize - state->y);
+                 strip_row++) {
+                TRACE(("Writing data into line %d ; \n", state->y + strip_row));
+
+                // UINT8 * bbb = state->buffer + strip_row * (state->bytes / rows_per_strip);
+                // TRACE(("chars: %x %x %x %x\n", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));
+
+                shuffler(
+                    (UINT8*) im->image[state->y + state->yoff + strip_row] +
+                    state->xoff * im->pixelsize,
+                    state->buffer + strip_row * row_byte_size,
+                    state->xsize);
+            }
+        }
+    }
+
     return 0;
 }

-int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) {
+int
+ImagingLibTiffDecode(
+    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes) {
     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;
     char *filename = "tempfile.tif";
-    char *mode = "r";
+    char *mode = "rC";
     TIFF *tiff;
-    uint16 photometric = 0; // init to not PHOTOMETRIC_YCBCR
-    int isYCbCr = 0;
+    uint16_t photometric = 0;  // init to not PHOTOMETRIC_YCBCR
+    uint16_t compression;
+    int readAsRGBA = 0;
+    uint16_t planarconfig = 0;
+    int planes = 1;
+    ImagingShuffler unpackers[4];
+    INT32 img_width, img_height;
+
+    memset(unpackers, 0, sizeof(ImagingShuffler) * 4);

     /* buffer is the encoded file, bytes is the length of the encoded file */
     /*     it all ends up in state->buffer, which is a uint8* from Imaging.h */

     TRACE(("in decoder: bytes %d\n", bytes));
-    TRACE(("State: count %d, state %d, x %d, y %d, ystep %d\n", state->count, state->state,
-           state->x, state->y, state->ystep));
-    TRACE(("State: xsize %d, ysize %d, xoff %d, yoff %d \n", state->xsize, state->ysize,
-           state->xoff, state->yoff));
+    TRACE(
+        ("State: count %d, state %d, x %d, y %d, ystep %d\n",
+         state->count,
+         state->state,
+         state->x,
+         state->y,
+         state->ystep));
+    TRACE(
+        ("State: xsize %d, ysize %d, xoff %d, yoff %d \n",
+         state->xsize,
+         state->ysize,
+         state->xoff,
+         state->yoff));
     TRACE(("State: bits %d, bytes %d \n", state->bits, state->bytes));
-    TRACE(("Buffer: %p: %c%c%c%c\n", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));
-    TRACE(("State->Buffer: %c%c%c%c\n", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));
-    TRACE(("Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n",
-           im->mode, im->type, im->bands, im->xsize, im->ysize));
-    TRACE(("Image: image8 %p, image32 %p, image %p, block %p \n",
-           im->image8, im->image32, im->image, im->block));
-    TRACE(("Image: pixelsize: %d, linesize %d \n",
-           im->pixelsize, im->linesize));
+    TRACE(
+        ("Buffer: %p: %c%c%c%c\n",
+         buffer,
+         (char)buffer[0],
+         (char)buffer[1],
+         (char)buffer[2],
+         (char)buffer[3]));
+    TRACE(
+        ("State->Buffer: %c%c%c%c\n",
+         (char)state->buffer[0],
+         (char)state->buffer[1],
+         (char)state->buffer[2],
+         (char)state->buffer[3]));
+    TRACE(
+        ("Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n",
+         im->mode,
+         im->type,
+         im->bands,
+         im->xsize,
+         im->ysize));
+    TRACE(
+        ("Image: image8 %p, image32 %p, image %p, block %p \n",
+         im->image8,
+         im->image32,
+         im->image,
+         im->block));
+    TRACE(("Image: pixelsize: %d, linesize %d \n", im->pixelsize, im->linesize));

     dump_state(clientstate);
     clientstate->size = bytes;
@@ -387,145 +613,109 @@
     TIFFSetWarningHandlerExt(NULL);

     if (clientstate->fp) {
-        TRACE(("Opening using fd: %d\n",clientstate->fp));
-        lseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.
+        TRACE(("Opening using fd: %d\n", clientstate->fp));
+        lseek(clientstate->fp, 0, SEEK_SET);  // Sometimes, I get it set to the end.
         tiff = TIFFFdOpen(fd_to_tiff_fd(clientstate->fp), filename, mode);
     } else {
         TRACE(("Opening from string\n"));
-        tiff = TIFFClientOpen(filename, mode,
-                              (thandle_t) clientstate,
-                              _tiffReadProc, _tiffWriteProc,
-                              _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
-                              _tiffMapProc, _tiffUnmapProc);
-    }
-
-    if (!tiff){
+        tiff = TIFFClientOpen(
+            filename,
+            mode,
+            (thandle_t)clientstate,
+            _tiffReadProc,
+            _tiffWriteProc,
+            _tiffSeekProc,
+            _tiffCloseProc,
+            _tiffSizeProc,
+            _tiffMapProc,
+            _tiffUnmapProc);
+    }
+
+    if (!tiff) {
         TRACE(("Error, didn't get the tiff\n"));
         state->errcode = IMAGING_CODEC_BROKEN;
         return -1;
     }

-    if (clientstate->ifd){
+    if (clientstate->ifd) {
         int rv;
-        uint32 ifdoffset = clientstate->ifd;
+        uint32_t ifdoffset = clientstate->ifd;
         TRACE(("reading tiff ifd %u\n", ifdoffset));
         rv = TIFFSetSubDirectory(tiff, ifdoffset);
-        if (!rv){
+        if (!rv) {
             TRACE(("error in TIFFSetSubDirectory"));
             goto decode_err;
         }
     }

-
+    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &img_width);
+    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &img_height);
+
+    if (state->xsize != img_width || state->ysize != img_height) {
+        TRACE(
+            ("Inconsistent Image Error: %d =? %d, %d =? %d",
+             state->xsize,
+             img_width,
+             state->ysize,
+             img_height));
+        state->errcode = IMAGING_CODEC_BROKEN;
+        goto decode_err;
+    }
+
+
     TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric);
-    isYCbCr = photometric == PHOTOMETRIC_YCBCR;
-
-    if (TIFFIsTiled(tiff)) {
-        INT32 x, y, tile_y;
-        UINT32 tile_width, tile_length, current_tile_length, current_line, current_tile_width, row_byte_size;
-        UINT8 *new_data;
-
-        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);
-        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);
-
-        /* overflow check for row_byte_size calculation */
-        if ((UINT32) INT_MAX / state->bits < tile_width) {
-            state->errcode = IMAGING_CODEC_MEMORY;
+    TIFFGetField(tiff, TIFFTAG_COMPRESSION, &compression);
+    TIFFGetFieldDefaulted(tiff, TIFFTAG_PLANARCONFIG, &planarconfig);
+
+    // Dealing with YCbCr images is complicated in case if subsampling
+    // Let LibTiff read them as RGBA
+    readAsRGBA = photometric == PHOTOMETRIC_YCBCR;
+
+    if (readAsRGBA && compression == COMPRESSION_JPEG && planarconfig == PLANARCONFIG_CONTIG) {
+        // If using new JPEG compression, let libjpeg do RGB conversion for performance reasons
+        TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
+        readAsRGBA = 0;
+    }
+
+    if (readAsRGBA) {
+        _decodeAsRGBA(im, state, tiff);
+    }
+    else {
+        planes = _pickUnpackers(im, state, tiff, planarconfig, unpackers);
+        if (planes <= 0) {
             goto decode_err;
         }

-
-        if (isYCbCr) {
-            row_byte_size = tile_width * 4;
-            /* sanity check, we use this value in shuffle below */
-            if (im->pixelsize != 4) {
-                state->errcode = IMAGING_CODEC_BROKEN;
-                goto decode_err;
-            }
-        } else {
-            // We could use TIFFTileSize, but for YCbCr data it returns subsampled data size
-            row_byte_size = (tile_width * state->bits + 7) / 8;
-        }
-
-        /* overflow check for realloc */
-        if (INT_MAX / row_byte_size < tile_length) {
-            state->errcode = IMAGING_CODEC_MEMORY;
-            goto decode_err;
-        }
-
-        state->bytes = row_byte_size * tile_length;
-
-        if (TIFFTileSize(tiff) > state->bytes) {
-            // If the strip size as expected by LibTiff isn't what we're expecting, abort.
-            state->errcode = IMAGING_CODEC_MEMORY;
-            goto decode_err;
-        }
-
-        /* realloc to fit whole tile */
-        /* malloc check above */
-        new_data = realloc (state->buffer, state->bytes);
-        if (!new_data) {
-            state->errcode = IMAGING_CODEC_MEMORY;
-            goto decode_err;
-        }
-
-        state->buffer = new_data;
-
-        TRACE(("TIFFTileSize: %d\n", state->bytes));
-
-        for (y = state->yoff; y < state->ysize; y += tile_length) {
-            for (x = state->xoff; x < state->xsize; x += tile_width) {
-                if (isYCbCr) {
-                    /* To avoid dealing with YCbCr subsampling, let libtiff handle it */
-                    if (!TIFFReadRGBATile(tiff, x, y, (UINT32 *)state->buffer)) {
-                        TRACE(("Decode Error, Tile at %dx%d\n", x, y));
-                        state->errcode = IMAGING_CODEC_BROKEN;
-                        goto decode_err;
-                    }
-                } else {
-                    if (TIFFReadTile(tiff, (tdata_t)state->buffer, x, y, 0, 0) == -1) {
-                        TRACE(("Decode Error, Tile at %dx%d\n", x, y));
-                        state->errcode = IMAGING_CODEC_BROKEN;
-                        goto decode_err;
+        if (TIFFIsTiled(tiff)) {
+            _decodeTile(im, state, tiff, planes, unpackers);
+        }
+        else {
+            _decodeStrip(im, state, tiff, planes, unpackers);
+        }
+
+        if (!state->errcode) {
+            // Check if raw mode was RGBa and it was stored on separate planes
+            // so we have to convert it to RGBA
+            if (planes > 3 && strcmp(im->mode, "RGBA") == 0) {
+                uint16_t extrasamples;
+                uint16_t* sampleinfo;
+                ImagingShuffler shuffle;
+                INT32 y;
+
+                TIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);
+
+                if (extrasamples >= 1 &&
+                    (sampleinfo[0] == EXTRASAMPLE_UNSPECIFIED || sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA)
+                    ) {
+                    shuffle = ImagingFindUnpacker("RGBA", "RGBa", NULL);
+
+                    for (y = state->yoff; y < state->ysize; y++) {
+                        UINT8* ptr = (UINT8*) im->image[y + state->yoff] +
+                            state->xoff * im->pixelsize;
+                        shuffle(ptr, ptr, state->xsize);
                     }
                 }
-
-                TRACE(("Read tile at %dx%d; \n\n", x, y));
-
-                current_tile_width = min((INT32) tile_width, state->xsize - x);
-                current_tile_length =  min((INT32) tile_length, state->ysize - y);
-                // iterate over each line in the tile and stuff data into image
-                for (tile_y = 0; tile_y < current_tile_length; tile_y++) {
-                    TRACE(("Writing tile data at %dx%d using tile_width: %d; \n", tile_y + y, x, current_tile_width));
-
-                    // UINT8 * bbb = state->buffer + tile_y * row_byte_size;
-                    // TRACE(("chars: %x%x%x%x\n", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));
-                    /*
-                     * For some reason the TIFFReadRGBATile() function
-                     * chooses the lower left corner as the origin.
-                     * Vertically mirror by shuffling the scanlines
-                     * backwards
-                     */
-
-                    if (isYCbCr) {
-                        current_line = tile_length - tile_y - 1;
-                    } else {
-                        current_line = tile_y;
-                    }
-
-                    state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,
-                       state->buffer + current_line * row_byte_size,
-                       current_tile_width
-                    );
-                }
             }
-        }
-    } else {
-        if (!isYCbCr) {
-            _decodeStrip(im, state, tiff);
-        }
-        else {
-            _decodeStripYCbCr(im, state, tiff);
         }
     }

@@ -537,7 +727,8 @@
     return -1;
 }

-int ImagingLibTiffEncodeInit(ImagingCodecState state, char *filename, int fp) {
+int
+ImagingLibTiffEncodeInit(ImagingCodecState state, char *filename, int fp) {
     // Open the FD or the pointer as a tiff file, for writing.
     // We may have to do some monkeying around to make this really work.
     // If we have a fp, then we're good.
@@ -546,21 +737,30 @@
     // Going to have to deal with the directory as well.

     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;
-    int bufsize = 64*1024;
+    int bufsize = 64 * 1024;
     char *mode = "w";

     TRACE(("initing libtiff\n"));
-    TRACE(("Filename %s, filepointer: %d \n", filename,  fp));
-    TRACE(("State: count %d, state %d, x %d, y %d, ystep %d\n", state->count, state->state,
-           state->x, state->y, state->ystep));
-    TRACE(("State: xsize %d, ysize %d, xoff %d, yoff %d \n", state->xsize, state->ysize,
-           state->xoff, state->yoff));
+    TRACE(("Filename %s, filepointer: %d \n", filename, fp));
+    TRACE(
+        ("State: count %d, state %d, x %d, y %d, ystep %d\n",
+         state->count,
+         state->state,
+         state->x,
+         state->y,
+         state->ystep));
+    TRACE(
+        ("State: xsize %d, ysize %d, xoff %d, yoff %d \n",
+         state->xsize,
+         state->ysize,
+         state->xoff,
+         state->yoff));
     TRACE(("State: bits %d, bytes %d \n", state->bits, state->bytes));
     TRACE(("State: context %p \n", state->context));

     clientstate->loc = 0;
     clientstate->size = 0;
-    clientstate->eof =0;
+    clientstate->eof = 0;
     clientstate->data = 0;
     clientstate->flrealloc = 0;
     clientstate->fp = fp;
@@ -568,27 +768,33 @@
     state->state = 0;

     if (fp) {
-        TRACE(("Opening using fd: %d for writing \n",clientstate->fp));
+        TRACE(("Opening using fd: %d for writing \n", clientstate->fp));
         clientstate->tiff = TIFFFdOpen(fd_to_tiff_fd(clientstate->fp), filename, mode);
     } else {
-        // malloc a buffer to write the tif, we're going to need to realloc or something if we need bigger.
+        // malloc a buffer to write the tif, we're going to need to realloc or something
+        // if we need bigger.
         TRACE(("Opening a buffer for writing \n"));
         /* malloc check ok, small constant allocation */
         clientstate->data = malloc(bufsize);
         clientstate->size = bufsize;
-        clientstate->flrealloc=1;
+        clientstate->flrealloc = 1;

         if (!clientstate->data) {
             TRACE(("Error, couldn't allocate a buffer of size %d\n", bufsize));
             return 0;
         }

-        clientstate->tiff = TIFFClientOpen(filename, mode,
-                                           (thandle_t) clientstate,
-                                           _tiffReadProc, _tiffWriteProc,
-                                           _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
-                                           _tiffNullMapProc, _tiffUnmapProc); /*force no mmap*/
-
+        clientstate->tiff = TIFFClientOpen(
+            filename,
+            mode,
+            (thandle_t)clientstate,
+            _tiffReadProc,
+            _tiffWriteProc,
+            _tiffSeekProc,
+            _tiffCloseProc,
+            _tiffSizeProc,
+            _tiffNullMapProc,
+            _tiffUnmapProc); /*force no mmap*/
     }

     if (!clientstate->tiff) {
@@ -597,13 +803,14 @@
     }

     return 1;
-
-}
-
-int ImagingLibTiffMergeFieldInfo(ImagingCodecState state, TIFFDataType field_type, int key, int is_var_length){
+}
+
+int
+ImagingLibTiffMergeFieldInfo(
+    ImagingCodecState state, TIFFDataType field_type, int key, int is_var_length) {
     // Refer to libtiff docs (http://www.simplesystems.org/libtiff/addingtags.html)
     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;
-    uint32 n;
+    uint32_t n;
     int status = 0;

     // custom fields added with ImagingLibTiffMergeFieldInfo are only used for
@@ -615,8 +822,14 @@
     int passcount = 0;

     TIFFFieldInfo info[] = {
-        { key, readcount, writecount, field_type, FIELD_CUSTOM, 1, passcount, "CustomField" }
-    };
+        {key,
+         readcount,
+         writecount,
+         field_type,
+         FIELD_CUSTOM,
+         1,
+         passcount,
+         "CustomField"}};

     if (is_var_length) {
         info[0].field_writecount = -1;
@@ -629,7 +842,8 @@
     n = sizeof(info) / sizeof(info[0]);

     // Test for libtiff 4.0 or later, excluding libtiff 3.9.6 and 3.9.7
-#if TIFFLIB_VERSION >= 20111221 && TIFFLIB_VERSION != 20120218 && TIFFLIB_VERSION != 20120922
+#if TIFFLIB_VERSION >= 20111221 && TIFFLIB_VERSION != 20120218 && \
+    TIFFLIB_VERSION != 20120922
     status = TIFFMergeFieldInfo(clientstate->tiff, info, n);
 #else
     TIFFMergeFieldInfo(clientstate->tiff, info, n);
@@ -637,7 +851,8 @@
     return status;
 }

-int ImagingLibTiffSetField(ImagingCodecState state, ttag_t tag, ...){
+int
+ImagingLibTiffSetField(ImagingCodecState state, ttag_t tag, ...) {
     // after tif_dir.c->TIFFSetField.
     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;
     va_list ap;
@@ -649,8 +864,8 @@
     return status;
 }

-
-int ImagingLibTiffEncode(Imaging im, ImagingCodecState state, UINT8* buffer, int bytes) {
+int
+ImagingLibTiffEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes) {
     /* One shot encoder. Encode everything to the tiff in the clientstate.
        If we're running off of a FD, then run once, we're good, everything
        ends up in the file, we close and we're done.
@@ -664,35 +879,65 @@
     TIFF *tiff = clientstate->tiff;

     TRACE(("in encoder: bytes %d\n", bytes));
-    TRACE(("State: count %d, state %d, x %d, y %d, ystep %d\n", state->count, state->state,
-           state->x, state->y, state->ystep));
-    TRACE(("State: xsize %d, ysize %d, xoff %d, yoff %d \n", state->xsize, state->ysize,
-           state->xoff, state->yoff));
+    TRACE(
+        ("State: count %d, state %d, x %d, y %d, ystep %d\n",
+         state->count,
+         state->state,
+         state->x,
+         state->y,
+         state->ystep));
+    TRACE(
+        ("State: xsize %d, ysize %d, xoff %d, yoff %d \n",
+         state->xsize,
+         state->ysize,
+         state->xoff,
+         state->yoff));
     TRACE(("State: bits %d, bytes %d \n", state->bits, state->bytes));
-    TRACE(("Buffer: %p: %c%c%c%c\n", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));
-    TRACE(("State->Buffer: %c%c%c%c\n", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));
-    TRACE(("Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n",
-           im->mode, im->type, im->bands, im->xsize, im->ysize));
-    TRACE(("Image: image8 %p, image32 %p, image %p, block %p \n",
-           im->image8, im->image32, im->image, im->block));
-    TRACE(("Image: pixelsize: %d, linesize %d \n",
-           im->pixelsize, im->linesize));
+    TRACE(
+        ("Buffer: %p: %c%c%c%c\n",
+         buffer,
+         (char)buffer[0],
+         (char)buffer[1],
+         (char)buffer[2],
+         (char)buffer[3]));
+    TRACE(
+        ("State->Buffer: %c%c%c%c\n",
+         (char)state->buffer[0],
+         (char)state->buffer[1],
+         (char)state->buffer[2],
+         (char)state->buffer[3]));
+    TRACE(
+        ("Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n",
+         im->mode,
+         im->type,
+         im->bands,
+         im->xsize,
+         im->ysize));
+    TRACE(
+        ("Image: image8 %p, image32 %p, image %p, block %p \n",
+         im->image8,
+         im->image32,
+         im->image,
+         im->block));
+    TRACE(("Image: pixelsize: %d, linesize %d \n", im->pixelsize, im->linesize));

     dump_state(clientstate);

     if (state->state == 0) {
         TRACE(("Encoding line bt line"));
-        while(state->y < state->ysize){
-            state->shuffle(state->buffer,
-                           (UINT8*) im->image[state->y + state->yoff] +
-                           state->xoff * im->pixelsize,
-                           state->xsize);
-
-            if (TIFFWriteScanline(tiff, (tdata_t)(state->buffer), (uint32)state->y, 0) == -1) {
+        while (state->y < state->ysize) {
+            state->shuffle(
+                state->buffer,
+                (UINT8 *)im->image[state->y + state->yoff] +
+                    state->xoff * im->pixelsize,
+                state->xsize);
+
+            if (TIFFWriteScanline(
+                    tiff, (tdata_t)(state->buffer), (uint32_t)state->y, 0) == -1) {
                 TRACE(("Encode Error, row %d\n", state->y));
                 state->errcode = IMAGING_CODEC_BROKEN;
                 TIFFClose(tiff);
-                if (!clientstate->fp){
+                if (!clientstate->fp) {
                     free(clientstate->data);
                 }
                 return -1;
@@ -701,7 +946,7 @@
         }

         if (state->y == state->ysize) {
-            state->state=1;
+            state->state = 1;

             TRACE(("Flushing \n"));
             if (!TIFFFlush(tiff)) {
@@ -709,7 +954,7 @@
                 // likely reason is memory.
                 state->errcode = IMAGING_CODEC_MEMORY;
                 TIFFClose(tiff);
-                if (!clientstate->fp){
+                if (!clientstate->fp) {
                     free(clientstate->data);
                 }
                 return -1;
@@ -718,13 +963,19 @@
             TIFFClose(tiff);
             // reset the clientstate metadata to use it to read out the buffer.
             clientstate->loc = 0;
-            clientstate->size = clientstate->eof; // redundant?
+            clientstate->size = clientstate->eof;  // redundant?
         }
     }

     if (state->state == 1 && !clientstate->fp) {
         int read = (int)_tiffReadProc(clientstate, (tdata_t)buffer, (tsize_t)bytes);
-        TRACE(("Buffer: %p: %c%c%c%c\n", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));
+        TRACE(
+            ("Buffer: %p: %c%c%c%c\n",
+             buffer,
+             (char)buffer[0],
+             (char)buffer[1],
+             (char)buffer[2],
+             (char)buffer[3]));
         if (clientstate->loc == clientstate->eof) {
             TRACE(("Hit EOF, calling an end, freeing data"));
             state->errcode = IMAGING_CODEC_END;
@@ -737,9 +988,8 @@
     return 0;
 }

-const char*
-ImagingTiffVersion(void)
-{
+const char *
+ImagingTiffVersion(void) {
     return TIFFGetVersion();
 }

('src/libImaging', 'SunRleDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,37 +15,30 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 int
-ImagingSunRleDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
+ImagingSunRleDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
     int n;
-    UINT8* ptr;
+    UINT8 *ptr;
     UINT8 extra_data = 0;
     UINT8 extra_bytes = 0;

     ptr = buf;

     for (;;) {
-
         if (bytes < 1) {
             return ptr - buf;
         }

         if (ptr[0] == 0x80) {
-
             if (bytes < 2) {
                 break;
             }

             n = ptr[1];

-
             if (n == 0) {
-
                 /* Literal 0x80 (2 bytes) */
                 n = 1;

@@ -55,7 +48,6 @@
                 bytes -= 2;

             } else {
-
                 /* Run (3 bytes) */
                 if (bytes < 3) {
                     break;
@@ -84,7 +76,7 @@
                 n += 1;

                 if (state->x + n > state->bytes) {
-                    extra_bytes = n;  /* full value */
+                    extra_bytes = n; /* full value */
                     n = state->bytes - state->x;
                     extra_bytes -= n;
                     extra_data = ptr[2];
@@ -94,11 +86,9 @@

                 ptr += 3;
                 bytes -= 3;
-
             }

         } else {
-
             /* Literal byte */
             n = 1;

@@ -106,18 +96,18 @@

             ptr += 1;
             bytes -= 1;
-
         }

         for (;;) {
             state->x += n;

             if (state->x >= state->bytes) {
-
                 /* Got a full line, unpack it */
-                state->shuffle((UINT8*) im->image[state->y + state->yoff] +
-                               state->xoff * im->pixelsize, state->buffer,
-                               state->xsize);
+                state->shuffle(
+                    (UINT8 *)im->image[state->y + state->yoff] +
+                        state->xoff * im->pixelsize,
+                    state->buffer,
+                    state->xsize);

                 state->x = 0;

@@ -132,7 +122,7 @@
             }

             if (state->x > 0) {
-                break; // assert
+                break;  // assert
             }

             if (extra_bytes >= state->bytes) {
('src/libImaging', 'ZipEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,25 +14,22 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-#ifdef  HAVE_LIBZ
+#ifdef HAVE_LIBZ

 #include "ZipCodecs.h"

 int
-ImagingZipEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)
-{
-    ZIPSTATE* context = (ZIPSTATE*) state->context;
+ImagingZipEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes) {
+    ZIPSTATE *context = (ZIPSTATE *)state->context;
     int err;
     int compress_level, compress_type;
-    UINT8* ptr;
+    UINT8 *ptr;
     int i, bpp, s, sum;
     ImagingSectionCookie cookie;

     if (!state->state) {
-
         /* Initialization */

         /* Valid modes are ZIP_PNG, ZIP_PNG_PALETTE, and ZIP_TIFF */
@@ -47,14 +44,14 @@
            and allocate filter buffers */
         free(state->buffer);
         /* malloc check ok, overflow checked above */
-        state->buffer = (UINT8*) malloc(state->bytes+1);
-        context->previous = (UINT8*) malloc(state->bytes+1);
-        context->prior = (UINT8*) malloc(state->bytes+1);
-        context->up = (UINT8*) malloc(state->bytes+1);
-        context->average = (UINT8*) malloc(state->bytes+1);
-        context->paeth = (UINT8*) malloc(state->bytes+1);
-        if (!state->buffer || !context->previous || !context->prior ||
-            !context->up || !context->average || !context->paeth) {
+        state->buffer = (UINT8 *)malloc(state->bytes + 1);
+        context->previous = (UINT8 *)malloc(state->bytes + 1);
+        context->prior = (UINT8 *)malloc(state->bytes + 1);
+        context->up = (UINT8 *)malloc(state->bytes + 1);
+        context->average = (UINT8 *)malloc(state->bytes + 1);
+        context->paeth = (UINT8 *)malloc(state->bytes + 1);
+        if (!state->buffer || !context->previous || !context->prior || !context->up ||
+            !context->average || !context->paeth) {
             free(context->paeth);
             free(context->average);
             free(context->up);
@@ -72,7 +69,7 @@
         context->paeth[0] = 4;

         /* Initialise previous buffer to black */
-        memset(context->previous, 0, state->bytes+1);
+        memset(context->previous, 0, state->bytes + 1);

         /* Setup compression context */
         context->z_stream.zalloc = (alloc_func)0;
@@ -81,33 +78,37 @@
         context->z_stream.next_in = 0;
         context->z_stream.avail_in = 0;

-        compress_level = (context->optimize) ? Z_BEST_COMPRESSION
-                                             : context->compress_level;
+        compress_level =
+            (context->optimize) ? Z_BEST_COMPRESSION : context->compress_level;

         if (context->compress_type == -1) {
-            compress_type = (context->mode == ZIP_PNG) ? Z_FILTERED
-                                                       : Z_DEFAULT_STRATEGY;
+            compress_type =
+                (context->mode == ZIP_PNG) ? Z_FILTERED : Z_DEFAULT_STRATEGY;
         } else {
             compress_type = context->compress_type;
         }

-        err = deflateInit2(&context->z_stream,
-                           /* compression level */
-                           compress_level,
-                           /* compression method */
-                           Z_DEFLATED,
-                           /* compression memory resources */
-                           15, 9,
-                           /* compression strategy (image data are filtered)*/
-                           compress_type);
+        err = deflateInit2(
+            &context->z_stream,
+            /* compression level */
+            compress_level,
+            /* compression method */
+            Z_DEFLATED,
+            /* compression memory resources */
+            15,
+            9,
+            /* compression strategy (image data are filtered)*/
+            compress_type);
         if (err < 0) {
             state->errcode = IMAGING_CODEC_CONFIG;
             return -1;
         }

         if (context->dictionary && context->dictionary_size > 0) {
-            err = deflateSetDictionary(&context->z_stream, (unsigned char *)context->dictionary,
-                                       context->dictionary_size);
+            err = deflateSetDictionary(
+                &context->z_stream,
+                (unsigned char *)context->dictionary,
+                context->dictionary_size);
             if (err < 0) {
                 state->errcode = IMAGING_CODEC_CONFIG;
                 return -1;
@@ -116,7 +117,6 @@

         /* Ready to decode */
         state->state = 1;
-
     }

     /* Setup the destination buffer */
@@ -147,203 +147,194 @@

     ImagingSectionEnter(&cookie);
     for (;;) {
-
         switch (state->state) {
-
-        case 1:
-
-            /* Compress image data */
-            while (context->z_stream.avail_out > 0) {
-
-                if (state->y >= state->ysize) {
-                    /* End of image; now flush compressor buffers */
-                    state->state = 2;
-                    break;
-
-                }
-
-                /* Stuff image data into the compressor */
-                state->shuffle(state->buffer+1,
-                               (UINT8*) im->image[state->y + state->yoff] +
-                               state->xoff * im->pixelsize,
-                               state->xsize);
-
-                state->y++;
-
-                context->output = state->buffer;
-
-                if (context->mode == ZIP_PNG) {
-
-                    /* Filter the image data.  For each line, select
-                       the filter that gives the least total distance
-                       from zero for the filtered data (taken from
-                       LIBPNG) */
-
-                    bpp = (state->bits + 7) / 8;
-
-                    /* 0. No filter */
-                    for (i = 1, sum = 0; i <= state->bytes; i++) {
-                        UINT8 v = state->buffer[i];
-                        sum += (v < 128) ? v : 256 - v;
-                    }
-
-                    /* 2. Up.  We'll test this first to save time when
-                       an image line is identical to the one above. */
-                    if (sum > 0) {
-                        for (i = 1, s = 0; i <= state->bytes; i++) {
-                            UINT8 v = state->buffer[i] - context->previous[i];
-                            context->up[i] = v;
-                            s += (v < 128) ? v : 256 - v;
-                        }
-                        if (s < sum) {
-                            context->output = context->up;
-                            sum = s; /* 0 if line was duplicated */
-                        }
-                    }
-
-                    /* 1. Prior */
-                    if (sum > 0) {
-                        for (i = 1, s = 0; i <= bpp; i++) {
+            case 1:
+
+                /* Compress image data */
+                while (context->z_stream.avail_out > 0) {
+                    if (state->y >= state->ysize) {
+                        /* End of image; now flush compressor buffers */
+                        state->state = 2;
+                        break;
+                    }
+
+                    /* Stuff image data into the compressor */
+                    state->shuffle(
+                        state->buffer + 1,
+                        (UINT8 *)im->image[state->y + state->yoff] +
+                            state->xoff * im->pixelsize,
+                        state->xsize);
+
+                    state->y++;
+
+                    context->output = state->buffer;
+
+                    if (context->mode == ZIP_PNG) {
+                        /* Filter the image data.  For each line, select
+                           the filter that gives the least total distance
+                           from zero for the filtered data (taken from
+                           LIBPNG) */
+
+                        bpp = (state->bits + 7) / 8;
+
+                        /* 0. No filter */
+                        for (i = 1, sum = 0; i <= state->bytes; i++) {
                             UINT8 v = state->buffer[i];
-                            context->prior[i] = v;
-                            s += (v < 128) ? v : 256 - v;
-                        }
-                        for (; i <= state->bytes; i++) {
-                            UINT8 v = state->buffer[i] - state->buffer[i-bpp];
-                            context->prior[i] = v;
-                            s += (v < 128) ? v : 256 - v;
-                        }
-                        if (s < sum) {
-                            context->output = context->prior;
-                            sum = s; /* 0 if line is solid */
-                        }
-                    }
-
-                    /* 3. Average (not very common in real-life images,
-                       so its only used with the optimize option) */
-                    if (context->optimize && sum > 0) {
-                        for (i = 1, s = 0; i <= bpp; i++) {
-                            UINT8 v = state->buffer[i] - context->previous[i]/2;
-                            context->average[i] = v;
-                            s += (v < 128) ? v : 256 - v;
-                        }
-                        for (; i <= state->bytes; i++) {
-                            UINT8 v = state->buffer[i] -
-                                      (state->buffer[i-bpp] + context->previous[i])/2;
-                            context->average[i] = v;
-                            s += (v < 128) ? v : 256 - v;
-                        }
-                        if (s < sum) {
-                            context->output = context->average;
-                            sum = s;
-                        }
-                    }
-
-                    /* 4. Paeth */
-                    if (sum > 0) {
-                        for (i = 1, s = 0; i <= bpp; i++) {
-                            UINT8 v = state->buffer[i] - context->previous[i];
-                            context->paeth[i] = v;
-                            s += (v < 128) ? v : 256 - v;
-                        }
-                        for (; i <= state->bytes; i++) {
-                            UINT8 v;
-                            int a, b, c;
-                            int pa, pb, pc;
-
-                            /* fetch pixels */
-                            a = state->buffer[i-bpp];
-                            b = context->previous[i];
-                            c = context->previous[i-bpp];
-
-                            /* distances to surrounding pixels */
-                            pa = abs(b - c);
-                            pb = abs(a - c);
-                            pc = abs(a + b - 2*c);
-
-                            /* pick predictor with the shortest distance */
-                            v = state->buffer[i] -
-                                ((pa <= pb && pa <= pc) ? a :
-                                 (pb <= pc) ? b : c);
-                            context->paeth[i] = v;
-                            s += (v < 128) ? v : 256 - v;
-                        }
-                        if (s < sum) {
-                            context->output = context->paeth;
-                            sum = s;
-                        }
-                    }
-                }
-
-                /* Compress this line */
-                context->z_stream.next_in = context->output;
-                context->z_stream.avail_in = state->bytes+1;
-
-                err = deflate(&context->z_stream, Z_NO_FLUSH);
-
-                if (err < 0) {
-                    /* Something went wrong inside the compression library */
-                    if (err == Z_DATA_ERROR) {
-                        state->errcode = IMAGING_CODEC_BROKEN;
-                    } else if (err == Z_MEM_ERROR) {
-                        state->errcode = IMAGING_CODEC_MEMORY;
-                    } else {
-                        state->errcode = IMAGING_CODEC_CONFIG;
-                    }
-                    free(context->paeth);
-                    free(context->average);
-                    free(context->up);
-                    free(context->prior);
-                    free(context->previous);
-                    deflateEnd(&context->z_stream);
-                    ImagingSectionLeave(&cookie);
-                    return -1;
-                }
-
-                /* Swap buffer pointers */
-                ptr = state->buffer;
-                state->buffer = context->previous;
-                context->previous = ptr;
-
-            }
-
-            if (context->z_stream.avail_out == 0) {
-                break; /* Buffer full */
-            }
-
-        case 2:
-
-            /* End of image data; flush compressor buffers */
-
-            while (context->z_stream.avail_out > 0) {
-
-                err = deflate(&context->z_stream, Z_FINISH);
-
-                if (err == Z_STREAM_END) {
-
-                    free(context->paeth);
-                    free(context->average);
-                    free(context->up);
-                    free(context->prior);
-                    free(context->previous);
-
-                    deflateEnd(&context->z_stream);
-
-                    state->errcode = IMAGING_CODEC_END;
-
-                    break;
+                            sum += (v < 128) ? v : 256 - v;
+                        }
+
+                        /* 2. Up.  We'll test this first to save time when
+                           an image line is identical to the one above. */
+                        if (sum > 0) {
+                            for (i = 1, s = 0; i <= state->bytes; i++) {
+                                UINT8 v = state->buffer[i] - context->previous[i];
+                                context->up[i] = v;
+                                s += (v < 128) ? v : 256 - v;
+                            }
+                            if (s < sum) {
+                                context->output = context->up;
+                                sum = s; /* 0 if line was duplicated */
+                            }
+                        }
+
+                        /* 1. Prior */
+                        if (sum > 0) {
+                            for (i = 1, s = 0; i <= bpp; i++) {
+                                UINT8 v = state->buffer[i];
+                                context->prior[i] = v;
+                                s += (v < 128) ? v : 256 - v;
+                            }
+                            for (; i <= state->bytes; i++) {
+                                UINT8 v = state->buffer[i] - state->buffer[i - bpp];
+                                context->prior[i] = v;
+                                s += (v < 128) ? v : 256 - v;
+                            }
+                            if (s < sum) {
+                                context->output = context->prior;
+                                sum = s; /* 0 if line is solid */
+                            }
+                        }
+
+                        /* 3. Average (not very common in real-life images,
+                           so its only used with the optimize option) */
+                        if (context->optimize && sum > 0) {
+                            for (i = 1, s = 0; i <= bpp; i++) {
+                                UINT8 v = state->buffer[i] - context->previous[i] / 2;
+                                context->average[i] = v;
+                                s += (v < 128) ? v : 256 - v;
+                            }
+                            for (; i <= state->bytes; i++) {
+                                UINT8 v =
+                                    state->buffer[i] -
+                                    (state->buffer[i - bpp] + context->previous[i]) / 2;
+                                context->average[i] = v;
+                                s += (v < 128) ? v : 256 - v;
+                            }
+                            if (s < sum) {
+                                context->output = context->average;
+                                sum = s;
+                            }
+                        }
+
+                        /* 4. Paeth */
+                        if (sum > 0) {
+                            for (i = 1, s = 0; i <= bpp; i++) {
+                                UINT8 v = state->buffer[i] - context->previous[i];
+                                context->paeth[i] = v;
+                                s += (v < 128) ? v : 256 - v;
+                            }
+                            for (; i <= state->bytes; i++) {
+                                UINT8 v;
+                                int a, b, c;
+                                int pa, pb, pc;
+
+                                /* fetch pixels */
+                                a = state->buffer[i - bpp];
+                                b = context->previous[i];
+                                c = context->previous[i - bpp];
+
+                                /* distances to surrounding pixels */
+                                pa = abs(b - c);
+                                pb = abs(a - c);
+                                pc = abs(a + b - 2 * c);
+
+                                /* pick predictor with the shortest distance */
+                                v = state->buffer[i] - ((pa <= pb && pa <= pc) ? a
+                                                        : (pb <= pc)           ? b
+                                                                               : c);
+                                context->paeth[i] = v;
+                                s += (v < 128) ? v : 256 - v;
+                            }
+                            if (s < sum) {
+                                context->output = context->paeth;
+                                sum = s;
+                            }
+                        }
+                    }
+
+                    /* Compress this line */
+                    context->z_stream.next_in = context->output;
+                    context->z_stream.avail_in = state->bytes + 1;
+
+                    err = deflate(&context->z_stream, Z_NO_FLUSH);
+
+                    if (err < 0) {
+                        /* Something went wrong inside the compression library */
+                        if (err == Z_DATA_ERROR) {
+                            state->errcode = IMAGING_CODEC_BROKEN;
+                        } else if (err == Z_MEM_ERROR) {
+                            state->errcode = IMAGING_CODEC_MEMORY;
+                        } else {
+                            state->errcode = IMAGING_CODEC_CONFIG;
+                        }
+                        free(context->paeth);
+                        free(context->average);
+                        free(context->up);
+                        free(context->prior);
+                        free(context->previous);
+                        deflateEnd(&context->z_stream);
+                        ImagingSectionLeave(&cookie);
+                        return -1;
+                    }
+
+                    /* Swap buffer pointers */
+                    ptr = state->buffer;
+                    state->buffer = context->previous;
+                    context->previous = ptr;
                 }

                 if (context->z_stream.avail_out == 0) {
                     break; /* Buffer full */
                 }

-            }
-
+            case 2:
+
+                /* End of image data; flush compressor buffers */
+
+                while (context->z_stream.avail_out > 0) {
+                    err = deflate(&context->z_stream, Z_FINISH);
+
+                    if (err == Z_STREAM_END) {
+                        free(context->paeth);
+                        free(context->average);
+                        free(context->up);
+                        free(context->prior);
+                        free(context->previous);
+
+                        deflateEnd(&context->z_stream);
+
+                        state->errcode = IMAGING_CODEC_END;
+
+                        break;
+                    }
+
+                    if (context->z_stream.avail_out == 0) {
+                        break; /* Buffer full */
+                    }
+                }
         }
         ImagingSectionLeave(&cookie);
         return bytes - context->z_stream.avail_out;
-
     }

     /* Should never ever arrive here... */
@@ -358,21 +349,18 @@

 int
 ImagingZipEncodeCleanup(ImagingCodecState state) {
-    ZIPSTATE* context = (ZIPSTATE*) state->context;
+    ZIPSTATE *context = (ZIPSTATE *)state->context;

     if (context->dictionary) {
-        free (context->dictionary);
+        free(context->dictionary);
         context->dictionary = NULL;
     }

     return -1;
 }

-
-
-const char*
-ImagingZipVersion(void)
-{
+const char *
+ImagingZipVersion(void) {
     return zlibVersion();
 }

('src/libImaging', 'QuantPngQuant.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -3,7 +3,9 @@

 #include "QuantTypes.h"

-int quantize_pngquant(Pixel *,
+int
+quantize_pngquant(
+    Pixel *,
     unsigned int,
     unsigned int,
     uint32_t,
('src/libImaging', 'Bit.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,7 +1,6 @@
 /* Bit.h */

 typedef struct {
-
     /* CONFIGURATION */

     /* Number of bits per pixel */
@@ -19,7 +18,7 @@

     /* Lookup table (not implemented) */
     unsigned long lutsize;
-    FLOAT32* lut;
+    FLOAT32 *lut;

     /* INTERNAL */
     unsigned long mask;
('src/libImaging', 'Copy.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,18 +15,15 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 static Imaging
-_copy(Imaging imOut, Imaging imIn)
-{
+_copy(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int y;

     if (!imIn) {
-        return (Imaging) ImagingError_ValueError(NULL);
+        return (Imaging)ImagingError_ValueError(NULL);
     }

     imOut = ImagingNew2Dirty(imIn->mode, imOut, imIn);
@@ -50,13 +47,11 @@
 }

 Imaging
-ImagingCopy(Imaging imIn)
-{
+ImagingCopy(Imaging imIn) {
     return _copy(NULL, imIn);
 }

 Imaging
-ImagingCopy2(Imaging imOut, Imaging imIn)
-{
+ImagingCopy2(Imaging imOut, Imaging imIn) {
     return _copy(imOut, imIn);
 }
('src/libImaging', 'Draw.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -37,17 +37,17 @@
 #include <math.h>
 #include <stdint.h>

-#define CEIL(v)  (int) ceil(v)
-#define FLOOR(v) ((v) >= 0.0 ? (int) (v) : (int) floor(v))
-
-#define INK8(ink) (*(UINT8*)ink)
+#define CEIL(v) (int)ceil(v)
+#define FLOOR(v) ((v) >= 0.0 ? (int)(v) : (int)floor(v))
+
+#define INK8(ink) (*(UINT8 *)ink)

 /*
  * Rounds around zero (up=away from zero, down=towards zero)
  * This guarantees that ROUND_UP|DOWN(f) == -ROUND_UP|DOWN(-f)
  */
-#define ROUND_UP(f)    ((int) ((f) >= 0.0 ? floor((f) + 0.5F) : -floor(fabs(f) + 0.5F)))
-#define ROUND_DOWN(f)    ((int) ((f) >= 0.0 ? ceil((f) - 0.5F) : -ceil(fabs(f) - 0.5F)))
+#define ROUND_UP(f) ((int)((f) >= 0.0 ? floor((f) + 0.5F) : -floor(fabs(f) + 0.5F)))
+#define ROUND_DOWN(f) ((int)((f) >= 0.0 ? ceil((f)-0.5F) : -ceil(fabs(f) - 0.5F)))

 /* -------------------------------------------------------------------- */
 /* Primitives                                                           */
@@ -65,34 +65,31 @@
 typedef void (*hline_handler)(Imaging, int, int, int, int);

 static inline void
-point8(Imaging im, int x, int y, int ink)
-{
+point8(Imaging im, int x, int y, int ink) {
     if (x >= 0 && x < im->xsize && y >= 0 && y < im->ysize) {
         if (strncmp(im->mode, "I;16", 4) == 0) {
-            im->image8[y][x*2] = (UINT8) ink;
-            im->image8[y][x*2+1] = (UINT8) ink;
+            im->image8[y][x * 2] = (UINT8)ink;
+            im->image8[y][x * 2 + 1] = (UINT8)ink;
         } else {
-            im->image8[y][x] = (UINT8) ink;
+            im->image8[y][x] = (UINT8)ink;
         }
     }
 }

 static inline void
-point32(Imaging im, int x, int y, int ink)
-{
+point32(Imaging im, int x, int y, int ink) {
     if (x >= 0 && x < im->xsize && y >= 0 && y < im->ysize) {
         im->image32[y][x] = ink;
     }
 }

 static inline void
-point32rgba(Imaging im, int x, int y, int ink)
-{
+point32rgba(Imaging im, int x, int y, int ink) {
     unsigned int tmp1;

     if (x >= 0 && x < im->xsize && y >= 0 && y < im->ysize) {
-        UINT8* out = (UINT8*) im->image[y]+x*4;
-        UINT8* in = (UINT8*) &ink;
+        UINT8 *out = (UINT8 *)im->image[y] + x * 4;
+        UINT8 *in = (UINT8 *)&ink;
         out[0] = BLEND(in[3], out[0], in[0], tmp1);
         out[1] = BLEND(in[3], out[1], in[1], tmp1);
         out[2] = BLEND(in[3], out[2], in[2], tmp1);
@@ -100,8 +97,7 @@
 }

 static inline void
-hline8(Imaging im, int x0, int y0, int x1, int ink)
-{
+hline8(Imaging im, int x0, int y0, int x1, int ink) {
     int tmp, pixelwidth;

     if (y0 >= 0 && y0 < im->ysize) {
@@ -116,21 +112,22 @@
         if (x1 < 0) {
             return;
         } else if (x1 >= im->xsize) {
-            x1 = im->xsize-1;
+            x1 = im->xsize - 1;
         }
         if (x0 <= x1) {
             pixelwidth = strncmp(im->mode, "I;16", 4) == 0 ? 2 : 1;
-            memset(im->image8[y0] + x0 * pixelwidth, (UINT8) ink,
-                   (x1 - x0 + 1) * pixelwidth);
+            memset(
+                im->image8[y0] + x0 * pixelwidth,
+                (UINT8)ink,
+                (x1 - x0 + 1) * pixelwidth);
         }
     }
 }

 static inline void
-hline32(Imaging im, int x0, int y0, int x1, int ink)
-{
+hline32(Imaging im, int x0, int y0, int x1, int ink) {
     int tmp;
-    INT32* p;
+    INT32 *p;

     if (y0 >= 0 && y0 < im->ysize) {
         if (x0 > x1) {
@@ -144,7 +141,7 @@
         if (x1 < 0) {
             return;
         } else if (x1 >= im->xsize) {
-            x1 = im->xsize-1;
+            x1 = im->xsize - 1;
         }
         p = im->image32[y0];
         while (x0 <= x1) {
@@ -154,8 +151,7 @@
 }

 static inline void
-hline32rgba(Imaging im, int x0, int y0, int x1, int ink)
-{
+hline32rgba(Imaging im, int x0, int y0, int x1, int ink) {
     int tmp;
     unsigned int tmp1;

@@ -171,36 +167,36 @@
         if (x1 < 0) {
             return;
         } else if (x1 >= im->xsize) {
-            x1 = im->xsize-1;
+            x1 = im->xsize - 1;
         }
         if (x0 <= x1) {
-            UINT8* out = (UINT8*) im->image[y0]+x0*4;
-            UINT8* in = (UINT8*) &ink;
+            UINT8 *out = (UINT8 *)im->image[y0] + x0 * 4;
+            UINT8 *in = (UINT8 *)&ink;
             while (x0 <= x1) {
                 out[0] = BLEND(in[3], out[0], in[0], tmp1);
                 out[1] = BLEND(in[3], out[1], in[1], tmp1);
                 out[2] = BLEND(in[3], out[2], in[2], tmp1);
-                x0++; out += 4;
+                x0++;
+                out += 4;
             }
         }
     }
 }

 static inline void
-line8(Imaging im, int x0, int y0, int x1, int y1, int ink)
-{
+line8(Imaging im, int x0, int y0, int x1, int y1, int ink) {
     int i, n, e;
     int dx, dy;
     int xs, ys;

     /* normalize coordinates */
-    dx = x1-x0;
+    dx = x1 - x0;
     if (dx < 0) {
         dx = -dx, xs = -1;
     } else {
         xs = 1;
     }
-    dy = y1-y0;
+    dy = y1 - y0;
     if (dy < 0) {
         dy = -dy, ys = -1;
     } else {
@@ -210,7 +206,6 @@
     n = (dx > dy) ? dx : dy;

     if (dx == 0) {
-
         /* vertical */
         for (i = 0; i < dy; i++) {
             point8(im, x0, y0, ink);
@@ -218,7 +213,6 @@
         }

     } else if (dy == 0) {
-
         /* horizontal */
         for (i = 0; i < dx; i++) {
             point8(im, x0, y0, ink);
@@ -226,7 +220,6 @@
         }

     } else if (dx > dy) {
-
         /* bresenham, horizontal slope */
         n = dx;
         dy += dy;
@@ -244,7 +237,6 @@
         }

     } else {
-
         /* bresenham, vertical slope */
         n = dy;
         dx += dx;
@@ -260,25 +252,23 @@
             e += dx;
             y0 += ys;
         }
-
     }
 }

 static inline void
-line32(Imaging im, int x0, int y0, int x1, int y1, int ink)
-{
+line32(Imaging im, int x0, int y0, int x1, int y1, int ink) {
     int i, n, e;
     int dx, dy;
     int xs, ys;

     /* normalize coordinates */
-    dx = x1-x0;
+    dx = x1 - x0;
     if (dx < 0) {
         dx = -dx, xs = -1;
     } else {
         xs = 1;
     }
-    dy = y1-y0;
+    dy = y1 - y0;
     if (dy < 0) {
         dy = -dy, ys = -1;
     } else {
@@ -288,7 +278,6 @@
     n = (dx > dy) ? dx : dy;

     if (dx == 0) {
-
         /* vertical */
         for (i = 0; i < dy; i++) {
             point32(im, x0, y0, ink);
@@ -296,7 +285,6 @@
         }

     } else if (dy == 0) {
-
         /* horizontal */
         for (i = 0; i < dx; i++) {
             point32(im, x0, y0, ink);
@@ -304,7 +292,6 @@
         }

     } else if (dx > dy) {
-
         /* bresenham, horizontal slope */
         n = dx;
         dy += dy;
@@ -322,7 +309,6 @@
         }

     } else {
-
         /* bresenham, vertical slope */
         n = dy;
         dx += dx;
@@ -338,25 +324,23 @@
             e += dx;
             y0 += ys;
         }
-
     }
 }

 static inline void
-line32rgba(Imaging im, int x0, int y0, int x1, int y1, int ink)
-{
+line32rgba(Imaging im, int x0, int y0, int x1, int y1, int ink) {
     int i, n, e;
     int dx, dy;
     int xs, ys;

     /* normalize coordinates */
-    dx = x1-x0;
+    dx = x1 - x0;
     if (dx < 0) {
         dx = -dx, xs = -1;
     } else {
         xs = 1;
     }
-    dy = y1-y0;
+    dy = y1 - y0;
     if (dy < 0) {
         dy = -dy, ys = -1;
     } else {
@@ -366,7 +350,6 @@
     n = (dx > dy) ? dx : dy;

     if (dx == 0) {
-
         /* vertical */
         for (i = 0; i < dy; i++) {
             point32rgba(im, x0, y0, ink);
@@ -374,7 +357,6 @@
         }

     } else if (dy == 0) {
-
         /* horizontal */
         for (i = 0; i < dx; i++) {
             point32rgba(im, x0, y0, ink);
@@ -382,7 +364,6 @@
         }

     } else if (dx > dy) {
-
         /* bresenham, horizontal slope */
         n = dx;
         dy += dy;
@@ -400,7 +381,6 @@
         }

     } else {
-
         /* bresenham, vertical slope */
         n = dy;
         dx += dx;
@@ -416,14 +396,12 @@
             e += dx;
             y0 += ys;
         }
-
     }
 }

 static int
-x_cmp(const void *x0, const void *x1)
-{
-    float diff = *((float*)x0) - *((float*)x1);
+x_cmp(const void *x0, const void *x1) {
+    float diff = *((float *)x0) - *((float *)x1);
     if (diff < 0) {
         return -1;
     } else if (diff > 0) {
@@ -433,10 +411,9 @@
     }
 }

-
 static void
-draw_horizontal_lines(Imaging im, int n, Edge *e, int ink, int *x_pos, int y, hline_handler hline)
-{
+draw_horizontal_lines(
+    Imaging im, int n, Edge *e, int ink, int *x_pos, int y, hline_handler hline) {
     int i;
     for (i = 0; i < n; i++) {
         if (e[i].ymin == y && e[i].ymin == e[i].ymax) {
@@ -458,7 +435,7 @@
             }

             (*hline)(im, xmin, e[i].ymin, xmax, ink);
-            *x_pos = xmax+1;
+            *x_pos = xmax + 1;
         }
     }
 }
@@ -467,16 +444,14 @@
  * Filled polygon draw function using scan line algorithm.
  */
 static inline int
-polygon_generic(Imaging im, int n, Edge *e, int ink, int eofill,
-        hline_handler hline)
-{
-
-    Edge** edge_table;
-    float* xx;
+polygon_generic(Imaging im, int n, Edge *e, int ink, int eofill, hline_handler hline, int hasAlpha) {
+    Edge **edge_table;
+    float *xx;
     int edge_count = 0;
     int ymin = im->ysize - 1;
     int ymax = 0;
-    int i;
+    int i, j, k;
+    float adjacent_line_x, adjacent_line_x_other_edge;

     if (n <= 0) {
         return 0;
@@ -484,7 +459,7 @@

     /* Initialize the edge table and find polygon boundaries */
     /* malloc check ok, using calloc */
-    edge_table = calloc(n, sizeof(Edge*));
+    edge_table = calloc(n, sizeof(Edge *));
     if (!edge_table) {
         return -1;
     }
@@ -497,6 +472,9 @@
             ymax = e[i].ymax;
         }
         if (e[i].ymin == e[i].ymax) {
+            if (hasAlpha != 1) {
+                (*hline)(im, e[i].xmin, e[i].ymin, e[i].xmax, ink);
+            }
             continue;
         }
         edge_table[edge_count++] = (e + i);
@@ -516,45 +494,83 @@
         return -1;
     }
     for (; ymin <= ymax; ymin++) {
-        int j = 0;
-        int x_pos = 0;
+        j = 0;
         for (i = 0; i < edge_count; i++) {
-            Edge* current = edge_table[i];
+            Edge *current = edge_table[i];
             if (ymin >= current->ymin && ymin <= current->ymax) {
                 xx[j++] = (ymin - current->y0) * current->dx + current->x0;
-            }
-            /* Needed to draw consistent polygons */
-            if (ymin == current->ymax && ymin < ymax) {
-                xx[j] = xx[j - 1];
-                j++;
+
+                if (ymin == current->ymax && ymin < ymax) {
+                    // Needed to draw consistent polygons
+                    xx[j] = xx[j - 1];
+                    j++;
+                } else if (current->dx != 0 && roundf(xx[j-1]) == xx[j-1]) {
+                    // Connect discontiguous corners
+                    for (k = 0; k < i; k++) {
+                        Edge *other_edge = edge_table[k];
+                        if ((current->dx > 0 && other_edge->dx <= 0) ||
+                            (current->dx < 0 && other_edge->dx >= 0)) {
+                            continue;
+                        }
+                        // Check if the two edges join to make a corner
+                        if (xx[j-1] == (ymin - other_edge->y0) * other_edge->dx + other_edge->x0) {
+                            // Determine points from the edges on the next row
+                            // Or if this is the last row, check the previous row
+                            int offset = ymin == ymax ? -1 : 1;
+                            adjacent_line_x = (ymin + offset - current->y0) * current->dx + current->x0;
+                            adjacent_line_x_other_edge = (ymin + offset - other_edge->y0) * other_edge->dx + other_edge->x0;
+                            if (ymin == current->ymax) {
+                                if (current->dx > 0) {
+                                    xx[k] = fmax(adjacent_line_x, adjacent_line_x_other_edge) + 1;
+                                } else {
+                                    xx[k] = fmin(adjacent_line_x, adjacent_line_x_other_edge) - 1;
+                                }
+                            } else {
+                                if (current->dx > 0) {
+                                    xx[k] = fmin(adjacent_line_x, adjacent_line_x_other_edge);
+                                } else {
+                                    xx[k] = fmax(adjacent_line_x, adjacent_line_x_other_edge) + 1;
+                                }
+                            }
+                            break;
+                        }
+                    }
+                }
             }
         }
         qsort(xx, j, sizeof(float), x_cmp);
-        for (i = 1; i < j; i += 2) {
-            int x_end = ROUND_DOWN(xx[i]);
-            if (x_end < x_pos) {
-                // Line would be before the current position
-                continue;
-            }
-            draw_horizontal_lines(im, n, e, ink, &x_pos, ymin, hline);
-            if (x_end < x_pos) {
-                // Line would be before the current position
-                continue;
-            }
-
-            int x_start = ROUND_UP(xx[i-1]);
-            if (x_pos > x_start) {
-                // Line would be partway through x_pos, so increase the starting point
-                x_start = x_pos;
-                if (x_end < x_start) {
-                    // Line would now end before it started
+        if (hasAlpha == 1) {
+            int x_pos = 0;
+            for (i = 1; i < j; i += 2) {
+                int x_end = ROUND_DOWN(xx[i]);
+                if (x_end < x_pos) {
+                    // Line would be before the current position
                     continue;
                 }
-            }
-            (*hline)(im, x_start, ymin, x_end, ink);
-            x_pos = x_end+1;
-        }
-        draw_horizontal_lines(im, n, e, ink, &x_pos, ymin, hline);
+                draw_horizontal_lines(im, n, e, ink, &x_pos, ymin, hline);
+                if (x_end < x_pos) {
+                    // Line would be before the current position
+                    continue;
+                }
+
+                int x_start = ROUND_UP(xx[i - 1]);
+                if (x_pos > x_start) {
+                    // Line would be partway through x_pos, so increase the starting point
+                    x_start = x_pos;
+                    if (x_end < x_start) {
+                        // Line would now end before it started
+                        continue;
+                    }
+                }
+                (*hline)(im, x_start, ymin, x_end, ink);
+                x_pos = x_end + 1;
+            }
+            draw_horizontal_lines(im, n, e, ink, &x_pos, ymin, hline);
+        } else {
+            for (i = 1; i < j; i += 2) {
+                (*hline)(im, ROUND_UP(xx[i - 1]), ymin, ROUND_DOWN(xx[i]), ink);
+            }
+        }
     }

     free(xx);
@@ -563,26 +579,22 @@
 }

 static inline int
-polygon8(Imaging im, int n, Edge *e, int ink, int eofill)
-{
-    return polygon_generic(im, n, e, ink, eofill, hline8);
+polygon8(Imaging im, int n, Edge *e, int ink, int eofill) {
+    return polygon_generic(im, n, e, ink, eofill, hline8, 0);
 }

 static inline int
-polygon32(Imaging im, int n, Edge *e, int ink, int eofill)
-{
-    return polygon_generic(im, n, e, ink, eofill, hline32);
+polygon32(Imaging im, int n, Edge *e, int ink, int eofill) {
+    return polygon_generic(im, n, e, ink, eofill, hline32, 0);
 }

 static inline int
-polygon32rgba(Imaging im, int n, Edge *e, int ink, int eofill)
-{
-    return polygon_generic(im, n, e, ink, eofill, hline32rgba);
+polygon32rgba(Imaging im, int n, Edge *e, int ink, int eofill) {
+    return polygon_generic(im, n, e, ink, eofill, hline32rgba, 1);
 }

 static inline void
-add_edge(Edge *e, int x0, int y0, int x1, int y1)
-{
+add_edge(Edge *e, int x0, int y0, int x1, int y1) {
     /* printf("edge %d %d %d %d\n", x0, y0, x1, y1); */

     if (x0 <= x1) {
@@ -601,7 +613,7 @@
         e->d = 0;
         e->dx = 0.0;
     } else {
-        e->dx = ((float)(x1-x0)) / (y1-y0);
+        e->dx = ((float)(x1 - x0)) / (y1 - y0);
         if (y0 == e->ymin) {
             e->d = 1;
         } else {
@@ -620,27 +632,26 @@
     int (*polygon)(Imaging im, int n, Edge *e, int ink, int eofill);
 } DRAW;

-DRAW draw8 = { point8,  hline8,  line8,  polygon8 };
-DRAW draw32 = { point32, hline32, line32, polygon32 };
-DRAW draw32rgba = { point32rgba, hline32rgba, line32rgba, polygon32rgba };
+DRAW draw8 = {point8, hline8, line8, polygon8};
+DRAW draw32 = {point32, hline32, line32, polygon32};
+DRAW draw32rgba = {point32rgba, hline32rgba, line32rgba, polygon32rgba};

 /* -------------------------------------------------------------------- */
 /* Interface                                                            */
 /* -------------------------------------------------------------------- */

-#define DRAWINIT()\
-    if (im->image8) {\
-        draw = &draw8;\
-        ink = INK8(ink_);\
-    } else {\
-        draw = (op) ? &draw32rgba : &draw32;    \
-        memcpy(&ink, ink_, sizeof(ink)); \
+#define DRAWINIT()                           \
+    if (im->image8) {                        \
+        draw = &draw8;                       \
+        ink = INK8(ink_);                    \
+    } else {                                 \
+        draw = (op) ? &draw32rgba : &draw32; \
+        memcpy(&ink, ink_, sizeof(ink));     \
     }

 int
-ImagingDrawPoint(Imaging im, int x0, int y0, const void* ink_, int op)
-{
-    DRAW* draw;
+ImagingDrawPoint(Imaging im, int x0, int y0, const void *ink_, int op) {
+    DRAW *draw;
     INT32 ink;

     DRAWINIT();
@@ -651,10 +662,8 @@
 }

 int
-ImagingDrawLine(Imaging im, int x0, int y0, int x1, int y1, const void* ink_,
-                int op)
-{
-    DRAW* draw;
+ImagingDrawLine(Imaging im, int x0, int y0, int x1, int y1, const void *ink_, int op) {
+    DRAW *draw;
     INT32 ink;

     DRAWINIT();
@@ -665,10 +674,9 @@
 }

 int
-ImagingDrawWideLine(Imaging im, int x0, int y0, int x1, int y1,
-                    const void* ink_, int width, int op)
-{
-    DRAW* draw;
+ImagingDrawWideLine(
+    Imaging im, int x0, int y0, int x1, int y1, const void *ink_, int width, int op) {
+    DRAW *draw;
     INT32 ink;
     int dx, dy;
     double big_hypotenuse, small_hypotenuse, ratio_max, ratio_min;
@@ -677,8 +685,8 @@

     DRAWINIT();

-    dx = x1-x0;
-    dy = y1-y0;
+    dx = x1 - x0;
+    dy = y1 - y0;
     if (dx == 0 && dy == 0) {
         draw->point(im, x0, y0, ink);
         return 0;
@@ -698,13 +706,12 @@
             {x0 - dxmin, y0 + dymax},
             {x1 - dxmin, y1 + dymax},
             {x1 + dxmax, y1 - dymin},
-            {x0 + dxmax, y0 - dymin}
-        };
-
-        add_edge(e+0, vertices[0][0], vertices[0][1], vertices[1][0], vertices[1][1]);
-        add_edge(e+1, vertices[1][0], vertices[1][1], vertices[2][0], vertices[2][1]);
-        add_edge(e+2, vertices[2][0], vertices[2][1], vertices[3][0], vertices[3][1]);
-        add_edge(e+3, vertices[3][0], vertices[3][1], vertices[0][0], vertices[0][1]);
+            {x0 + dxmax, y0 - dymin}};
+
+        add_edge(e + 0, vertices[0][0], vertices[0][1], vertices[1][0], vertices[1][1]);
+        add_edge(e + 1, vertices[1][0], vertices[1][1], vertices[2][0], vertices[2][1]);
+        add_edge(e + 2, vertices[2][0], vertices[2][1], vertices[3][0], vertices[3][1]);
+        add_edge(e + 3, vertices[3][0], vertices[3][1], vertices[0][0], vertices[0][1]);

         draw->polygon(im, 4, e, ink, 0);
     }
@@ -712,13 +719,20 @@
 }

 int
-ImagingDrawRectangle(Imaging im, int x0, int y0, int x1, int y1,
-                     const void* ink_, int fill, int width, int op)
-{
+ImagingDrawRectangle(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    const void *ink_,
+    int fill,
+    int width,
+    int op) {
     int i;
     int y;
     int tmp;
-    DRAW* draw;
+    DRAW *draw;
     INT32 ink;

     DRAWINIT();
@@ -728,7 +742,6 @@
     }

     if (fill) {
-
         if (y0 < 0) {
             y0 = 0;
         } else if (y0 >= im->ysize) {
@@ -751,10 +764,10 @@
             width = 1;
         }
         for (i = 0; i < width; i++) {
-            draw->hline(im, x0, y0+i, x1, ink);
-            draw->hline(im, x0, y1-i, x1, ink);
-            draw->line(im, x1-i, y0, x1-i, y1, ink);
-            draw->line(im, x0+i, y1, x0+i, y0, ink);
+            draw->hline(im, x0, y0 + i, x1, ink);
+            draw->hline(im, x0, y1 - i, x1, ink);
+            draw->line(im, x1 - i, y0 + width, x1 - i, y1 - width + 1, ink);
+            draw->line(im, x0 + i, y0 + width, x0 + i, y1 - width + 1, ink);
         }
     }

@@ -762,11 +775,9 @@
 }

 int
-ImagingDrawPolygon(Imaging im, int count, int* xy, const void* ink_,
-                   int fill, int op)
-{
-    int i, n;
-    DRAW* draw;
+ImagingDrawPolygon(Imaging im, int count, int *xy, const void *ink_, int fill, int width, int op) {
+    int i, n, x0, y0, x1, y1;
+    DRAW *draw;
     INT32 ink;

     if (count <= 0) {
@@ -776,44 +787,62 @@
     DRAWINIT();

     if (fill) {
-
         /* Build edge list */
         /* malloc check ok, using calloc */
-        Edge* e = calloc(count, sizeof(Edge));
+        Edge *e = calloc(count, sizeof(Edge));
         if (!e) {
-            (void) ImagingError_MemoryError();
+            (void)ImagingError_MemoryError();
             return -1;
         }
-        for (i = n = 0; i < count-1; i++) {
-            add_edge(&e[n++], xy[i+i], xy[i+i+1], xy[i+i+2], xy[i+i+3]);
-        }
-        if (xy[i+i] != xy[0] || xy[i+i+1] != xy[1]) {
-            add_edge(&e[n++], xy[i+i], xy[i+i+1], xy[0], xy[1]);
+        for (i = n = 0; i < count - 1; i++) {
+            x0 = xy[i * 2];
+            y0 = xy[i * 2 + 1];
+            x1 = xy[i * 2 + 2];
+            y1 = xy[i * 2 + 3];
+            if (y0 == y1 && i != 0 && y0 == xy[i * 2 - 1]) {
+                // This is a horizontal line,
+                // that immediately follows another horizontal line
+                Edge *last_e = &e[n-1];
+                if (x1 > x0 && x0 > xy[i * 2 - 2]) {
+                    // They are both increasing in x
+                    last_e->xmax = x1;
+                    continue;
+                } else if (x1 < x0 && x0 < xy[i * 2 - 2]) {
+                    // They are both decreasing in x
+                    last_e->xmin = x1;
+                    continue;
+                }
+            }
+            add_edge(&e[n++], x0, y0, x1, y1);
+        }
+        if (xy[i * 2] != xy[0] || xy[i * 2 + 1] != xy[1]) {
+            add_edge(&e[n++], xy[i * 2], xy[i * 2 + 1], xy[0], xy[1]);
         }
         draw->polygon(im, n, e, ink, 0);
         free(e);

     } else {
-
         /* Outline */
-        for (i = 0; i < count-1; i++) {
-            draw->line(im, xy[i+i], xy[i+i+1], xy[i+i+2], xy[i+i+3], ink);
-        }
-        draw->line(im, xy[i+i], xy[i+i+1], xy[0], xy[1], ink);
-
+        if (width == 1) {
+            for (i = 0; i < count - 1; i++) {
+                draw->line(im, xy[i * 2], xy[i * 2 + 1], xy[i * 2 + 2], xy[i * 2 + 3], ink);
+            }
+            draw->line(im, xy[i * 2], xy[i * 2 + 1], xy[0], xy[1], ink);
+        } else {
+            for (i = 0; i < count - 1; i++) {
+                ImagingDrawWideLine(im, xy[i * 2], xy[i * 2 + 1], xy[i * 2 + 2], xy[i * 2 + 3], ink_, width, op);
+            }
+            ImagingDrawWideLine(im, xy[i * 2], xy[i * 2 + 1], xy[0], xy[1], ink_, width, op);
+        }
     }

     return 0;
 }

 int
-ImagingDrawBitmap(Imaging im, int x0, int y0, Imaging bitmap, const void* ink,
-                  int op)
-{
+ImagingDrawBitmap(Imaging im, int x0, int y0, Imaging bitmap, const void *ink, int op) {
     return ImagingFill2(
-        im, ink, bitmap,
-        x0, y0, x0 + bitmap->xsize, y0 + bitmap->ysize
-        );
+        im, ink, bitmap, x0, y0, x0 + bitmap->xsize, y0 + bitmap->ysize);
 }

 /* -------------------------------------------------------------------- */
@@ -830,7 +859,8 @@
     int8_t finished;
 } quarter_state;

-void quarter_init(quarter_state* s, int32_t a, int32_t b) {
+void
+quarter_init(quarter_state *s, int32_t a, int32_t b) {
     if (a < 0 || b < 0) {
         s->finished = 1;
     } else {
@@ -849,11 +879,13 @@

 // deviation of the point from ellipse curve, basically a substitution
 // of the point into the ellipse equation
-int64_t quarter_delta(quarter_state* s, int64_t x, int64_t y) {
+int64_t
+quarter_delta(quarter_state *s, int64_t x, int64_t y) {
     return llabs(s->a2 * y * y + s->b2 * x * x - s->a2b2);
 }

-int8_t quarter_next(quarter_state* s, int32_t* ret_x, int32_t* ret_y) {
+int8_t
+quarter_next(quarter_state *s, int32_t *ret_x, int32_t *ret_y) {
     if (s->finished) {
         return -1;
     }
@@ -903,7 +935,8 @@
     int8_t leftmost;
 } ellipse_state;

-void ellipse_init(ellipse_state* s, int32_t a, int32_t b, int32_t w) {
+void
+ellipse_init(ellipse_state *s, int32_t a, int32_t b, int32_t w) {
     s->bufcnt = 0;
     s->leftmost = a % 2;
     quarter_init(&s->st_o, a, b);
@@ -916,7 +949,8 @@
     }
 }

-int8_t ellipse_next(ellipse_state* s, int32_t* ret_x0, int32_t* ret_y, int32_t* ret_x1) {
+int8_t
+ellipse_next(ellipse_state *s, int32_t *ret_x0, int32_t *ret_y, int32_t *ret_x1) {
     if (s->bufcnt == 0) {
         if (s->finished) {
             return -1;
@@ -974,470 +1008,519 @@
 // of resulting disjoint clipped segments organized into a sorted linked list
 // of their end points.
 typedef enum {
-  CT_AND, // intersection
-  CT_OR, // union
-  CT_CLIP // half-plane clipping
+    CT_AND,  // intersection
+    CT_OR,   // union
+    CT_CLIP  // half-plane clipping
 } clip_type;

 typedef struct clip_node {
-  clip_type type;
-  double a, b, c; // half-plane coeffs, only used in clipping nodes
-  struct clip_node* l; // child pointers, are only non-NULL in combining nodes
-  struct clip_node* r;
+    clip_type type;
+    double a, b, c;       // half-plane coeffs, only used in clipping nodes
+    struct clip_node *l;  // child pointers, are only non-NULL in combining nodes
+    struct clip_node *r;
 } clip_node;

 // Linked list for the ends of the clipped horizontal segments.
 // Since the segment is always horizontal, we don't need to store Y coordinate.
 typedef struct event_list {
-  int32_t x;
-  int8_t type; // used internally, 1 for the left end (smaller X), -1 for the
-               // right end; pointless in output since the output segments
-               // are disjoint, therefore the types would always come in pairs
-               // and interchange (1 -1 1 -1 ...)
-  struct event_list* next;
+    int32_t x;
+    int8_t type;  // used internally, 1 for the left end (smaller X), -1 for the
+                  // right end; pointless in output since the output segments
+                  // are disjoint, therefore the types would always come in pairs
+                  // and interchange (1 -1 1 -1 ...)
+    struct event_list *next;
 } event_list;

 // Mirrors all the clipping nodes of the tree relative to the y = x line.
-void clip_tree_transpose(clip_node* root) {
-  if (root != NULL) {
-    if (root->type == CT_CLIP) {
-      double t = root->a;
-      root->a = root->b;
-      root->b = t;
-    }
-    clip_tree_transpose(root->l);
-    clip_tree_transpose(root->r);
-  }
+void
+clip_tree_transpose(clip_node *root) {
+    if (root != NULL) {
+        if (root->type == CT_CLIP) {
+            double t = root->a;
+            root->a = root->b;
+            root->b = t;
+        }
+        clip_tree_transpose(root->l);
+        clip_tree_transpose(root->r);
+    }
 }

 // Outputs a sequence of open-close events (types -1 and 1) for
 // non-intersecting segments sorted by X coordinate.
 // Combining nodes (AND, OR) may also accept sequences for intersecting
 // segments, i.e. something like correct bracket sequences.
-int clip_tree_do_clip(clip_node* root, int32_t x0, int32_t y, int32_t x1, event_list** ret) {
-  if (root == NULL) {
-    event_list* start = malloc(sizeof(event_list));
-    if (!start) {
-      ImagingError_MemoryError();
-      return -1;
-    }
-    event_list* end = malloc(sizeof(event_list));
-    if (!end) {
-      free(start);
-      ImagingError_MemoryError();
-      return -1;
-    }
-    start->x = x0;
-    start->type = 1;
-    start->next = end;
-    end->x = x1;
-    end->type = -1;
-    end->next = NULL;
-    *ret = start;
+int
+clip_tree_do_clip(
+    clip_node *root, int32_t x0, int32_t y, int32_t x1, event_list **ret) {
+    if (root == NULL) {
+        event_list *start = malloc(sizeof(event_list));
+        if (!start) {
+            ImagingError_MemoryError();
+            return -1;
+        }
+        event_list *end = malloc(sizeof(event_list));
+        if (!end) {
+            free(start);
+            ImagingError_MemoryError();
+            return -1;
+        }
+        start->x = x0;
+        start->type = 1;
+        start->next = end;
+        end->x = x1;
+        end->type = -1;
+        end->next = NULL;
+        *ret = start;
+        return 0;
+    }
+    if (root->type == CT_CLIP) {
+        double eps = 1e-9;
+        double A = root->a;
+        double B = root->b;
+        double C = root->c;
+        if (fabs(A) < eps) {
+            if (B * y + C < -eps) {
+                x0 = 1;
+                x1 = 0;
+            }
+        } else {
+            // X of intersection
+            double ix = -(B * y + C) / A;
+            if (A * x0 + B * y + C < eps) {
+                x0 = lround(fmax(x0, ix));
+            }
+            if (A * x1 + B * y + C < eps) {
+                x1 = lround(fmin(x1, ix));
+            }
+        }
+        if (x0 <= x1) {
+            event_list *start = malloc(sizeof(event_list));
+            if (!start) {
+                ImagingError_MemoryError();
+                return -1;
+            }
+            event_list *end = malloc(sizeof(event_list));
+            if (!end) {
+                free(start);
+                ImagingError_MemoryError();
+                return -1;
+            }
+            start->x = x0;
+            start->type = 1;
+            start->next = end;
+            end->x = x1;
+            end->type = -1;
+            end->next = NULL;
+            *ret = start;
+        } else {
+            *ret = NULL;
+        }
+        return 0;
+    }
+    if (root->type == CT_OR || root->type == CT_AND) {
+        event_list *l1;
+        event_list *l2;
+        if (clip_tree_do_clip(root->l, x0, y, x1, &l1) < 0) {
+            return -1;
+        }
+        if (clip_tree_do_clip(root->r, x0, y, x1, &l2) < 0) {
+            while (l1) {
+                l2 = l1->next;
+                free(l1);
+                l1 = l2;
+            }
+            return -1;
+        }
+        *ret = NULL;
+        event_list *tail = NULL;
+        int32_t k1 = 0;
+        int32_t k2 = 0;
+        while (l1 != NULL || l2 != NULL) {
+            event_list *t;
+            if (l2 == NULL ||
+                (l1 != NULL &&
+                 (l1->x < l2->x || (l1->x == l2->x && l1->type > l2->type)))) {
+                t = l1;
+                k1 += t->type;
+                assert(k1 >= 0);
+                l1 = l1->next;
+            } else {
+                t = l2;
+                k2 += t->type;
+                assert(k2 >= 0);
+                l2 = l2->next;
+            }
+            t->next = NULL;
+            if ((root->type == CT_OR &&
+                 ((t->type == 1 && (tail == NULL || tail->type == -1)) ||
+                  (t->type == -1 && k1 == 0 && k2 == 0))) ||
+                (root->type == CT_AND &&
+                 ((t->type == 1 && (tail == NULL || tail->type == -1) && k1 > 0 &&
+                   k2 > 0) ||
+                  (t->type == -1 && tail != NULL && tail->type == 1 &&
+                   (k1 == 0 || k2 == 0))))) {
+                if (tail == NULL) {
+                    *ret = t;
+                } else {
+                    tail->next = t;
+                }
+                tail = t;
+            } else {
+                free(t);
+            }
+        }
+        return 0;
+    }
+    *ret = NULL;
     return 0;
-  }
-  if (root->type == CT_CLIP) {
-    double eps = 1e-9;
-    double A = root->a;
-    double B = root->b;
-    double C = root->c;
-    if (fabs(A) < eps) {
-      if (B * y + C < -eps) {
-        x0 = 1;
-        x1 = 0;
-      }
-    } else {
-      // X of intersection
-      double ix = - (B * y + C) / A;
-      if (A * x0 + B * y + C < eps) {
-        x0 = lround(fmax(x0, ix));
-      }
-      if (A * x1 + B * y + C < eps) {
-        x1 = lround(fmin(x1, ix));
-      }
-    }
-    if (x0 <= x1) {
-      event_list* start = malloc(sizeof(event_list));
-      if (!start) {
-        ImagingError_MemoryError();
-        return -1;
-      }
-      event_list* end = malloc(sizeof(event_list));
-      if (!end) {
-        free(start);
-        ImagingError_MemoryError();
-        return -1;
-      }
-      start->x = x0;
-      start->type = 1;
-      start->next = end;
-      end->x = x1;
-      end->type = -1;
-      end->next = NULL;
-      *ret = start;
-    } else {
-      *ret = NULL;
-    }
-    return 0;
-  }
-  if (root->type == CT_OR || root->type == CT_AND) {
-    event_list* l1;
-    event_list* l2;
-    if (clip_tree_do_clip(root->l, x0, y, x1, &l1) < 0) {
-      return -1;
-    }
-    if (clip_tree_do_clip(root->r, x0, y, x1, &l2) < 0) {
-      while (l1) {
-        l2 = l1->next;
-        free(l1);
-        l1 = l2;
-      }
-      return -1;
-    }
-    *ret = NULL;
-    event_list* tail = NULL;
-    int32_t k1 = 0;
-    int32_t k2 = 0;
-    while (l1 != NULL || l2 != NULL) {
-      event_list* t;
-      if (l2 == NULL || (l1 != NULL && (l1->x < l2->x || (l1->x == l2->x && l1->type > l2->type)))) {
-        t = l1;
-        k1 += t->type;
-        assert(k1 >= 0);
-        l1 = l1->next;
-      } else {
-        t = l2;
-        k2 += t->type;
-        assert(k2 >= 0);
-        l2 = l2->next;
-      }
-      t->next = NULL;
-      if ((root->type == CT_OR && (
-              (t->type == 1 && (tail == NULL || tail->type == -1)) ||
-              (t->type == -1 && k1 == 0 && k2 == 0)
-          )) ||
-          (root->type == CT_AND && (
-              (t->type == 1 && (tail == NULL || tail->type == -1) && k1 > 0 && k2 > 0) ||
-              (t->type == -1 && tail != NULL && tail->type == 1 && (k1 == 0 || k2 == 0))
-          ))) {
-        if (tail == NULL) {
-          *ret = t;
-        } else {
-          tail->next = t;
-        }
-        tail = t;
-      } else {
-        free(t);
-      }
-    }
-    return 0;
-  }
-  *ret = NULL;
-  return 0;
 }

 // One more layer of processing on top of the regular ellipse.
 // Uses the clipping tree.
 // Used for producing ellipse derivatives such as arc, chord, pie, etc.
 typedef struct {
-  ellipse_state st;
-  clip_node* root;
-  clip_node nodes[7];
-  int32_t node_count;
-  event_list* head;
-  int32_t y;
+    ellipse_state st;
+    clip_node *root;
+    clip_node nodes[7];
+    int32_t node_count;
+    event_list *head;
+    int32_t y;
 } clip_ellipse_state;

-typedef void (*clip_ellipse_init)(clip_ellipse_state*, int32_t, int32_t, int32_t, float, float);
-
-void debug_clip_tree(clip_node* root, int space) {
-  if (root == NULL) {
-    return;
-  }
-  if (root->type == CT_CLIP) {
-    int t = space;
-    while (t--) {
-      fputc(' ', stderr);
-    }
-    fprintf(stderr, "clip %+fx%+fy%+f > 0\n", root->a, root->b, root->c);
-  } else {
-    debug_clip_tree(root->l, space + 2);
-    int t = space;
-    while (t--) {
-      fputc(' ', stderr);
-    }
-    fprintf(stderr, "%s\n", root->type == CT_AND ? "and" : "or");
-    debug_clip_tree(root->r, space + 2);
-  }
-  if (space == 0) {
-    fputc('\n', stderr);
-  }
+typedef void (*clip_ellipse_init)(
+    clip_ellipse_state *, int32_t, int32_t, int32_t, float, float);
+
+void
+debug_clip_tree(clip_node *root, int space) {
+    if (root == NULL) {
+        return;
+    }
+    if (root->type == CT_CLIP) {
+        int t = space;
+        while (t--) {
+            fputc(' ', stderr);
+        }
+        fprintf(stderr, "clip %+fx%+fy%+f > 0\n", root->a, root->b, root->c);
+    } else {
+        debug_clip_tree(root->l, space + 2);
+        int t = space;
+        while (t--) {
+            fputc(' ', stderr);
+        }
+        fprintf(stderr, "%s\n", root->type == CT_AND ? "and" : "or");
+        debug_clip_tree(root->r, space + 2);
+    }
+    if (space == 0) {
+        fputc('\n', stderr);
+    }
 }

 // Resulting angles will satisfy 0 <= al < 360, al <= ar <= al + 360
-void normalize_angles(float* al, float* ar) {
-  if (*ar - *al >= 360) {
-    *al = 0;
-    *ar = 360;
-  } else {
-    *al = fmod(*al < 0 ? 360 - (fmod(-*al, 360)) : *al, 360);
-    *ar = *al + fmod(*ar < *al ? 360 - fmod(*al - *ar, 360) : *ar - *al, 360);
-  }
+void
+normalize_angles(float *al, float *ar) {
+    if (*ar - *al >= 360) {
+        *al = 0;
+        *ar = 360;
+    } else {
+        *al = fmod(*al < 0 ? 360 - (fmod(-*al, 360)) : *al, 360);
+        *ar = *al + fmod(*ar < *al ? 360 - fmod(*al - *ar, 360) : *ar - *al, 360);
+    }
 }

 // An arc with caps orthogonal to the ellipse curve.
-void arc_init(clip_ellipse_state* s, int32_t a, int32_t b, int32_t w, float al, float ar) {
-  if (a < b) {
-    // transpose the coordinate system
-    arc_init(s, b, a, w, 90 - ar, 90 - al);
-    ellipse_init(&s->st, a, b, w);
-    clip_tree_transpose(s->root);
-  } else {
-    // a >= b, based on "wide" ellipse
-    ellipse_init(&s->st, a, b, w);
+void
+arc_init(clip_ellipse_state *s, int32_t a, int32_t b, int32_t w, float al, float ar) {
+    if (a < b) {
+        // transpose the coordinate system
+        arc_init(s, b, a, w, 90 - ar, 90 - al);
+        ellipse_init(&s->st, a, b, w);
+        clip_tree_transpose(s->root);
+    } else {
+        // a >= b, based on "wide" ellipse
+        ellipse_init(&s->st, a, b, w);
+
+        s->head = NULL;
+        s->node_count = 0;
+        normalize_angles(&al, &ar);
+
+        // building clipping tree, a lot of different cases
+        if (ar == al + 360) {
+            s->root = NULL;
+        } else {
+            clip_node *lc = s->nodes + s->node_count++;
+            clip_node *rc = s->nodes + s->node_count++;
+            lc->l = lc->r = rc->l = rc->r = NULL;
+            lc->type = rc->type = CT_CLIP;
+            lc->a = -a * sin(al * M_PI / 180.0);
+            lc->b = b * cos(al * M_PI / 180.0);
+            lc->c = (a * a - b * b) * sin(al * M_PI / 90.0) / 2.0;
+            rc->a = a * sin(ar * M_PI / 180.0);
+            rc->b = -b * cos(ar * M_PI / 180.0);
+            rc->c = (b * b - a * a) * sin(ar * M_PI / 90.0) / 2.0;
+            if (fmod(al, 180) == 0 || fmod(ar, 180) == 0) {
+                s->root = s->nodes + s->node_count++;
+                s->root->l = lc;
+                s->root->r = rc;
+                s->root->type = ar - al < 180 ? CT_AND : CT_OR;
+            } else if (((int)(al / 180) + (int)(ar / 180)) % 2 == 1) {
+                s->root = s->nodes + s->node_count++;
+                s->root->l = s->nodes + s->node_count++;
+                s->root->l->l = s->nodes + s->node_count++;
+                s->root->l->r = lc;
+                s->root->r = s->nodes + s->node_count++;
+                s->root->r->l = s->nodes + s->node_count++;
+                s->root->r->r = rc;
+                s->root->type = CT_OR;
+                s->root->l->type = CT_AND;
+                s->root->r->type = CT_AND;
+                s->root->l->l->type = CT_CLIP;
+                s->root->r->l->type = CT_CLIP;
+                s->root->l->l->l = s->root->l->l->r = NULL;
+                s->root->r->l->l = s->root->r->l->r = NULL;
+                s->root->l->l->a = s->root->l->l->c = 0;
+                s->root->r->l->a = s->root->r->l->c = 0;
+                s->root->l->l->b = (int)(al / 180) % 2 == 0 ? 1 : -1;
+                s->root->r->l->b = (int)(ar / 180) % 2 == 0 ? 1 : -1;
+            } else {
+                s->root = s->nodes + s->node_count++;
+                s->root->l = s->nodes + s->node_count++;
+                s->root->r = s->nodes + s->node_count++;
+                s->root->type = s->root->l->type = ar - al < 180 ? CT_AND : CT_OR;
+                s->root->l->l = lc;
+                s->root->l->r = rc;
+                s->root->r->type = CT_CLIP;
+                s->root->r->l = s->root->r->r = NULL;
+                s->root->r->a = s->root->r->c = 0;
+                s->root->r->b = ar < 180 || ar > 540 ? 1 : -1;
+            }
+        }
+    }
+}
+
+// A chord line.
+void
+chord_line_init(
+    clip_ellipse_state *s, int32_t a, int32_t b, int32_t w, float al, float ar) {
+    ellipse_init(&s->st, a, b, a + b + 1);

     s->head = NULL;
     s->node_count = 0;
-    normalize_angles(&al, &ar);
-
-    // building clipping tree, a lot of different cases
-    if (ar == al + 360) {
-      s->root = NULL;
-    } else {
-      clip_node* lc = s->nodes + s->node_count++;
-      clip_node* rc = s->nodes + s->node_count++;
-      lc->l = lc->r = rc->l = rc->r = NULL;
-      lc->type = rc->type = CT_CLIP;
-      lc->a = -a * sin(al * M_PI / 180.0);
-      lc->b = b * cos(al * M_PI / 180.0);
-      lc->c = (a * a - b * b) * sin(al * M_PI / 90.0) / 2.0;
-      rc->a = a * sin(ar * M_PI / 180.0);
-      rc->b = -b * cos(ar * M_PI / 180.0);
-      rc->c = (b * b - a * a) * sin(ar * M_PI / 90.0) / 2.0;
-      if (fmod(al, 180) == 0 || fmod(ar, 180) == 0) {
+
+    // line equation for chord
+    double xl = a * cos(al * M_PI / 180.0), xr = a * cos(ar * M_PI / 180.0);
+    double yl = b * sin(al * M_PI / 180.0), yr = b * sin(ar * M_PI / 180.0);
+    s->root = s->nodes + s->node_count++;
+    s->root->l = s->nodes + s->node_count++;
+    s->root->r = s->nodes + s->node_count++;
+    s->root->type = CT_AND;
+    s->root->l->type = s->root->r->type = CT_CLIP;
+    s->root->l->l = s->root->l->r = s->root->r->l = s->root->r->r = NULL;
+    s->root->l->a = yr - yl;
+    s->root->l->b = xl - xr;
+    s->root->l->c = -(s->root->l->a * xl + s->root->l->b * yl);
+    s->root->r->a = -s->root->l->a;
+    s->root->r->b = -s->root->l->b;
+    s->root->r->c =
+        2 * w * sqrt(pow(s->root->l->a, 2.0) + pow(s->root->l->b, 2.0)) - s->root->l->c;
+}
+
+// Pie side.
+void
+pie_side_init(
+    clip_ellipse_state *s, int32_t a, int32_t b, int32_t w, float al, float _) {
+    ellipse_init(&s->st, a, b, a + b + 1);
+
+    s->head = NULL;
+    s->node_count = 0;
+
+    double xl = a * cos(al * M_PI / 180.0);
+    double yl = b * sin(al * M_PI / 180.0);
+    double a1 = -yl;
+    double b1 = xl;
+    double c1 = w * sqrt(a1 * a1 + b1 * b1);
+
+    s->root = s->nodes + s->node_count++;
+    s->root->type = CT_AND;
+    s->root->l = s->nodes + s->node_count++;
+    s->root->l->type = CT_AND;
+
+    clip_node *cnode;
+    cnode = s->nodes + s->node_count++;
+    cnode->l = cnode->r = NULL;
+    cnode->type = CT_CLIP;
+    cnode->a = a1;
+    cnode->b = b1;
+    cnode->c = c1;
+    s->root->l->l = cnode;
+    cnode = s->nodes + s->node_count++;
+    cnode->l = cnode->r = NULL;
+    cnode->type = CT_CLIP;
+    cnode->a = -a1;
+    cnode->b = -b1;
+    cnode->c = c1;
+    s->root->l->r = cnode;
+    cnode = s->nodes + s->node_count++;
+    cnode->l = cnode->r = NULL;
+    cnode->type = CT_CLIP;
+    cnode->a = b1;
+    cnode->b = -a1;
+    cnode->c = 0;
+    s->root->r = cnode;
+}
+
+// A chord.
+void
+chord_init(clip_ellipse_state *s, int32_t a, int32_t b, int32_t w, float al, float ar) {
+    ellipse_init(&s->st, a, b, w);
+
+    s->head = NULL;
+    s->node_count = 0;
+
+    // line equation for chord
+    double xl = a * cos(al * M_PI / 180.0), xr = a * cos(ar * M_PI / 180.0);
+    double yl = b * sin(al * M_PI / 180.0), yr = b * sin(ar * M_PI / 180.0);
+    s->root = s->nodes + s->node_count++;
+    s->root->l = s->root->r = NULL;
+    s->root->type = CT_CLIP;
+    s->root->a = yr - yl;
+    s->root->b = xl - xr;
+    s->root->c = -(s->root->a * xl + s->root->b * yl);
+}
+
+// A pie. Can also be used to draw an arc with ugly sharp caps.
+void
+pie_init(clip_ellipse_state *s, int32_t a, int32_t b, int32_t w, float al, float ar) {
+    ellipse_init(&s->st, a, b, w);
+
+    s->head = NULL;
+    s->node_count = 0;
+
+    // line equations for pie sides
+    double xl = a * cos(al * M_PI / 180.0), xr = a * cos(ar * M_PI / 180.0);
+    double yl = b * sin(al * M_PI / 180.0), yr = b * sin(ar * M_PI / 180.0);
+
+    clip_node *lc = s->nodes + s->node_count++;
+    clip_node *rc = s->nodes + s->node_count++;
+    lc->l = lc->r = rc->l = rc->r = NULL;
+    lc->type = rc->type = CT_CLIP;
+    lc->a = -yl;
+    lc->b = xl;
+    lc->c = 0;
+    rc->a = yr;
+    rc->b = -xr;
+    rc->c = 0;
+
+    s->root = s->nodes + s->node_count++;
+    s->root->l = lc;
+    s->root->r = rc;
+    s->root->type = ar - al < 180 ? CT_AND : CT_OR;
+
+    // add one more semiplane to avoid spikes
+    if (ar - al < 90) {
+        clip_node *old_root = s->root;
+        clip_node *spike_clipper = s->nodes + s->node_count++;
         s->root = s->nodes + s->node_count++;
-        s->root->l = lc;
-        s->root->r = rc;
-        s->root->type = ar - al < 180 ? CT_AND : CT_OR;
-      } else if (((int)(al / 180) + (int)(ar / 180)) % 2 == 1) {
-        s->root = s->nodes + s->node_count++;
-        s->root->l = s->nodes + s->node_count++;
-        s->root->l->l = s->nodes + s->node_count++;
-        s->root->l->r = lc;
-        s->root->r = s->nodes + s->node_count++;
-        s->root->r->l = s->nodes + s->node_count++;
-        s->root->r->r = rc;
-        s->root->type = CT_OR;
-        s->root->l->type = CT_AND;
-        s->root->r->type = CT_AND;
-        s->root->l->l->type = CT_CLIP;
-        s->root->r->l->type = CT_CLIP;
-        s->root->l->l->l = s->root->l->l->r = NULL;
-        s->root->r->l->l = s->root->r->l->r = NULL;
-        s->root->l->l->a = s->root->l->l->c = 0;
-        s->root->r->l->a = s->root->r->l->c = 0;
-        s->root->l->l->b = (int)(al / 180) % 2 == 0 ? 1 : -1;
-        s->root->r->l->b = (int)(ar / 180) % 2 == 0 ? 1 : -1;
-      } else {
-        s->root = s->nodes + s->node_count++;
-        s->root->l = s->nodes + s->node_count++;
-        s->root->r = s->nodes + s->node_count++;
-        s->root->type = s->root->l->type = ar - al < 180 ? CT_AND : CT_OR;
-        s->root->l->l = lc;
-        s->root->l->r = rc;
-        s->root->r->type = CT_CLIP;
-        s->root->r->l = s->root->r->r = NULL;
-        s->root->r->a = s->root->r->c = 0;
-        s->root->r->b = ar < 180 || ar > 540 ? 1 : -1;
-      }
-    }
-  }
-}
-
-// A chord line.
-void chord_line_init(clip_ellipse_state* s, int32_t a, int32_t b, int32_t w, float al, float ar) {
-  ellipse_init(&s->st, a, b, a + b + 1);
-
-  s->head = NULL;
-  s->node_count = 0;
-
-  // line equation for chord
-  double xl = a * cos(al * M_PI / 180.0), xr = a * cos(ar * M_PI / 180.0);
-  double yl = b * sin(al * M_PI / 180.0), yr = b * sin(ar * M_PI / 180.0);
-  s->root = s->nodes + s->node_count++;
-  s->root->l = s->nodes + s->node_count++;
-  s->root->r = s->nodes + s->node_count++;
-  s->root->type = CT_AND;
-  s->root->l->type = s->root->r->type = CT_CLIP;
-  s->root->l->l = s->root->l->r = s->root->r->l = s->root->r->r = NULL;
-  s->root->l->a = yr - yl;
-  s->root->l->b = xl - xr;
-  s->root->l->c = -(s->root->l->a * xl + s->root->l->b * yl);
-  s->root->r->a = -s->root->l->a;
-  s->root->r->b = -s->root->l->b;
-  s->root->r->c = 2 * w * sqrt(pow(s->root->l->a, 2.0) + pow(s->root->l->b, 2.0)) - s->root->l->c;
-}
-
-// Pie side.
-void pie_side_init(clip_ellipse_state* s, int32_t a, int32_t b, int32_t w, float al, float _) {
-  ellipse_init(&s->st, a, b, a + b + 1);
-
-  s->head = NULL;
-  s->node_count = 0;
-
-  double xl = a * cos(al * M_PI / 180.0);
-  double yl = b * sin(al * M_PI / 180.0);
-  double a1 = -yl;
-  double b1 = xl;
-  double c1 = w * sqrt(a1 * a1 + b1 * b1);
-
-  s->root = s->nodes + s->node_count++;
-  s->root->type = CT_AND;
-  s->root->l = s->nodes + s->node_count++;
-  s->root->l->type = CT_AND;
-
-  clip_node* cnode;
-  cnode = s->nodes + s->node_count++;
-  cnode->l = cnode->r = NULL;
-  cnode->type = CT_CLIP;
-  cnode->a = a1;
-  cnode->b = b1;
-  cnode->c = c1;
-  s->root->l->l = cnode;
-  cnode = s->nodes + s->node_count++;
-  cnode->l = cnode->r = NULL;
-  cnode->type = CT_CLIP;
-  cnode->a = -a1;
-  cnode->b = -b1;
-  cnode->c = c1;
-  s->root->l->r = cnode;
-  cnode = s->nodes + s->node_count++;
-  cnode->l = cnode->r = NULL;
-  cnode->type = CT_CLIP;
-  cnode->a = b1;
-  cnode->b = -a1;
-  cnode->c = 0;
-  s->root->r = cnode;
-}
-
-// A chord.
-void chord_init(clip_ellipse_state* s, int32_t a, int32_t b, int32_t w, float al, float ar) {
-  ellipse_init(&s->st, a, b, w);
-
-  s->head = NULL;
-  s->node_count = 0;
-
-  // line equation for chord
-  double xl = a * cos(al * M_PI / 180.0), xr = a * cos(ar * M_PI / 180.0);
-  double yl = b * sin(al * M_PI / 180.0), yr = b * sin(ar * M_PI / 180.0);
-  s->root = s->nodes + s->node_count++;
-  s->root->l = s->root->r = NULL;
-  s->root->type = CT_CLIP;
-  s->root->a = yr - yl;
-  s->root->b = xl - xr;
-  s->root->c = -(s->root->a * xl + s->root->b * yl);
-}
-
-// A pie. Can also be used to draw an arc with ugly sharp caps.
-void pie_init(clip_ellipse_state* s, int32_t a, int32_t b, int32_t w, float al, float ar) {
-  ellipse_init(&s->st, a, b, w);
-
-  s->head = NULL;
-  s->node_count = 0;
-
-  // line equations for pie sides
-  double xl = a * cos(al * M_PI / 180.0), xr = a * cos(ar * M_PI / 180.0);
-  double yl = b * sin(al * M_PI / 180.0), yr = b * sin(ar * M_PI / 180.0);
-
-  clip_node* lc = s->nodes + s->node_count++;
-  clip_node* rc = s->nodes + s->node_count++;
-  lc->l = lc->r = rc->l = rc->r = NULL;
-  lc->type = rc->type = CT_CLIP;
-  lc->a = -yl;
-  lc->b = xl;
-  lc->c = 0;
-  rc->a = yr;
-  rc->b = -xr;
-  rc->c = 0;
-
-  s->root = s->nodes + s->node_count++;
-  s->root->l = lc;
-  s->root->r = rc;
-  s->root->type = ar - al < 180 ? CT_AND : CT_OR;
-}
-
-void clip_ellipse_free(clip_ellipse_state* s) {
-  while (s->head != NULL) {
-    event_list* t = s->head;
-    s->head = s->head->next;
-    free(t);
-  }
-}
-
-int8_t clip_ellipse_next(clip_ellipse_state* s, int32_t* ret_x0, int32_t* ret_y, int32_t* ret_x1) {
-  int32_t x0, y, x1;
-  while (s->head == NULL && ellipse_next(&s->st, &x0, &y, &x1) >= 0) {
-    if (clip_tree_do_clip(s->root, x0, y, x1, &s->head) < 0) {
-      return -2;
-    }
-    s->y = y;
-  }
-  if (s->head != NULL) {
-    *ret_y = s->y;
-    event_list* t = s->head;
-    s->head = s->head->next;
-    *ret_x0 = t->x;
-    free(t);
-    t = s->head;
-    assert(t != NULL);
-    s->head = s->head->next;
-    *ret_x1 = t->x;
-    free(t);
-    return 0;
-  }
-  return -1;
+        s->root->l = old_root;
+        s->root->r = spike_clipper;
+        s->root->type = CT_AND;
+
+        spike_clipper->l = spike_clipper->r = NULL;
+        spike_clipper->type = CT_CLIP;
+        spike_clipper->a = (xl + xr) / 2.0;
+        spike_clipper->b = (yl + yr) / 2.0;
+        spike_clipper->c = 0;
+    }
+}
+
+void
+clip_ellipse_free(clip_ellipse_state *s) {
+    while (s->head != NULL) {
+        event_list *t = s->head;
+        s->head = s->head->next;
+        free(t);
+    }
+}
+
+int8_t
+clip_ellipse_next(
+    clip_ellipse_state *s, int32_t *ret_x0, int32_t *ret_y, int32_t *ret_x1) {
+    int32_t x0, y, x1;
+    while (s->head == NULL && ellipse_next(&s->st, &x0, &y, &x1) >= 0) {
+        if (clip_tree_do_clip(s->root, x0, y, x1, &s->head) < 0) {
+            return -2;
+        }
+        s->y = y;
+    }
+    if (s->head != NULL) {
+        *ret_y = s->y;
+        event_list *t = s->head;
+        s->head = s->head->next;
+        *ret_x0 = t->x;
+        free(t);
+        t = s->head;
+        assert(t != NULL);
+        s->head = s->head->next;
+        *ret_x1 = t->x;
+        free(t);
+        return 0;
+    }
+    return -1;
 }

 static int
-ellipseNew(Imaging im, int x0, int y0, int x1, int y1,
-        const void* ink_, int fill,
-        int width, int op)
-{
-    DRAW* draw;
+ellipseNew(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    const void *ink_,
+    int fill,
+    int width,
+    int op) {
+    DRAW *draw;
     INT32 ink;
     DRAWINIT();

     int a = x1 - x0;
     int b = y1 - y0;
     if (a < 0 || b < 0) {
-      return 0;
+        return 0;
     }
     if (fill) {
-      width = a + b;
+        width = a + b;
     }

     ellipse_state st;
     ellipse_init(&st, a, b, width);
     int32_t X0, Y, X1;
     while (ellipse_next(&st, &X0, &Y, &X1) != -1) {
-      draw->hline(im, x0 + (X0 + a) / 2, y0 + (Y + b) / 2, x0 + (X1 + a) / 2, ink);
+        draw->hline(im, x0 + (X0 + a) / 2, y0 + (Y + b) / 2, x0 + (X1 + a) / 2, ink);
     }
     return 0;
 }

 static int
-clipEllipseNew(Imaging im, int x0, int y0, int x1, int y1,
-        float start, float end,
-        const void* ink_, int width, int op, clip_ellipse_init init)
-{
-    DRAW* draw;
+clipEllipseNew(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink_,
+    int width,
+    int op,
+    clip_ellipse_init init) {
+    DRAW *draw;
     INT32 ink;
     DRAWINIT();

     int a = x1 - x0;
     int b = y1 - y0;
     if (a < 0 || b < 0) {
-      return 0;
+        return 0;
     }

     clip_ellipse_state st;
@@ -1446,123 +1529,186 @@
     int32_t X0, Y, X1;
     int next_code;
     while ((next_code = clip_ellipse_next(&st, &X0, &Y, &X1)) >= 0) {
-      draw->hline(im, x0 + (X0 + a) / 2, y0 + (Y + b) / 2, x0 + (X1 + a) / 2, ink);
+        draw->hline(im, x0 + (X0 + a) / 2, y0 + (Y + b) / 2, x0 + (X1 + a) / 2, ink);
     }
     clip_ellipse_free(&st);
     return next_code == -1 ? 0 : -1;
 }
 static int
-arcNew(Imaging im, int x0, int y0, int x1, int y1,
-        float start, float end,
-        const void* ink_, int width, int op)
-{
-  return clipEllipseNew(im, x0, y0, x1, y1, start, end, ink_, width, op, arc_init);
+arcNew(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink_,
+    int width,
+    int op) {
+    return clipEllipseNew(im, x0, y0, x1, y1, start, end, ink_, width, op, arc_init);
 }

 static int
-chordNew(Imaging im, int x0, int y0, int x1, int y1,
-        float start, float end,
-        const void* ink_, int width, int op)
-{
-  return clipEllipseNew(im, x0, y0, x1, y1, start, end, ink_, width, op, chord_init);
+chordNew(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink_,
+    int width,
+    int op) {
+    return clipEllipseNew(im, x0, y0, x1, y1, start, end, ink_, width, op, chord_init);
 }

 static int
-chordLineNew(Imaging im, int x0, int y0, int x1, int y1,
-        float start, float end,
-        const void* ink_, int width, int op)
-{
-  return clipEllipseNew(im, x0, y0, x1, y1, start, end, ink_, width, op, chord_line_init);
+chordLineNew(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink_,
+    int width,
+    int op) {
+    return clipEllipseNew(
+        im, x0, y0, x1, y1, start, end, ink_, width, op, chord_line_init);
 }

 static int
-pieNew(Imaging im, int x0, int y0, int x1, int y1,
-        float start, float end,
-        const void* ink_, int width, int op)
-{
-  return clipEllipseNew(im, x0, y0, x1, y1, start, end, ink_, width, op, pie_init);
+pieNew(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink_,
+    int width,
+    int op) {
+    return clipEllipseNew(im, x0, y0, x1, y1, start, end, ink_, width, op, pie_init);
 }

 static int
-pieSideNew(Imaging im, int x0, int y0, int x1, int y1,
-        float start,
-        const void* ink_, int width, int op)
-{
-  return clipEllipseNew(im, x0, y0, x1, y1, start, 0, ink_, width, op, pie_side_init);
+pieSideNew(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    const void *ink_,
+    int width,
+    int op) {
+    return clipEllipseNew(im, x0, y0, x1, y1, start, 0, ink_, width, op, pie_side_init);
 }

 int
-ImagingDrawEllipse(Imaging im, int x0, int y0, int x1, int y1,
-                   const void* ink, int fill, int width, int op)
-{
+ImagingDrawEllipse(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    const void *ink,
+    int fill,
+    int width,
+    int op) {
     return ellipseNew(im, x0, y0, x1, y1, ink, fill, width, op);
 }

 int
-ImagingDrawArc(Imaging im, int x0, int y0, int x1, int y1,
-               float start, float end, const void* ink, int width, int op)
-{
+ImagingDrawArc(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink,
+    int width,
+    int op) {
     normalize_angles(&start, &end);
     if (start + 360 == end) {
-      return ImagingDrawEllipse(im, x0, y0, x1, y1, ink, 0, width, op);
+        return ImagingDrawEllipse(im, x0, y0, x1, y1, ink, 0, width, op);
     }
     if (start == end) {
-      return 0;
+        return 0;
     }
     return arcNew(im, x0, y0, x1, y1, start, end, ink, width, op);
 }

-
 int
-ImagingDrawChord(Imaging im, int x0, int y0, int x1, int y1,
-                 float start, float end, const void* ink, int fill,
-                 int width, int op)
-{
+ImagingDrawChord(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink,
+    int fill,
+    int width,
+    int op) {
     normalize_angles(&start, &end);
     if (start + 360 == end) {
-      return ImagingDrawEllipse(im, x0, y0, x1, y1, ink, fill, width, op);
+        return ImagingDrawEllipse(im, x0, y0, x1, y1, ink, fill, width, op);
     }
     if (start == end) {
-      return 0;
+        return 0;
     }
     if (fill) {
-      return chordNew(im, x0, y0, x1, y1, start, end, ink, x1 - x0 + y1 - y0 + 1, op);
-    } else {
-      if (chordLineNew(im, x0, y0, x1, y1, start, end, ink, width, op)) {
-        return -1;
-      }
-      return chordNew(im, x0, y0, x1, y1, start, end, ink, width, op);
-    }
-}
-
+        return chordNew(im, x0, y0, x1, y1, start, end, ink, x1 - x0 + y1 - y0 + 1, op);
+    } else {
+        if (chordLineNew(im, x0, y0, x1, y1, start, end, ink, width, op)) {
+            return -1;
+        }
+        return chordNew(im, x0, y0, x1, y1, start, end, ink, width, op);
+    }
+}

 int
-ImagingDrawPieslice(Imaging im, int x0, int y0, int x1, int y1,
-                    float start, float end, const void* ink, int fill,
-                    int width, int op)
-{
+ImagingDrawPieslice(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink,
+    int fill,
+    int width,
+    int op) {
     normalize_angles(&start, &end);
     if (start + 360 == end) {
-      return ellipseNew(im, x0, y0, x1, y1, ink, fill, width, op);
+        return ellipseNew(im, x0, y0, x1, y1, ink, fill, width, op);
     }
     if (start == end) {
-      return 0;
+        return 0;
     }
     if (fill) {
-      return pieNew(im, x0, y0, x1, y1, start, end, ink, x1 + y1 - x0 - y0, op);
-    } else {
-      if (pieSideNew(im, x0, y0, x1, y1, start, ink, width, op)) {
-        return -1;
-      }
-      if (pieSideNew(im, x0, y0, x1, y1, end, ink, width, op)) {
-        return -1;
-      }
-      int xc = lround((x0 + x1 - width) / 2.0), yc = lround((y0 + y1 - width) / 2.0);
-      ellipseNew(im, xc, yc, xc + width - 1, yc + width - 1, ink, 1, 0, op);
-      return pieNew(im, x0, y0, x1, y1, start, end, ink, width, op);
-    }
-}
-
+        return pieNew(im, x0, y0, x1, y1, start, end, ink, x1 + y1 - x0 - y0, op);
+    } else {
+        if (pieSideNew(im, x0, y0, x1, y1, start, ink, width, op)) {
+            return -1;
+        }
+        if (pieSideNew(im, x0, y0, x1, y1, end, ink, width, op)) {
+            return -1;
+        }
+        int xc = lround((x0 + x1 - width) / 2.0), yc = lround((y0 + y1 - width) / 2.0);
+        ellipseNew(im, xc, yc, xc + width - 1, yc + width - 1, ink, 1, 0, op);
+        return pieNew(im, x0, y0, x1, y1, start, end, ink, width, op);
+    }
+}

 /* -------------------------------------------------------------------- */

@@ -1572,7 +1718,6 @@
    itself */

 struct ImagingOutlineInstance {
-
     float x0, y0;

     float x, y;
@@ -1581,18 +1726,15 @@
     Edge *edges;

     int size;
-
 };

-
 ImagingOutline
-ImagingOutlineNew(void)
-{
+ImagingOutlineNew(void) {
     ImagingOutline outline;

     outline = calloc(1, sizeof(struct ImagingOutlineInstance));
     if (!outline) {
-        return (ImagingOutline) ImagingError_MemoryError();
+        return (ImagingOutline)ImagingError_MemoryError();
     }

     outline->edges = NULL;
@@ -1604,8 +1746,7 @@
 }

 void
-ImagingOutlineDelete(ImagingOutline outline)
-{
+ImagingOutlineDelete(ImagingOutline outline) {
     if (!outline) {
         return;
     }
@@ -1617,11 +1758,9 @@
     free(outline);
 }

-
-static Edge*
-allocate(ImagingOutline outline, int extra)
-{
-    Edge* e;
+static Edge *
+allocate(ImagingOutline outline, int extra) {
+    Edge *e;

     if (outline->count + extra > outline->size) {
         /* expand outline buffer */
@@ -1650,8 +1789,7 @@
 }

 int
-ImagingOutlineMove(ImagingOutline outline, float x0, float y0)
-{
+ImagingOutlineMove(ImagingOutline outline, float x0, float y0) {
     outline->x = outline->x0 = x0;
     outline->y = outline->y0 = y0;

@@ -1659,16 +1797,15 @@
 }

 int
-ImagingOutlineLine(ImagingOutline outline, float x1, float y1)
-{
-    Edge* e;
+ImagingOutlineLine(ImagingOutline outline, float x1, float y1) {
+    Edge *e;

     e = allocate(outline, 1);
     if (!e) {
         return -1; /* out of memory */
     }

-    add_edge(e, (int) outline->x, (int) outline->y, (int) x1, (int) y1);
+    add_edge(e, (int)outline->x, (int)outline->y, (int)x1, (int)y1);

     outline->x = x1;
     outline->y = y1;
@@ -1677,10 +1814,15 @@
 }

 int
-ImagingOutlineCurve(ImagingOutline outline, float x1, float y1,
-                    float x2, float y2, float x3, float y3)
-{
-    Edge* e;
+ImagingOutlineCurve(
+    ImagingOutline outline,
+    float x1,
+    float y1,
+    float x2,
+    float y2,
+    float x3,
+    float y3) {
+    Edge *e;
     int i;
     float xo, yo;

@@ -1697,22 +1839,20 @@
     /* flatten the bezier segment */

     for (i = 1; i <= STEPS; i++) {
-
-        float t = ((float) i) / STEPS;
-        float t2 = t*t;
-        float t3 = t2*t;
+        float t = ((float)i) / STEPS;
+        float t2 = t * t;
+        float t3 = t2 * t;

         float u = 1.0F - t;
-        float u2 = u*u;
-        float u3 = u2*u;
-
-        float x = outline->x*u3 + 3*(x1*t*u2 + x2*t2*u) + x3*t3 + 0.5;
-        float y = outline->y*u3 + 3*(y1*t*u2 + y2*t2*u) + y3*t3 + 0.5;
-
-        add_edge(e++, xo, yo, (int) x, (int) y);
+        float u2 = u * u;
+        float u3 = u2 * u;
+
+        float x = outline->x * u3 + 3 * (x1 * t * u2 + x2 * t2 * u) + x3 * t3 + 0.5;
+        float y = outline->y * u3 + 3 * (y1 * t * u2 + y2 * t2 * u) + y3 * t3 + 0.5;
+
+        add_edge(e++, xo, yo, (int)x, (int)y);

         xo = x, yo = y;
-
     }

     outline->x = xo;
@@ -1722,8 +1862,7 @@
 }

 int
-ImagingOutlineClose(ImagingOutline outline)
-{
+ImagingOutlineClose(ImagingOutline outline) {
     if (outline->x == outline->x0 && outline->y == outline->y0) {
         return 0;
     }
@@ -1731,34 +1870,30 @@
 }

 int
-ImagingOutlineTransform(ImagingOutline outline, double a[6])
-{
+ImagingOutlineTransform(ImagingOutline outline, double a[6]) {
     Edge *eIn;
     Edge *eOut;
     int i, n;
     int x0, y0, x1, y1;
     int X0, Y0, X1, Y1;

-    double a0 = a[0]; double a1 = a[1]; double a2 = a[2];
-    double a3 = a[3]; double a4 = a[4]; double a5 = a[5];
+    double a0 = a[0];
+    double a1 = a[1];
+    double a2 = a[2];
+    double a3 = a[3];
+    double a4 = a[4];
+    double a5 = a[5];

     eIn = outline->edges;
     n = outline->count;

-    /* FIXME: ugly! */
-    outline->edges = NULL;
-    outline->count = outline->size = 0;
-
     eOut = allocate(outline, n);
     if (!eOut) {
-        outline->edges = eIn;
-        outline->count = outline->size = n;
         ImagingError_MemoryError();
         return -1;
     }

     for (i = 0; i < n; i++) {
-
         x0 = eIn->x0;
         y0 = eIn->y0;

@@ -1778,28 +1913,30 @@
            upgrade your compiler (make sure you have the right service
            pack) */

-        X0 = (int) (a0*x0 + a1*y0 + a2);
-        Y0 = (int) (a3*x0 + a4*y0 + a5);
-        X1 = (int) (a0*x1 + a1*y1 + a2);
-        Y1 = (int) (a3*x1 + a4*y1 + a5);
+        X0 = (int)(a0 * x0 + a1 * y0 + a2);
+        Y0 = (int)(a3 * x0 + a4 * y0 + a5);
+        X1 = (int)(a0 * x1 + a1 * y1 + a2);
+        Y1 = (int)(a3 * x1 + a4 * y1 + a5);

         add_edge(eOut, X0, Y0, X1, Y1);

         eIn++;
         eOut++;
-
-    }
-
-    free(eIn);
+    }
+
+    free(outline->edges);
+
+    /* FIXME: ugly! */
+    outline->edges = NULL;
+    outline->count = outline->size = 0;

     return 0;
 }

 int
-ImagingDrawOutline(Imaging im, ImagingOutline outline, const void* ink_,
-                   int fill, int op)
-{
-    DRAW* draw;
+ImagingDrawOutline(
+    Imaging im, ImagingOutline outline, const void *ink_, int fill, int op) {
+    DRAW *draw;
     INT32 ink;

     DRAWINIT();
('src/libImaging', 'Geometry.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,28 +15,27 @@
 /* Transpose operations                                                 */

 Imaging
-ImagingFlipLeftRight(Imaging imOut, Imaging imIn)
-{
+ImagingFlipLeftRight(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int x, y, xr;

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }
     if (imIn->xsize != imOut->xsize || imIn->ysize != imOut->ysize) {
-        return (Imaging) ImagingError_Mismatch();
+        return (Imaging)ImagingError_Mismatch();
     }

     ImagingCopyPalette(imOut, imIn);

-#define FLIP_LEFT_RIGHT(INT, image) \
-    for (y = 0; y < imIn->ysize; y++) { \
-        INT* in = (INT *)imIn->image[y]; \
-        INT* out = (INT *)imOut->image[y]; \
-        xr = imIn->xsize-1; \
+#define FLIP_LEFT_RIGHT(INT, image)               \
+    for (y = 0; y < imIn->ysize; y++) {           \
+        INT *in = (INT *)imIn->image[y];          \
+        INT *out = (INT *)imOut->image[y];        \
+        xr = imIn->xsize - 1;                     \
         for (x = 0; x < imIn->xsize; x++, xr--) { \
-            out[xr] = in[x]; \
-        } \
+            out[xr] = in[x];                      \
+        }                                         \
     }

     ImagingSectionEnter(&cookie);
@@ -58,18 +57,16 @@
     return imOut;
 }

-
 Imaging
-ImagingFlipTopBottom(Imaging imOut, Imaging imIn)
-{
+ImagingFlipTopBottom(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int y, yr;

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }
     if (imIn->xsize != imOut->xsize || imIn->ysize != imOut->ysize) {
-        return (Imaging) ImagingError_Mismatch();
+        return (Imaging)ImagingError_Mismatch();
     }

     ImagingCopyPalette(imOut, imIn);
@@ -86,43 +83,45 @@
     return imOut;
 }

-
 Imaging
-ImagingRotate90(Imaging imOut, Imaging imIn)
-{
+ImagingRotate90(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int x, y, xx, yy, xr, xxsize, yysize;
     int xxx, yyy, xxxsize, yyysize;

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }
     if (imIn->xsize != imOut->ysize || imIn->ysize != imOut->xsize) {
-        return (Imaging) ImagingError_Mismatch();
+        return (Imaging)ImagingError_Mismatch();
     }

     ImagingCopyPalette(imOut, imIn);

-#define ROTATE_90(INT, image) \
-    for (y = 0; y < imIn->ysize; y += ROTATE_CHUNK) { \
-        for (x = 0; x < imIn->xsize; x += ROTATE_CHUNK) { \
+#define ROTATE_90(INT, image)                                                         \
+    for (y = 0; y < imIn->ysize; y += ROTATE_CHUNK) {                                 \
+        for (x = 0; x < imIn->xsize; x += ROTATE_CHUNK) {                             \
             yysize = y + ROTATE_CHUNK < imIn->ysize ? y + ROTATE_CHUNK : imIn->ysize; \
             xxsize = x + ROTATE_CHUNK < imIn->xsize ? x + ROTATE_CHUNK : imIn->xsize; \
-            for (yy = y; yy < yysize; yy += ROTATE_SMALL_CHUNK) { \
-                for (xx = x; xx < xxsize; xx += ROTATE_SMALL_CHUNK) { \
-                    yyysize = yy + ROTATE_SMALL_CHUNK < imIn->ysize ? yy + ROTATE_SMALL_CHUNK : imIn->ysize; \
-                    xxxsize = xx + ROTATE_SMALL_CHUNK < imIn->xsize ? xx + ROTATE_SMALL_CHUNK : imIn->xsize; \
-                    for (yyy = yy; yyy < yyysize; yyy++) { \
-                        INT* in = (INT *)imIn->image[yyy]; \
-                        xr = imIn->xsize - 1 - xx; \
-                        for (xxx = xx; xxx < xxxsize; xxx++, xr--) { \
-                            INT* out = (INT *)imOut->image[xr]; \
-                            out[yyy] = in[xxx]; \
-                        } \
-                    } \
-                } \
-            } \
-        } \
+            for (yy = y; yy < yysize; yy += ROTATE_SMALL_CHUNK) {                     \
+                for (xx = x; xx < xxsize; xx += ROTATE_SMALL_CHUNK) {                 \
+                    yyysize = yy + ROTATE_SMALL_CHUNK < imIn->ysize                   \
+                                  ? yy + ROTATE_SMALL_CHUNK                           \
+                                  : imIn->ysize;                                      \
+                    xxxsize = xx + ROTATE_SMALL_CHUNK < imIn->xsize                   \
+                                  ? xx + ROTATE_SMALL_CHUNK                           \
+                                  : imIn->xsize;                                      \
+                    for (yyy = yy; yyy < yyysize; yyy++) {                            \
+                        INT *in = (INT *)imIn->image[yyy];                            \
+                        xr = imIn->xsize - 1 - xx;                                    \
+                        for (xxx = xx; xxx < xxxsize; xxx++, xr--) {                  \
+                            INT *out = (INT *)imOut->image[xr];                       \
+                            out[yyy] = in[xxx];                                       \
+                        }                                                             \
+                    }                                                                 \
+                }                                                                     \
+            }                                                                         \
+        }                                                                             \
     }

     ImagingSectionEnter(&cookie);
@@ -144,42 +143,44 @@
     return imOut;
 }

-
 Imaging
-ImagingTranspose(Imaging imOut, Imaging imIn)
-{
+ImagingTranspose(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int x, y, xx, yy, xxsize, yysize;
     int xxx, yyy, xxxsize, yyysize;

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }
     if (imIn->xsize != imOut->ysize || imIn->ysize != imOut->xsize) {
-        return (Imaging) ImagingError_Mismatch();
+        return (Imaging)ImagingError_Mismatch();
     }

     ImagingCopyPalette(imOut, imIn);

-#define TRANSPOSE(INT, image) \
-    for (y = 0; y < imIn->ysize; y += ROTATE_CHUNK) { \
-        for (x = 0; x < imIn->xsize; x += ROTATE_CHUNK) { \
+#define TRANSPOSE(INT, image)                                                         \
+    for (y = 0; y < imIn->ysize; y += ROTATE_CHUNK) {                                 \
+        for (x = 0; x < imIn->xsize; x += ROTATE_CHUNK) {                             \
             yysize = y + ROTATE_CHUNK < imIn->ysize ? y + ROTATE_CHUNK : imIn->ysize; \
             xxsize = x + ROTATE_CHUNK < imIn->xsize ? x + ROTATE_CHUNK : imIn->xsize; \
-            for (yy = y; yy < yysize; yy += ROTATE_SMALL_CHUNK) { \
-                for (xx = x; xx < xxsize; xx += ROTATE_SMALL_CHUNK) { \
-                    yyysize = yy + ROTATE_SMALL_CHUNK < imIn->ysize ? yy + ROTATE_SMALL_CHUNK : imIn->ysize; \
-                    xxxsize = xx + ROTATE_SMALL_CHUNK < imIn->xsize ? xx + ROTATE_SMALL_CHUNK : imIn->xsize; \
-                    for (yyy = yy; yyy < yyysize; yyy++) { \
-                        INT* in = (INT *)imIn->image[yyy]; \
-                        for (xxx = xx; xxx < xxxsize; xxx++) { \
-                            INT* out = (INT *)imOut->image[xxx]; \
-                            out[yyy] = in[xxx]; \
-                        } \
-                    } \
-                } \
-            } \
-        } \
+            for (yy = y; yy < yysize; yy += ROTATE_SMALL_CHUNK) {                     \
+                for (xx = x; xx < xxsize; xx += ROTATE_SMALL_CHUNK) {                 \
+                    yyysize = yy + ROTATE_SMALL_CHUNK < imIn->ysize                   \
+                                  ? yy + ROTATE_SMALL_CHUNK                           \
+                                  : imIn->ysize;                                      \
+                    xxxsize = xx + ROTATE_SMALL_CHUNK < imIn->xsize                   \
+                                  ? xx + ROTATE_SMALL_CHUNK                           \
+                                  : imIn->xsize;                                      \
+                    for (yyy = yy; yyy < yyysize; yyy++) {                            \
+                        INT *in = (INT *)imIn->image[yyy];                            \
+                        for (xxx = xx; xxx < xxxsize; xxx++) {                        \
+                            INT *out = (INT *)imOut->image[xxx];                      \
+                            out[yyy] = in[xxx];                                       \
+                        }                                                             \
+                    }                                                                 \
+                }                                                                     \
+            }                                                                         \
+        }                                                                             \
     }

     ImagingSectionEnter(&cookie);
@@ -201,44 +202,46 @@
     return imOut;
 }

-
 Imaging
-ImagingTransverse(Imaging imOut, Imaging imIn)
-{
+ImagingTransverse(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int x, y, xr, yr, xx, yy, xxsize, yysize;
     int xxx, yyy, xxxsize, yyysize;

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }
     if (imIn->xsize != imOut->ysize || imIn->ysize != imOut->xsize) {
-        return (Imaging) ImagingError_Mismatch();
+        return (Imaging)ImagingError_Mismatch();
     }

     ImagingCopyPalette(imOut, imIn);

-#define TRANSVERSE(INT, image) \
-    for (y = 0; y < imIn->ysize; y += ROTATE_CHUNK) { \
-        for (x = 0; x < imIn->xsize; x += ROTATE_CHUNK) { \
+#define TRANSVERSE(INT, image)                                                        \
+    for (y = 0; y < imIn->ysize; y += ROTATE_CHUNK) {                                 \
+        for (x = 0; x < imIn->xsize; x += ROTATE_CHUNK) {                             \
             yysize = y + ROTATE_CHUNK < imIn->ysize ? y + ROTATE_CHUNK : imIn->ysize; \
             xxsize = x + ROTATE_CHUNK < imIn->xsize ? x + ROTATE_CHUNK : imIn->xsize; \
-            for (yy = y; yy < yysize; yy += ROTATE_SMALL_CHUNK) { \
-                for (xx = x; xx < xxsize; xx += ROTATE_SMALL_CHUNK) { \
-                    yyysize = yy + ROTATE_SMALL_CHUNK < imIn->ysize ? yy + ROTATE_SMALL_CHUNK : imIn->ysize; \
-                    xxxsize = xx + ROTATE_SMALL_CHUNK < imIn->xsize ? xx + ROTATE_SMALL_CHUNK : imIn->xsize; \
-                    yr = imIn->ysize - 1 - yy; \
-                    for (yyy = yy; yyy < yyysize; yyy++, yr--) { \
-                        INT* in = (INT *)imIn->image[yyy]; \
-                        xr = imIn->xsize - 1 - xx; \
-                        for (xxx = xx; xxx < xxxsize; xxx++, xr--) { \
-                            INT* out = (INT *)imOut->image[xr]; \
-                            out[yr] = in[xxx]; \
-                        } \
-                    } \
-                } \
-            } \
-        } \
+            for (yy = y; yy < yysize; yy += ROTATE_SMALL_CHUNK) {                     \
+                for (xx = x; xx < xxsize; xx += ROTATE_SMALL_CHUNK) {                 \
+                    yyysize = yy + ROTATE_SMALL_CHUNK < imIn->ysize                   \
+                                  ? yy + ROTATE_SMALL_CHUNK                           \
+                                  : imIn->ysize;                                      \
+                    xxxsize = xx + ROTATE_SMALL_CHUNK < imIn->xsize                   \
+                                  ? xx + ROTATE_SMALL_CHUNK                           \
+                                  : imIn->xsize;                                      \
+                    yr = imIn->ysize - 1 - yy;                                        \
+                    for (yyy = yy; yyy < yyysize; yyy++, yr--) {                      \
+                        INT *in = (INT *)imIn->image[yyy];                            \
+                        xr = imIn->xsize - 1 - xx;                                    \
+                        for (xxx = xx; xxx < xxxsize; xxx++, xr--) {                  \
+                            INT *out = (INT *)imOut->image[xr];                       \
+                            out[yr] = in[xxx];                                        \
+                        }                                                             \
+                    }                                                                 \
+                }                                                                     \
+            }                                                                         \
+        }                                                                             \
     }

     ImagingSectionEnter(&cookie);
@@ -260,35 +263,33 @@
     return imOut;
 }

-
 Imaging
-ImagingRotate180(Imaging imOut, Imaging imIn)
-{
+ImagingRotate180(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int x, y, xr, yr;

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }
     if (imIn->xsize != imOut->xsize || imIn->ysize != imOut->ysize) {
-        return (Imaging) ImagingError_Mismatch();
+        return (Imaging)ImagingError_Mismatch();
     }

     ImagingCopyPalette(imOut, imIn);

-#define ROTATE_180(INT, image) \
-    for (y = 0; y < imIn->ysize; y++, yr--) { \
-        INT* in = (INT *)imIn->image[y]; \
-        INT* out = (INT *)imOut->image[yr]; \
-        xr = imIn->xsize-1; \
+#define ROTATE_180(INT, image)                    \
+    for (y = 0; y < imIn->ysize; y++, yr--) {     \
+        INT *in = (INT *)imIn->image[y];          \
+        INT *out = (INT *)imOut->image[yr];       \
+        xr = imIn->xsize - 1;                     \
         for (x = 0; x < imIn->xsize; x++, xr--) { \
-            out[xr] = in[x]; \
-        } \
+            out[xr] = in[x];                      \
+        }                                         \
     }

     ImagingSectionEnter(&cookie);

-    yr = imIn->ysize-1;
+    yr = imIn->ysize - 1;
     if (imIn->image8) {
         if (strncmp(imIn->mode, "I;16", 4) == 0) {
             ROTATE_180(UINT16, image8)
@@ -306,43 +307,45 @@
     return imOut;
 }

-
 Imaging
-ImagingRotate270(Imaging imOut, Imaging imIn)
-{
+ImagingRotate270(Imaging imOut, Imaging imIn) {
     ImagingSectionCookie cookie;
     int x, y, xx, yy, yr, xxsize, yysize;
     int xxx, yyy, xxxsize, yyysize;

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }
     if (imIn->xsize != imOut->ysize || imIn->ysize != imOut->xsize) {
-        return (Imaging) ImagingError_Mismatch();
+        return (Imaging)ImagingError_Mismatch();
     }

     ImagingCopyPalette(imOut, imIn);

-#define ROTATE_270(INT, image) \
-    for (y = 0; y < imIn->ysize; y += ROTATE_CHUNK) { \
-        for (x = 0; x < imIn->xsize; x += ROTATE_CHUNK) { \
+#define ROTATE_270(INT, image)                                                        \
+    for (y = 0; y < imIn->ysize; y += ROTATE_CHUNK) {                                 \
+        for (x = 0; x < imIn->xsize; x += ROTATE_CHUNK) {                             \
             yysize = y + ROTATE_CHUNK < imIn->ysize ? y + ROTATE_CHUNK : imIn->ysize; \
             xxsize = x + ROTATE_CHUNK < imIn->xsize ? x + ROTATE_CHUNK : imIn->xsize; \
-            for (yy = y; yy < yysize; yy += ROTATE_SMALL_CHUNK) { \
-                for (xx = x; xx < xxsize; xx += ROTATE_SMALL_CHUNK) { \
-                    yyysize = yy + ROTATE_SMALL_CHUNK < imIn->ysize ? yy + ROTATE_SMALL_CHUNK : imIn->ysize; \
-                    xxxsize = xx + ROTATE_SMALL_CHUNK < imIn->xsize ? xx + ROTATE_SMALL_CHUNK : imIn->xsize; \
-                    yr = imIn->ysize - 1 - yy; \
-                    for (yyy = yy; yyy < yyysize; yyy++, yr--) { \
-                        INT* in = (INT *)imIn->image[yyy]; \
-                        for (xxx = xx; xxx < xxxsize; xxx++) { \
-                            INT* out = (INT *)imOut->image[xxx]; \
-                            out[yr] = in[xxx]; \
-                        } \
-                    } \
-                } \
-            } \
-        } \
+            for (yy = y; yy < yysize; yy += ROTATE_SMALL_CHUNK) {                     \
+                for (xx = x; xx < xxsize; xx += ROTATE_SMALL_CHUNK) {                 \
+                    yyysize = yy + ROTATE_SMALL_CHUNK < imIn->ysize                   \
+                                  ? yy + ROTATE_SMALL_CHUNK                           \
+                                  : imIn->ysize;                                      \
+                    xxxsize = xx + ROTATE_SMALL_CHUNK < imIn->xsize                   \
+                                  ? xx + ROTATE_SMALL_CHUNK                           \
+                                  : imIn->xsize;                                      \
+                    yr = imIn->ysize - 1 - yy;                                        \
+                    for (yyy = yy; yyy < yyysize; yyy++, yr--) {                      \
+                        INT *in = (INT *)imIn->image[yyy];                            \
+                        for (xxx = xx; xxx < xxxsize; xxx++) {                        \
+                            INT *out = (INT *)imOut->image[xxx];                      \
+                            out[yr] = in[xxx];                                        \
+                        }                                                             \
+                    }                                                                 \
+                }                                                                     \
+            }                                                                         \
+        }                                                                             \
     }

     ImagingSectionEnter(&cookie);
@@ -364,63 +367,74 @@
     return imOut;
 }

-
 /* -------------------------------------------------------------------- */
 /* Transforms                                                           */

 /* transform primitives (ImagingTransformMap) */

 static int
-affine_transform(double* xout, double* yout, int x, int y, void* data)
-{
+affine_transform(double *xout, double *yout, int x, int y, void *data) {
     /* full moon tonight.  your compiler will generate bogus code
        for simple expressions, unless you reorganize the code, or
        install Service Pack 3 */

-    double* a = (double*) data;
-    double a0 = a[0]; double a1 = a[1]; double a2 = a[2];
-    double a3 = a[3]; double a4 = a[4]; double a5 = a[5];
+    double *a = (double *)data;
+    double a0 = a[0];
+    double a1 = a[1];
+    double a2 = a[2];
+    double a3 = a[3];
+    double a4 = a[4];
+    double a5 = a[5];

     double xin = x + 0.5;
     double yin = y + 0.5;

-    xout[0] = a0*xin + a1*yin + a2;
-    yout[0] = a3*xin + a4*yin + a5;
-
-    return 1;
-}
-
-static int
-perspective_transform(double* xout, double* yout, int x, int y, void* data)
-{
-    double* a = (double*) data;
-    double a0 = a[0]; double a1 = a[1]; double a2 = a[2];
-    double a3 = a[3]; double a4 = a[4]; double a5 = a[5];
-    double a6 = a[6]; double a7 = a[7];
+    xout[0] = a0 * xin + a1 * yin + a2;
+    yout[0] = a3 * xin + a4 * yin + a5;
+
+    return 1;
+}
+
+static int
+perspective_transform(double *xout, double *yout, int x, int y, void *data) {
+    double *a = (double *)data;
+    double a0 = a[0];
+    double a1 = a[1];
+    double a2 = a[2];
+    double a3 = a[3];
+    double a4 = a[4];
+    double a5 = a[5];
+    double a6 = a[6];
+    double a7 = a[7];

     double xin = x + 0.5;
     double yin = y + 0.5;

-    xout[0] = (a0*xin + a1*yin + a2) / (a6*xin + a7*yin + 1);
-    yout[0] = (a3*xin + a4*yin + a5) / (a6*xin + a7*yin + 1);
-
-    return 1;
-}
-
-static int
-quad_transform(double* xout, double* yout, int x, int y, void* data)
-{
+    xout[0] = (a0 * xin + a1 * yin + a2) / (a6 * xin + a7 * yin + 1);
+    yout[0] = (a3 * xin + a4 * yin + a5) / (a6 * xin + a7 * yin + 1);
+
+    return 1;
+}
+
+static int
+quad_transform(double *xout, double *yout, int x, int y, void *data) {
     /* quad warp: map quadrilateral to rectangle */

-    double* a = (double*) data;
-    double a0 = a[0]; double a1 = a[1]; double a2 = a[2]; double a3 = a[3];
-    double a4 = a[4]; double a5 = a[5]; double a6 = a[6]; double a7 = a[7];
+    double *a = (double *)data;
+    double a0 = a[0];
+    double a1 = a[1];
+    double a2 = a[2];
+    double a3 = a[3];
+    double a4 = a[4];
+    double a5 = a[5];
+    double a6 = a[6];
+    double a7 = a[7];

     double xin = x + 0.5;
     double yin = y + 0.5;

-    xout[0] = a0 + a1*xin + a2*yin + a3*xin*yin;
-    yout[0] = a4 + a5*xin + a6*yin + a7*xin*yin;
+    xout[0] = a0 + a1 * xin + a2 * yin + a3 * xin * yin;
+    yout[0] = a4 + a5 * xin + a6 * yin + a7 * xin * yin;

     return 1;
 }
@@ -428,20 +442,18 @@
 /* transform filters (ImagingTransformFilter) */

 static int
-nearest_filter8(void* out, Imaging im, double xin, double yin)
-{
+nearest_filter8(void *out, Imaging im, double xin, double yin) {
     int x = COORD(xin);
     int y = COORD(yin);
     if (x < 0 || x >= im->xsize || y < 0 || y >= im->ysize) {
         return 0;
     }
-    ((UINT8*)out)[0] = im->image8[y][x];
-    return 1;
-}
-
-static int
-nearest_filter16(void* out, Imaging im, double xin, double yin)
-{
+    ((UINT8 *)out)[0] = im->image8[y][x];
+    return 1;
+}
+
+static int
+nearest_filter16(void *out, Imaging im, double xin, double yin) {
     int x = COORD(xin);
     int y = COORD(yin);
     if (x < 0 || x >= im->xsize || y < 0 || y >= im->ysize) {
@@ -452,8 +464,7 @@
 }

 static int
-nearest_filter32(void* out, Imaging im, double xin, double yin)
-{
+nearest_filter32(void *out, Imaging im, double xin, double yin) {
     int x = COORD(xin);
     int y = COORD(yin);
     if (x < 0 || x >= im->xsize || y < 0 || y >= im->ysize) {
@@ -463,54 +474,52 @@
     return 1;
 }

-#define XCLIP(im, x) ( ((x) < 0) ? 0 : ((x) < im->xsize) ? (x) : im->xsize-1 )
-#define YCLIP(im, y) ( ((y) < 0) ? 0 : ((y) < im->ysize) ? (y) : im->ysize-1 )
-
-#define BILINEAR(v, a, b, d)\
-    (v = (a) + ( (b) - (a) ) * (d))
-
-#define BILINEAR_HEAD(type)\
-    int x, y;\
-    int x0, x1;\
-    double v1, v2;\
-    double dx, dy;\
-    type* in;\
-    if (xin < 0.0 || xin >= im->xsize || yin < 0.0 || yin >= im->ysize) {\
-        return 0;\
-    }\
-    xin -= 0.5;\
-    yin -= 0.5;\
-    x = FLOOR(xin);\
-    y = FLOOR(yin);\
-    dx = xin - x;\
+#define XCLIP(im, x) (((x) < 0) ? 0 : ((x) < im->xsize) ? (x) : im->xsize - 1)
+#define YCLIP(im, y) (((y) < 0) ? 0 : ((y) < im->ysize) ? (y) : im->ysize - 1)
+
+#define BILINEAR(v, a, b, d) (v = (a) + ((b) - (a)) * (d))
+
+#define BILINEAR_HEAD(type)                                               \
+    int x, y;                                                             \
+    int x0, x1;                                                           \
+    double v1, v2;                                                        \
+    double dx, dy;                                                        \
+    type *in;                                                             \
+    if (xin < 0.0 || xin >= im->xsize || yin < 0.0 || yin >= im->ysize) { \
+        return 0;                                                         \
+    }                                                                     \
+    xin -= 0.5;                                                           \
+    yin -= 0.5;                                                           \
+    x = FLOOR(xin);                                                       \
+    y = FLOOR(yin);                                                       \
+    dx = xin - x;                                                         \
     dy = yin - y;

-#define BILINEAR_BODY(type, image, step, offset) {\
-    in = (type*) ((image)[YCLIP(im, y)] + offset);\
-    x0 = XCLIP(im, x+0)*step;\
-    x1 = XCLIP(im, x+1)*step;\
-    BILINEAR(v1, in[x0], in[x1], dx);\
-    if (y+1 >= 0 && y+1 < im->ysize) {\
-        in = (type*) ((image)[y+1] + offset);\
-        BILINEAR(v2, in[x0], in[x1], dx);\
-    } else {\
-        v2 = v1;\
-    }\
-    BILINEAR(v1, v1, v2, dy);\
-}
-
-static int
-bilinear_filter8(void* out, Imaging im, double xin, double yin)
-{
+#define BILINEAR_BODY(type, image, step, offset)       \
+    {                                                  \
+        in = (type *)((image)[YCLIP(im, y)] + offset); \
+        x0 = XCLIP(im, x + 0) * step;                  \
+        x1 = XCLIP(im, x + 1) * step;                  \
+        BILINEAR(v1, in[x0], in[x1], dx);              \
+        if (y + 1 >= 0 && y + 1 < im->ysize) {         \
+            in = (type *)((image)[y + 1] + offset);    \
+            BILINEAR(v2, in[x0], in[x1], dx);          \
+        } else {                                       \
+            v2 = v1;                                   \
+        }                                              \
+        BILINEAR(v1, v1, v2, dy);                      \
+    }
+
+static int
+bilinear_filter8(void *out, Imaging im, double xin, double yin) {
     BILINEAR_HEAD(UINT8);
     BILINEAR_BODY(UINT8, im->image8, 1, 0);
-    ((UINT8*)out)[0] = (UINT8) v1;
-    return 1;
-}
-
-static int
-bilinear_filter32I(void* out, Imaging im, double xin, double yin)
-{
+    ((UINT8 *)out)[0] = (UINT8)v1;
+    return 1;
+}
+
+static int
+bilinear_filter32I(void *out, Imaging im, double xin, double yin) {
     INT32 k;
     BILINEAR_HEAD(INT32);
     BILINEAR_BODY(INT32, im->image32, 1, 0);
@@ -520,8 +529,7 @@
 }

 static int
-bilinear_filter32F(void* out, Imaging im, double xin, double yin)
-{
+bilinear_filter32F(void *out, Imaging im, double xin, double yin) {
     FLOAT32 k;
     BILINEAR_HEAD(FLOAT32);
     BILINEAR_BODY(FLOAT32, im->image32, 1, 0);
@@ -531,26 +539,24 @@
 }

 static int
-bilinear_filter32LA(void* out, Imaging im, double xin, double yin)
-{
+bilinear_filter32LA(void *out, Imaging im, double xin, double yin) {
     BILINEAR_HEAD(UINT8);
     BILINEAR_BODY(UINT8, im->image, 4, 0);
-    ((UINT8*)out)[0] = (UINT8) v1;
-    ((UINT8*)out)[1] = (UINT8) v1;
-    ((UINT8*)out)[2] = (UINT8) v1;
+    ((UINT8 *)out)[0] = (UINT8)v1;
+    ((UINT8 *)out)[1] = (UINT8)v1;
+    ((UINT8 *)out)[2] = (UINT8)v1;
     BILINEAR_BODY(UINT8, im->image, 4, 3);
-    ((UINT8*)out)[3] = (UINT8) v1;
-    return 1;
-}
-
-static int
-bilinear_filter32RGB(void* out, Imaging im, double xin, double yin)
-{
+    ((UINT8 *)out)[3] = (UINT8)v1;
+    return 1;
+}
+
+static int
+bilinear_filter32RGB(void *out, Imaging im, double xin, double yin) {
     int b;
     BILINEAR_HEAD(UINT8);
     for (b = 0; b < im->bands; b++) {
         BILINEAR_BODY(UINT8, im->image, 4, b);
-        ((UINT8*)out)[b] = (UINT8) v1;
+        ((UINT8 *)out)[b] = (UINT8)v1;
     }
     return 1;
 }
@@ -559,79 +565,79 @@
 #undef BILINEAR_HEAD
 #undef BILINEAR_BODY

-#define BICUBIC(v, v1, v2, v3, v4, d) {\
-    double p1 = v2;\
-    double p2 = -v1 + v3;\
-    double p3 = 2*(v1 - v2) + v3 - v4;\
-    double p4 = -v1 + v2 - v3 + v4;\
-    v = p1 + (d)*(p2 + (d)*(p3 + (d)*p4));\
-}
-
-#define BICUBIC_HEAD(type)\
-    int x = FLOOR(xin);\
-    int y = FLOOR(yin);\
-    int x0, x1, x2, x3;\
-    double v1, v2, v3, v4;\
-    double dx, dy;\
-    type* in;\
-    if (xin < 0.0 || xin >= im->xsize || yin < 0.0 || yin >= im->ysize) {\
-        return 0;\
-    }\
-    xin -= 0.5;\
-    yin -= 0.5;\
-    x = FLOOR(xin);\
-    y = FLOOR(yin);\
-    dx = xin - x;\
-    dy = yin - y;\
-    x--; y--;
-
-#define BICUBIC_BODY(type, image, step, offset) {\
-    in = (type*) ((image)[YCLIP(im, y)] + offset);\
-    x0 = XCLIP(im, x+0)*step;\
-    x1 = XCLIP(im, x+1)*step;\
-    x2 = XCLIP(im, x+2)*step;\
-    x3 = XCLIP(im, x+3)*step;\
-    BICUBIC(v1, in[x0], in[x1], in[x2], in[x3], dx);\
-    if (y+1 >= 0 && y+1 < im->ysize) {\
-        in = (type*) ((image)[y+1] + offset);\
-        BICUBIC(v2, in[x0], in[x1], in[x2], in[x3], dx);\
-    } else {\
-        v2 = v1;\
-    }\
-    if (y+2 >= 0 && y+2 < im->ysize) {\
-        in = (type*) ((image)[y+2] + offset);\
-        BICUBIC(v3, in[x0], in[x1], in[x2], in[x3], dx);\
-    } else {\
-        v3 = v2;\
-    }\
-    if (y+3 >= 0 && y+3 < im->ysize) {\
-        in = (type*) ((image)[y+3] + offset);\
-        BICUBIC(v4, in[x0], in[x1], in[x2], in[x3], dx);\
-    } else {\
-        v4 = v3;\
-    }\
-    BICUBIC(v1, v1, v2, v3, v4, dy);\
-}
-
-
-static int
-bicubic_filter8(void* out, Imaging im, double xin, double yin)
-{
+#define BICUBIC(v, v1, v2, v3, v4, d)              \
+    {                                              \
+        double p1 = v2;                            \
+        double p2 = -v1 + v3;                      \
+        double p3 = 2 * (v1 - v2) + v3 - v4;       \
+        double p4 = -v1 + v2 - v3 + v4;            \
+        v = p1 + (d) * (p2 + (d) * (p3 + (d)*p4)); \
+    }
+
+#define BICUBIC_HEAD(type)                                                \
+    int x = FLOOR(xin);                                                   \
+    int y = FLOOR(yin);                                                   \
+    int x0, x1, x2, x3;                                                   \
+    double v1, v2, v3, v4;                                                \
+    double dx, dy;                                                        \
+    type *in;                                                             \
+    if (xin < 0.0 || xin >= im->xsize || yin < 0.0 || yin >= im->ysize) { \
+        return 0;                                                         \
+    }                                                                     \
+    xin -= 0.5;                                                           \
+    yin -= 0.5;                                                           \
+    x = FLOOR(xin);                                                       \
+    y = FLOOR(yin);                                                       \
+    dx = xin - x;                                                         \
+    dy = yin - y;                                                         \
+    x--;                                                                  \
+    y--;
+
+#define BICUBIC_BODY(type, image, step, offset)              \
+    {                                                        \
+        in = (type *)((image)[YCLIP(im, y)] + offset);       \
+        x0 = XCLIP(im, x + 0) * step;                        \
+        x1 = XCLIP(im, x + 1) * step;                        \
+        x2 = XCLIP(im, x + 2) * step;                        \
+        x3 = XCLIP(im, x + 3) * step;                        \
+        BICUBIC(v1, in[x0], in[x1], in[x2], in[x3], dx);     \
+        if (y + 1 >= 0 && y + 1 < im->ysize) {               \
+            in = (type *)((image)[y + 1] + offset);          \
+            BICUBIC(v2, in[x0], in[x1], in[x2], in[x3], dx); \
+        } else {                                             \
+            v2 = v1;                                         \
+        }                                                    \
+        if (y + 2 >= 0 && y + 2 < im->ysize) {               \
+            in = (type *)((image)[y + 2] + offset);          \
+            BICUBIC(v3, in[x0], in[x1], in[x2], in[x3], dx); \
+        } else {                                             \
+            v3 = v2;                                         \
+        }                                                    \
+        if (y + 3 >= 0 && y + 3 < im->ysize) {               \
+            in = (type *)((image)[y + 3] + offset);          \
+            BICUBIC(v4, in[x0], in[x1], in[x2], in[x3], dx); \
+        } else {                                             \
+            v4 = v3;                                         \
+        }                                                    \
+        BICUBIC(v1, v1, v2, v3, v4, dy);                     \
+    }
+
+static int
+bicubic_filter8(void *out, Imaging im, double xin, double yin) {
     BICUBIC_HEAD(UINT8);
     BICUBIC_BODY(UINT8, im->image8, 1, 0);
     if (v1 <= 0.0) {
-        ((UINT8*)out)[0] = 0;
+        ((UINT8 *)out)[0] = 0;
     } else if (v1 >= 255.0) {
-        ((UINT8*)out)[0] = 255;
+        ((UINT8 *)out)[0] = 255;
     } else {
-        ((UINT8*)out)[0] = (UINT8) v1;
-    }
-    return 1;
-}
-
-static int
-bicubic_filter32I(void* out, Imaging im, double xin, double yin)
-{
+        ((UINT8 *)out)[0] = (UINT8)v1;
+    }
+    return 1;
+}
+
+static int
+bicubic_filter32I(void *out, Imaging im, double xin, double yin) {
     INT32 k;
     BICUBIC_HEAD(INT32);
     BICUBIC_BODY(INT32, im->image32, 1, 0);
@@ -641,8 +647,7 @@
 }

 static int
-bicubic_filter32F(void* out, Imaging im, double xin, double yin)
-{
+bicubic_filter32F(void *out, Imaging im, double xin, double yin) {
     FLOAT32 k;
     BICUBIC_HEAD(FLOAT32);
     BICUBIC_BODY(FLOAT32, im->image32, 1, 0);
@@ -652,47 +657,45 @@
 }

 static int
-bicubic_filter32LA(void* out, Imaging im, double xin, double yin)
-{
+bicubic_filter32LA(void *out, Imaging im, double xin, double yin) {
     BICUBIC_HEAD(UINT8);
     BICUBIC_BODY(UINT8, im->image, 4, 0);
     if (v1 <= 0.0) {
-        ((UINT8*)out)[0] = 0;
-        ((UINT8*)out)[1] = 0;
-        ((UINT8*)out)[2] = 0;
+        ((UINT8 *)out)[0] = 0;
+        ((UINT8 *)out)[1] = 0;
+        ((UINT8 *)out)[2] = 0;
     } else if (v1 >= 255.0) {
-        ((UINT8*)out)[0] = 255;
-        ((UINT8*)out)[1] = 255;
-        ((UINT8*)out)[2] = 255;
+        ((UINT8 *)out)[0] = 255;
+        ((UINT8 *)out)[1] = 255;
+        ((UINT8 *)out)[2] = 255;
     } else {
-        ((UINT8*)out)[0] = (UINT8) v1;
-        ((UINT8*)out)[1] = (UINT8) v1;
-        ((UINT8*)out)[2] = (UINT8) v1;
+        ((UINT8 *)out)[0] = (UINT8)v1;
+        ((UINT8 *)out)[1] = (UINT8)v1;
+        ((UINT8 *)out)[2] = (UINT8)v1;
     }
     BICUBIC_BODY(UINT8, im->image, 4, 3);
     if (v1 <= 0.0) {
-        ((UINT8*)out)[3] = 0;
+        ((UINT8 *)out)[3] = 0;
     } else if (v1 >= 255.0) {
-        ((UINT8*)out)[3] = 255;
+        ((UINT8 *)out)[3] = 255;
     } else {
-        ((UINT8*)out)[3] = (UINT8) v1;
-    }
-    return 1;
-}
-
-static int
-bicubic_filter32RGB(void* out, Imaging im, double xin, double yin)
-{
+        ((UINT8 *)out)[3] = (UINT8)v1;
+    }
+    return 1;
+}
+
+static int
+bicubic_filter32RGB(void *out, Imaging im, double xin, double yin) {
     int b;
     BICUBIC_HEAD(UINT8);
     for (b = 0; b < im->bands; b++) {
         BICUBIC_BODY(UINT8, im->image, 4, b);
         if (v1 <= 0.0) {
-            ((UINT8*)out)[b] = 0;
+            ((UINT8 *)out)[b] = 0;
         } else if (v1 >= 255.0) {
-            ((UINT8*)out)[b] = 255;
+            ((UINT8 *)out)[b] = 255;
         } else {
-            ((UINT8*)out)[b] = (UINT8) v1;
+            ((UINT8 *)out)[b] = (UINT8)v1;
         }
     }
     return 1;
@@ -703,64 +706,63 @@
 #undef BICUBIC_BODY

 static ImagingTransformFilter
-getfilter(Imaging im, int filterid)
-{
+getfilter(Imaging im, int filterid) {
     switch (filterid) {
-    case IMAGING_TRANSFORM_NEAREST:
-        if (im->image8) {
-            switch (im->type) {
-            case IMAGING_TYPE_UINT8:
-                return nearest_filter8;
-            case IMAGING_TYPE_SPECIAL:
-                switch (im->pixelsize) {
-                case 1:
-                    return nearest_filter8;
-                case 2:
-                    return nearest_filter16;
-                case 4:
-                    return nearest_filter32;
+        case IMAGING_TRANSFORM_NEAREST:
+            if (im->image8) {
+                switch (im->type) {
+                    case IMAGING_TYPE_UINT8:
+                        return nearest_filter8;
+                    case IMAGING_TYPE_SPECIAL:
+                        switch (im->pixelsize) {
+                            case 1:
+                                return nearest_filter8;
+                            case 2:
+                                return nearest_filter16;
+                            case 4:
+                                return nearest_filter32;
+                        }
+                }
+            } else {
+                return nearest_filter32;
+            }
+            break;
+        case IMAGING_TRANSFORM_BILINEAR:
+            if (im->image8) {
+                return bilinear_filter8;
+            } else if (im->image32) {
+                switch (im->type) {
+                    case IMAGING_TYPE_UINT8:
+                        if (im->bands == 2) {
+                            return bilinear_filter32LA;
+                        } else {
+                            return bilinear_filter32RGB;
+                        }
+                    case IMAGING_TYPE_INT32:
+                        return bilinear_filter32I;
+                    case IMAGING_TYPE_FLOAT32:
+                        return bilinear_filter32F;
                 }
             }
-        } else {
-            return nearest_filter32;
-        }
-        break;
-    case IMAGING_TRANSFORM_BILINEAR:
-        if (im->image8) {
-            return bilinear_filter8;
-        } else if (im->image32) {
-            switch (im->type) {
-            case IMAGING_TYPE_UINT8:
-                if (im->bands == 2) {
-                    return bilinear_filter32LA;
-                } else {
-                    return bilinear_filter32RGB;
+            break;
+        case IMAGING_TRANSFORM_BICUBIC:
+            if (im->image8) {
+                return bicubic_filter8;
+            } else if (im->image32) {
+                switch (im->type) {
+                    case IMAGING_TYPE_UINT8:
+                        if (im->bands == 2) {
+                            return bicubic_filter32LA;
+                        } else {
+                            return bicubic_filter32RGB;
+                        }
+                    case IMAGING_TYPE_INT32:
+                        return bicubic_filter32I;
+                    case IMAGING_TYPE_FLOAT32:
+                        return bicubic_filter32F;
                 }
-            case IMAGING_TYPE_INT32:
-                return bilinear_filter32I;
-            case IMAGING_TYPE_FLOAT32:
-                return bilinear_filter32F;
             }
-        }
-        break;
-    case IMAGING_TRANSFORM_BICUBIC:
-        if (im->image8) {
-            return bicubic_filter8;
-        } else if (im->image32) {
-            switch (im->type) {
-            case IMAGING_TYPE_UINT8:
-                if (im->bands == 2) {
-                    return bicubic_filter32LA;
-                } else {
-                    return bicubic_filter32RGB;
-                }
-            case IMAGING_TYPE_INT32:
-                return bicubic_filter32I;
-            case IMAGING_TYPE_FLOAT32:
-                return bicubic_filter32F;
-            }
-        }
-        break;
+            break;
     }
     /* no such filter */
     return NULL;
@@ -770,10 +772,16 @@

 Imaging
 ImagingGenericTransform(
-    Imaging imOut, Imaging imIn, int x0, int y0, int x1, int y1,
-    ImagingTransformMap transform, void* transform_data,
-    int filterid, int fill)
-{
+    Imaging imOut,
+    Imaging imIn,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    ImagingTransformMap transform,
+    void *transform_data,
+    int filterid,
+    int fill) {
     /* slow generic transformation.  use ImagingTransformAffine or
        ImagingScaleAffine where possible. */

@@ -784,11 +792,11 @@

     ImagingTransformFilter filter = getfilter(imIn, filterid);
     if (!filter) {
-        return (Imaging) ImagingError_ValueError("bad filter number");
+        return (Imaging)ImagingError_ValueError("bad filter number");
     }

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     ImagingCopyPalette(imOut, imIn);
@@ -809,10 +817,10 @@
     }

     for (y = y0; y < y1; y++) {
-        out = imOut->image[y] + x0*imOut->pixelsize;
+        out = imOut->image[y] + x0 * imOut->pixelsize;
         for (x = x0; x < x1; x++) {
-            if ( ! transform(&xx, &yy, x-x0, y-y0, transform_data) ||
-                 ! filter(out, imIn, xx, yy)) {
+            if (!transform(&xx, &yy, x - x0, y - y0, transform_data) ||
+                !filter(out, imIn, xx, yy)) {
                 if (fill) {
                     memset(out, 0, imOut->pixelsize);
                 }
@@ -827,10 +835,15 @@
 }

 static Imaging
-ImagingScaleAffine(Imaging imOut, Imaging imIn,
-                   int x0, int y0, int x1, int y1,
-                   double a[6], int fill)
-{
+ImagingScaleAffine(
+    Imaging imOut,
+    Imaging imIn,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    double a[6],
+    int fill) {
     /* scale, nearest neighbour resampling */

     ImagingSectionCookie cookie;
@@ -841,7 +854,7 @@
     int *xintab;

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     ImagingCopyPalette(imOut, imIn);
@@ -860,10 +873,10 @@
     }

     /* malloc check ok, uses calloc for overflow */
-    xintab = (int*) calloc(imOut->xsize, sizeof(int));
+    xintab = (int *)calloc(imOut->xsize, sizeof(int));
     if (!xintab) {
         ImagingDelete(imOut);
-        return (Imaging) ImagingError_MemoryError();
+        return (Imaging)ImagingError_MemoryError();
     }

     xo = a[2] + a[0] * 0.5;
@@ -875,8 +888,8 @@
     /* Pretabulate horizontal pixel positions */
     for (x = x0; x < x1; x++) {
         xin = COORD(xo);
-        if (xin >= 0 && xin < (int) imIn->xsize) {
-            xmax = x+1;
+        if (xin >= 0 && xin < (int)imIn->xsize) {
+            xmax = x + 1;
             if (x < xmin) {
                 xmin = x;
             }
@@ -885,21 +898,21 @@
         xo += a[0];
     }

-#define AFFINE_SCALE(pixel, image)\
-    for (y = y0; y < y1; y++) {\
-        int yi = COORD(yo);\
-        pixel *in, *out;\
-        out = imOut->image[y];\
-        if (fill && x1 > x0) {\
-            memset(out+x0, 0, (x1-x0)*sizeof(pixel));\
-        }\
-        if (yi >= 0 && yi < imIn->ysize) {\
-            in = imIn->image[yi];\
-            for (x = xmin; x < xmax; x++) {\
-                out[x] = in[xintab[x]];\
-            }\
-        }\
-        yo += a[4];\
+#define AFFINE_SCALE(pixel, image)                          \
+    for (y = y0; y < y1; y++) {                             \
+        int yi = COORD(yo);                                 \
+        pixel *in, *out;                                    \
+        out = imOut->image[y];                              \
+        if (fill && x1 > x0) {                              \
+            memset(out + x0, 0, (x1 - x0) * sizeof(pixel)); \
+        }                                                   \
+        if (yi >= 0 && yi < imIn->ysize) {                  \
+            in = imIn->image[yi];                           \
+            for (x = xmin; x < xmax; x++) {                 \
+                out[x] = in[xintab[x]];                     \
+            }                                               \
+        }                                                   \
+        yo += a[4];                                         \
     }

     ImagingSectionEnter(&cookie);
@@ -920,17 +933,23 @@
 }

 static inline int
-check_fixed(double a[6], int x, int y)
-{
-    return (fabs(x*a[0] + y*a[1] + a[2]) < 32768.0 &&
-            fabs(x*a[3] + y*a[4] + a[5]) < 32768.0);
+check_fixed(double a[6], int x, int y) {
+    return (
+        fabs(x * a[0] + y * a[1] + a[2]) < 32768.0 &&
+        fabs(x * a[3] + y * a[4] + a[5]) < 32768.0);
 }

 static inline Imaging
-affine_fixed(Imaging imOut, Imaging imIn,
-             int x0, int y0, int x1, int y1,
-             double a[6], int filterid, int fill)
-{
+affine_fixed(
+    Imaging imOut,
+    Imaging imIn,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    double a[6],
+    int filterid,
+    int fill) {
     /* affine transform, nearest neighbour resampling, fixed point
        arithmetics */

@@ -943,41 +962,43 @@

     ImagingCopyPalette(imOut, imIn);

-    xsize = (int) imIn->xsize;
-    ysize = (int) imIn->ysize;
+    xsize = (int)imIn->xsize;
+    ysize = (int)imIn->ysize;

 /* use 16.16 fixed point arithmetics */
 #define FIX(v) FLOOR((v)*65536.0 + 0.5)

-    a0 = FIX(a[0]); a1 = FIX(a[1]);
-    a3 = FIX(a[3]); a4 = FIX(a[4]);
+    a0 = FIX(a[0]);
+    a1 = FIX(a[1]);
+    a3 = FIX(a[3]);
+    a4 = FIX(a[4]);
     a2 = FIX(a[2] + a[0] * 0.5 + a[1] * 0.5);
     a5 = FIX(a[5] + a[3] * 0.5 + a[4] * 0.5);

 #undef FIX

-#define AFFINE_TRANSFORM_FIXED(pixel, image)\
-    for (y = y0; y < y1; y++) {\
-        pixel *out;\
-        xx = a2;\
-        yy = a5;\
-        out = imOut->image[y];\
-        if (fill && x1 > x0) {\
-            memset(out+x0, 0, (x1-x0)*sizeof(pixel));\
-        }\
-        for (x = x0; x < x1; x++, out++) {\
-            xin = xx >> 16;\
-            if (xin >= 0 && xin < xsize) {\
-                yin = yy >> 16;\
-                if (yin >= 0 && yin < ysize) {\
-                    *out = imIn->image[yin][xin];\
-                }\
-            }\
-            xx += a0;\
-            yy += a3;\
-        }\
-        a2 += a1;\
-        a5 += a4;\
+#define AFFINE_TRANSFORM_FIXED(pixel, image)                \
+    for (y = y0; y < y1; y++) {                             \
+        pixel *out;                                         \
+        xx = a2;                                            \
+        yy = a5;                                            \
+        out = imOut->image[y];                              \
+        if (fill && x1 > x0) {                              \
+            memset(out + x0, 0, (x1 - x0) * sizeof(pixel)); \
+        }                                                   \
+        for (x = x0; x < x1; x++, out++) {                  \
+            xin = xx >> 16;                                 \
+            if (xin >= 0 && xin < xsize) {                  \
+                yin = yy >> 16;                             \
+                if (yin >= 0 && yin < ysize) {              \
+                    *out = imIn->image[yin][xin];           \
+                }                                           \
+            }                                               \
+            xx += a0;                                       \
+            yy += a3;                                       \
+        }                                                   \
+        a2 += a1;                                           \
+        a5 += a4;                                           \
     }

     ImagingSectionEnter(&cookie);
@@ -996,10 +1017,16 @@
 }

 Imaging
-ImagingTransformAffine(Imaging imOut, Imaging imIn,
-                       int x0, int y0, int x1, int y1,
-                       double a[6], int filterid, int fill)
-{
+ImagingTransformAffine(
+    Imaging imOut,
+    Imaging imIn,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    double a[6],
+    int filterid,
+    int fill) {
     /* affine transform, nearest neighbour resampling, floating point
        arithmetics*/

@@ -1012,10 +1039,7 @@

     if (filterid || imIn->type == IMAGING_TYPE_SPECIAL) {
         return ImagingGenericTransform(
-            imOut, imIn,
-            x0, y0, x1, y1,
-            affine_transform, a,
-            filterid, fill);
+            imOut, imIn, x0, y0, x1, y1, affine_transform, a, filterid, fill);
     }

     if (a[1] == 0 && a[3] == 0) {
@@ -1024,7 +1048,7 @@
     }

     if (!imOut || !imIn || strcmp(imIn->mode, imOut->mode) != 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (x0 < 0) {
@@ -1043,8 +1067,8 @@
     /* translate all four corners to check if they are within the
        range that can be represented by the fixed point arithmetics */

-    if (check_fixed(a, 0, 0) && check_fixed(a, x1-x0, y1-y0) &&
-        check_fixed(a, 0, y1-y0) && check_fixed(a, x1-x0, 0)) {
+    if (check_fixed(a, 0, 0) && check_fixed(a, x1 - x0, y1 - y0) &&
+        check_fixed(a, 0, y1 - y0) && check_fixed(a, x1 - x0, 0)) {
         return affine_fixed(imOut, imIn, x0, y0, x1, y1, a, filterid, fill);
     }

@@ -1054,34 +1078,34 @@

     ImagingCopyPalette(imOut, imIn);

-    xsize = (int) imIn->xsize;
-    ysize = (int) imIn->ysize;
+    xsize = (int)imIn->xsize;
+    ysize = (int)imIn->ysize;

     xo = a[2] + a[1] * 0.5 + a[0] * 0.5;
     yo = a[5] + a[4] * 0.5 + a[3] * 0.5;

-#define AFFINE_TRANSFORM(pixel, image)\
-    for (y = y0; y < y1; y++) {\
-        pixel *out;\
-        xx = xo;\
-        yy = yo;\
-        out = imOut->image[y];\
-        if (fill && x1 > x0) {\
-            memset(out+x0, 0, (x1-x0)*sizeof(pixel));\
-        }\
-        for (x = x0; x < x1; x++, out++) {\
-            xin = COORD(xx);\
-            if (xin >= 0 && xin < xsize) {\
-                yin = COORD(yy);\
-                if (yin >= 0 && yin < ysize) {\
-                    *out = imIn->image[yin][xin];\
-                }\
-            }\
-            xx += a[0];\
-            yy += a[3];\
-        }\
-        xo += a[1];\
-        yo += a[4];\
+#define AFFINE_TRANSFORM(pixel, image)                      \
+    for (y = y0; y < y1; y++) {                             \
+        pixel *out;                                         \
+        xx = xo;                                            \
+        yy = yo;                                            \
+        out = imOut->image[y];                              \
+        if (fill && x1 > x0) {                              \
+            memset(out + x0, 0, (x1 - x0) * sizeof(pixel)); \
+        }                                                   \
+        for (x = x0; x < x1; x++, out++) {                  \
+            xin = COORD(xx);                                \
+            if (xin >= 0 && xin < xsize) {                  \
+                yin = COORD(yy);                            \
+                if (yin >= 0 && yin < ysize) {              \
+                    *out = imIn->image[yin][xin];           \
+                }                                           \
+            }                                               \
+            xx += a[0];                                     \
+            yy += a[3];                                     \
+        }                                                   \
+        xo += a[1];                                         \
+        yo += a[4];                                         \
     }

     ImagingSectionEnter(&cookie);
@@ -1100,29 +1124,34 @@
 }

 Imaging
-ImagingTransform(Imaging imOut, Imaging imIn, int method,
-                 int x0, int y0, int x1, int y1,
-                 double a[8], int filterid, int fill)
-{
+ImagingTransform(
+    Imaging imOut,
+    Imaging imIn,
+    int method,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    double a[8],
+    int filterid,
+    int fill) {
     ImagingTransformMap transform;

-    switch(method) {
-    case IMAGING_TRANSFORM_AFFINE:
-        return ImagingTransformAffine(
-            imOut, imIn, x0, y0, x1, y1, a, filterid, fill);
-        break;
-    case IMAGING_TRANSFORM_PERSPECTIVE:
-        transform = perspective_transform;
-        break;
-    case IMAGING_TRANSFORM_QUAD:
-        transform = quad_transform;
-        break;
-    default:
-        return (Imaging) ImagingError_ValueError("bad transform method");
+    switch (method) {
+        case IMAGING_TRANSFORM_AFFINE:
+            return ImagingTransformAffine(
+                imOut, imIn, x0, y0, x1, y1, a, filterid, fill);
+            break;
+        case IMAGING_TRANSFORM_PERSPECTIVE:
+            transform = perspective_transform;
+            break;
+        case IMAGING_TRANSFORM_QUAD:
+            transform = quad_transform;
+            break;
+        default:
+            return (Imaging)ImagingError_ValueError("bad transform method");
     }

     return ImagingGenericTransform(
-        imOut, imIn,
-        x0, y0, x1, y1,
-        transform, a, filterid, fill);
-}
+        imOut, imIn, x0, y0, x1, y1, transform, a, filterid, fill);
+}
('src/libImaging', 'ConvertYCbCr.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -28,356 +28,332 @@

 #define SCALE 6 /* bits */

-static INT16 Y_R[] = { 0, 19, 38, 57, 77, 96, 115, 134, 153, 172, 191,
-210, 230, 249, 268, 287, 306, 325, 344, 364, 383, 402, 421, 440, 459,
-478, 498, 517, 536, 555, 574, 593, 612, 631, 651, 670, 689, 708, 727,
-746, 765, 785, 804, 823, 842, 861, 880, 899, 919, 938, 957, 976, 995,
-1014, 1033, 1052, 1072, 1091, 1110, 1129, 1148, 1167, 1186, 1206,
-1225, 1244, 1263, 1282, 1301, 1320, 1340, 1359, 1378, 1397, 1416,
-1435, 1454, 1473, 1493, 1512, 1531, 1550, 1569, 1588, 1607, 1627,
-1646, 1665, 1684, 1703, 1722, 1741, 1761, 1780, 1799, 1818, 1837,
-1856, 1875, 1894, 1914, 1933, 1952, 1971, 1990, 2009, 2028, 2048,
-2067, 2086, 2105, 2124, 2143, 2162, 2182, 2201, 2220, 2239, 2258,
-2277, 2296, 2315, 2335, 2354, 2373, 2392, 2411, 2430, 2449, 2469,
-2488, 2507, 2526, 2545, 2564, 2583, 2602, 2622, 2641, 2660, 2679,
-2698, 2717, 2736, 2756, 2775, 2794, 2813, 2832, 2851, 2870, 2890,
-2909, 2928, 2947, 2966, 2985, 3004, 3023, 3043, 3062, 3081, 3100,
-3119, 3138, 3157, 3177, 3196, 3215, 3234, 3253, 3272, 3291, 3311,
-3330, 3349, 3368, 3387, 3406, 3425, 3444, 3464, 3483, 3502, 3521,
-3540, 3559, 3578, 3598, 3617, 3636, 3655, 3674, 3693, 3712, 3732,
-3751, 3770, 3789, 3808, 3827, 3846, 3865, 3885, 3904, 3923, 3942,
-3961, 3980, 3999, 4019, 4038, 4057, 4076, 4095, 4114, 4133, 4153,
-4172, 4191, 4210, 4229, 4248, 4267, 4286, 4306, 4325, 4344, 4363,
-4382, 4401, 4420, 4440, 4459, 4478, 4497, 4516, 4535, 4554, 4574,
-4593, 4612, 4631, 4650, 4669, 4688, 4707, 4727, 4746, 4765, 4784,
-4803, 4822, 4841, 4861, 4880 };
-
-static INT16 Y_G[] = { 0, 38, 75, 113, 150, 188, 225, 263, 301, 338,
-376, 413, 451, 488, 526, 564, 601, 639, 676, 714, 751, 789, 826, 864,
-902, 939, 977, 1014, 1052, 1089, 1127, 1165, 1202, 1240, 1277, 1315,
-1352, 1390, 1428, 1465, 1503, 1540, 1578, 1615, 1653, 1691, 1728,
-1766, 1803, 1841, 1878, 1916, 1954, 1991, 2029, 2066, 2104, 2141,
-2179, 2217, 2254, 2292, 2329, 2367, 2404, 2442, 2479, 2517, 2555,
-2592, 2630, 2667, 2705, 2742, 2780, 2818, 2855, 2893, 2930, 2968,
-3005, 3043, 3081, 3118, 3156, 3193, 3231, 3268, 3306, 3344, 3381,
-3419, 3456, 3494, 3531, 3569, 3607, 3644, 3682, 3719, 3757, 3794,
-3832, 3870, 3907, 3945, 3982, 4020, 4057, 4095, 4132, 4170, 4208,
-4245, 4283, 4320, 4358, 4395, 4433, 4471, 4508, 4546, 4583, 4621,
-4658, 4696, 4734, 4771, 4809, 4846, 4884, 4921, 4959, 4997, 5034,
-5072, 5109, 5147, 5184, 5222, 5260, 5297, 5335, 5372, 5410, 5447,
-5485, 5522, 5560, 5598, 5635, 5673, 5710, 5748, 5785, 5823, 5861,
-5898, 5936, 5973, 6011, 6048, 6086, 6124, 6161, 6199, 6236, 6274,
-6311, 6349, 6387, 6424, 6462, 6499, 6537, 6574, 6612, 6650, 6687,
-6725, 6762, 6800, 6837, 6875, 6913, 6950, 6988, 7025, 7063, 7100,
-7138, 7175, 7213, 7251, 7288, 7326, 7363, 7401, 7438, 7476, 7514,
-7551, 7589, 7626, 7664, 7701, 7739, 7777, 7814, 7852, 7889, 7927,
-7964, 8002, 8040, 8077, 8115, 8152, 8190, 8227, 8265, 8303, 8340,
-8378, 8415, 8453, 8490, 8528, 8566, 8603, 8641, 8678, 8716, 8753,
-8791, 8828, 8866, 8904, 8941, 8979, 9016, 9054, 9091, 9129, 9167,
-9204, 9242, 9279, 9317, 9354, 9392, 9430, 9467, 9505, 9542, 9580 };
-
-static INT16 Y_B[] = { 0, 7, 15, 22, 29, 36, 44, 51, 58, 66, 73, 80,
-88, 95, 102, 109, 117, 124, 131, 139, 146, 153, 161, 168, 175, 182,
-190, 197, 204, 212, 219, 226, 233, 241, 248, 255, 263, 270, 277, 285,
-292, 299, 306, 314, 321, 328, 336, 343, 350, 358, 365, 372, 379, 387,
-394, 401, 409, 416, 423, 430, 438, 445, 452, 460, 467, 474, 482, 489,
-496, 503, 511, 518, 525, 533, 540, 547, 554, 562, 569, 576, 584, 591,
-598, 606, 613, 620, 627, 635, 642, 649, 657, 664, 671, 679, 686, 693,
-700, 708, 715, 722, 730, 737, 744, 751, 759, 766, 773, 781, 788, 795,
-803, 810, 817, 824, 832, 839, 846, 854, 861, 868, 876, 883, 890, 897,
-905, 912, 919, 927, 934, 941, 948, 956, 963, 970, 978, 985, 992, 1000,
-1007, 1014, 1021, 1029, 1036, 1043, 1051, 1058, 1065, 1073, 1080,
-1087, 1094, 1102, 1109, 1116, 1124, 1131, 1138, 1145, 1153, 1160,
-1167, 1175, 1182, 1189, 1197, 1204, 1211, 1218, 1226, 1233, 1240,
-1248, 1255, 1262, 1270, 1277, 1284, 1291, 1299, 1306, 1313, 1321,
-1328, 1335, 1342, 1350, 1357, 1364, 1372, 1379, 1386, 1394, 1401,
-1408, 1415, 1423, 1430, 1437, 1445, 1452, 1459, 1466, 1474, 1481,
-1488, 1496, 1503, 1510, 1518, 1525, 1532, 1539, 1547, 1554, 1561,
-1569, 1576, 1583, 1591, 1598, 1605, 1612, 1620, 1627, 1634, 1642,
-1649, 1656, 1663, 1671, 1678, 1685, 1693, 1700, 1707, 1715, 1722,
-1729, 1736, 1744, 1751, 1758, 1766, 1773, 1780, 1788, 1795, 1802,
-1809, 1817, 1824, 1831, 1839, 1846, 1853, 1860 };
-
-static INT16 Cb_R[] = { 0, -10, -21, -31, -42, -53, -64, -75, -85,
--96, -107, -118, -129, -139, -150, -161, -172, -183, -193, -204, -215,
--226, -237, -247, -258, -269, -280, -291, -301, -312, -323, -334,
--345, -355, -366, -377, -388, -399, -409, -420, -431, -442, -453,
--463, -474, -485, -496, -507, -517, -528, -539, -550, -561, -571,
--582, -593, -604, -615, -625, -636, -647, -658, -669, -679, -690,
--701, -712, -723, -733, -744, -755, -766, -777, -787, -798, -809,
--820, -831, -841, -852, -863, -874, -885, -895, -906, -917, -928,
--939, -949, -960, -971, -982, -993, -1003, -1014, -1025, -1036, -1047,
--1057, -1068, -1079, -1090, -1101, -1111, -1122, -1133, -1144, -1155,
--1165, -1176, -1187, -1198, -1209, -1219, -1230, -1241, -1252, -1263,
--1273, -1284, -1295, -1306, -1317, -1327, -1338, -1349, -1360, -1371,
--1381, -1392, -1403, -1414, -1425, -1435, -1446, -1457, -1468, -1479,
--1489, -1500, -1511, -1522, -1533, -1543, -1554, -1565, -1576, -1587,
--1597, -1608, -1619, -1630, -1641, -1651, -1662, -1673, -1684, -1694,
--1705, -1716, -1727, -1738, -1748, -1759, -1770, -1781, -1792, -1802,
--1813, -1824, -1835, -1846, -1856, -1867, -1878, -1889, -1900, -1910,
--1921, -1932, -1943, -1954, -1964, -1975, -1986, -1997, -2008, -2018,
--2029, -2040, -2051, -2062, -2072, -2083, -2094, -2105, -2116, -2126,
--2137, -2148, -2159, -2170, -2180, -2191, -2202, -2213, -2224, -2234,
--2245, -2256, -2267, -2278, -2288, -2299, -2310, -2321, -2332, -2342,
--2353, -2364, -2375, -2386, -2396, -2407, -2418, -2429, -2440, -2450,
--2461, -2472, -2483, -2494, -2504, -2515, -2526, -2537, -2548, -2558,
--2569, -2580, -2591, -2602, -2612, -2623, -2634, -2645, -2656, -2666,
--2677, -2688, -2699, -2710, -2720, -2731, -2742, -2753 };
-
-static INT16 Cb_G[] = { 0, -20, -41, -63, -84, -105, -126, -147, -169,
--190, -211, -232, -253, -275, -296, -317, -338, -359, -381, -402,
--423, -444, -465, -487, -508, -529, -550, -571, -593, -614, -635,
--656, -677, -699, -720, -741, -762, -783, -805, -826, -847, -868,
--889, -911, -932, -953, -974, -995, -1017, -1038, -1059, -1080, -1101,
--1123, -1144, -1165, -1186, -1207, -1229, -1250, -1271, -1292, -1313,
--1335, -1356, -1377, -1398, -1419, -1441, -1462, -1483, -1504, -1525,
--1547, -1568, -1589, -1610, -1631, -1653, -1674, -1695, -1716, -1737,
--1759, -1780, -1801, -1822, -1843, -1865, -1886, -1907, -1928, -1949,
--1971, -1992, -2013, -2034, -2055, -2077, -2098, -2119, -2140, -2161,
--2183, -2204, -2225, -2246, -2267, -2289, -2310, -2331, -2352, -2373,
--2395, -2416, -2437, -2458, -2479, -2501, -2522, -2543, -2564, -2585,
--2607, -2628, -2649, -2670, -2691, -2713, -2734, -2755, -2776, -2797,
--2819, -2840, -2861, -2882, -2903, -2925, -2946, -2967, -2988, -3009,
--3031, -3052, -3073, -3094, -3115, -3137, -3158, -3179, -3200, -3221,
--3243, -3264, -3285, -3306, -3328, -3349, -3370, -3391, -3412, -3434,
--3455, -3476, -3497, -3518, -3540, -3561, -3582, -3603, -3624, -3646,
--3667, -3688, -3709, -3730, -3752, -3773, -3794, -3815, -3836, -3858,
--3879, -3900, -3921, -3942, -3964, -3985, -4006, -4027, -4048, -4070,
--4091, -4112, -4133, -4154, -4176, -4197, -4218, -4239, -4260, -4282,
--4303, -4324, -4345, -4366, -4388, -4409, -4430, -4451, -4472, -4494,
--4515, -4536, -4557, -4578, -4600, -4621, -4642, -4663, -4684, -4706,
--4727, -4748, -4769, -4790, -4812, -4833, -4854, -4875, -4896, -4918,
--4939, -4960, -4981, -5002, -5024, -5045, -5066, -5087, -5108, -5130,
--5151, -5172, -5193, -5214, -5236, -5257, -5278, -5299, -5320, -5342,
--5363, -5384, -5405 };
-
-static INT16 Cb_B[] = { 0, 32, 64, 96, 128, 160, 192, 224, 256, 288,
-320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736,
-768, 800, 832, 864, 896, 928, 960, 992, 1024, 1056, 1088, 1120, 1152,
-1184, 1216, 1248, 1280, 1312, 1344, 1376, 1408, 1440, 1472, 1504,
-1536, 1568, 1600, 1632, 1664, 1696, 1728, 1760, 1792, 1824, 1856,
-1888, 1920, 1952, 1984, 2016, 2048, 2080, 2112, 2144, 2176, 2208,
-2240, 2272, 2304, 2336, 2368, 2400, 2432, 2464, 2496, 2528, 2560,
-2592, 2624, 2656, 2688, 2720, 2752, 2784, 2816, 2848, 2880, 2912,
-2944, 2976, 3008, 3040, 3072, 3104, 3136, 3168, 3200, 3232, 3264,
-3296, 3328, 3360, 3392, 3424, 3456, 3488, 3520, 3552, 3584, 3616,
-3648, 3680, 3712, 3744, 3776, 3808, 3840, 3872, 3904, 3936, 3968,
-4000, 4032, 4064, 4096, 4128, 4160, 4192, 4224, 4256, 4288, 4320,
-4352, 4384, 4416, 4448, 4480, 4512, 4544, 4576, 4608, 4640, 4672,
-4704, 4736, 4768, 4800, 4832, 4864, 4896, 4928, 4960, 4992, 5024,
-5056, 5088, 5120, 5152, 5184, 5216, 5248, 5280, 5312, 5344, 5376,
-5408, 5440, 5472, 5504, 5536, 5568, 5600, 5632, 5664, 5696, 5728,
-5760, 5792, 5824, 5856, 5888, 5920, 5952, 5984, 6016, 6048, 6080,
-6112, 6144, 6176, 6208, 6240, 6272, 6304, 6336, 6368, 6400, 6432,
-6464, 6496, 6528, 6560, 6592, 6624, 6656, 6688, 6720, 6752, 6784,
-6816, 6848, 6880, 6912, 6944, 6976, 7008, 7040, 7072, 7104, 7136,
-7168, 7200, 7232, 7264, 7296, 7328, 7360, 7392, 7424, 7456, 7488,
-7520, 7552, 7584, 7616, 7648, 7680, 7712, 7744, 7776, 7808, 7840,
-7872, 7904, 7936, 7968, 8000, 8032, 8064, 8096, 8128, 8160 };
+static INT16 Y_R[] = {
+    0,    19,   38,   57,   77,   96,   115,  134,  153,  172,  191,  210,  230,  249,
+    268,  287,  306,  325,  344,  364,  383,  402,  421,  440,  459,  478,  498,  517,
+    536,  555,  574,  593,  612,  631,  651,  670,  689,  708,  727,  746,  765,  785,
+    804,  823,  842,  861,  880,  899,  919,  938,  957,  976,  995,  1014, 1033, 1052,
+    1072, 1091, 1110, 1129, 1148, 1167, 1186, 1206, 1225, 1244, 1263, 1282, 1301, 1320,
+    1340, 1359, 1378, 1397, 1416, 1435, 1454, 1473, 1493, 1512, 1531, 1550, 1569, 1588,
+    1607, 1627, 1646, 1665, 1684, 1703, 1722, 1741, 1761, 1780, 1799, 1818, 1837, 1856,
+    1875, 1894, 1914, 1933, 1952, 1971, 1990, 2009, 2028, 2048, 2067, 2086, 2105, 2124,
+    2143, 2162, 2182, 2201, 2220, 2239, 2258, 2277, 2296, 2315, 2335, 2354, 2373, 2392,
+    2411, 2430, 2449, 2469, 2488, 2507, 2526, 2545, 2564, 2583, 2602, 2622, 2641, 2660,
+    2679, 2698, 2717, 2736, 2756, 2775, 2794, 2813, 2832, 2851, 2870, 2890, 2909, 2928,
+    2947, 2966, 2985, 3004, 3023, 3043, 3062, 3081, 3100, 3119, 3138, 3157, 3177, 3196,
+    3215, 3234, 3253, 3272, 3291, 3311, 3330, 3349, 3368, 3387, 3406, 3425, 3444, 3464,
+    3483, 3502, 3521, 3540, 3559, 3578, 3598, 3617, 3636, 3655, 3674, 3693, 3712, 3732,
+    3751, 3770, 3789, 3808, 3827, 3846, 3865, 3885, 3904, 3923, 3942, 3961, 3980, 3999,
+    4019, 4038, 4057, 4076, 4095, 4114, 4133, 4153, 4172, 4191, 4210, 4229, 4248, 4267,
+    4286, 4306, 4325, 4344, 4363, 4382, 4401, 4420, 4440, 4459, 4478, 4497, 4516, 4535,
+    4554, 4574, 4593, 4612, 4631, 4650, 4669, 4688, 4707, 4727, 4746, 4765, 4784, 4803,
+    4822, 4841, 4861, 4880};
+
+static INT16 Y_G[] = {
+    0,    38,   75,   113,  150,  188,  225,  263,  301,  338,  376,  413,  451,  488,
+    526,  564,  601,  639,  676,  714,  751,  789,  826,  864,  902,  939,  977,  1014,
+    1052, 1089, 1127, 1165, 1202, 1240, 1277, 1315, 1352, 1390, 1428, 1465, 1503, 1540,
+    1578, 1615, 1653, 1691, 1728, 1766, 1803, 1841, 1878, 1916, 1954, 1991, 2029, 2066,
+    2104, 2141, 2179, 2217, 2254, 2292, 2329, 2367, 2404, 2442, 2479, 2517, 2555, 2592,
+    2630, 2667, 2705, 2742, 2780, 2818, 2855, 2893, 2930, 2968, 3005, 3043, 3081, 3118,
+    3156, 3193, 3231, 3268, 3306, 3344, 3381, 3419, 3456, 3494, 3531, 3569, 3607, 3644,
+    3682, 3719, 3757, 3794, 3832, 3870, 3907, 3945, 3982, 4020, 4057, 4095, 4132, 4170,
+    4208, 4245, 4283, 4320, 4358, 4395, 4433, 4471, 4508, 4546, 4583, 4621, 4658, 4696,
+    4734, 4771, 4809, 4846, 4884, 4921, 4959, 4997, 5034, 5072, 5109, 5147, 5184, 5222,
+    5260, 5297, 5335, 5372, 5410, 5447, 5485, 5522, 5560, 5598, 5635, 5673, 5710, 5748,
+    5785, 5823, 5861, 5898, 5936, 5973, 6011, 6048, 6086, 6124, 6161, 6199, 6236, 6274,
+    6311, 6349, 6387, 6424, 6462, 6499, 6537, 6574, 6612, 6650, 6687, 6725, 6762, 6800,
+    6837, 6875, 6913, 6950, 6988, 7025, 7063, 7100, 7138, 7175, 7213, 7251, 7288, 7326,
+    7363, 7401, 7438, 7476, 7514, 7551, 7589, 7626, 7664, 7701, 7739, 7777, 7814, 7852,
+    7889, 7927, 7964, 8002, 8040, 8077, 8115, 8152, 8190, 8227, 8265, 8303, 8340, 8378,
+    8415, 8453, 8490, 8528, 8566, 8603, 8641, 8678, 8716, 8753, 8791, 8828, 8866, 8904,
+    8941, 8979, 9016, 9054, 9091, 9129, 9167, 9204, 9242, 9279, 9317, 9354, 9392, 9430,
+    9467, 9505, 9542, 9580};
+
+static INT16 Y_B[] = {
+    0,    7,    15,   22,   29,   36,   44,   51,   58,   66,   73,   80,   88,   95,
+    102,  109,  117,  124,  131,  139,  146,  153,  161,  168,  175,  182,  190,  197,
+    204,  212,  219,  226,  233,  241,  248,  255,  263,  270,  277,  285,  292,  299,
+    306,  314,  321,  328,  336,  343,  350,  358,  365,  372,  379,  387,  394,  401,
+    409,  416,  423,  430,  438,  445,  452,  460,  467,  474,  482,  489,  496,  503,
+    511,  518,  525,  533,  540,  547,  554,  562,  569,  576,  584,  591,  598,  606,
+    613,  620,  627,  635,  642,  649,  657,  664,  671,  679,  686,  693,  700,  708,
+    715,  722,  730,  737,  744,  751,  759,  766,  773,  781,  788,  795,  803,  810,
+    817,  824,  832,  839,  846,  854,  861,  868,  876,  883,  890,  897,  905,  912,
+    919,  927,  934,  941,  948,  956,  963,  970,  978,  985,  992,  1000, 1007, 1014,
+    1021, 1029, 1036, 1043, 1051, 1058, 1065, 1073, 1080, 1087, 1094, 1102, 1109, 1116,
+    1124, 1131, 1138, 1145, 1153, 1160, 1167, 1175, 1182, 1189, 1197, 1204, 1211, 1218,
+    1226, 1233, 1240, 1248, 1255, 1262, 1270, 1277, 1284, 1291, 1299, 1306, 1313, 1321,
+    1328, 1335, 1342, 1350, 1357, 1364, 1372, 1379, 1386, 1394, 1401, 1408, 1415, 1423,
+    1430, 1437, 1445, 1452, 1459, 1466, 1474, 1481, 1488, 1496, 1503, 1510, 1518, 1525,
+    1532, 1539, 1547, 1554, 1561, 1569, 1576, 1583, 1591, 1598, 1605, 1612, 1620, 1627,
+    1634, 1642, 1649, 1656, 1663, 1671, 1678, 1685, 1693, 1700, 1707, 1715, 1722, 1729,
+    1736, 1744, 1751, 1758, 1766, 1773, 1780, 1788, 1795, 1802, 1809, 1817, 1824, 1831,
+    1839, 1846, 1853, 1860};
+
+static INT16 Cb_R[] = {
+    0,     -10,   -21,   -31,   -42,   -53,   -64,   -75,   -85,   -96,   -107,  -118,
+    -129,  -139,  -150,  -161,  -172,  -183,  -193,  -204,  -215,  -226,  -237,  -247,
+    -258,  -269,  -280,  -291,  -301,  -312,  -323,  -334,  -345,  -355,  -366,  -377,
+    -388,  -399,  -409,  -420,  -431,  -442,  -453,  -463,  -474,  -485,  -496,  -507,
+    -517,  -528,  -539,  -550,  -561,  -571,  -582,  -593,  -604,  -615,  -625,  -636,
+    -647,  -658,  -669,  -679,  -690,  -701,  -712,  -723,  -733,  -744,  -755,  -766,
+    -777,  -787,  -798,  -809,  -820,  -831,  -841,  -852,  -863,  -874,  -885,  -895,
+    -906,  -917,  -928,  -939,  -949,  -960,  -971,  -982,  -993,  -1003, -1014, -1025,
+    -1036, -1047, -1057, -1068, -1079, -1090, -1101, -1111, -1122, -1133, -1144, -1155,
+    -1165, -1176, -1187, -1198, -1209, -1219, -1230, -1241, -1252, -1263, -1273, -1284,
+    -1295, -1306, -1317, -1327, -1338, -1349, -1360, -1371, -1381, -1392, -1403, -1414,
+    -1425, -1435, -1446, -1457, -1468, -1479, -1489, -1500, -1511, -1522, -1533, -1543,
+    -1554, -1565, -1576, -1587, -1597, -1608, -1619, -1630, -1641, -1651, -1662, -1673,
+    -1684, -1694, -1705, -1716, -1727, -1738, -1748, -1759, -1770, -1781, -1792, -1802,
+    -1813, -1824, -1835, -1846, -1856, -1867, -1878, -1889, -1900, -1910, -1921, -1932,
+    -1943, -1954, -1964, -1975, -1986, -1997, -2008, -2018, -2029, -2040, -2051, -2062,
+    -2072, -2083, -2094, -2105, -2116, -2126, -2137, -2148, -2159, -2170, -2180, -2191,
+    -2202, -2213, -2224, -2234, -2245, -2256, -2267, -2278, -2288, -2299, -2310, -2321,
+    -2332, -2342, -2353, -2364, -2375, -2386, -2396, -2407, -2418, -2429, -2440, -2450,
+    -2461, -2472, -2483, -2494, -2504, -2515, -2526, -2537, -2548, -2558, -2569, -2580,
+    -2591, -2602, -2612, -2623, -2634, -2645, -2656, -2666, -2677, -2688, -2699, -2710,
+    -2720, -2731, -2742, -2753};
+
+static INT16 Cb_G[] = {
+    0,     -20,   -41,   -63,   -84,   -105,  -126,  -147,  -169,  -190,  -211,  -232,
+    -253,  -275,  -296,  -317,  -338,  -359,  -381,  -402,  -423,  -444,  -465,  -487,
+    -508,  -529,  -550,  -571,  -593,  -614,  -635,  -656,  -677,  -699,  -720,  -741,
+    -762,  -783,  -805,  -826,  -847,  -868,  -889,  -911,  -932,  -953,  -974,  -995,
+    -1017, -1038, -1059, -1080, -1101, -1123, -1144, -1165, -1186, -1207, -1229, -1250,
+    -1271, -1292, -1313, -1335, -1356, -1377, -1398, -1419, -1441, -1462, -1483, -1504,
+    -1525, -1547, -1568, -1589, -1610, -1631, -1653, -1674, -1695, -1716, -1737, -1759,
+    -1780, -1801, -1822, -1843, -1865, -1886, -1907, -1928, -1949, -1971, -1992, -2013,
+    -2034, -2055, -2077, -2098, -2119, -2140, -2161, -2183, -2204, -2225, -2246, -2267,
+    -2289, -2310, -2331, -2352, -2373, -2395, -2416, -2437, -2458, -2479, -2501, -2522,
+    -2543, -2564, -2585, -2607, -2628, -2649, -2670, -2691, -2713, -2734, -2755, -2776,
+    -2797, -2819, -2840, -2861, -2882, -2903, -2925, -2946, -2967, -2988, -3009, -3031,
+    -3052, -3073, -3094, -3115, -3137, -3158, -3179, -3200, -3221, -3243, -3264, -3285,
+    -3306, -3328, -3349, -3370, -3391, -3412, -3434, -3455, -3476, -3497, -3518, -3540,
+    -3561, -3582, -3603, -3624, -3646, -3667, -3688, -3709, -3730, -3752, -3773, -3794,
+    -3815, -3836, -3858, -3879, -3900, -3921, -3942, -3964, -3985, -4006, -4027, -4048,
+    -4070, -4091, -4112, -4133, -4154, -4176, -4197, -4218, -4239, -4260, -4282, -4303,
+    -4324, -4345, -4366, -4388, -4409, -4430, -4451, -4472, -4494, -4515, -4536, -4557,
+    -4578, -4600, -4621, -4642, -4663, -4684, -4706, -4727, -4748, -4769, -4790, -4812,
+    -4833, -4854, -4875, -4896, -4918, -4939, -4960, -4981, -5002, -5024, -5045, -5066,
+    -5087, -5108, -5130, -5151, -5172, -5193, -5214, -5236, -5257, -5278, -5299, -5320,
+    -5342, -5363, -5384, -5405};
+
+static INT16 Cb_B[] = {
+    0,    32,   64,   96,   128,  160,  192,  224,  256,  288,  320,  352,  384,  416,
+    448,  480,  512,  544,  576,  608,  640,  672,  704,  736,  768,  800,  832,  864,
+    896,  928,  960,  992,  1024, 1056, 1088, 1120, 1152, 1184, 1216, 1248, 1280, 1312,
+    1344, 1376, 1408, 1440, 1472, 1504, 1536, 1568, 1600, 1632, 1664, 1696, 1728, 1760,
+    1792, 1824, 1856, 1888, 1920, 1952, 1984, 2016, 2048, 2080, 2112, 2144, 2176, 2208,
+    2240, 2272, 2304, 2336, 2368, 2400, 2432, 2464, 2496, 2528, 2560, 2592, 2624, 2656,
+    2688, 2720, 2752, 2784, 2816, 2848, 2880, 2912, 2944, 2976, 3008, 3040, 3072, 3104,
+    3136, 3168, 3200, 3232, 3264, 3296, 3328, 3360, 3392, 3424, 3456, 3488, 3520, 3552,
+    3584, 3616, 3648, 3680, 3712, 3744, 3776, 3808, 3840, 3872, 3904, 3936, 3968, 4000,
+    4032, 4064, 4096, 4128, 4160, 4192, 4224, 4256, 4288, 4320, 4352, 4384, 4416, 4448,
+    4480, 4512, 4544, 4576, 4608, 4640, 4672, 4704, 4736, 4768, 4800, 4832, 4864, 4896,
+    4928, 4960, 4992, 5024, 5056, 5088, 5120, 5152, 5184, 5216, 5248, 5280, 5312, 5344,
+    5376, 5408, 5440, 5472, 5504, 5536, 5568, 5600, 5632, 5664, 5696, 5728, 5760, 5792,
+    5824, 5856, 5888, 5920, 5952, 5984, 6016, 6048, 6080, 6112, 6144, 6176, 6208, 6240,
+    6272, 6304, 6336, 6368, 6400, 6432, 6464, 6496, 6528, 6560, 6592, 6624, 6656, 6688,
+    6720, 6752, 6784, 6816, 6848, 6880, 6912, 6944, 6976, 7008, 7040, 7072, 7104, 7136,
+    7168, 7200, 7232, 7264, 7296, 7328, 7360, 7392, 7424, 7456, 7488, 7520, 7552, 7584,
+    7616, 7648, 7680, 7712, 7744, 7776, 7808, 7840, 7872, 7904, 7936, 7968, 8000, 8032,
+    8064, 8096, 8128, 8160};

 #define Cr_R Cb_B

-static INT16 Cr_G[] = { 0, -26, -53, -79, -106, -133, -160, -187,
--213, -240, -267, -294, -321, -347, -374, -401, -428, -455, -481,
--508, -535, -562, -589, -615, -642, -669, -696, -722, -749, -776,
--803, -830, -856, -883, -910, -937, -964, -990, -1017, -1044, -1071,
--1098, -1124, -1151, -1178, -1205, -1232, -1258, -1285, -1312, -1339,
--1366, -1392, -1419, -1446, -1473, -1500, -1526, -1553, -1580, -1607,
--1634, -1660, -1687, -1714, -1741, -1768, -1794, -1821, -1848, -1875,
--1902, -1928, -1955, -1982, -2009, -2036, -2062, -2089, -2116, -2143,
--2169, -2196, -2223, -2250, -2277, -2303, -2330, -2357, -2384, -2411,
--2437, -2464, -2491, -2518, -2545, -2571, -2598, -2625, -2652, -2679,
--2705, -2732, -2759, -2786, -2813, -2839, -2866, -2893, -2920, -2947,
--2973, -3000, -3027, -3054, -3081, -3107, -3134, -3161, -3188, -3215,
--3241, -3268, -3295, -3322, -3349, -3375, -3402, -3429, -3456, -3483,
--3509, -3536, -3563, -3590, -3616, -3643, -3670, -3697, -3724, -3750,
--3777, -3804, -3831, -3858, -3884, -3911, -3938, -3965, -3992, -4018,
--4045, -4072, -4099, -4126, -4152, -4179, -4206, -4233, -4260, -4286,
--4313, -4340, -4367, -4394, -4420, -4447, -4474, -4501, -4528, -4554,
--4581, -4608, -4635, -4662, -4688, -4715, -4742, -4769, -4796, -4822,
--4849, -4876, -4903, -4929, -4956, -4983, -5010, -5037, -5063, -5090,
--5117, -5144, -5171, -5197, -5224, -5251, -5278, -5305, -5331, -5358,
--5385, -5412, -5439, -5465, -5492, -5519, -5546, -5573, -5599, -5626,
--5653, -5680, -5707, -5733, -5760, -5787, -5814, -5841, -5867, -5894,
--5921, -5948, -5975, -6001, -6028, -6055, -6082, -6109, -6135, -6162,
--6189, -6216, -6243, -6269, -6296, -6323, -6350, -6376, -6403, -6430,
--6457, -6484, -6510, -6537, -6564, -6591, -6618, -6644, -6671, -6698,
--6725, -6752, -6778, -6805, -6832 };
-
-static INT16 Cr_B[] = { 0, -4, -9, -15, -20, -25, -30, -35, -41, -46,
--51, -56, -61, -67, -72, -77, -82, -87, -93, -98, -103, -108, -113,
--119, -124, -129, -134, -140, -145, -150, -155, -160, -166, -171,
--176, -181, -186, -192, -197, -202, -207, -212, -218, -223, -228,
--233, -238, -244, -249, -254, -259, -264, -270, -275, -280, -285,
--290, -296, -301, -306, -311, -316, -322, -327, -332, -337, -342,
--348, -353, -358, -363, -368, -374, -379, -384, -389, -394, -400,
--405, -410, -415, -421, -426, -431, -436, -441, -447, -452, -457,
--462, -467, -473, -478, -483, -488, -493, -499, -504, -509, -514,
--519, -525, -530, -535, -540, -545, -551, -556, -561, -566, -571,
--577, -582, -587, -592, -597, -603, -608, -613, -618, -623, -629,
--634, -639, -644, -649, -655, -660, -665, -670, -675, -681, -686,
--691, -696, -702, -707, -712, -717, -722, -728, -733, -738, -743,
--748, -754, -759, -764, -769, -774, -780, -785, -790, -795, -800,
--806, -811, -816, -821, -826, -832, -837, -842, -847, -852, -858,
--863, -868, -873, -878, -884, -889, -894, -899, -904, -910, -915,
--920, -925, -930, -936, -941, -946, -951, -957, -962, -967, -972,
--977, -983, -988, -993, -998, -1003, -1009, -1014, -1019, -1024,
--1029, -1035, -1040, -1045, -1050, -1055, -1061, -1066, -1071, -1076,
--1081, -1087, -1092, -1097, -1102, -1107, -1113, -1118, -1123, -1128,
--1133, -1139, -1144, -1149, -1154, -1159, -1165, -1170, -1175, -1180,
--1185, -1191, -1196, -1201, -1206, -1211, -1217, -1222, -1227, -1232,
--1238, -1243, -1248, -1253, -1258, -1264, -1269, -1274, -1279, -1284,
--1290, -1295, -1300, -1305, -1310, -1316, -1321, -1326 };
-
-static INT16 R_Cr[] = { -11484, -11394, -11305, -11215, -11125,
--11036, -10946, -10856, -10766, -10677, -10587, -10497, -10407,
--10318, -10228, -10138, -10049, -9959, -9869, -9779, -9690, -9600,
--9510, -9420, -9331, -9241, -9151, -9062, -8972, -8882, -8792, -8703,
--8613, -8523, -8433, -8344, -8254, -8164, -8075, -7985, -7895, -7805,
--7716, -7626, -7536, -7446, -7357, -7267, -7177, -7088, -6998, -6908,
--6818, -6729, -6639, -6549, -6459, -6370, -6280, -6190, -6101, -6011,
--5921, -5831, -5742, -5652, -5562, -5472, -5383, -5293, -5203, -5113,
--5024, -4934, -4844, -4755, -4665, -4575, -4485, -4396, -4306, -4216,
--4126, -4037, -3947, -3857, -3768, -3678, -3588, -3498, -3409, -3319,
--3229, -3139, -3050, -2960, -2870, -2781, -2691, -2601, -2511, -2422,
--2332, -2242, -2152, -2063, -1973, -1883, -1794, -1704, -1614, -1524,
--1435, -1345, -1255, -1165, -1076, -986, -896, -807, -717, -627, -537,
--448, -358, -268, -178, -89, 0, 90, 179, 269, 359, 449, 538, 628, 718,
-808, 897, 987, 1077, 1166, 1256, 1346, 1436, 1525, 1615, 1705, 1795,
-1884, 1974, 2064, 2153, 2243, 2333, 2423, 2512, 2602, 2692, 2782,
-2871, 2961, 3051, 3140, 3230, 3320, 3410, 3499, 3589, 3679, 3769,
-3858, 3948, 4038, 4127, 4217, 4307, 4397, 4486, 4576, 4666, 4756,
-4845, 4935, 5025, 5114, 5204, 5294, 5384, 5473, 5563, 5653, 5743,
-5832, 5922, 6012, 6102, 6191, 6281, 6371, 6460, 6550, 6640, 6730,
-6819, 6909, 6999, 7089, 7178, 7268, 7358, 7447, 7537, 7627, 7717,
-7806, 7896, 7986, 8076, 8165, 8255, 8345, 8434, 8524, 8614, 8704,
-8793, 8883, 8973, 9063, 9152, 9242, 9332, 9421, 9511, 9601, 9691,
-9780, 9870, 9960, 10050, 10139, 10229, 10319, 10408, 10498, 10588,
-10678, 10767, 10857, 10947, 11037, 11126, 11216, 11306, 11395 };
-
-static INT16 G_Cb[] = { 2819, 2797, 2775, 2753, 2731, 2709, 2687,
-2665, 2643, 2621, 2599, 2577, 2555, 2533, 2511, 2489, 2467, 2445,
-2423, 2401, 2379, 2357, 2335, 2313, 2291, 2269, 2247, 2225, 2202,
-2180, 2158, 2136, 2114, 2092, 2070, 2048, 2026, 2004, 1982, 1960,
-1938, 1916, 1894, 1872, 1850, 1828, 1806, 1784, 1762, 1740, 1718,
-1696, 1674, 1652, 1630, 1608, 1586, 1564, 1542, 1520, 1498, 1476,
-1454, 1432, 1410, 1388, 1366, 1344, 1321, 1299, 1277, 1255, 1233,
-1211, 1189, 1167, 1145, 1123, 1101, 1079, 1057, 1035, 1013, 991, 969,
-947, 925, 903, 881, 859, 837, 815, 793, 771, 749, 727, 705, 683, 661,
-639, 617, 595, 573, 551, 529, 507, 485, 463, 440, 418, 396, 374, 352,
-330, 308, 286, 264, 242, 220, 198, 176, 154, 132, 110, 88, 66, 44, 22,
-0, -21, -43, -65, -87, -109, -131, -153, -175, -197, -219, -241, -263,
--285, -307, -329, -351, -373, -395, -417, -439, -462, -484, -506,
--528, -550, -572, -594, -616, -638, -660, -682, -704, -726, -748,
--770, -792, -814, -836, -858, -880, -902, -924, -946, -968, -990,
--1012, -1034, -1056, -1078, -1100, -1122, -1144, -1166, -1188, -1210,
--1232, -1254, -1276, -1298, -1320, -1343, -1365, -1387, -1409, -1431,
--1453, -1475, -1497, -1519, -1541, -1563, -1585, -1607, -1629, -1651,
--1673, -1695, -1717, -1739, -1761, -1783, -1805, -1827, -1849, -1871,
--1893, -1915, -1937, -1959, -1981, -2003, -2025, -2047, -2069, -2091,
--2113, -2135, -2157, -2179, -2201, -2224, -2246, -2268, -2290, -2312,
--2334, -2356, -2378, -2400, -2422, -2444, -2466, -2488, -2510, -2532,
--2554, -2576, -2598, -2620, -2642, -2664, -2686, -2708, -2730, -2752,
--2774, -2796 };
-
-static INT16 G_Cr[] = { 5850, 5805, 5759, 5713, 5667, 5622, 5576,
-5530, 5485, 5439, 5393, 5347, 5302, 5256, 5210, 5165, 5119, 5073,
-5028, 4982, 4936, 4890, 4845, 4799, 4753, 4708, 4662, 4616, 4570,
-4525, 4479, 4433, 4388, 4342, 4296, 4251, 4205, 4159, 4113, 4068,
-4022, 3976, 3931, 3885, 3839, 3794, 3748, 3702, 3656, 3611, 3565,
-3519, 3474, 3428, 3382, 3336, 3291, 3245, 3199, 3154, 3108, 3062,
-3017, 2971, 2925, 2879, 2834, 2788, 2742, 2697, 2651, 2605, 2559,
-2514, 2468, 2422, 2377, 2331, 2285, 2240, 2194, 2148, 2102, 2057,
-2011, 1965, 1920, 1874, 1828, 1782, 1737, 1691, 1645, 1600, 1554,
-1508, 1463, 1417, 1371, 1325, 1280, 1234, 1188, 1143, 1097, 1051,
-1006, 960, 914, 868, 823, 777, 731, 686, 640, 594, 548, 503, 457, 411,
-366, 320, 274, 229, 183, 137, 91, 46, 0, -45, -90, -136, -182, -228,
--273, -319, -365, -410, -456, -502, -547, -593, -639, -685, -730,
--776, -822, -867, -913, -959, -1005, -1050, -1096, -1142, -1187,
--1233, -1279, -1324, -1370, -1416, -1462, -1507, -1553, -1599, -1644,
--1690, -1736, -1781, -1827, -1873, -1919, -1964, -2010, -2056, -2101,
--2147, -2193, -2239, -2284, -2330, -2376, -2421, -2467, -2513, -2558,
--2604, -2650, -2696, -2741, -2787, -2833, -2878, -2924, -2970, -3016,
--3061, -3107, -3153, -3198, -3244, -3290, -3335, -3381, -3427, -3473,
--3518, -3564, -3610, -3655, -3701, -3747, -3793, -3838, -3884, -3930,
--3975, -4021, -4067, -4112, -4158, -4204, -4250, -4295, -4341, -4387,
--4432, -4478, -4524, -4569, -4615, -4661, -4707, -4752, -4798, -4844,
--4889, -4935, -4981, -5027, -5072, -5118, -5164, -5209, -5255, -5301,
--5346, -5392, -5438, -5484, -5529, -5575, -5621, -5666, -5712, -5758,
--5804 };
-
-static INT16 B_Cb[] = { -14515, -14402, -14288, -14175, -14062,
--13948, -13835, -13721, -13608, -13495, -13381, -13268, -13154,
--13041, -12928, -12814, -12701, -12587, -12474, -12360, -12247,
--12134, -12020, -11907, -11793, -11680, -11567, -11453, -11340,
--11226, -11113, -11000, -10886, -10773, -10659, -10546, -10433,
--10319, -10206, -10092, -9979, -9865, -9752, -9639, -9525, -9412,
--9298, -9185, -9072, -8958, -8845, -8731, -8618, -8505, -8391, -8278,
--8164, -8051, -7938, -7824, -7711, -7597, -7484, -7371, -7257, -7144,
--7030, -6917, -6803, -6690, -6577, -6463, -6350, -6236, -6123, -6010,
--5896, -5783, -5669, -5556, -5443, -5329, -5216, -5102, -4989, -4876,
--4762, -4649, -4535, -4422, -4309, -4195, -4082, -3968, -3855, -3741,
--3628, -3515, -3401, -3288, -3174, -3061, -2948, -2834, -2721, -2607,
--2494, -2381, -2267, -2154, -2040, -1927, -1814, -1700, -1587, -1473,
--1360, -1246, -1133, -1020, -906, -793, -679, -566, -453, -339, -226,
--112, 0, 113, 227, 340, 454, 567, 680, 794, 907, 1021, 1134, 1247,
-1361, 1474, 1588, 1701, 1815, 1928, 2041, 2155, 2268, 2382, 2495,
-2608, 2722, 2835, 2949, 3062, 3175, 3289, 3402, 3516, 3629, 3742,
-3856, 3969, 4083, 4196, 4310, 4423, 4536, 4650, 4763, 4877, 4990,
-5103, 5217, 5330, 5444, 5557, 5670, 5784, 5897, 6011, 6124, 6237,
-6351, 6464, 6578, 6691, 6804, 6918, 7031, 7145, 7258, 7372, 7485,
-7598, 7712, 7825, 7939, 8052, 8165, 8279, 8392, 8506, 8619, 8732,
-8846, 8959, 9073, 9186, 9299, 9413, 9526, 9640, 9753, 9866, 9980,
-10093, 10207, 10320, 10434, 10547, 10660, 10774, 10887, 11001, 11114,
-11227, 11341, 11454, 11568, 11681, 11794, 11908, 12021, 12135, 12248,
-12361, 12475, 12588, 12702, 12815, 12929, 13042, 13155, 13269, 13382,
-13496, 13609, 13722, 13836, 13949, 14063, 14176, 14289, 14403 };
-
+static INT16 Cr_G[] = {
+    0,     -26,   -53,   -79,   -106,  -133,  -160,  -187,  -213,  -240,  -267,  -294,
+    -321,  -347,  -374,  -401,  -428,  -455,  -481,  -508,  -535,  -562,  -589,  -615,
+    -642,  -669,  -696,  -722,  -749,  -776,  -803,  -830,  -856,  -883,  -910,  -937,
+    -964,  -990,  -1017, -1044, -1071, -1098, -1124, -1151, -1178, -1205, -1232, -1258,
+    -1285, -1312, -1339, -1366, -1392, -1419, -1446, -1473, -1500, -1526, -1553, -1580,
+    -1607, -1634, -1660, -1687, -1714, -1741, -1768, -1794, -1821, -1848, -1875, -1902,
+    -1928, -1955, -1982, -2009, -2036, -2062, -2089, -2116, -2143, -2169, -2196, -2223,
+    -2250, -2277, -2303, -2330, -2357, -2384, -2411, -2437, -2464, -2491, -2518, -2545,
+    -2571, -2598, -2625, -2652, -2679, -2705, -2732, -2759, -2786, -2813, -2839, -2866,
+    -2893, -2920, -2947, -2973, -3000, -3027, -3054, -3081, -3107, -3134, -3161, -3188,
+    -3215, -3241, -3268, -3295, -3322, -3349, -3375, -3402, -3429, -3456, -3483, -3509,
+    -3536, -3563, -3590, -3616, -3643, -3670, -3697, -3724, -3750, -3777, -3804, -3831,
+    -3858, -3884, -3911, -3938, -3965, -3992, -4018, -4045, -4072, -4099, -4126, -4152,
+    -4179, -4206, -4233, -4260, -4286, -4313, -4340, -4367, -4394, -4420, -4447, -4474,
+    -4501, -4528, -4554, -4581, -4608, -4635, -4662, -4688, -4715, -4742, -4769, -4796,
+    -4822, -4849, -4876, -4903, -4929, -4956, -4983, -5010, -5037, -5063, -5090, -5117,
+    -5144, -5171, -5197, -5224, -5251, -5278, -5305, -5331, -5358, -5385, -5412, -5439,
+    -5465, -5492, -5519, -5546, -5573, -5599, -5626, -5653, -5680, -5707, -5733, -5760,
+    -5787, -5814, -5841, -5867, -5894, -5921, -5948, -5975, -6001, -6028, -6055, -6082,
+    -6109, -6135, -6162, -6189, -6216, -6243, -6269, -6296, -6323, -6350, -6376, -6403,
+    -6430, -6457, -6484, -6510, -6537, -6564, -6591, -6618, -6644, -6671, -6698, -6725,
+    -6752, -6778, -6805, -6832};
+
+static INT16 Cr_B[] = {
+    0,     -4,    -9,    -15,   -20,   -25,   -30,   -35,   -41,   -46,   -51,   -56,
+    -61,   -67,   -72,   -77,   -82,   -87,   -93,   -98,   -103,  -108,  -113,  -119,
+    -124,  -129,  -134,  -140,  -145,  -150,  -155,  -160,  -166,  -171,  -176,  -181,
+    -186,  -192,  -197,  -202,  -207,  -212,  -218,  -223,  -228,  -233,  -238,  -244,
+    -249,  -254,  -259,  -264,  -270,  -275,  -280,  -285,  -290,  -296,  -301,  -306,
+    -311,  -316,  -322,  -327,  -332,  -337,  -342,  -348,  -353,  -358,  -363,  -368,
+    -374,  -379,  -384,  -389,  -394,  -400,  -405,  -410,  -415,  -421,  -426,  -431,
+    -436,  -441,  -447,  -452,  -457,  -462,  -467,  -473,  -478,  -483,  -488,  -493,
+    -499,  -504,  -509,  -514,  -519,  -525,  -530,  -535,  -540,  -545,  -551,  -556,
+    -561,  -566,  -571,  -577,  -582,  -587,  -592,  -597,  -603,  -608,  -613,  -618,
+    -623,  -629,  -634,  -639,  -644,  -649,  -655,  -660,  -665,  -670,  -675,  -681,
+    -686,  -691,  -696,  -702,  -707,  -712,  -717,  -722,  -728,  -733,  -738,  -743,
+    -748,  -754,  -759,  -764,  -769,  -774,  -780,  -785,  -790,  -795,  -800,  -806,
+    -811,  -816,  -821,  -826,  -832,  -837,  -842,  -847,  -852,  -858,  -863,  -868,
+    -873,  -878,  -884,  -889,  -894,  -899,  -904,  -910,  -915,  -920,  -925,  -930,
+    -936,  -941,  -946,  -951,  -957,  -962,  -967,  -972,  -977,  -983,  -988,  -993,
+    -998,  -1003, -1009, -1014, -1019, -1024, -1029, -1035, -1040, -1045, -1050, -1055,
+    -1061, -1066, -1071, -1076, -1081, -1087, -1092, -1097, -1102, -1107, -1113, -1118,
+    -1123, -1128, -1133, -1139, -1144, -1149, -1154, -1159, -1165, -1170, -1175, -1180,
+    -1185, -1191, -1196, -1201, -1206, -1211, -1217, -1222, -1227, -1232, -1238, -1243,
+    -1248, -1253, -1258, -1264, -1269, -1274, -1279, -1284, -1290, -1295, -1300, -1305,
+    -1310, -1316, -1321, -1326};
+
+static INT16 R_Cr[] = {
+    -11484, -11394, -11305, -11215, -11125, -11036, -10946, -10856, -10766, -10677,
+    -10587, -10497, -10407, -10318, -10228, -10138, -10049, -9959,  -9869,  -9779,
+    -9690,  -9600,  -9510,  -9420,  -9331,  -9241,  -9151,  -9062,  -8972,  -8882,
+    -8792,  -8703,  -8613,  -8523,  -8433,  -8344,  -8254,  -8164,  -8075,  -7985,
+    -7895,  -7805,  -7716,  -7626,  -7536,  -7446,  -7357,  -7267,  -7177,  -7088,
+    -6998,  -6908,  -6818,  -6729,  -6639,  -6549,  -6459,  -6370,  -6280,  -6190,
+    -6101,  -6011,  -5921,  -5831,  -5742,  -5652,  -5562,  -5472,  -5383,  -5293,
+    -5203,  -5113,  -5024,  -4934,  -4844,  -4755,  -4665,  -4575,  -4485,  -4396,
+    -4306,  -4216,  -4126,  -4037,  -3947,  -3857,  -3768,  -3678,  -3588,  -3498,
+    -3409,  -3319,  -3229,  -3139,  -3050,  -2960,  -2870,  -2781,  -2691,  -2601,
+    -2511,  -2422,  -2332,  -2242,  -2152,  -2063,  -1973,  -1883,  -1794,  -1704,
+    -1614,  -1524,  -1435,  -1345,  -1255,  -1165,  -1076,  -986,   -896,   -807,
+    -717,   -627,   -537,   -448,   -358,   -268,   -178,   -89,    0,      90,
+    179,    269,    359,    449,    538,    628,    718,    808,    897,    987,
+    1077,   1166,   1256,   1346,   1436,   1525,   1615,   1705,   1795,   1884,
+    1974,   2064,   2153,   2243,   2333,   2423,   2512,   2602,   2692,   2782,
+    2871,   2961,   3051,   3140,   3230,   3320,   3410,   3499,   3589,   3679,
+    3769,   3858,   3948,   4038,   4127,   4217,   4307,   4397,   4486,   4576,
+    4666,   4756,   4845,   4935,   5025,   5114,   5204,   5294,   5384,   5473,
+    5563,   5653,   5743,   5832,   5922,   6012,   6102,   6191,   6281,   6371,
+    6460,   6550,   6640,   6730,   6819,   6909,   6999,   7089,   7178,   7268,
+    7358,   7447,   7537,   7627,   7717,   7806,   7896,   7986,   8076,   8165,
+    8255,   8345,   8434,   8524,   8614,   8704,   8793,   8883,   8973,   9063,
+    9152,   9242,   9332,   9421,   9511,   9601,   9691,   9780,   9870,   9960,
+    10050,  10139,  10229,  10319,  10408,  10498,  10588,  10678,  10767,  10857,
+    10947,  11037,  11126,  11216,  11306,  11395};
+
+static INT16 G_Cb[] = {
+    2819,  2797,  2775,  2753,  2731,  2709,  2687,  2665,  2643,  2621,  2599,  2577,
+    2555,  2533,  2511,  2489,  2467,  2445,  2423,  2401,  2379,  2357,  2335,  2313,
+    2291,  2269,  2247,  2225,  2202,  2180,  2158,  2136,  2114,  2092,  2070,  2048,
+    2026,  2004,  1982,  1960,  1938,  1916,  1894,  1872,  1850,  1828,  1806,  1784,
+    1762,  1740,  1718,  1696,  1674,  1652,  1630,  1608,  1586,  1564,  1542,  1520,
+    1498,  1476,  1454,  1432,  1410,  1388,  1366,  1344,  1321,  1299,  1277,  1255,
+    1233,  1211,  1189,  1167,  1145,  1123,  1101,  1079,  1057,  1035,  1013,  991,
+    969,   947,   925,   903,   881,   859,   837,   815,   793,   771,   749,   727,
+    705,   683,   661,   639,   617,   595,   573,   551,   529,   507,   485,   463,
+    440,   418,   396,   374,   352,   330,   308,   286,   264,   242,   220,   198,
+    176,   154,   132,   110,   88,    66,    44,    22,    0,     -21,   -43,   -65,
+    -87,   -109,  -131,  -153,  -175,  -197,  -219,  -241,  -263,  -285,  -307,  -329,
+    -351,  -373,  -395,  -417,  -439,  -462,  -484,  -506,  -528,  -550,  -572,  -594,
+    -616,  -638,  -660,  -682,  -704,  -726,  -748,  -770,  -792,  -814,  -836,  -858,
+    -880,  -902,  -924,  -946,  -968,  -990,  -1012, -1034, -1056, -1078, -1100, -1122,
+    -1144, -1166, -1188, -1210, -1232, -1254, -1276, -1298, -1320, -1343, -1365, -1387,
+    -1409, -1431, -1453, -1475, -1497, -1519, -1541, -1563, -1585, -1607, -1629, -1651,
+    -1673, -1695, -1717, -1739, -1761, -1783, -1805, -1827, -1849, -1871, -1893, -1915,
+    -1937, -1959, -1981, -2003, -2025, -2047, -2069, -2091, -2113, -2135, -2157, -2179,
+    -2201, -2224, -2246, -2268, -2290, -2312, -2334, -2356, -2378, -2400, -2422, -2444,
+    -2466, -2488, -2510, -2532, -2554, -2576, -2598, -2620, -2642, -2664, -2686, -2708,
+    -2730, -2752, -2774, -2796};
+
+static INT16 G_Cr[] = {
+    5850,  5805,  5759,  5713,  5667,  5622,  5576,  5530,  5485,  5439,  5393,  5347,
+    5302,  5256,  5210,  5165,  5119,  5073,  5028,  4982,  4936,  4890,  4845,  4799,
+    4753,  4708,  4662,  4616,  4570,  4525,  4479,  4433,  4388,  4342,  4296,  4251,
+    4205,  4159,  4113,  4068,  4022,  3976,  3931,  3885,  3839,  3794,  3748,  3702,
+    3656,  3611,  3565,  3519,  3474,  3428,  3382,  3336,  3291,  3245,  3199,  3154,
+    3108,  3062,  3017,  2971,  2925,  2879,  2834,  2788,  2742,  2697,  2651,  2605,
+    2559,  2514,  2468,  2422,  2377,  2331,  2285,  2240,  2194,  2148,  2102,  2057,
+    2011,  1965,  1920,  1874,  1828,  1782,  1737,  1691,  1645,  1600,  1554,  1508,
+    1463,  1417,  1371,  1325,  1280,  1234,  1188,  1143,  1097,  1051,  1006,  960,
+    914,   868,   823,   777,   731,   686,   640,   594,   548,   503,   457,   411,
+    366,   320,   274,   229,   183,   137,   91,    46,    0,     -45,   -90,   -136,
+    -182,  -228,  -273,  -319,  -365,  -410,  -456,  -502,  -547,  -593,  -639,  -685,
+    -730,  -776,  -822,  -867,  -913,  -959,  -1005, -1050, -1096, -1142, -1187, -1233,
+    -1279, -1324, -1370, -1416, -1462, -1507, -1553, -1599, -1644, -1690, -1736, -1781,
+    -1827, -1873, -1919, -1964, -2010, -2056, -2101, -2147, -2193, -2239, -2284, -2330,
+    -2376, -2421, -2467, -2513, -2558, -2604, -2650, -2696, -2741, -2787, -2833, -2878,
+    -2924, -2970, -3016, -3061, -3107, -3153, -3198, -3244, -3290, -3335, -3381, -3427,
+    -3473, -3518, -3564, -3610, -3655, -3701, -3747, -3793, -3838, -3884, -3930, -3975,
+    -4021, -4067, -4112, -4158, -4204, -4250, -4295, -4341, -4387, -4432, -4478, -4524,
+    -4569, -4615, -4661, -4707, -4752, -4798, -4844, -4889, -4935, -4981, -5027, -5072,
+    -5118, -5164, -5209, -5255, -5301, -5346, -5392, -5438, -5484, -5529, -5575, -5621,
+    -5666, -5712, -5758, -5804};
+
+static INT16 B_Cb[] = {
+    -14515, -14402, -14288, -14175, -14062, -13948, -13835, -13721, -13608, -13495,
+    -13381, -13268, -13154, -13041, -12928, -12814, -12701, -12587, -12474, -12360,
+    -12247, -12134, -12020, -11907, -11793, -11680, -11567, -11453, -11340, -11226,
+    -11113, -11000, -10886, -10773, -10659, -10546, -10433, -10319, -10206, -10092,
+    -9979,  -9865,  -9752,  -9639,  -9525,  -9412,  -9298,  -9185,  -9072,  -8958,
+    -8845,  -8731,  -8618,  -8505,  -8391,  -8278,  -8164,  -8051,  -7938,  -7824,
+    -7711,  -7597,  -7484,  -7371,  -7257,  -7144,  -7030,  -6917,  -6803,  -6690,
+    -6577,  -6463,  -6350,  -6236,  -6123,  -6010,  -5896,  -5783,  -5669,  -5556,
+    -5443,  -5329,  -5216,  -5102,  -4989,  -4876,  -4762,  -4649,  -4535,  -4422,
+    -4309,  -4195,  -4082,  -3968,  -3855,  -3741,  -3628,  -3515,  -3401,  -3288,
+    -3174,  -3061,  -2948,  -2834,  -2721,  -2607,  -2494,  -2381,  -2267,  -2154,
+    -2040,  -1927,  -1814,  -1700,  -1587,  -1473,  -1360,  -1246,  -1133,  -1020,
+    -906,   -793,   -679,   -566,   -453,   -339,   -226,   -112,   0,      113,
+    227,    340,    454,    567,    680,    794,    907,    1021,   1134,   1247,
+    1361,   1474,   1588,   1701,   1815,   1928,   2041,   2155,   2268,   2382,
+    2495,   2608,   2722,   2835,   2949,   3062,   3175,   3289,   3402,   3516,
+    3629,   3742,   3856,   3969,   4083,   4196,   4310,   4423,   4536,   4650,
+    4763,   4877,   4990,   5103,   5217,   5330,   5444,   5557,   5670,   5784,
+    5897,   6011,   6124,   6237,   6351,   6464,   6578,   6691,   6804,   6918,
+    7031,   7145,   7258,   7372,   7485,   7598,   7712,   7825,   7939,   8052,
+    8165,   8279,   8392,   8506,   8619,   8732,   8846,   8959,   9073,   9186,
+    9299,   9413,   9526,   9640,   9753,   9866,   9980,   10093,  10207,  10320,
+    10434,  10547,  10660,  10774,  10887,  11001,  11114,  11227,  11341,  11454,
+    11568,  11681,  11794,  11908,  12021,  12135,  12248,  12361,  12475,  12588,
+    12702,  12815,  12929,  13042,  13155,  13269,  13382,  13496,  13609,  13722,
+    13836,  13949,  14063,  14176,  14289,  14403};

 void
-ImagingConvertRGB2YCbCr(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingConvertRGB2YCbCr(UINT8 *out, const UINT8 *in, int pixels) {
     int x;
     UINT8 a;
     int r, g, b;
     int y, cr, cb;

-    for (x = 0; x < pixels; x++, in +=4, out += 4) {
-
+    for (x = 0; x < pixels; x++, in += 4, out += 4) {
         r = in[0];
         g = in[1];
         b = in[2];
         a = in[3];

-        y =  (Y_R[r]  +  Y_G[g] +  Y_B[b]) >> SCALE;
+        y = (Y_R[r] + Y_G[g] + Y_B[b]) >> SCALE;
         cb = ((Cb_R[r] + Cb_G[g] + Cb_B[b]) >> SCALE) + 128;
         cr = ((Cr_R[r] + Cr_G[g] + Cr_B[b]) >> SCALE) + 128;

-        out[0] = (UINT8) y;
-        out[1] = (UINT8) cb;
-        out[2] = (UINT8) cr;
+        out[0] = (UINT8)y;
+        out[1] = (UINT8)cb;
+        out[2] = (UINT8)cr;
         out[3] = a;
     }
 }

 void
-ImagingConvertYCbCr2RGB(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingConvertYCbCr2RGB(UINT8 *out, const UINT8 *in, int pixels) {
     int x;
     UINT8 a;
     int r, g, b;
     int y, cr, cb;

     for (x = 0; x < pixels; x++, in += 4, out += 4) {
-
         y = in[0];
         cb = in[1];
         cr = in[2];
         a = in[3];

-        r = y + ((           R_Cr[cr]) >> SCALE);
+        r = y + ((R_Cr[cr]) >> SCALE);
         g = y + ((G_Cb[cb] + G_Cr[cr]) >> SCALE);
-        b = y + ((B_Cb[cb]           ) >> SCALE);
+        b = y + ((B_Cb[cb]) >> SCALE);

         out[0] = (r <= 0) ? 0 : (r >= 255) ? 255 : r;
         out[1] = (g <= 0) ? 0 : (g >= 255) ? 255 : g;
('src/libImaging', 'QuantOctree.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -3,12 +3,7 @@

 #include "QuantTypes.h"

-int quantize_octree(Pixel *,
-          uint32_t,
-          uint32_t,
-          Pixel **,
-          uint32_t *,
-          uint32_t **,
-          int);
+int
+quantize_octree(Pixel *, uint32_t, uint32_t, Pixel **, uint32_t *, uint32_t **, int);

 #endif
('src/libImaging', 'Filter.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -26,59 +26,59 @@

 #include "Imaging.h"

-
-static inline UINT8 clip8(float in)
-{
+static inline UINT8
+clip8(float in) {
     if (in <= 0.0) {
         return 0;
     }
     if (in >= 255.0) {
         return 255;
     }
-    return (UINT8) in;
+    return (UINT8)in;
 }

 Imaging
-ImagingExpand(Imaging imIn, int xmargin, int ymargin, int mode)
-{
+ImagingExpand(Imaging imIn, int xmargin, int ymargin, int mode) {
     Imaging imOut;
     int x, y;
     ImagingSectionCookie cookie;

     if (xmargin < 0 && ymargin < 0) {
-        return (Imaging) ImagingError_ValueError("bad kernel size");
+        return (Imaging)ImagingError_ValueError("bad kernel size");
     }

     imOut = ImagingNewDirty(
-        imIn->mode, imIn->xsize+2*xmargin, imIn->ysize+2*ymargin);
+        imIn->mode, imIn->xsize + 2 * xmargin, imIn->ysize + 2 * ymargin);
     if (!imOut) {
         return NULL;
     }

-#define EXPAND_LINE(type, image, yin, yout) {\
-    for (x = 0; x < xmargin; x++) {\
-        imOut->image[yout][x] = imIn->image[yin][0];\
-    }\
-    for (x = 0; x < imIn->xsize; x++) {\
-        imOut->image[yout][x+xmargin] = imIn->image[yin][x];\
-    }\
-    for (x = 0; x < xmargin; x++) {\
-        imOut->image[yout][xmargin+imIn->xsize+x] =\
-            imIn->image[yin][imIn->xsize-1];\
-    }\
-}
-
-#define EXPAND(type, image) {\
-    for (y = 0; y < ymargin; y++) {\
-        EXPAND_LINE(type, image, 0, y);\
-    }\
-    for (y = 0; y < imIn->ysize; y++) {\
-        EXPAND_LINE(type, image, y, y+ymargin);\
-    }\
-    for (y = 0; y < ymargin; y++) {\
-        EXPAND_LINE(type, image, imIn->ysize-1, ymargin+imIn->ysize+y);\
-    }\
-}
+#define EXPAND_LINE(type, image, yin, yout)                        \
+    {                                                              \
+        for (x = 0; x < xmargin; x++) {                            \
+            imOut->image[yout][x] = imIn->image[yin][0];           \
+        }                                                          \
+        for (x = 0; x < imIn->xsize; x++) {                        \
+            imOut->image[yout][x + xmargin] = imIn->image[yin][x]; \
+        }                                                          \
+        for (x = 0; x < xmargin; x++) {                            \
+            imOut->image[yout][xmargin + imIn->xsize + x] =        \
+                imIn->image[yin][imIn->xsize - 1];                 \
+        }                                                          \
+    }
+
+#define EXPAND(type, image)                                                       \
+    {                                                                             \
+        for (y = 0; y < ymargin; y++) {                                           \
+            EXPAND_LINE(type, image, 0, y);                                       \
+        }                                                                         \
+        for (y = 0; y < imIn->ysize; y++) {                                       \
+            EXPAND_LINE(type, image, y, y + ymargin);                             \
+        }                                                                         \
+        for (y = 0; y < ymargin; y++) {                                           \
+            EXPAND_LINE(type, image, imIn->ysize - 1, ymargin + imIn->ysize + y); \
+        }                                                                         \
+    }

     ImagingSectionEnter(&cookie);
     if (imIn->image8) {
@@ -93,15 +93,11 @@
     return imOut;
 }

-
 void
-ImagingFilter3x3(Imaging imOut, Imaging im, const float* kernel,
-                 float offset)
-{
-#define KERNEL1x3(in0, x, kernel, d) ( \
-    _i2f((UINT8) in0[x-d])  * (kernel)[0] + \
-    _i2f((UINT8) in0[x])    * (kernel)[1] + \
-    _i2f((UINT8) in0[x+d])  * (kernel)[2])
+ImagingFilter3x3(Imaging imOut, Imaging im, const float *kernel, float offset) {
+#define KERNEL1x3(in0, x, kernel, d)                                             \
+    (_i2f((UINT8)in0[x - d]) * (kernel)[0] + _i2f((UINT8)in0[x]) * (kernel)[1] + \
+     _i2f((UINT8)in0[x + d]) * (kernel)[2])

     int x = 0, y = 0;

@@ -109,86 +105,84 @@
     if (im->bands == 1) {
         // Add one time for rounding
         offset += 0.5;
-        for (y = 1; y < im->ysize-1; y++) {
-            UINT8* in_1 = (UINT8*) im->image[y-1];
-            UINT8* in0 = (UINT8*) im->image[y];
-            UINT8* in1 = (UINT8*) im->image[y+1];
-            UINT8* out = (UINT8*) imOut->image[y];
+        for (y = 1; y < im->ysize - 1; y++) {
+            UINT8 *in_1 = (UINT8 *)im->image[y - 1];
+            UINT8 *in0 = (UINT8 *)im->image[y];
+            UINT8 *in1 = (UINT8 *)im->image[y + 1];
+            UINT8 *out = (UINT8 *)imOut->image[y];

             out[0] = in0[0];
-            for (x = 1; x < im->xsize-1; x++) {
+            for (x = 1; x < im->xsize - 1; x++) {
                 float ss = offset;
                 ss += KERNEL1x3(in1, x, &kernel[0], 1);
                 ss += KERNEL1x3(in0, x, &kernel[3], 1);
                 ss += KERNEL1x3(in_1, x, &kernel[6], 1);
                 out[x] = clip8(ss);
-             }
+            }
             out[x] = in0[x];
         }
     } else {
         // Add one time for rounding
         offset += 0.5;
-        for (y = 1; y < im->ysize-1; y++) {
-            UINT8* in_1 = (UINT8*) im->image[y-1];
-            UINT8* in0 = (UINT8*) im->image[y];
-            UINT8* in1 = (UINT8*) im->image[y+1];
-            UINT8* out = (UINT8*) imOut->image[y];
+        for (y = 1; y < im->ysize - 1; y++) {
+            UINT8 *in_1 = (UINT8 *)im->image[y - 1];
+            UINT8 *in0 = (UINT8 *)im->image[y];
+            UINT8 *in1 = (UINT8 *)im->image[y + 1];
+            UINT8 *out = (UINT8 *)imOut->image[y];

             memcpy(out, in0, sizeof(UINT32));
             if (im->bands == 2) {
-                for (x = 1; x < im->xsize-1; x++) {
+                for (x = 1; x < im->xsize - 1; x++) {
                     float ss0 = offset;
                     float ss3 = offset;
                     UINT32 v;
-                    ss0 += KERNEL1x3(in1, x*4+0, &kernel[0], 4);
-                    ss3 += KERNEL1x3(in1, x*4+3, &kernel[0], 4);
-                    ss0 += KERNEL1x3(in0, x*4+0, &kernel[3], 4);
-                    ss3 += KERNEL1x3(in0, x*4+3, &kernel[3], 4);
-                    ss0 += KERNEL1x3(in_1, x*4+0, &kernel[6], 4);
-                    ss3 += KERNEL1x3(in_1, x*4+3, &kernel[6], 4);
+                    ss0 += KERNEL1x3(in1, x * 4 + 0, &kernel[0], 4);
+                    ss3 += KERNEL1x3(in1, x * 4 + 3, &kernel[0], 4);
+                    ss0 += KERNEL1x3(in0, x * 4 + 0, &kernel[3], 4);
+                    ss3 += KERNEL1x3(in0, x * 4 + 3, &kernel[3], 4);
+                    ss0 += KERNEL1x3(in_1, x * 4 + 0, &kernel[6], 4);
+                    ss3 += KERNEL1x3(in_1, x * 4 + 3, &kernel[6], 4);
                     v = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
                     memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (im->bands == 3) {
-                for (x = 1; x < im->xsize-1; x++) {
+                for (x = 1; x < im->xsize - 1; x++) {
                     float ss0 = offset;
                     float ss1 = offset;
                     float ss2 = offset;
                     UINT32 v;
-                    ss0 += KERNEL1x3(in1, x*4+0, &kernel[0], 4);
-                    ss1 += KERNEL1x3(in1, x*4+1, &kernel[0], 4);
-                    ss2 += KERNEL1x3(in1, x*4+2, &kernel[0], 4);
-                    ss0 += KERNEL1x3(in0, x*4+0, &kernel[3], 4);
-                    ss1 += KERNEL1x3(in0, x*4+1, &kernel[3], 4);
-                    ss2 += KERNEL1x3(in0, x*4+2, &kernel[3], 4);
-                    ss0 += KERNEL1x3(in_1, x*4+0, &kernel[6], 4);
-                    ss1 += KERNEL1x3(in_1, x*4+1, &kernel[6], 4);
-                    ss2 += KERNEL1x3(in_1, x*4+2, &kernel[6], 4);
-                    v = MAKE_UINT32(
-                        clip8(ss0), clip8(ss1), clip8(ss2), 0);
+                    ss0 += KERNEL1x3(in1, x * 4 + 0, &kernel[0], 4);
+                    ss1 += KERNEL1x3(in1, x * 4 + 1, &kernel[0], 4);
+                    ss2 += KERNEL1x3(in1, x * 4 + 2, &kernel[0], 4);
+                    ss0 += KERNEL1x3(in0, x * 4 + 0, &kernel[3], 4);
+                    ss1 += KERNEL1x3(in0, x * 4 + 1, &kernel[3], 4);
+                    ss2 += KERNEL1x3(in0, x * 4 + 2, &kernel[3], 4);
+                    ss0 += KERNEL1x3(in_1, x * 4 + 0, &kernel[6], 4);
+                    ss1 += KERNEL1x3(in_1, x * 4 + 1, &kernel[6], 4);
+                    ss2 += KERNEL1x3(in_1, x * 4 + 2, &kernel[6], 4);
+                    v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), 0);
                     memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (im->bands == 4) {
-                for (x = 1; x < im->xsize-1; x++) {
+                for (x = 1; x < im->xsize - 1; x++) {
                     float ss0 = offset;
                     float ss1 = offset;
                     float ss2 = offset;
                     float ss3 = offset;
                     UINT32 v;
-                    ss0 += KERNEL1x3(in1, x*4+0, &kernel[0], 4);
-                    ss1 += KERNEL1x3(in1, x*4+1, &kernel[0], 4);
-                    ss2 += KERNEL1x3(in1, x*4+2, &kernel[0], 4);
-                    ss3 += KERNEL1x3(in1, x*4+3, &kernel[0], 4);
-                    ss0 += KERNEL1x3(in0, x*4+0, &kernel[3], 4);
-                    ss1 += KERNEL1x3(in0, x*4+1, &kernel[3], 4);
-                    ss2 += KERNEL1x3(in0, x*4+2, &kernel[3], 4);
-                    ss3 += KERNEL1x3(in0, x*4+3, &kernel[3], 4);
-                    ss0 += KERNEL1x3(in_1, x*4+0, &kernel[6], 4);
-                    ss1 += KERNEL1x3(in_1, x*4+1, &kernel[6], 4);
-                    ss2 += KERNEL1x3(in_1, x*4+2, &kernel[6], 4);
-                    ss3 += KERNEL1x3(in_1, x*4+3, &kernel[6], 4);
-                    v = MAKE_UINT32(
-                        clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
+                    ss0 += KERNEL1x3(in1, x * 4 + 0, &kernel[0], 4);
+                    ss1 += KERNEL1x3(in1, x * 4 + 1, &kernel[0], 4);
+                    ss2 += KERNEL1x3(in1, x * 4 + 2, &kernel[0], 4);
+                    ss3 += KERNEL1x3(in1, x * 4 + 3, &kernel[0], 4);
+                    ss0 += KERNEL1x3(in0, x * 4 + 0, &kernel[3], 4);
+                    ss1 += KERNEL1x3(in0, x * 4 + 1, &kernel[3], 4);
+                    ss2 += KERNEL1x3(in0, x * 4 + 2, &kernel[3], 4);
+                    ss3 += KERNEL1x3(in0, x * 4 + 3, &kernel[3], 4);
+                    ss0 += KERNEL1x3(in_1, x * 4 + 0, &kernel[6], 4);
+                    ss1 += KERNEL1x3(in_1, x * 4 + 1, &kernel[6], 4);
+                    ss2 += KERNEL1x3(in_1, x * 4 + 2, &kernel[6], 4);
+                    ss3 += KERNEL1x3(in_1, x * 4 + 3, &kernel[6], 4);
+                    v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
                     memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             }
@@ -198,17 +192,13 @@
     memcpy(imOut->image[y], im->image[y], im->linesize);
 }

-
 void
-ImagingFilter5x5(Imaging imOut, Imaging im, const float* kernel,
-                 float offset)
-{
-#define KERNEL1x5(in0, x, kernel, d) ( \
-    _i2f((UINT8) in0[x-d-d])   * (kernel)[0] + \
-    _i2f((UINT8) in0[x-d])     * (kernel)[1] + \
-    _i2f((UINT8) in0[x])       * (kernel)[2] + \
-    _i2f((UINT8) in0[x+d])     * (kernel)[3] + \
-    _i2f((UINT8) in0[x+d+d])   * (kernel)[4])
+ImagingFilter5x5(Imaging imOut, Imaging im, const float *kernel, float offset) {
+#define KERNEL1x5(in0, x, kernel, d)                                             \
+    (_i2f((UINT8)in0[x - d - d]) * (kernel)[0] +                                 \
+     _i2f((UINT8)in0[x - d]) * (kernel)[1] + _i2f((UINT8)in0[x]) * (kernel)[2] + \
+     _i2f((UINT8)in0[x + d]) * (kernel)[3] +                                     \
+     _i2f((UINT8)in0[x + d + d]) * (kernel)[4])

     int x = 0, y = 0;

@@ -217,17 +207,17 @@
     if (im->bands == 1) {
         // Add one time for rounding
         offset += 0.5;
-        for (y = 2; y < im->ysize-2; y++) {
-            UINT8* in_2 = (UINT8*) im->image[y-2];
-            UINT8* in_1 = (UINT8*) im->image[y-1];
-            UINT8* in0 = (UINT8*) im->image[y];
-            UINT8* in1 = (UINT8*) im->image[y+1];
-            UINT8* in2 = (UINT8*) im->image[y+2];
-            UINT8* out = (UINT8*) imOut->image[y];
+        for (y = 2; y < im->ysize - 2; y++) {
+            UINT8 *in_2 = (UINT8 *)im->image[y - 2];
+            UINT8 *in_1 = (UINT8 *)im->image[y - 1];
+            UINT8 *in0 = (UINT8 *)im->image[y];
+            UINT8 *in1 = (UINT8 *)im->image[y + 1];
+            UINT8 *in2 = (UINT8 *)im->image[y + 2];
+            UINT8 *out = (UINT8 *)imOut->image[y];

             out[0] = in0[0];
             out[1] = in0[1];
-            for (x = 2; x < im->xsize-2; x++) {
+            for (x = 2; x < im->xsize - 2; x++) {
                 float ss = offset;
                 ss += KERNEL1x5(in2, x, &kernel[0], 1);
                 ss += KERNEL1x5(in1, x, &kernel[5], 1);
@@ -236,112 +226,109 @@
                 ss += KERNEL1x5(in_2, x, &kernel[20], 1);
                 out[x] = clip8(ss);
             }
-            out[x+0] = in0[x+0];
-            out[x+1] = in0[x+1];
+            out[x + 0] = in0[x + 0];
+            out[x + 1] = in0[x + 1];
         }
     } else {
         // Add one time for rounding
         offset += 0.5;
-        for (y = 2; y < im->ysize-2; y++) {
-            UINT8* in_2 = (UINT8*) im->image[y-2];
-            UINT8* in_1 = (UINT8*) im->image[y-1];
-            UINT8* in0 = (UINT8*) im->image[y];
-            UINT8* in1 = (UINT8*) im->image[y+1];
-            UINT8* in2 = (UINT8*) im->image[y+2];
-            UINT8* out = (UINT8*) imOut->image[y];
+        for (y = 2; y < im->ysize - 2; y++) {
+            UINT8 *in_2 = (UINT8 *)im->image[y - 2];
+            UINT8 *in_1 = (UINT8 *)im->image[y - 1];
+            UINT8 *in0 = (UINT8 *)im->image[y];
+            UINT8 *in1 = (UINT8 *)im->image[y + 1];
+            UINT8 *in2 = (UINT8 *)im->image[y + 2];
+            UINT8 *out = (UINT8 *)imOut->image[y];

             memcpy(out, in0, sizeof(UINT32) * 2);
             if (im->bands == 2) {
-                for (x = 2; x < im->xsize-2; x++) {
+                for (x = 2; x < im->xsize - 2; x++) {
                     float ss0 = offset;
                     float ss3 = offset;
                     UINT32 v;
-                    ss0 += KERNEL1x5(in2, x*4+0, &kernel[0], 4);
-                    ss3 += KERNEL1x5(in2, x*4+3, &kernel[0], 4);
-                    ss0 += KERNEL1x5(in1, x*4+0, &kernel[5], 4);
-                    ss3 += KERNEL1x5(in1, x*4+3, &kernel[5], 4);
-                    ss0 += KERNEL1x5(in0, x*4+0, &kernel[10], 4);
-                    ss3 += KERNEL1x5(in0, x*4+3, &kernel[10], 4);
-                    ss0 += KERNEL1x5(in_1, x*4+0, &kernel[15], 4);
-                    ss3 += KERNEL1x5(in_1, x*4+3, &kernel[15], 4);
-                    ss0 += KERNEL1x5(in_2, x*4+0, &kernel[20], 4);
-                    ss3 += KERNEL1x5(in_2, x*4+3, &kernel[20], 4);
+                    ss0 += KERNEL1x5(in2, x * 4 + 0, &kernel[0], 4);
+                    ss3 += KERNEL1x5(in2, x * 4 + 3, &kernel[0], 4);
+                    ss0 += KERNEL1x5(in1, x * 4 + 0, &kernel[5], 4);
+                    ss3 += KERNEL1x5(in1, x * 4 + 3, &kernel[5], 4);
+                    ss0 += KERNEL1x5(in0, x * 4 + 0, &kernel[10], 4);
+                    ss3 += KERNEL1x5(in0, x * 4 + 3, &kernel[10], 4);
+                    ss0 += KERNEL1x5(in_1, x * 4 + 0, &kernel[15], 4);
+                    ss3 += KERNEL1x5(in_1, x * 4 + 3, &kernel[15], 4);
+                    ss0 += KERNEL1x5(in_2, x * 4 + 0, &kernel[20], 4);
+                    ss3 += KERNEL1x5(in_2, x * 4 + 3, &kernel[20], 4);
                     v = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
                     memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (im->bands == 3) {
-                for (x = 2; x < im->xsize-2; x++) {
+                for (x = 2; x < im->xsize - 2; x++) {
                     float ss0 = offset;
                     float ss1 = offset;
                     float ss2 = offset;
                     UINT32 v;
-                    ss0 += KERNEL1x5(in2, x*4+0, &kernel[0], 4);
-                    ss1 += KERNEL1x5(in2, x*4+1, &kernel[0], 4);
-                    ss2 += KERNEL1x5(in2, x*4+2, &kernel[0], 4);
-                    ss0 += KERNEL1x5(in1, x*4+0, &kernel[5], 4);
-                    ss1 += KERNEL1x5(in1, x*4+1, &kernel[5], 4);
-                    ss2 += KERNEL1x5(in1, x*4+2, &kernel[5], 4);
-                    ss0 += KERNEL1x5(in0, x*4+0, &kernel[10], 4);
-                    ss1 += KERNEL1x5(in0, x*4+1, &kernel[10], 4);
-                    ss2 += KERNEL1x5(in0, x*4+2, &kernel[10], 4);
-                    ss0 += KERNEL1x5(in_1, x*4+0, &kernel[15], 4);
-                    ss1 += KERNEL1x5(in_1, x*4+1, &kernel[15], 4);
-                    ss2 += KERNEL1x5(in_1, x*4+2, &kernel[15], 4);
-                    ss0 += KERNEL1x5(in_2, x*4+0, &kernel[20], 4);
-                    ss1 += KERNEL1x5(in_2, x*4+1, &kernel[20], 4);
-                    ss2 += KERNEL1x5(in_2, x*4+2, &kernel[20], 4);
-                    v = MAKE_UINT32(
-                        clip8(ss0), clip8(ss1), clip8(ss2), 0);
+                    ss0 += KERNEL1x5(in2, x * 4 + 0, &kernel[0], 4);
+                    ss1 += KERNEL1x5(in2, x * 4 + 1, &kernel[0], 4);
+                    ss2 += KERNEL1x5(in2, x * 4 + 2, &kernel[0], 4);
+                    ss0 += KERNEL1x5(in1, x * 4 + 0, &kernel[5], 4);
+                    ss1 += KERNEL1x5(in1, x * 4 + 1, &kernel[5], 4);
+                    ss2 += KERNEL1x5(in1, x * 4 + 2, &kernel[5], 4);
+                    ss0 += KERNEL1x5(in0, x * 4 + 0, &kernel[10], 4);
+                    ss1 += KERNEL1x5(in0, x * 4 + 1, &kernel[10], 4);
+                    ss2 += KERNEL1x5(in0, x * 4 + 2, &kernel[10], 4);
+                    ss0 += KERNEL1x5(in_1, x * 4 + 0, &kernel[15], 4);
+                    ss1 += KERNEL1x5(in_1, x * 4 + 1, &kernel[15], 4);
+                    ss2 += KERNEL1x5(in_1, x * 4 + 2, &kernel[15], 4);
+                    ss0 += KERNEL1x5(in_2, x * 4 + 0, &kernel[20], 4);
+                    ss1 += KERNEL1x5(in_2, x * 4 + 1, &kernel[20], 4);
+                    ss2 += KERNEL1x5(in_2, x * 4 + 2, &kernel[20], 4);
+                    v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), 0);
                     memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (im->bands == 4) {
-                for (x = 2; x < im->xsize-2; x++) {
+                for (x = 2; x < im->xsize - 2; x++) {
                     float ss0 = offset;
                     float ss1 = offset;
                     float ss2 = offset;
                     float ss3 = offset;
                     UINT32 v;
-                    ss0 += KERNEL1x5(in2, x*4+0, &kernel[0], 4);
-                    ss1 += KERNEL1x5(in2, x*4+1, &kernel[0], 4);
-                    ss2 += KERNEL1x5(in2, x*4+2, &kernel[0], 4);
-                    ss3 += KERNEL1x5(in2, x*4+3, &kernel[0], 4);
-                    ss0 += KERNEL1x5(in1, x*4+0, &kernel[5], 4);
-                    ss1 += KERNEL1x5(in1, x*4+1, &kernel[5], 4);
-                    ss2 += KERNEL1x5(in1, x*4+2, &kernel[5], 4);
-                    ss3 += KERNEL1x5(in1, x*4+3, &kernel[5], 4);
-                    ss0 += KERNEL1x5(in0, x*4+0, &kernel[10], 4);
-                    ss1 += KERNEL1x5(in0, x*4+1, &kernel[10], 4);
-                    ss2 += KERNEL1x5(in0, x*4+2, &kernel[10], 4);
-                    ss3 += KERNEL1x5(in0, x*4+3, &kernel[10], 4);
-                    ss0 += KERNEL1x5(in_1, x*4+0, &kernel[15], 4);
-                    ss1 += KERNEL1x5(in_1, x*4+1, &kernel[15], 4);
-                    ss2 += KERNEL1x5(in_1, x*4+2, &kernel[15], 4);
-                    ss3 += KERNEL1x5(in_1, x*4+3, &kernel[15], 4);
-                    ss0 += KERNEL1x5(in_2, x*4+0, &kernel[20], 4);
-                    ss1 += KERNEL1x5(in_2, x*4+1, &kernel[20], 4);
-                    ss2 += KERNEL1x5(in_2, x*4+2, &kernel[20], 4);
-                    ss3 += KERNEL1x5(in_2, x*4+3, &kernel[20], 4);
-                    v = MAKE_UINT32(
-                        clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
+                    ss0 += KERNEL1x5(in2, x * 4 + 0, &kernel[0], 4);
+                    ss1 += KERNEL1x5(in2, x * 4 + 1, &kernel[0], 4);
+                    ss2 += KERNEL1x5(in2, x * 4 + 2, &kernel[0], 4);
+                    ss3 += KERNEL1x5(in2, x * 4 + 3, &kernel[0], 4);
+                    ss0 += KERNEL1x5(in1, x * 4 + 0, &kernel[5], 4);
+                    ss1 += KERNEL1x5(in1, x * 4 + 1, &kernel[5], 4);
+                    ss2 += KERNEL1x5(in1, x * 4 + 2, &kernel[5], 4);
+                    ss3 += KERNEL1x5(in1, x * 4 + 3, &kernel[5], 4);
+                    ss0 += KERNEL1x5(in0, x * 4 + 0, &kernel[10], 4);
+                    ss1 += KERNEL1x5(in0, x * 4 + 1, &kernel[10], 4);
+                    ss2 += KERNEL1x5(in0, x * 4 + 2, &kernel[10], 4);
+                    ss3 += KERNEL1x5(in0, x * 4 + 3, &kernel[10], 4);
+                    ss0 += KERNEL1x5(in_1, x * 4 + 0, &kernel[15], 4);
+                    ss1 += KERNEL1x5(in_1, x * 4 + 1, &kernel[15], 4);
+                    ss2 += KERNEL1x5(in_1, x * 4 + 2, &kernel[15], 4);
+                    ss3 += KERNEL1x5(in_1, x * 4 + 3, &kernel[15], 4);
+                    ss0 += KERNEL1x5(in_2, x * 4 + 0, &kernel[20], 4);
+                    ss1 += KERNEL1x5(in_2, x * 4 + 1, &kernel[20], 4);
+                    ss2 += KERNEL1x5(in_2, x * 4 + 2, &kernel[20], 4);
+                    ss3 += KERNEL1x5(in_2, x * 4 + 3, &kernel[20], 4);
+                    v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
                     memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             }
-            memcpy(out + x * sizeof(UINT32), in0 + x * sizeof(UINT32), sizeof(UINT32) * 2);
+            memcpy(
+                out + x * sizeof(UINT32), in0 + x * sizeof(UINT32), sizeof(UINT32) * 2);
         }
     }
     memcpy(imOut->image[y], im->image[y], im->linesize);
-    memcpy(imOut->image[y+1], im->image[y+1], im->linesize);
+    memcpy(imOut->image[y + 1], im->image[y + 1], im->linesize);
 }

 Imaging
-ImagingFilter(Imaging im, int xsize, int ysize, const FLOAT32* kernel,
-              FLOAT32 offset)
-{
+ImagingFilter(Imaging im, int xsize, int ysize, const FLOAT32 *kernel, FLOAT32 offset) {
     Imaging imOut;
     ImagingSectionCookie cookie;

-    if ( ! im || im->type != IMAGING_TYPE_UINT8) {
-        return (Imaging) ImagingError_ModeError();
+    if (!im || im->type != IMAGING_TYPE_UINT8) {
+        return (Imaging)ImagingError_ModeError();
     }

     if (im->xsize < xsize || im->ysize < ysize) {
@@ -349,7 +336,7 @@
     }

     if ((xsize != 3 && xsize != 5) || xsize != ysize) {
-        return (Imaging) ImagingError_ValueError("bad kernel size");
+        return (Imaging)ImagingError_ValueError("bad kernel size");
     }

     imOut = ImagingNewDirty(im->mode, im->xsize, im->ysize);
@@ -368,4 +355,3 @@
     ImagingSectionLeave(&cookie);
     return imOut;
 }
-
('src/libImaging', 'HexDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,23 +13,22 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-#define HEX(v) ((v >= '0' && v <= '9') ? v - '0' :\
-        (v >= 'a' && v <= 'f') ? v - 'a' + 10 :\
-        (v >= 'A' && v <= 'F') ? v - 'A' + 10 : -1)
+#define HEX(v)                               \
+    ((v >= '0' && v <= '9')   ? v - '0'      \
+     : (v >= 'a' && v <= 'f') ? v - 'a' + 10 \
+     : (v >= 'A' && v <= 'F') ? v - 'A' + 10 \
+                              : -1)

 int
-ImagingHexDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
-    UINT8* ptr;
+ImagingHexDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
+    UINT8 *ptr;
     int a, b;

     ptr = buf;

     for (;;) {
-
         if (bytes < 2) {
             return ptr - buf;
         }
@@ -38,22 +37,19 @@
         b = HEX(ptr[1]);

         if (a < 0 || b < 0) {
-
             ptr++;
             bytes--;

         } else {
-
             ptr += 2;
             bytes -= 2;

-            state->buffer[state->x] = (a<<4) + b;
+            state->buffer[state->x] = (a << 4) + b;

             if (++state->x >= state->bytes) {
-
                 /* Got a full line, unpack it */
-                state->shuffle((UINT8*) im->image[state->y], state->buffer,
-                           state->xsize);
+                state->shuffle(
+                    (UINT8 *)im->image[state->y], state->buffer, state->xsize);

                 state->x = 0;

@@ -62,7 +58,6 @@
                     return -1;
                 }
             }
-
         }
     }
 }
('src/libImaging', 'UnpackYCC.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,150 +13,151 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"
-

 /* Tables generated by pcdtables.py, based on transforms taken from
    the "Colour Space Conversions FAQ" by Roberts/Ford. */

-static INT16 L[] = { 0, 1, 3, 4, 5, 7, 8, 10, 11, 12, 14, 15, 16, 18,
-19, 20, 22, 23, 24, 26, 27, 29, 30, 31, 33, 34, 35, 37, 38, 39, 41,
-42, 43, 45, 46, 48, 49, 50, 52, 53, 54, 56, 57, 58, 60, 61, 62, 64,
-65, 67, 68, 69, 71, 72, 73, 75, 76, 77, 79, 80, 82, 83, 84, 86, 87,
-88, 90, 91, 92, 94, 95, 96, 98, 99, 101, 102, 103, 105, 106, 107, 109,
-110, 111, 113, 114, 115, 117, 118, 120, 121, 122, 124, 125, 126, 128,
-129, 130, 132, 133, 134, 136, 137, 139, 140, 141, 143, 144, 145, 147,
-148, 149, 151, 152, 153, 155, 156, 158, 159, 160, 162, 163, 164, 166,
-167, 168, 170, 171, 173, 174, 175, 177, 178, 179, 181, 182, 183, 185,
-186, 187, 189, 190, 192, 193, 194, 196, 197, 198, 200, 201, 202, 204,
-205, 206, 208, 209, 211, 212, 213, 215, 216, 217, 219, 220, 221, 223,
-224, 225, 227, 228, 230, 231, 232, 234, 235, 236, 238, 239, 240, 242,
-243, 245, 246, 247, 249, 250, 251, 253, 254, 255, 257, 258, 259, 261,
-262, 264, 265, 266, 268, 269, 270, 272, 273, 274, 276, 277, 278, 280,
-281, 283, 284, 285, 287, 288, 289, 291, 292, 293, 295, 296, 297, 299,
-300, 302, 303, 304, 306, 307, 308, 310, 311, 312, 314, 315, 317, 318,
-319, 321, 322, 323, 325, 326, 327, 329, 330, 331, 333, 334, 336, 337,
-338, 340, 341, 342, 344, 345, 346 };
+static INT16 L[] = {
+    0,   1,   3,   4,   5,   7,   8,   10,  11,  12,  14,  15,  16,  18,  19,  20,
+    22,  23,  24,  26,  27,  29,  30,  31,  33,  34,  35,  37,  38,  39,  41,  42,
+    43,  45,  46,  48,  49,  50,  52,  53,  54,  56,  57,  58,  60,  61,  62,  64,
+    65,  67,  68,  69,  71,  72,  73,  75,  76,  77,  79,  80,  82,  83,  84,  86,
+    87,  88,  90,  91,  92,  94,  95,  96,  98,  99,  101, 102, 103, 105, 106, 107,
+    109, 110, 111, 113, 114, 115, 117, 118, 120, 121, 122, 124, 125, 126, 128, 129,
+    130, 132, 133, 134, 136, 137, 139, 140, 141, 143, 144, 145, 147, 148, 149, 151,
+    152, 153, 155, 156, 158, 159, 160, 162, 163, 164, 166, 167, 168, 170, 171, 173,
+    174, 175, 177, 178, 179, 181, 182, 183, 185, 186, 187, 189, 190, 192, 193, 194,
+    196, 197, 198, 200, 201, 202, 204, 205, 206, 208, 209, 211, 212, 213, 215, 216,
+    217, 219, 220, 221, 223, 224, 225, 227, 228, 230, 231, 232, 234, 235, 236, 238,
+    239, 240, 242, 243, 245, 246, 247, 249, 250, 251, 253, 254, 255, 257, 258, 259,
+    261, 262, 264, 265, 266, 268, 269, 270, 272, 273, 274, 276, 277, 278, 280, 281,
+    283, 284, 285, 287, 288, 289, 291, 292, 293, 295, 296, 297, 299, 300, 302, 303,
+    304, 306, 307, 308, 310, 311, 312, 314, 315, 317, 318, 319, 321, 322, 323, 325,
+    326, 327, 329, 330, 331, 333, 334, 336, 337, 338, 340, 341, 342, 344, 345, 346};

-static INT16 CB[] = { -345, -343, -341, -338, -336, -334, -332, -329,
--327, -325, -323, -321, -318, -316, -314, -312, -310, -307, -305,
--303, -301, -298, -296, -294, -292, -290, -287, -285, -283, -281,
--278, -276, -274, -272, -270, -267, -265, -263, -261, -258, -256,
--254, -252, -250, -247, -245, -243, -241, -239, -236, -234, -232,
--230, -227, -225, -223, -221, -219, -216, -214, -212, -210, -207,
--205, -203, -201, -199, -196, -194, -192, -190, -188, -185, -183,
--181, -179, -176, -174, -172, -170, -168, -165, -163, -161, -159,
--156, -154, -152, -150, -148, -145, -143, -141, -139, -137, -134,
--132, -130, -128, -125, -123, -121, -119, -117, -114, -112, -110,
--108, -105, -103, -101, -99, -97, -94, -92, -90, -88, -85, -83, -81,
--79, -77, -74, -72, -70, -68, -66, -63, -61, -59, -57, -54, -52, -50,
--48, -46, -43, -41, -39, -37, -34, -32, -30, -28, -26, -23, -21, -19,
--17, -15, -12, -10, -8, -6, -3, -1, 0, 2, 4, 7, 9, 11, 13, 16, 18, 20,
-22, 24, 27, 29, 31, 33, 35, 38, 40, 42, 44, 47, 49, 51, 53, 55, 58,
-60, 62, 64, 67, 69, 71, 73, 75, 78, 80, 82, 84, 86, 89, 91, 93, 95,
-98, 100, 102, 104, 106, 109, 111, 113, 115, 118, 120, 122, 124, 126,
-129, 131, 133, 135, 138, 140, 142, 144, 146, 149, 151, 153, 155, 157,
-160, 162, 164, 166, 169, 171, 173, 175, 177, 180, 182, 184, 186, 189,
-191, 193, 195, 197, 200, 202, 204, 206, 208, 211, 213, 215, 217, 220 };
+static INT16 CB[] = {
+    -345, -343, -341, -338, -336, -334, -332, -329, -327, -325, -323, -321, -318, -316,
+    -314, -312, -310, -307, -305, -303, -301, -298, -296, -294, -292, -290, -287, -285,
+    -283, -281, -278, -276, -274, -272, -270, -267, -265, -263, -261, -258, -256, -254,
+    -252, -250, -247, -245, -243, -241, -239, -236, -234, -232, -230, -227, -225, -223,
+    -221, -219, -216, -214, -212, -210, -207, -205, -203, -201, -199, -196, -194, -192,
+    -190, -188, -185, -183, -181, -179, -176, -174, -172, -170, -168, -165, -163, -161,
+    -159, -156, -154, -152, -150, -148, -145, -143, -141, -139, -137, -134, -132, -130,
+    -128, -125, -123, -121, -119, -117, -114, -112, -110, -108, -105, -103, -101, -99,
+    -97,  -94,  -92,  -90,  -88,  -85,  -83,  -81,  -79,  -77,  -74,  -72,  -70,  -68,
+    -66,  -63,  -61,  -59,  -57,  -54,  -52,  -50,  -48,  -46,  -43,  -41,  -39,  -37,
+    -34,  -32,  -30,  -28,  -26,  -23,  -21,  -19,  -17,  -15,  -12,  -10,  -8,   -6,
+    -3,   -1,   0,    2,    4,    7,    9,    11,   13,   16,   18,   20,   22,   24,
+    27,   29,   31,   33,   35,   38,   40,   42,   44,   47,   49,   51,   53,   55,
+    58,   60,   62,   64,   67,   69,   71,   73,   75,   78,   80,   82,   84,   86,
+    89,   91,   93,   95,   98,   100,  102,  104,  106,  109,  111,  113,  115,  118,
+    120,  122,  124,  126,  129,  131,  133,  135,  138,  140,  142,  144,  146,  149,
+    151,  153,  155,  157,  160,  162,  164,  166,  169,  171,  173,  175,  177,  180,
+    182,  184,  186,  189,  191,  193,  195,  197,  200,  202,  204,  206,  208,  211,
+    213,  215,  217,  220};

-static INT16 GB[] = { 67, 67, 66, 66, 65, 65, 65, 64, 64, 63, 63, 62,
-62, 62, 61, 61, 60, 60, 59, 59, 59, 58, 58, 57, 57, 56, 56, 56, 55,
-55, 54, 54, 53, 53, 52, 52, 52, 51, 51, 50, 50, 49, 49, 49, 48, 48,
-47, 47, 46, 46, 46, 45, 45, 44, 44, 43, 43, 43, 42, 42, 41, 41, 40,
-40, 40, 39, 39, 38, 38, 37, 37, 37, 36, 36, 35, 35, 34, 34, 34, 33,
-33, 32, 32, 31, 31, 31, 30, 30, 29, 29, 28, 28, 28, 27, 27, 26, 26,
-25, 25, 25, 24, 24, 23, 23, 22, 22, 22, 21, 21, 20, 20, 19, 19, 19,
-18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 13, 13, 12, 12, 12, 11,
-11, 10, 10, 9, 9, 9, 8, 8, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 3, 2, 2,
-1, 1, 0, 0, 0, 0, 0, -1, -1, -2, -2, -2, -3, -3, -4, -4, -5, -5, -5,
--6, -6, -7, -7, -8, -8, -8, -9, -9, -10, -10, -11, -11, -11, -12, -12,
--13, -13, -14, -14, -14, -15, -15, -16, -16, -17, -17, -18, -18, -18,
--19, -19, -20, -20, -21, -21, -21, -22, -22, -23, -23, -24, -24, -24,
--25, -25, -26, -26, -27, -27, -27, -28, -28, -29, -29, -30, -30, -30,
--31, -31, -32, -32, -33, -33, -33, -34, -34, -35, -35, -36, -36, -36,
--37, -37, -38, -38, -39, -39, -39, -40, -40, -41, -41, -42 };
+static INT16 GB[] = {
+    67,  67,  66,  66,  65,  65,  65,  64,  64,  63,  63,  62,  62,  62,  61,  61,
+    60,  60,  59,  59,  59,  58,  58,  57,  57,  56,  56,  56,  55,  55,  54,  54,
+    53,  53,  52,  52,  52,  51,  51,  50,  50,  49,  49,  49,  48,  48,  47,  47,
+    46,  46,  46,  45,  45,  44,  44,  43,  43,  43,  42,  42,  41,  41,  40,  40,
+    40,  39,  39,  38,  38,  37,  37,  37,  36,  36,  35,  35,  34,  34,  34,  33,
+    33,  32,  32,  31,  31,  31,  30,  30,  29,  29,  28,  28,  28,  27,  27,  26,
+    26,  25,  25,  25,  24,  24,  23,  23,  22,  22,  22,  21,  21,  20,  20,  19,
+    19,  19,  18,  18,  17,  17,  16,  16,  15,  15,  15,  14,  14,  13,  13,  12,
+    12,  12,  11,  11,  10,  10,  9,   9,   9,   8,   8,   7,   7,   6,   6,   6,
+    5,   5,   4,   4,   3,   3,   3,   2,   2,   1,   1,   0,   0,   0,   0,   0,
+    -1,  -1,  -2,  -2,  -2,  -3,  -3,  -4,  -4,  -5,  -5,  -5,  -6,  -6,  -7,  -7,
+    -8,  -8,  -8,  -9,  -9,  -10, -10, -11, -11, -11, -12, -12, -13, -13, -14, -14,
+    -14, -15, -15, -16, -16, -17, -17, -18, -18, -18, -19, -19, -20, -20, -21, -21,
+    -21, -22, -22, -23, -23, -24, -24, -24, -25, -25, -26, -26, -27, -27, -27, -28,
+    -28, -29, -29, -30, -30, -30, -31, -31, -32, -32, -33, -33, -33, -34, -34, -35,
+    -35, -36, -36, -36, -37, -37, -38, -38, -39, -39, -39, -40, -40, -41, -41, -42};

-static INT16 CR[] = { -249, -247, -245, -243, -241, -239, -238, -236,
--234, -232, -230, -229, -227, -225, -223, -221, -219, -218, -216,
--214, -212, -210, -208, -207, -205, -203, -201, -199, -198, -196,
--194, -192, -190, -188, -187, -185, -183, -181, -179, -178, -176,
--174, -172, -170, -168, -167, -165, -163, -161, -159, -157, -156,
--154, -152, -150, -148, -147, -145, -143, -141, -139, -137, -136,
--134, -132, -130, -128, -127, -125, -123, -121, -119, -117, -116,
--114, -112, -110, -108, -106, -105, -103, -101, -99, -97, -96, -94,
--92, -90, -88, -86, -85, -83, -81, -79, -77, -76, -74, -72, -70, -68,
--66, -65, -63, -61, -59, -57, -55, -54, -52, -50, -48, -46, -45, -43,
--41, -39, -37, -35, -34, -32, -30, -28, -26, -25, -23, -21, -19, -17,
--15, -14, -12, -10, -8, -6, -4, -3, -1, 0, 2, 4, 5, 7, 9, 11, 13, 15,
-16, 18, 20, 22, 24, 26, 27, 29, 31, 33, 35, 36, 38, 40, 42, 44, 46,
-47, 49, 51, 53, 55, 56, 58, 60, 62, 64, 66, 67, 69, 71, 73, 75, 77,
-78, 80, 82, 84, 86, 87, 89, 91, 93, 95, 97, 98, 100, 102, 104, 106,
-107, 109, 111, 113, 115, 117, 118, 120, 122, 124, 126, 128, 129, 131,
-133, 135, 137, 138, 140, 142, 144, 146, 148, 149, 151, 153, 155, 157,
-158, 160, 162, 164, 166, 168, 169, 171, 173, 175, 177, 179, 180, 182,
-184, 186, 188, 189, 191, 193, 195, 197, 199, 200, 202, 204, 206, 208,
-209, 211, 213, 215 };
+static INT16 CR[] = {
+    -249, -247, -245, -243, -241, -239, -238, -236, -234, -232, -230, -229, -227, -225,
+    -223, -221, -219, -218, -216, -214, -212, -210, -208, -207, -205, -203, -201, -199,
+    -198, -196, -194, -192, -190, -188, -187, -185, -183, -181, -179, -178, -176, -174,
+    -172, -170, -168, -167, -165, -163, -161, -159, -157, -156, -154, -152, -150, -148,
+    -147, -145, -143, -141, -139, -137, -136, -134, -132, -130, -128, -127, -125, -123,
+    -121, -119, -117, -116, -114, -112, -110, -108, -106, -105, -103, -101, -99,  -97,
+    -96,  -94,  -92,  -90,  -88,  -86,  -85,  -83,  -81,  -79,  -77,  -76,  -74,  -72,
+    -70,  -68,  -66,  -65,  -63,  -61,  -59,  -57,  -55,  -54,  -52,  -50,  -48,  -46,
+    -45,  -43,  -41,  -39,  -37,  -35,  -34,  -32,  -30,  -28,  -26,  -25,  -23,  -21,
+    -19,  -17,  -15,  -14,  -12,  -10,  -8,   -6,   -4,   -3,   -1,   0,    2,    4,
+    5,    7,    9,    11,   13,   15,   16,   18,   20,   22,   24,   26,   27,   29,
+    31,   33,   35,   36,   38,   40,   42,   44,   46,   47,   49,   51,   53,   55,
+    56,   58,   60,   62,   64,   66,   67,   69,   71,   73,   75,   77,   78,   80,
+    82,   84,   86,   87,   89,   91,   93,   95,   97,   98,   100,  102,  104,  106,
+    107,  109,  111,  113,  115,  117,  118,  120,  122,  124,  126,  128,  129,  131,
+    133,  135,  137,  138,  140,  142,  144,  146,  148,  149,  151,  153,  155,  157,
+    158,  160,  162,  164,  166,  168,  169,  171,  173,  175,  177,  179,  180,  182,
+    184,  186,  188,  189,  191,  193,  195,  197,  199,  200,  202,  204,  206,  208,
+    209,  211,  213,  215};

-static INT16 GR[] = { 127, 126, 125, 124, 123, 122, 121, 121, 120, 119,
-118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 108, 107, 106,
-105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 95, 94, 93, 92, 91,
-90, 89, 88, 87, 86, 85, 84, 83, 83, 82, 81, 80, 79, 78, 77, 76, 75,
-74, 73, 72, 71, 70, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59,
-58, 57, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 45, 44,
-43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 32, 31, 30, 29, 28,
-27, 26, 25, 24, 23, 22, 21, 20, 19, 19, 18, 17, 16, 15, 14, 13, 12,
-11, 10, 9, 8, 7, 6, 6, 5, 4, 3, 2, 1, 0, 0, -1, -2, -3, -4, -5, -5,
--6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -18, -19,
--20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -31, -32,
--33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -44, -45,
--46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -56, -57, -58,
--59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -69, -70, -71,
--72, -73, -74, -75, -76, -77, -78, -79, -80, -81, -82, -82, -83, -84,
--85, -86, -87, -88, -89, -90, -91, -92, -93, -94, -94, -95, -96, -97,
--98, -99, -100, -101, -102, -103, -104, -105, -106, -107, -107, -108 };
+static INT16 GR[] = {
+    127, 126, 125, 124, 123, 122, 121,  121,  120,  119,  118,  117,  116,  115,  114,
+    113, 112, 111, 110, 109, 108, 108,  107,  106,  105,  104,  103,  102,  101,  100,
+    99,  98,  97,  96,  95,  95,  94,   93,   92,   91,   90,   89,   88,   87,   86,
+    85,  84,  83,  83,  82,  81,  80,   79,   78,   77,   76,   75,   74,   73,   72,
+    71,  70,  70,  69,  68,  67,  66,   65,   64,   63,   62,   61,   60,   59,   58,
+    57,  57,  56,  55,  54,  53,  52,   51,   50,   49,   48,   47,   46,   45,   45,
+    44,  43,  42,  41,  40,  39,  38,   37,   36,   35,   34,   33,   32,   32,   31,
+    30,  29,  28,  27,  26,  25,  24,   23,   22,   21,   20,   19,   19,   18,   17,
+    16,  15,  14,  13,  12,  11,  10,   9,    8,    7,    6,    6,    5,    4,    3,
+    2,   1,   0,   0,   -1,  -2,  -3,   -4,   -5,   -5,   -6,   -7,   -8,   -9,   -10,
+    -11, -12, -13, -14, -15, -16, -17,  -18,  -18,  -19,  -20,  -21,  -22,  -23,  -24,
+    -25, -26, -27, -28, -29, -30, -31,  -31,  -32,  -33,  -34,  -35,  -36,  -37,  -38,
+    -39, -40, -41, -42, -43, -44, -44,  -45,  -46,  -47,  -48,  -49,  -50,  -51,  -52,
+    -53, -54, -55, -56, -56, -57, -58,  -59,  -60,  -61,  -62,  -63,  -64,  -65,  -66,
+    -67, -68, -69, -69, -70, -71, -72,  -73,  -74,  -75,  -76,  -77,  -78,  -79,  -80,
+    -81, -82, -82, -83, -84, -85, -86,  -87,  -88,  -89,  -90,  -91,  -92,  -93,  -94,
+    -94, -95, -96, -97, -98, -99, -100, -101, -102, -103, -104, -105, -106, -107, -107,
+    -108};

 #define R 0
 #define G 1
 #define B 2
 #define A 3

-#define YCC2RGB(rgb, y, cb, cr) {\
-    int l = L[y];\
-    int r = l + CR[cr];\
-    int g = l + GR[cr] + GB[cb];\
-    int b = l + CB[cb];\
-    rgb[0] = (r <= 0) ? 0 : (r >= 255) ? 255 : r;\
-    rgb[1] = (g <= 0) ? 0 : (g >= 255) ? 255 : g;\
-    rgb[2] = (b <= 0) ? 0 : (b >= 255) ? 255 : b;\
-}
+#define YCC2RGB(rgb, y, cb, cr)                       \
+    {                                                 \
+        int l = L[y];                                 \
+        int r = l + CR[cr];                           \
+        int g = l + GR[cr] + GB[cb];                  \
+        int b = l + CB[cb];                           \
+        rgb[0] = (r <= 0) ? 0 : (r >= 255) ? 255 : r; \
+        rgb[1] = (g <= 0) ? 0 : (g >= 255) ? 255 : g; \
+        rgb[2] = (b <= 0) ? 0 : (b >= 255) ? 255 : b; \
+    }

 void
-ImagingUnpackYCC(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackYCC(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* PhotoYCC triplets */
     for (i = 0; i < pixels; i++) {
         YCC2RGB(out, in[0], in[1], in[2]);
         out[A] = 255;
-        out += 4; in += 3;
+        out += 4;
+        in += 3;
     }
 }

 void
-ImagingUnpackYCCA(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingUnpackYCCA(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* PhotoYCC triplets plus premultiplied alpha */
     for (i = 0; i < pixels; i++) {
         /* Divide by alpha */
         UINT8 rgb[3];
-        rgb[0] = (in[3] == 0) ? 0 : (((int) in[0] * 255) / in[3]);
-        rgb[1] = (in[3] == 0) ? 0 : (((int) in[1] * 255) / in[3]);
-        rgb[2] = (in[3] == 0) ? 0 : (((int) in[2] * 255) / in[3]);
+        rgb[0] = (in[3] == 0) ? 0 : (((int)in[0] * 255) / in[3]);
+        rgb[1] = (in[3] == 0) ? 0 : (((int)in[1] * 255) / in[3]);
+        rgb[2] = (in[3] == 0) ? 0 : (((int)in[2] * 255) / in[3]);
         /* Convert non-multiplied data to RGB */
         YCC2RGB(out, rgb[0], rgb[1], rgb[2]);
         out[A] = in[3];
-        out += 4; in += 4;
+        out += 4;
+        in += 4;
     }
 }
('src/libImaging', 'JpegDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,10 +21,9 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

-#ifdef  HAVE_LIBJPEG
+#ifdef HAVE_LIBJPEG

 #undef HAVE_PROTOTYPES
 #undef HAVE_STDLIB_H
@@ -37,7 +36,6 @@

 #include "Jpeg.h"

-
 #define STRINGIFY(x) #x
 #define TOSTRING(x) STRINGIFY(x)

@@ -50,20 +48,19 @@
 #endif

 int
-ImagingJpegUseJCSExtensions()
-{
+ImagingJpegUseJCSExtensions() {
     int use_jcs_extensions = 0;
-    #ifdef JCS_EXTENSIONS
-        #if defined(LIBJPEG_TURBO_VERSION_NUMBER)
-            #if LIBJPEG_TURBO_VERSION_NUMBER >= 1002010
-                use_jcs_extensions = 1;
-            #endif
-        #else
-            if (libjpeg_turbo_version) {
-                use_jcs_extensions = strcmp(libjpeg_turbo_version, "1.2.1") >= 0;
-            }
-        #endif
-    #endif
+#ifdef JCS_EXTENSIONS
+#if defined(LIBJPEG_TURBO_VERSION_NUMBER)
+#if LIBJPEG_TURBO_VERSION_NUMBER >= 1002010
+    use_jcs_extensions = 1;
+#endif
+#else
+    if (libjpeg_turbo_version) {
+        use_jcs_extensions = strcmp(libjpeg_turbo_version, "1.2.1") >= 0;
+    }
+#endif
+#endif
     return use_jcs_extensions;
 }

@@ -72,24 +69,19 @@
 /* -------------------------------------------------------------------- */

 METHODDEF(void)
-stub(j_decompress_ptr cinfo)
-{
-    /* empty */
-}
+stub(j_decompress_ptr cinfo) { /* empty */ }

 METHODDEF(boolean)
-fill_input_buffer(j_decompress_ptr cinfo)
-{
+fill_input_buffer(j_decompress_ptr cinfo) {
     /* Suspension */
     return FALSE;
 }

 METHODDEF(void)
-skip_input_data(j_decompress_ptr cinfo, long num_bytes)
-{
-    JPEGSOURCE* source = (JPEGSOURCE*) cinfo->src;
-
-    if (num_bytes > (long) source->pub.bytes_in_buffer) {
+skip_input_data(j_decompress_ptr cinfo, long num_bytes) {
+    JPEGSOURCE *source = (JPEGSOURCE *)cinfo->src;
+
+    if (num_bytes > (long)source->pub.bytes_in_buffer) {
         /* We need to skip more data than we have in the buffer.
            This will force the JPEG library to suspend decoding. */
         source->skip = num_bytes - source->pub.bytes_in_buffer;
@@ -103,50 +95,42 @@
     }
 }

-
 GLOBAL(void)
-jpeg_buffer_src(j_decompress_ptr cinfo, JPEGSOURCE* source)
-{
-  cinfo->src = (void*) source;
-
-  /* Prepare for suspending reader */
-  source->pub.init_source = stub;
-  source->pub.fill_input_buffer = fill_input_buffer;
-  source->pub.skip_input_data = skip_input_data;
-  source->pub.resync_to_restart = jpeg_resync_to_restart;
-  source->pub.term_source = stub;
-  source->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
-
-  source->skip = 0;
-}
-
+jpeg_buffer_src(j_decompress_ptr cinfo, JPEGSOURCE *source) {
+    cinfo->src = (void *)source;
+
+    /* Prepare for suspending reader */
+    source->pub.init_source = stub;
+    source->pub.fill_input_buffer = fill_input_buffer;
+    source->pub.skip_input_data = skip_input_data;
+    source->pub.resync_to_restart = jpeg_resync_to_restart;
+    source->pub.term_source = stub;
+    source->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
+
+    source->skip = 0;
+}

 /* -------------------------------------------------------------------- */
 /* Error handler                                                        */
 /* -------------------------------------------------------------------- */

 METHODDEF(void)
-error(j_common_ptr cinfo)
-{
-  JPEGERROR* error;
-  error = (JPEGERROR*) cinfo->err;
-  longjmp(error->setjmp_buffer, 1);
+error(j_common_ptr cinfo) {
+    JPEGERROR *error;
+    error = (JPEGERROR *)cinfo->err;
+    longjmp(error->setjmp_buffer, 1);
 }

 METHODDEF(void)
-output(j_common_ptr cinfo)
-{
-    /* nothing */
-}
+output(j_common_ptr cinfo) { /* nothing */ }

 /* -------------------------------------------------------------------- */
 /* Decoder                                                              */
 /* -------------------------------------------------------------------- */

 int
-ImagingJpegDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
-    JPEGSTATE* context = (JPEGSTATE*) state->context;
+ImagingJpegDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
+    JPEGSTATE *context = (JPEGSTATE *)state->context;
     int ok;

     if (setjmp(context->error.setjmp_buffer)) {
@@ -157,7 +141,6 @@
     }

     if (!state->state) {
-
         /* Setup decompression context */
         context->cinfo.err = jpeg_std_error(&context->error.pub);
         context->error.pub.error_exit = error;
@@ -167,7 +150,6 @@

         /* Ready to decode */
         state->state = 1;
-
     }

     /* Load the source buffer */
@@ -182,137 +164,137 @@
     }

     switch (state->state) {
-
-    case 1:
-
-        /* Read JPEG header, until we find an image body. */
-        do {
-
-            /* Note that we cannot return unless we have decoded
-               as much data as possible. */
-            ok = jpeg_read_header(&context->cinfo, FALSE);
-
-        } while (ok == JPEG_HEADER_TABLES_ONLY);
-
-        if (ok == JPEG_SUSPENDED) {
-            break;
-        }
-
-        /* Decoder settings */
-
-        /* jpegmode indicates whats in the file; if not set, we'll
-           trust the decoder */
-        if (strcmp(context->jpegmode, "L") == 0) {
-            context->cinfo.jpeg_color_space = JCS_GRAYSCALE;
-        } else if (strcmp(context->jpegmode, "RGB") == 0) {
-            context->cinfo.jpeg_color_space = JCS_RGB;
-        } else if (strcmp(context->jpegmode, "CMYK") == 0) {
-            context->cinfo.jpeg_color_space = JCS_CMYK;
-        } else if (strcmp(context->jpegmode, "YCbCr") == 0) {
-            context->cinfo.jpeg_color_space = JCS_YCbCr;
-        } else if (strcmp(context->jpegmode, "YCbCrK") == 0) {
-            context->cinfo.jpeg_color_space = JCS_YCCK;
-        }
-
-        /* rawmode indicates what we want from the decoder.  if not
-           set, conversions are disabled */
-        if (strcmp(context->rawmode, "L") == 0) {
-            context->cinfo.out_color_space = JCS_GRAYSCALE;
-        } else if (strcmp(context->rawmode, "RGB") == 0) {
-            context->cinfo.out_color_space = JCS_RGB;
-        }
-    #ifdef JCS_EXTENSIONS
-        else if (strcmp(context->rawmode, "RGBX") == 0) {
+        case 1:
+
+            /* Read JPEG header, until we find an image body. */
+            do {
+                /* Note that we cannot return unless we have decoded
+                   as much data as possible. */
+                ok = jpeg_read_header(&context->cinfo, FALSE);
+
+            } while (ok == JPEG_HEADER_TABLES_ONLY);
+
+            if (ok == JPEG_SUSPENDED) {
+                break;
+            }
+
+            /* Decoder settings */
+
+            /* jpegmode indicates whats in the file; if not set, we'll
+               trust the decoder */
+            if (strcmp(context->jpegmode, "L") == 0) {
+                context->cinfo.jpeg_color_space = JCS_GRAYSCALE;
+            } else if (strcmp(context->jpegmode, "RGB") == 0) {
+                context->cinfo.jpeg_color_space = JCS_RGB;
+            } else if (strcmp(context->jpegmode, "CMYK") == 0) {
+                context->cinfo.jpeg_color_space = JCS_CMYK;
+            } else if (strcmp(context->jpegmode, "YCbCr") == 0) {
+                context->cinfo.jpeg_color_space = JCS_YCbCr;
+            } else if (strcmp(context->jpegmode, "YCbCrK") == 0) {
+                context->cinfo.jpeg_color_space = JCS_YCCK;
+            }
+
+            /* rawmode indicates what we want from the decoder.  if not
+               set, conversions are disabled */
+            if (strcmp(context->rawmode, "L") == 0) {
+                context->cinfo.out_color_space = JCS_GRAYSCALE;
+            } else if (strcmp(context->rawmode, "RGB") == 0) {
+                context->cinfo.out_color_space = JCS_RGB;
+            }
+#ifdef JCS_EXTENSIONS
+            else if (strcmp(context->rawmode, "RGBX") == 0) {
                 context->cinfo.out_color_space = JCS_EXT_RGBX;
-        }
-    #endif
-        else if (strcmp(context->rawmode, "CMYK") == 0 ||
-                 strcmp(context->rawmode, "CMYK;I") == 0) {
-            context->cinfo.out_color_space = JCS_CMYK;
-        } else if (strcmp(context->rawmode, "YCbCr") == 0) {
-            context->cinfo.out_color_space = JCS_YCbCr;
-        } else if (strcmp(context->rawmode, "YCbCrK") == 0) {
-            context->cinfo.out_color_space = JCS_YCCK;
-        } else {
-            /* Disable decoder conversions */
-            context->cinfo.jpeg_color_space = JCS_UNKNOWN;
-            context->cinfo.out_color_space = JCS_UNKNOWN;
-        }
-
-        if (context->scale > 1) {
-            context->cinfo.scale_num = 1;
-            context->cinfo.scale_denom = context->scale;
-        }
-        if (context->draft) {
-            context->cinfo.do_fancy_upsampling = FALSE;
-            context->cinfo.dct_method = JDCT_FASTEST;
-        }
-
-        state->state++;
-        /* fall through */
-
-    case 2:
-
-        /* Set things up for decompression (this processes the entire
-           file if necessary to return data line by line) */
-        if (!jpeg_start_decompress(&context->cinfo)) {
-            break;
-        }
-
-        state->state++;
-        /* fall through */
-
-    case 3:
-
-        /* Decompress a single line of data */
-        ok = 1;
-        while (state->y < state->ysize) {
-            ok = jpeg_read_scanlines(&context->cinfo, &state->buffer, 1);
+            }
+#endif
+            else if (
+                strcmp(context->rawmode, "CMYK") == 0 ||
+                strcmp(context->rawmode, "CMYK;I") == 0) {
+                context->cinfo.out_color_space = JCS_CMYK;
+            } else if (strcmp(context->rawmode, "YCbCr") == 0) {
+                context->cinfo.out_color_space = JCS_YCbCr;
+            } else if (strcmp(context->rawmode, "YCbCrK") == 0) {
+                context->cinfo.out_color_space = JCS_YCCK;
+            } else {
+                /* Disable decoder conversions */
+                context->cinfo.jpeg_color_space = JCS_UNKNOWN;
+                context->cinfo.out_color_space = JCS_UNKNOWN;
+            }
+
+            if (context->scale > 1) {
+                context->cinfo.scale_num = 1;
+                context->cinfo.scale_denom = context->scale;
+            }
+            if (context->draft) {
+                context->cinfo.do_fancy_upsampling = FALSE;
+                context->cinfo.dct_method = JDCT_FASTEST;
+            }
+
+            state->state++;
+            /* fall through */
+
+        case 2:
+
+            /* Set things up for decompression (this processes the entire
+               file if necessary to return data line by line) */
+            if (!jpeg_start_decompress(&context->cinfo)) {
+                break;
+            }
+
+            state->state++;
+            /* fall through */
+
+        case 3:
+
+            /* Decompress a single line of data */
+            ok = 1;
+            while (state->y < state->ysize) {
+                ok = jpeg_read_scanlines(&context->cinfo, &state->buffer, 1);
+                if (ok != 1) {
+                    break;
+                }
+                state->shuffle(
+                    (UINT8 *)im->image[state->y + state->yoff] +
+                        state->xoff * im->pixelsize,
+                    state->buffer,
+                    state->xsize);
+                state->y++;
+            }
             if (ok != 1) {
                 break;
             }
-            state->shuffle((UINT8*) im->image[state->y + state->yoff] +
-                           state->xoff * im->pixelsize, state->buffer,
-                           state->xsize);
-            state->y++;
-        }
-        if (ok != 1) {
-            break;
-        }
-        state->state++;
-        /* fall through */
-
-    case 4:
-
-        /* Finish decompression */
-        if (!jpeg_finish_decompress(&context->cinfo)) {
-            /* FIXME: add strictness mode test */
-            if (state->y < state->ysize) {
-                break;
-            }
-        }
-
-        /* Clean up */
-        jpeg_destroy_decompress(&context->cinfo);
-        /* if (jerr.pub.num_warnings) return BROKEN; */
-        return -1;
-
+            state->state++;
+            /* fall through */
+
+        case 4:
+
+            /* Finish decompression */
+            if (!jpeg_finish_decompress(&context->cinfo)) {
+                /* FIXME: add strictness mode test */
+                if (state->y < state->ysize) {
+                    break;
+                }
+            }
+
+            /* Clean up */
+            jpeg_destroy_decompress(&context->cinfo);
+            /* if (jerr.pub.num_warnings) return BROKEN; */
+            return -1;
     }

     /* Return number of bytes consumed */
     return context->source.pub.next_input_byte - buf;
-
 }

 /* -------------------------------------------------------------------- */
 /* Cleanup                                                              */
 /* -------------------------------------------------------------------- */

-int ImagingJpegDecodeCleanup(ImagingCodecState state){
+int
+ImagingJpegDecodeCleanup(ImagingCodecState state) {
     /* called to free the decompression engine when the decode terminates
        due to a corrupt or truncated image
     */
-    JPEGSTATE* context = (JPEGSTATE*) state->context;
+    JPEGSTATE *context = (JPEGSTATE *)state->context;

     /* Clean up */
     jpeg_destroy_decompress(&context->cinfo);
@@ -320,4 +302,3 @@
 }

 #endif
-
('src/libImaging', 'QuantHash.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -18,23 +18,38 @@
 typedef Pixel HashKey_t;
 typedef uint32_t HashVal_t;

-typedef uint32_t (*HashFunc)(const HashTable *,const HashKey_t);
-typedef int (*HashCmpFunc)(const HashTable *,const HashKey_t,const HashKey_t);
-typedef void (*IteratorFunc)(const HashTable *,const HashKey_t,const HashVal_t,void *);
-typedef void (*IteratorUpdateFunc)(const HashTable *,const HashKey_t,HashVal_t *,void *);
-typedef void (*ComputeFunc)(const HashTable *,const HashKey_t,HashVal_t *);
-typedef void (*CollisionFunc)(const HashTable *,HashKey_t *,HashVal_t *,HashKey_t,HashVal_t);
+typedef uint32_t (*HashFunc)(const HashTable *, const HashKey_t);
+typedef int (*HashCmpFunc)(const HashTable *, const HashKey_t, const HashKey_t);
+typedef void (*IteratorFunc)(
+    const HashTable *, const HashKey_t, const HashVal_t, void *);
+typedef void (*IteratorUpdateFunc)(
+    const HashTable *, const HashKey_t, HashVal_t *, void *);
+typedef void (*ComputeFunc)(const HashTable *, const HashKey_t, HashVal_t *);
+typedef void (*CollisionFunc)(
+    const HashTable *, HashKey_t *, HashVal_t *, HashKey_t, HashVal_t);

-HashTable * hashtable_new(HashFunc hf,HashCmpFunc cf);
-void hashtable_free(HashTable *h);
-void hashtable_foreach(HashTable *h,IteratorFunc i,void *u);
-void hashtable_foreach_update(HashTable *h,IteratorUpdateFunc i,void *u);
-int hashtable_insert(HashTable *h,HashKey_t key,HashVal_t val);
-int hashtable_lookup(const HashTable *h,const HashKey_t key,HashVal_t *valp);
-int hashtable_insert_or_update_computed(HashTable *h,HashKey_t key,ComputeFunc newFunc,ComputeFunc existsFunc);
-void *hashtable_set_user_data(HashTable *h,void *data);
-void *hashtable_get_user_data(const HashTable *h);
-uint32_t hashtable_get_count(const HashTable *h);
-void hashtable_rehash_compute(HashTable *h,CollisionFunc cf);
+HashTable *
+hashtable_new(HashFunc hf, HashCmpFunc cf);
+void
+hashtable_free(HashTable *h);
+void
+hashtable_foreach(HashTable *h, IteratorFunc i, void *u);
+void
+hashtable_foreach_update(HashTable *h, IteratorUpdateFunc i, void *u);
+int
+hashtable_insert(HashTable *h, HashKey_t key, HashVal_t val);
+int
+hashtable_lookup(const HashTable *h, const HashKey_t key, HashVal_t *valp);
+int
+hashtable_insert_or_update_computed(
+    HashTable *h, HashKey_t key, ComputeFunc newFunc, ComputeFunc existsFunc);
+void *
+hashtable_set_user_data(HashTable *h, void *data);
+void *
+hashtable_get_user_data(const HashTable *h);
+uint32_t
+hashtable_get_count(const HashTable *h);
+void
+hashtable_rehash_compute(HashTable *h, CollisionFunc cf);

-#endif // __QUANTHASH_H__
+#endif  // __QUANTHASH_H__
('src/libImaging', 'Pack.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
- /*
+/*
  * The Python Imaging Library.
  * $Id$
  *
@@ -25,7 +25,6 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #define R 0
@@ -41,20 +40,28 @@

 /* byte swapping macros */

-#define C16N\
-        (out[0]=tmp[0], out[1]=tmp[1]);
-#define C16S\
-        (out[1]=tmp[0], out[0]=tmp[1]);
-#define C32N\
-        (out[0]=tmp[0], out[1]=tmp[1], out[2]=tmp[2], out[3]=tmp[3]);
-#define C32S\
-        (out[3]=tmp[0], out[2]=tmp[1], out[1]=tmp[2], out[0]=tmp[3]);
-#define C64N\
-        (out[0]=tmp[0], out[1]=tmp[1], out[2]=tmp[2], out[3]=tmp[3],\
-         out[4]=tmp[4], out[5]=tmp[5], out[6]=tmp[6], out[7]=tmp[7]);
-#define C64S\
-        (out[7]=tmp[0], out[6]=tmp[1], out[5]=tmp[2], out[4]=tmp[3],\
-         out[3]=tmp[4], out[2]=tmp[5], out[1]=tmp[6], out[0]=tmp[7]);
+#define C16N (out[0] = tmp[0], out[1] = tmp[1]);
+#define C16S (out[1] = tmp[0], out[0] = tmp[1]);
+#define C32N (out[0] = tmp[0], out[1] = tmp[1], out[2] = tmp[2], out[3] = tmp[3]);
+#define C32S (out[3] = tmp[0], out[2] = tmp[1], out[1] = tmp[2], out[0] = tmp[3]);
+#define C64N          \
+    (out[0] = tmp[0], \
+     out[1] = tmp[1], \
+     out[2] = tmp[2], \
+     out[3] = tmp[3], \
+     out[4] = tmp[4], \
+     out[5] = tmp[5], \
+     out[6] = tmp[6], \
+     out[7] = tmp[7]);
+#define C64S          \
+    (out[7] = tmp[0], \
+     out[6] = tmp[1], \
+     out[5] = tmp[2], \
+     out[4] = tmp[3], \
+     out[3] = tmp[4], \
+     out[2] = tmp[5], \
+     out[1] = tmp[6], \
+     out[0] = tmp[7]);

 #ifdef WORDS_BIGENDIAN
 #define C16B C16N
@@ -72,13 +79,12 @@
 #define C64L C64N
 #endif

-
-static void
-pack1(UINT8* out, const UINT8* in, int pixels)
-{
+static void
+pack1(UINT8 *out, const UINT8 *in, int pixels) {
     int i, m, b;
     /* bilevel (black is 0) */
-    b = 0; m = 128;
+    b = 0;
+    m = 128;
     for (i = 0; i < pixels; i++) {
         if (in[i] != 0) {
             b |= m;
@@ -86,7 +92,8 @@
         m >>= 1;
         if (m == 0) {
             *out++ = b;
-            b = 0; m = 128;
+            b = 0;
+            m = 128;
         }
     }
     if (m != 128) {
@@ -95,11 +102,11 @@
 }

 static void
-pack1I(UINT8* out, const UINT8* in, int pixels)
-{
+pack1I(UINT8 *out, const UINT8 *in, int pixels) {
     int i, m, b;
     /* bilevel (black is 1) */
-    b = 0; m = 128;
+    b = 0;
+    m = 128;
     for (i = 0; i < pixels; i++) {
         if (in[i] == 0) {
             b |= m;
@@ -107,7 +114,8 @@
         m >>= 1;
         if (m == 0) {
             *out++ = b;
-            b = 0; m = 128;
+            b = 0;
+            m = 128;
         }
     }
     if (m != 128) {
@@ -116,19 +124,20 @@
 }

 static void
-pack1R(UINT8* out, const UINT8* in, int pixels)
-{
+pack1R(UINT8 *out, const UINT8 *in, int pixels) {
     int i, m, b;
     /* bilevel, lsb first (black is 0) */
-    b = 0; m = 1;
+    b = 0;
+    m = 1;
     for (i = 0; i < pixels; i++) {
         if (in[i] != 0) {
             b |= m;
         }
         m <<= 1;
-        if (m == 256){
+        if (m == 256) {
             *out++ = b;
-            b = 0; m = 1;
+            b = 0;
+            m = 1;
         }
     }
     if (m != 1) {
@@ -137,19 +146,20 @@
 }

 static void
-pack1IR(UINT8* out, const UINT8* in, int pixels)
-{
+pack1IR(UINT8 *out, const UINT8 *in, int pixels) {
     int i, m, b;
     /* bilevel, lsb first (black is 1) */
-    b = 0; m = 1;
+    b = 0;
+    m = 1;
     for (i = 0; i < pixels; i++) {
         if (in[i] == 0) {
             b |= m;
         }
         m <<= 1;
-        if (m == 256){
+        if (m == 256) {
             *out++ = b;
-            b = 0; m = 1;
+            b = 0;
+            m = 1;
         }
     }
     if (m != 1) {
@@ -158,8 +168,7 @@
 }

 static void
-pack1L(UINT8* out, const UINT8* in, int pixels)
-{
+pack1L(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* bilevel, stored as bytes */
     for (i = 0; i < pixels; i++) {
@@ -168,12 +177,11 @@
 }

 static void
-packP4(UINT8* out, const UINT8* in, int pixels)
-{
+packP4(UINT8 *out, const UINT8 *in, int pixels) {
     while (pixels >= 2) {
-        *out++ = (in[0] << 4) |
-                 (in[1] & 15);
-        in += 2; pixels -= 2;
+        *out++ = (in[0] << 4) | (in[1] & 15);
+        in += 2;
+        pixels -= 2;
     }

     if (pixels) {
@@ -182,34 +190,27 @@
 }

 static void
-packP2(UINT8* out, const UINT8* in, int pixels)
-{
+packP2(UINT8 *out, const UINT8 *in, int pixels) {
     while (pixels >= 4) {
-        *out++ = (in[0] << 6) |
-                 ((in[1] & 3) << 4) |
-                 ((in[2] & 3) << 2) |
-                 (in[3] & 3);
-        in += 4; pixels -= 4;
+        *out++ = (in[0] << 6) | ((in[1] & 3) << 4) | ((in[2] & 3) << 2) | (in[3] & 3);
+        in += 4;
+        pixels -= 4;
     }

     switch (pixels) {
-    case 3:
-        out[0] = (in[0] << 6) |
-                 ((in[1] & 3) << 4) |
-                 ((in[2] & 3) << 2);
-        break;
-    case 2:
-        out[0] = (in[0] << 6) |
-                 ((in[1] & 3) << 4);
-        break;
-    case 1:
-        out[0] = (in[0] << 6);
-    }
-}
-
-static void
-packL16(UINT8* out, const UINT8* in, int pixels)
-{
+        case 3:
+            out[0] = (in[0] << 6) | ((in[1] & 3) << 4) | ((in[2] & 3) << 2);
+            break;
+        case 2:
+            out[0] = (in[0] << 6) | ((in[1] & 3) << 4);
+            break;
+        case 1:
+            out[0] = (in[0] << 6);
+    }
+}
+
+static void
+packL16(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* L -> L;16, e.g: \xff77 -> \x00\xff\x00\x77 */
     for (i = 0; i < pixels; i++) {
@@ -220,8 +221,7 @@
 }

 static void
-packL16B(UINT8* out, const UINT8* in, int pixels)
-{
+packL16B(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* L -> L;16B, e.g: \xff77 -> \xff\x00\x77\x00 */
     for (i = 0; i < pixels; i++) {
@@ -231,34 +231,31 @@
     }
 }

-
-static void
-packLA(UINT8* out, const UINT8* in, int pixels)
-{
+static void
+packLA(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* LA, pixel interleaved */
     for (i = 0; i < pixels; i++) {
         out[0] = in[R];
         out[1] = in[A];
-        out += 2; in += 4;
-    }
-}
-
-static void
-packLAL(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 2;
+        in += 4;
+    }
+}
+
+static void
+packLAL(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* LA, line interleaved */
     for (i = 0; i < pixels; i++) {
         out[i] = in[R];
-        out[i+pixels] = in[A];
-        in += 4;
-    }
-}
-
-void
-ImagingPackRGB(UINT8* out, const UINT8* in, int pixels)
-{
+        out[i + pixels] = in[A];
+        in += 4;
+    }
+}
+
+void
+ImagingPackRGB(UINT8 *out, const UINT8 *in, int pixels) {
     int i = 0;
     /* RGB triplets */
 #ifdef __sparc
@@ -267,25 +264,25 @@
         out[0] = in[R];
         out[1] = in[G];
         out[2] = in[B];
-        out += 3; in += 4;
+        out += 3;
+        in += 4;
     }
 #else
-    for (; i < pixels-1; i++) {
+    for (; i < pixels - 1; i++) {
         memcpy(out, in + i * 4, 4);
         out += 3;
     }
     for (; i < pixels; i++) {
-        out[0] = in[i*4+R];
-        out[1] = in[i*4+G];
-        out[2] = in[i*4+B];
+        out[0] = in[i * 4 + R];
+        out[1] = in[i * 4 + G];
+        out[2] = in[i * 4 + B];
         out += 3;
     }
 #endif
 }

 void
-ImagingPackXRGB(UINT8* out, const UINT8* in, int pixels)
-{
+ImagingPackXRGB(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* XRGB, triplets with left padding */
     for (i = 0; i < pixels; i++) {
@@ -293,26 +290,26 @@
         out[1] = in[R];
         out[2] = in[G];
         out[3] = in[B];
-        out += 4; in += 4;
-    }
-}
-
-void
-ImagingPackBGR(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 4;
+        in += 4;
+    }
+}
+
+void
+ImagingPackBGR(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, reversed bytes */
     for (i = 0; i < pixels; i++) {
         out[0] = in[B];
         out[1] = in[G];
         out[2] = in[R];
-        out += 3; in += 4;
-    }
-}
-
-void
-ImagingPackBGRX(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 3;
+        in += 4;
+    }
+}
+
+void
+ImagingPackBGRX(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* BGRX, reversed bytes with right padding */
     for (i = 0; i < pixels; i++) {
@@ -320,13 +317,13 @@
         out[1] = in[G];
         out[2] = in[R];
         out[3] = 0;
-        out += 4; in += 4;
-    }
-}
-
-void
-ImagingPackXBGR(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 4;
+        in += 4;
+    }
+}
+
+void
+ImagingPackXBGR(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* XBGR, reversed bytes with left padding */
     for (i = 0; i < pixels; i++) {
@@ -334,13 +331,13 @@
         out[1] = in[B];
         out[2] = in[G];
         out[3] = in[R];
-        out += 4; in += 4;
-    }
-}
-
-void
-ImagingPackBGRA(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 4;
+        in += 4;
+    }
+}
+
+void
+ImagingPackBGRA(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* BGRX, reversed bytes with right padding */
     for (i = 0; i < pixels; i++) {
@@ -348,13 +345,13 @@
         out[1] = in[G];
         out[2] = in[R];
         out[3] = in[A];
-        out += 4; in += 4;
-    }
-}
-
-void
-ImagingPackABGR(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 4;
+        in += 4;
+    }
+}
+
+void
+ImagingPackABGR(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* XBGR, reversed bytes with left padding */
     for (i = 0; i < pixels; i++) {
@@ -362,13 +359,13 @@
         out[1] = in[B];
         out[2] = in[G];
         out[3] = in[R];
-        out += 4; in += 4;
-    }
-}
-
-void
-ImagingPackBGRa(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 4;
+        in += 4;
+    }
+}
+
+void
+ImagingPackBGRa(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* BGRa, reversed bytes with premultiplied alpha */
     for (i = 0; i < pixels; i++) {
@@ -377,43 +374,41 @@
         out[0] = MULDIV255(in[B], alpha, tmp);
         out[1] = MULDIV255(in[G], alpha, tmp);
         out[2] = MULDIV255(in[R], alpha, tmp);
-        out += 4; in += 4;
-    }
-}
-
-static void
-packRGBL(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 4;
+        in += 4;
+    }
+}
+
+static void
+packRGBL(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* RGB, line interleaved */
     for (i = 0; i < pixels; i++) {
         out[i] = in[R];
-        out[i+pixels] = in[G];
-        out[i+pixels+pixels] = in[B];
-        in += 4;
-    }
-}
-
-static void
-packRGBXL(UINT8* out, const UINT8* in, int pixels)
-{
+        out[i + pixels] = in[G];
+        out[i + pixels + pixels] = in[B];
+        in += 4;
+    }
+}
+
+static void
+packRGBXL(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* RGBX, line interleaved */
     for (i = 0; i < pixels; i++) {
         out[i] = in[R];
-        out[i+pixels] = in[G];
-        out[i+pixels+pixels] = in[B];
-        out[i+pixels+pixels+pixels] = in[X];
-        in += 4;
-    }
-}
-
-static void
-packI16B(UINT8* out, const UINT8* in_, int pixels)
-{
+        out[i + pixels] = in[G];
+        out[i + pixels + pixels] = in[B];
+        out[i + pixels + pixels + pixels] = in[X];
+        in += 4;
+    }
+}
+
+static void
+packI16B(UINT8 *out, const UINT8 *in_, int pixels) {
     int i;
     UINT16 tmp_;
-    UINT8* tmp = (UINT8*) &tmp_;
+    UINT8 *tmp = (UINT8 *)&tmp_;
     for (i = 0; i < pixels; i++) {
         INT32 in;
         memcpy(&in, in_, sizeof(in));
@@ -425,96 +420,91 @@
             tmp_ = in;
         }
         C16B;
-        out += 2; in_ += sizeof(in);
-    }
-}
-
-static void
-packI16N_I16B(UINT8* out, const UINT8* in, int pixels){
-    int i;
-    UINT8* tmp = (UINT8*) in;
+        out += 2;
+        in_ += sizeof(in);
+    }
+}
+
+static void
+packI16N_I16B(UINT8 *out, const UINT8 *in, int pixels) {
+    int i;
+    UINT8 *tmp = (UINT8 *)in;
     for (i = 0; i < pixels; i++) {
         C16B;
-        out += 2; tmp += 2;
-    }
-
-}
-static void
-packI16N_I16(UINT8* out, const UINT8* in, int pixels){
-    int i;
-    UINT8* tmp = (UINT8*) in;
+        out += 2;
+        tmp += 2;
+    }
+}
+static void
+packI16N_I16(UINT8 *out, const UINT8 *in, int pixels) {
+    int i;
+    UINT8 *tmp = (UINT8 *)in;
     for (i = 0; i < pixels; i++) {
         C16L;
-        out += 2; tmp += 2;
-    }
-}
-
-
-static void
-packI32S(UINT8* out, const UINT8* in, int pixels)
-{
-    int i;
-    UINT8* tmp = (UINT8*) in;
+        out += 2;
+        tmp += 2;
+    }
+}
+
+static void
+packI32S(UINT8 *out, const UINT8 *in, int pixels) {
+    int i;
+    UINT8 *tmp = (UINT8 *)in;
     for (i = 0; i < pixels; i++) {
         C32L;
-        out += 4; tmp += 4;
-    }
-}
-
-void
-ImagingPackLAB(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 4;
+        tmp += 4;
+    }
+}
+
+void
+ImagingPackLAB(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     /* LAB triplets */
     for (i = 0; i < pixels; i++) {
         out[0] = in[0];
         out[1] = in[1] ^ 128; /* signed in outside world */
         out[2] = in[2] ^ 128;
-        out += 3; in += 4;
-    }
-}
-
-static void
-copy1(UINT8* out, const UINT8* in, int pixels)
-{
+        out += 3;
+        in += 4;
+    }
+}
+
+static void
+copy1(UINT8 *out, const UINT8 *in, int pixels) {
     /* L, P */
     memcpy(out, in, pixels);
 }

 static void
-copy2(UINT8* out, const UINT8* in, int pixels)
-{
+copy2(UINT8 *out, const UINT8 *in, int pixels) {
     /* I;16, etc */
-    memcpy(out, in, pixels*2);
-}
-
-static void
-copy3(UINT8* out, const UINT8* in, int pixels)
-{
+    memcpy(out, in, pixels * 2);
+}
+
+static void
+copy3(UINT8 *out, const UINT8 *in, int pixels) {
     /* BGR;24, etc */
-    memcpy(out, in, pixels*3);
-}
-
-static void
-copy4(UINT8* out, const UINT8* in, int pixels)
-{
+    memcpy(out, in, pixels * 3);
+}
+
+static void
+copy4(UINT8 *out, const UINT8 *in, int pixels) {
     /* RGBA, CMYK quadruples */
-    memcpy(out, in, 4*pixels);
-}
-
-static void
-copy4I(UINT8* out, const UINT8* in, int pixels)
-{
+    memcpy(out, in, 4 * pixels);
+}
+
+static void
+copy4I(UINT8 *out, const UINT8 *in, int pixels) {
     /* RGBA, CMYK quadruples, inverted */
     int i;
-    for (i = 0; i < pixels*4; i++) {
+    for (i = 0; i < pixels * 4; i++) {
         out[i] = ~in[i];
     }
 }

 static void
-band0(UINT8* out, const UINT8* in, int pixels)
-{
+band0(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     for (i = 0; i < pixels; i++, in += 4) {
         out[i] = in[0];
@@ -522,8 +512,7 @@
 }

 static void
-band1(UINT8* out, const UINT8* in, int pixels)
-{
+band1(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     for (i = 0; i < pixels; i++, in += 4) {
         out[i] = in[1];
@@ -531,8 +520,7 @@
 }

 static void
-band2(UINT8* out, const UINT8* in, int pixels)
-{
+band2(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     for (i = 0; i < pixels; i++, in += 4) {
         out[i] = in[2];
@@ -540,8 +528,7 @@
 }

 static void
-band3(UINT8* out, const UINT8* in, int pixels)
-{
+band3(UINT8 *out, const UINT8 *in, int pixels) {
     int i;
     for (i = 0; i < pixels; i++, in += 4) {
         out[i] = in[3];
@@ -549,143 +536,146 @@
 }

 static struct {
-    const char* mode;
-    const char* rawmode;
+    const char *mode;
+    const char *rawmode;
     int bits;
     ImagingShuffler pack;
 } packers[] = {

     /* bilevel */
-    {"1",       "1",            1,      pack1},
-    {"1",       "1;I",          1,      pack1I},
-    {"1",       "1;R",          1,      pack1R},
-    {"1",       "1;IR",         1,      pack1IR},
-    {"1",       "L",            8,      pack1L},
+    {"1", "1", 1, pack1},
+    {"1", "1;I", 1, pack1I},
+    {"1", "1;R", 1, pack1R},
+    {"1", "1;IR", 1, pack1IR},
+    {"1", "L", 8, pack1L},

     /* greyscale */
-    {"L",       "L",            8,      copy1},
-    {"L",       "L;16",         16,     packL16},
-    {"L",       "L;16B",        16,     packL16B},
+    {"L", "L", 8, copy1},
+    {"L", "L;16", 16, packL16},
+    {"L", "L;16B", 16, packL16B},

     /* greyscale w. alpha */
-    {"LA",      "LA",           16,     packLA},
-    {"LA",      "LA;L",         16,     packLAL},
+    {"LA", "LA", 16, packLA},
+    {"LA", "LA;L", 16, packLAL},

     /* greyscale w. alpha premultiplied */
-    {"La",      "La",           16,     packLA},
+    {"La", "La", 16, packLA},

     /* palette */
-    {"P",       "P;1",          1,      pack1},
-    {"P",       "P;2",          2,      packP2},
-    {"P",       "P;4",          4,      packP4},
-    {"P",       "P",            8,      copy1},
+    {"P", "P;1", 1, pack1},
+    {"P", "P;2", 2, packP2},
+    {"P", "P;4", 4, packP4},
+    {"P", "P", 8, copy1},

     /* palette w. alpha */
-    {"PA",      "PA",           16,     packLA},
-    {"PA",      "PA;L",         16,     packLAL},
+    {"PA", "PA", 16, packLA},
+    {"PA", "PA;L", 16, packLAL},

     /* true colour */
-    {"RGB",     "RGB",          24,     ImagingPackRGB},
-    {"RGB",     "RGBX",         32,     copy4},
-    {"RGB",     "XRGB",         32,     ImagingPackXRGB},
-    {"RGB",     "BGR",          24,     ImagingPackBGR},
-    {"RGB",     "BGRX",         32,     ImagingPackBGRX},
-    {"RGB",     "XBGR",         32,     ImagingPackXBGR},
-    {"RGB",     "RGB;L",        24,     packRGBL},
-    {"RGB",     "R",            8,      band0},
-    {"RGB",     "G",            8,      band1},
-    {"RGB",     "B",            8,      band2},
+    {"RGB", "RGB", 24, ImagingPackRGB},
+    {"RGB", "RGBX", 32, copy4},
+    {"RGB", "RGBA", 32, copy4},
+    {"RGB", "XRGB", 32, ImagingPackXRGB},
+    {"RGB", "BGR", 24, ImagingPackBGR},
+    {"RGB", "BGRX", 32, ImagingPackBGRX},
+    {"RGB", "XBGR", 32, ImagingPackXBGR},
+    {"RGB", "RGB;L", 24, packRGBL},
+    {"RGB", "R", 8, band0},
+    {"RGB", "G", 8, band1},
+    {"RGB", "B", 8, band2},

     /* true colour w. alpha */
-    {"RGBA",    "RGBA",         32,     copy4},
-    {"RGBA",    "RGBA;L",       32,     packRGBXL},
-    {"RGBA",    "RGB",          24,     ImagingPackRGB},
-    {"RGBA",    "BGR",          24,     ImagingPackBGR},
-    {"RGBA",    "BGRA",         32,     ImagingPackBGRA},
-    {"RGBA",    "ABGR",         32,     ImagingPackABGR},
-    {"RGBA",    "BGRa",         32,     ImagingPackBGRa},
-    {"RGBA",    "R",            8,      band0},
-    {"RGBA",    "G",            8,      band1},
-    {"RGBA",    "B",            8,      band2},
-    {"RGBA",    "A",            8,      band3},
+    {"RGBA", "RGBA", 32, copy4},
+    {"RGBA", "RGBA;L", 32, packRGBXL},
+    {"RGBA", "RGB", 24, ImagingPackRGB},
+    {"RGBA", "BGR", 24, ImagingPackBGR},
+    {"RGBA", "BGRA", 32, ImagingPackBGRA},
+    {"RGBA", "ABGR", 32, ImagingPackABGR},
+    {"RGBA", "BGRa", 32, ImagingPackBGRa},
+    {"RGBA", "R", 8, band0},
+    {"RGBA", "G", 8, band1},
+    {"RGBA", "B", 8, band2},
+    {"RGBA", "A", 8, band3},

     /* true colour w. alpha premultiplied */
-    {"RGBa",    "RGBa",         32,     copy4},
-    {"RGBa",    "BGRa",         32,     ImagingPackBGRA},
-    {"RGBa",    "aBGR",         32,     ImagingPackABGR},
+    {"RGBa", "RGBa", 32, copy4},
+    {"RGBa", "BGRa", 32, ImagingPackBGRA},
+    {"RGBa", "aBGR", 32, ImagingPackABGR},

     /* true colour w. padding */
-    {"RGBX",    "RGBX",         32,     copy4},
-    {"RGBX",    "RGBX;L",       32,     packRGBXL},
-    {"RGBX",    "RGB",          24,     ImagingPackRGB},
-    {"RGBX",    "BGR",          24,     ImagingPackBGR},
-    {"RGBX",    "BGRX",         32,     ImagingPackBGRX},
-    {"RGBX",    "XBGR",         32,     ImagingPackXBGR},
-    {"RGBX",    "R",            8,      band0},
-    {"RGBX",    "G",            8,      band1},
-    {"RGBX",    "B",            8,      band2},
-    {"RGBX",    "X",            8,      band3},
+    {"RGBX", "RGBX", 32, copy4},
+    {"RGBX", "RGBX;L", 32, packRGBXL},
+    {"RGBX", "RGB", 24, ImagingPackRGB},
+    {"RGBX", "BGR", 24, ImagingPackBGR},
+    {"RGBX", "BGRX", 32, ImagingPackBGRX},
+    {"RGBX", "XBGR", 32, ImagingPackXBGR},
+    {"RGBX", "R", 8, band0},
+    {"RGBX", "G", 8, band1},
+    {"RGBX", "B", 8, band2},
+    {"RGBX", "X", 8, band3},

     /* colour separation */
-    {"CMYK",    "CMYK",         32,     copy4},
-    {"CMYK",    "CMYK;I",       32,     copy4I},
-    {"CMYK",    "CMYK;L",       32,     packRGBXL},
-    {"CMYK",    "C",            8,      band0},
-    {"CMYK",    "M",            8,      band1},
-    {"CMYK",    "Y",            8,      band2},
-    {"CMYK",    "K",            8,      band3},
+    {"CMYK", "CMYK", 32, copy4},
+    {"CMYK", "CMYK;I", 32, copy4I},
+    {"CMYK", "CMYK;L", 32, packRGBXL},
+    {"CMYK", "C", 8, band0},
+    {"CMYK", "M", 8, band1},
+    {"CMYK", "Y", 8, band2},
+    {"CMYK", "K", 8, band3},

     /* video (YCbCr) */
-    {"YCbCr",   "YCbCr",        24,     ImagingPackRGB},
-    {"YCbCr",   "YCbCr;L",      24,     packRGBL},
-    {"YCbCr",   "YCbCrX",       32,     copy4},
-    {"YCbCr",   "YCbCrK",       32,     copy4},
-    {"YCbCr",   "Y",            8,      band0},
-    {"YCbCr",   "Cb",           8,      band1},
-    {"YCbCr",   "Cr",           8,      band2},
+    {"YCbCr", "YCbCr", 24, ImagingPackRGB},
+    {"YCbCr", "YCbCr;L", 24, packRGBL},
+    {"YCbCr", "YCbCrX", 32, copy4},
+    {"YCbCr", "YCbCrK", 32, copy4},
+    {"YCbCr", "Y", 8, band0},
+    {"YCbCr", "Cb", 8, band1},
+    {"YCbCr", "Cr", 8, band2},

     /* LAB Color */
-    {"LAB",     "LAB",         24,     ImagingPackLAB},
-    {"LAB",     "L",           8,      band0},
-    {"LAB",     "A",           8,      band1},
-    {"LAB",     "B",           8,      band2},
+    {"LAB", "LAB", 24, ImagingPackLAB},
+    {"LAB", "L", 8, band0},
+    {"LAB", "A", 8, band1},
+    {"LAB", "B", 8, band2},

     /* HSV */
-    {"HSV",     "HSV",         24,     ImagingPackRGB},
-    {"HSV",     "H",           8,      band0},
-    {"HSV",     "S",           8,      band1},
-    {"HSV",     "V",           8,      band2},
+    {"HSV", "HSV", 24, ImagingPackRGB},
+    {"HSV", "H", 8, band0},
+    {"HSV", "S", 8, band1},
+    {"HSV", "V", 8, band2},

     /* integer */
-    {"I",       "I",            32,     copy4},
-    {"I",       "I;16B",        16,     packI16B},
-    {"I",       "I;32S",        32,     packI32S},
-    {"I",       "I;32NS",       32,     copy4},
+    {"I", "I", 32, copy4},
+    {"I", "I;16B", 16, packI16B},
+    {"I", "I;32S", 32, packI32S},
+    {"I", "I;32NS", 32, copy4},

     /* floating point */
-    {"F",       "F",            32,     copy4},
-    {"F",       "F;32F",        32,     packI32S},
-    {"F",       "F;32NF",       32,     copy4},
+    {"F", "F", 32, copy4},
+    {"F", "F;32F", 32, packI32S},
+    {"F", "F;32NF", 32, copy4},

     /* storage modes */
-    {"I;16",    "I;16",         16,     copy2},
-    {"I;16",    "I;16B",        16,     packI16N_I16B},
-    {"I;16B",   "I;16B",        16,     copy2},
-    {"I;16L",   "I;16L",        16,     copy2},
-    {"I;16",    "I;16N",        16,     packI16N_I16}, // LibTiff native->image endian.
-    {"I;16L",   "I;16N",        16,     packI16N_I16},
-    {"I;16B",   "I;16N",        16,     packI16N_I16B},
-    {"BGR;15",  "BGR;15",       16,     copy2},
-    {"BGR;16",  "BGR;16",       16,     copy2},
-    {"BGR;24",  "BGR;24",       24,     copy3},
+    {"I;16", "I;16", 16, copy2},
+#ifdef WORDS_BIGENDIAN
+    {"I;16", "I;16B", 16, packI16N_I16},
+#else
+    {"I;16", "I;16B", 16, packI16N_I16B},
+#endif
+    {"I;16B", "I;16B", 16, copy2},
+    {"I;16L", "I;16L", 16, copy2},
+    {"I;16", "I;16N", 16, packI16N_I16},  // LibTiff native->image endian.
+    {"I;16L", "I;16N", 16, packI16N_I16},
+    {"I;16B", "I;16N", 16, packI16N_I16B},
+    {"BGR;15", "BGR;15", 16, copy2},
+    {"BGR;16", "BGR;16", 16, copy2},
+    {"BGR;24", "BGR;24", 24, copy3},

     {NULL} /* sentinel */
 };

-
 ImagingShuffler
-ImagingFindPacker(const char* mode, const char* rawmode, int* bits_out)
-{
+ImagingFindPacker(const char *mode, const char *rawmode, int *bits_out) {
     int i;

     /* find a suitable pixel packer */
('src/libImaging', 'Fill.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,14 +15,12 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #include "math.h"

 Imaging
-ImagingFill(Imaging im, const void* colour)
-{
+ImagingFill(Imaging im, const void *colour) {
     int x, y;
     ImagingSectionCookie cookie;

@@ -53,7 +51,7 @@
                 }
             }
         } else {
-            unsigned char cc = (unsigned char) *(UINT8*) colour;
+            unsigned char cc = (unsigned char)*(UINT8 *)colour;
             for (y = 0; y < im->ysize; y++) {
                 memset(im->image[y], cc, im->linesize);
             }
@@ -65,13 +63,12 @@
 }

 Imaging
-ImagingFillLinearGradient(const char *mode)
-{
+ImagingFillLinearGradient(const char *mode) {
     Imaging im;
     int y;

     if (strlen(mode) != 1) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     im = ImagingNewDirty(mode, 256, 256);
@@ -79,22 +76,34 @@
         return NULL;
     }

-    for (y = 0; y < 256; y++) {
-        memset(im->image8[y], (unsigned char) y, 256);
+    if (im->image8) {
+        for (y = 0; y < 256; y++) {
+            memset(im->image8[y], (unsigned char)y, 256);
+        }
+    } else {
+        int x;
+        for (y = 0; y < 256; y++) {
+            for (x = 0; x < 256; x++) {
+                if (im->type == IMAGING_TYPE_FLOAT32) {
+                    IMAGING_PIXEL_FLOAT32(im, x, y) = y;
+                } else {
+                    IMAGING_PIXEL_INT32(im, x, y) = y;
+                }
+            }
+        }
     }

     return im;
 }

 Imaging
-ImagingFillRadialGradient(const char *mode)
-{
+ImagingFillRadialGradient(const char *mode) {
     Imaging im;
     int x, y;
     int d;

     if (strlen(mode) != 1) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     im = ImagingNewDirty(mode, 256, 256);
@@ -104,11 +113,19 @@

     for (y = 0; y < 256; y++) {
         for (x = 0; x < 256; x++) {
-            d = (int) sqrt((double) ((x-128)*(x-128) + (y-128)*(y-128)) * 2.0);
+            d = (int)sqrt(
+                (double)((x - 128) * (x - 128) + (y - 128) * (y - 128)) * 2.0);
             if (d >= 255) {
-                im->image8[y][x] = 255;
+                d = 255;
+            }
+            if (im->image8) {
+                im->image8[y][x] = d;
             } else {
-                im->image8[y][x] = d;
+                if (im->type == IMAGING_TYPE_FLOAT32) {
+                    IMAGING_PIXEL_FLOAT32(im, x, y) = d;
+                } else {
+                    IMAGING_PIXEL_INT32(im, x, y) = d;
+                }
             }
         }
     }
('src/libImaging', 'Imaging.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -10,19 +10,15 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "ImPlatform.h"
-

 #if defined(__cplusplus)
 extern "C" {
 #endif

-
 #ifndef M_PI
-#define M_PI    3.1415926535897932384626433832795
-#endif
-
+#define M_PI 3.1415926535897932384626433832795
+#endif

 /* -------------------------------------------------------------------- */

@@ -57,12 +53,12 @@

 /* Handles */

-typedef struct ImagingMemoryInstance* Imaging;
-
-typedef struct ImagingAccessInstance* ImagingAccess;
-typedef struct ImagingHistogramInstance* ImagingHistogram;
-typedef struct ImagingOutlineInstance* ImagingOutline;
-typedef struct ImagingPaletteInstance* ImagingPalette;
+typedef struct ImagingMemoryInstance *Imaging;
+
+typedef struct ImagingAccessInstance *ImagingAccess;
+typedef struct ImagingHistogramInstance *ImagingHistogram;
+typedef struct ImagingOutlineInstance *ImagingOutline;
+typedef struct ImagingPaletteInstance *ImagingPalette;

 /* handle magics (used with PyCObject). */
 #define IMAGING_MAGIC "PIL Imaging"
@@ -73,7 +69,8 @@
 #define IMAGING_TYPE_FLOAT32 2
 #define IMAGING_TYPE_SPECIAL 3 /* check mode for details */

-#define IMAGING_MODE_LENGTH 6+1 /* Band names ("1", "L", "P", "RGB", "RGBA", "CMYK", "YCbCr", "BGR;xy") */
+#define IMAGING_MODE_LENGTH \
+    6 + 1 /* Band names ("1", "L", "P", "RGB", "RGBA", "CMYK", "YCbCr", "BGR;xy") */

 typedef struct {
     char *ptr;
@@ -81,158 +78,179 @@
 } ImagingMemoryBlock;

 struct ImagingMemoryInstance {
-
     /* Format */
-    char mode[IMAGING_MODE_LENGTH];     /* Band names ("1", "L", "P", "RGB", "RGBA", "CMYK", "YCbCr", "BGR;xy") */
-    int type;           /* Data type (IMAGING_TYPE_*) */
-    int depth;          /* Depth (ignored in this version) */
-    int bands;          /* Number of bands (1, 2, 3, or 4) */
-    int xsize;          /* Image dimension. */
+    char mode[IMAGING_MODE_LENGTH]; /* Band names ("1", "L", "P", "RGB", "RGBA", "CMYK",
+                                       "YCbCr", "BGR;xy") */
+    int type;                       /* Data type (IMAGING_TYPE_*) */
+    int depth;                      /* Depth (ignored in this version) */
+    int bands;                      /* Number of bands (1, 2, 3, or 4) */
+    int xsize;                      /* Image dimension. */
     int ysize;

     /* Colour palette (for "P" images only) */
     ImagingPalette palette;

     /* Data pointers */
-    UINT8 **image8;     /* Set for 8-bit images (pixelsize=1). */
-    INT32 **image32;    /* Set for 32-bit images (pixelsize=4). */
+    UINT8 **image8;  /* Set for 8-bit images (pixelsize=1). */
+    INT32 **image32; /* Set for 32-bit images (pixelsize=4). */

     /* Internals */
-    char **image;       /* Actual raster data. */
-    char *block;        /* Set if data is allocated in a single block. */
-    ImagingMemoryBlock *blocks;     /* Memory blocks for pixel storage */
-
-    int pixelsize;      /* Size of a pixel, in bytes (1, 2 or 4) */
-    int linesize;       /* Size of a line, in bytes (xsize * pixelsize) */
+    char **image;               /* Actual raster data. */
+    char *block;                /* Set if data is allocated in a single block. */
+    ImagingMemoryBlock *blocks; /* Memory blocks for pixel storage */
+
+    int pixelsize; /* Size of a pixel, in bytes (1, 2 or 4) */
+    int linesize;  /* Size of a line, in bytes (xsize * pixelsize) */

     /* Virtual methods */
     void (*destroy)(Imaging im);
 };

-
-#define IMAGING_PIXEL_1(im,x,y) ((im)->image8[(y)][(x)])
-#define IMAGING_PIXEL_L(im,x,y) ((im)->image8[(y)][(x)])
-#define IMAGING_PIXEL_LA(im,x,y) ((im)->image[(y)][(x)*4])
-#define IMAGING_PIXEL_P(im,x,y) ((im)->image8[(y)][(x)])
-#define IMAGING_PIXEL_PA(im,x,y) ((im)->image[(y)][(x)*4])
-#define IMAGING_PIXEL_I(im,x,y) ((im)->image32[(y)][(x)])
-#define IMAGING_PIXEL_F(im,x,y) (((FLOAT32*)(im)->image32[y])[x])
-#define IMAGING_PIXEL_RGB(im,x,y) ((im)->image[(y)][(x)*4])
-#define IMAGING_PIXEL_RGBA(im,x,y) ((im)->image[(y)][(x)*4])
-#define IMAGING_PIXEL_CMYK(im,x,y) ((im)->image[(y)][(x)*4])
-#define IMAGING_PIXEL_YCbCr(im,x,y) ((im)->image[(y)][(x)*4])
-
-#define IMAGING_PIXEL_UINT8(im,x,y) ((im)->image8[(y)][(x)])
-#define IMAGING_PIXEL_INT32(im,x,y) ((im)->image32[(y)][(x)])
-#define IMAGING_PIXEL_FLOAT32(im,x,y) (((FLOAT32*)(im)->image32[y])[x])
+#define IMAGING_PIXEL_1(im, x, y) ((im)->image8[(y)][(x)])
+#define IMAGING_PIXEL_L(im, x, y) ((im)->image8[(y)][(x)])
+#define IMAGING_PIXEL_LA(im, x, y) ((im)->image[(y)][(x)*4])
+#define IMAGING_PIXEL_P(im, x, y) ((im)->image8[(y)][(x)])
+#define IMAGING_PIXEL_PA(im, x, y) ((im)->image[(y)][(x)*4])
+#define IMAGING_PIXEL_I(im, x, y) ((im)->image32[(y)][(x)])
+#define IMAGING_PIXEL_F(im, x, y) (((FLOAT32 *)(im)->image32[y])[x])
+#define IMAGING_PIXEL_RGB(im, x, y) ((im)->image[(y)][(x)*4])
+#define IMAGING_PIXEL_RGBA(im, x, y) ((im)->image[(y)][(x)*4])
+#define IMAGING_PIXEL_CMYK(im, x, y) ((im)->image[(y)][(x)*4])
+#define IMAGING_PIXEL_YCbCr(im, x, y) ((im)->image[(y)][(x)*4])
+
+#define IMAGING_PIXEL_UINT8(im, x, y) ((im)->image8[(y)][(x)])
+#define IMAGING_PIXEL_INT32(im, x, y) ((im)->image32[(y)][(x)])
+#define IMAGING_PIXEL_FLOAT32(im, x, y) (((FLOAT32 *)(im)->image32[y])[x])

 struct ImagingAccessInstance {
-  const char* mode;
-  void* (*line)(Imaging im, int x, int y);
-  void (*get_pixel)(Imaging im, int x, int y, void* pixel);
-  void (*put_pixel)(Imaging im, int x, int y, const void* pixel);
+    const char *mode;
+    void *(*line)(Imaging im, int x, int y);
+    void (*get_pixel)(Imaging im, int x, int y, void *pixel);
+    void (*put_pixel)(Imaging im, int x, int y, const void *pixel);
 };

 struct ImagingHistogramInstance {
-
     /* Format */
-    char mode[IMAGING_MODE_LENGTH];     /* Band names (of corresponding source image) */
-    int bands;          /* Number of bands (1, 3, or 4) */
+    char mode[IMAGING_MODE_LENGTH]; /* Band names (of corresponding source image) */
+    int bands;                      /* Number of bands (1, 3, or 4) */

     /* Data */
-    long *histogram;    /* Histogram (bands*256 longs) */
-
+    long *histogram; /* Histogram (bands*256 longs) */
 };

-
 struct ImagingPaletteInstance {
-
     /* Format */
-    char mode[IMAGING_MODE_LENGTH];     /* Band names */
+    char mode[IMAGING_MODE_LENGTH]; /* Band names */

     /* Data */
-    UINT8 palette[1024];/* Palette data (same format as image data) */
-
-    INT16* cache;       /* Palette cache (used for predefined palettes) */
-    int keep_cache;     /* This palette will be reused; keep cache */
-
+    int size;
+    UINT8 palette[1024]; /* Palette data (same format as image data) */
+
+    INT16 *cache;   /* Palette cache (used for predefined palettes) */
+    int keep_cache; /* This palette will be reused; keep cache */
 };

 typedef struct ImagingMemoryArena {
-    int alignment;        /* Alignment in memory of each line of an image */
-    int block_size;       /* Preferred block size, bytes */
-    int blocks_max;       /* Maximum number of cached blocks */
-    int blocks_cached;    /* Current number of blocks not associated with images */
+    int alignment;     /* Alignment in memory of each line of an image */
+    int block_size;    /* Preferred block size, bytes */
+    int blocks_max;    /* Maximum number of cached blocks */
+    int blocks_cached; /* Current number of blocks not associated with images */
     ImagingMemoryBlock *blocks_pool;
-    int stats_new_count;           /* Number of new allocated images */
-    int stats_allocated_blocks;    /* Number of allocated blocks */
-    int stats_reused_blocks;       /* Number of blocks which were retrieved from a pool */
-    int stats_reallocated_blocks;  /* Number of blocks which were actually reallocated after retrieving */
-    int stats_freed_blocks;        /* Number of freed blocks */
-} *ImagingMemoryArena;
-
+    int stats_new_count;        /* Number of new allocated images */
+    int stats_allocated_blocks; /* Number of allocated blocks */
+    int stats_reused_blocks;    /* Number of blocks which were retrieved from a pool */
+    int stats_reallocated_blocks; /* Number of blocks which were actually reallocated
+                                     after retrieving */
+    int stats_freed_blocks;       /* Number of freed blocks */
+} * ImagingMemoryArena;

 /* Objects */
 /* ------- */

 extern struct ImagingMemoryArena ImagingDefaultArena;
-extern int ImagingMemorySetBlocksMax(ImagingMemoryArena arena, int blocks_max);
-extern void ImagingMemoryClearCache(ImagingMemoryArena arena, int new_size);
-
-extern Imaging ImagingNew(const char* mode, int xsize, int ysize);
-extern Imaging ImagingNewDirty(const char* mode, int xsize, int ysize);
-extern Imaging ImagingNew2Dirty(const char* mode, Imaging imOut, Imaging imIn);
-extern void    ImagingDelete(Imaging im);
-
-extern Imaging ImagingNewBlock(const char* mode, int xsize, int ysize);
-
-extern Imaging ImagingNewPrologue(const char *mode,
-                                  int xsize, int ysize);
-extern Imaging ImagingNewPrologueSubtype(const char *mode,
-                                         int xsize, int ysize,
-                                         int structure_size);
-
-extern void ImagingCopyPalette(Imaging destination, Imaging source);
-
-extern void ImagingHistogramDelete(ImagingHistogram histogram);
-
-extern void ImagingAccessInit(void);
-extern ImagingAccess ImagingAccessNew(Imaging im);
-extern void _ImagingAccessDelete(Imaging im, ImagingAccess access);
+extern int
+ImagingMemorySetBlocksMax(ImagingMemoryArena arena, int blocks_max);
+extern void
+ImagingMemoryClearCache(ImagingMemoryArena arena, int new_size);
+
+extern Imaging
+ImagingNew(const char *mode, int xsize, int ysize);
+extern Imaging
+ImagingNewDirty(const char *mode, int xsize, int ysize);
+extern Imaging
+ImagingNew2Dirty(const char *mode, Imaging imOut, Imaging imIn);
+extern void
+ImagingDelete(Imaging im);
+
+extern Imaging
+ImagingNewBlock(const char *mode, int xsize, int ysize);
+
+extern Imaging
+ImagingNewPrologue(const char *mode, int xsize, int ysize);
+extern Imaging
+ImagingNewPrologueSubtype(const char *mode, int xsize, int ysize, int structure_size);
+
+extern void
+ImagingCopyPalette(Imaging destination, Imaging source);
+
+extern void
+ImagingHistogramDelete(ImagingHistogram histogram);
+
+extern void
+ImagingAccessInit(void);
+extern ImagingAccess
+ImagingAccessNew(Imaging im);
+extern void
+_ImagingAccessDelete(Imaging im, ImagingAccess access);
 #define ImagingAccessDelete(im, access) /* nop, for now */

-extern ImagingPalette ImagingPaletteNew(const char *mode);
-extern ImagingPalette ImagingPaletteNewBrowser(void);
-extern ImagingPalette ImagingPaletteDuplicate(ImagingPalette palette);
-extern void           ImagingPaletteDelete(ImagingPalette palette);
-
-extern int  ImagingPaletteCachePrepare(ImagingPalette palette);
-extern void ImagingPaletteCacheUpdate(ImagingPalette palette,
-                                      int r, int g, int b);
-extern void ImagingPaletteCacheDelete(ImagingPalette palette);
-
-#define ImagingPaletteCache(p, r, g, b)\
-    p->cache[(r>>2) + (g>>2)*64 + (b>>2)*64*64]
-
-extern Imaging ImagingQuantize(Imaging im, int colours, int mode, int kmeans);
+extern ImagingPalette
+ImagingPaletteNew(const char *mode);
+extern ImagingPalette
+ImagingPaletteNewBrowser(void);
+extern ImagingPalette
+ImagingPaletteDuplicate(ImagingPalette palette);
+extern void
+ImagingPaletteDelete(ImagingPalette palette);
+
+extern int
+ImagingPaletteCachePrepare(ImagingPalette palette);
+extern void
+ImagingPaletteCacheUpdate(ImagingPalette palette, int r, int g, int b);
+extern void
+ImagingPaletteCacheDelete(ImagingPalette palette);
+
+#define ImagingPaletteCache(p, r, g, b) \
+    p->cache[(r >> 2) + (g >> 2) * 64 + (b >> 2) * 64 * 64]
+
+extern Imaging
+ImagingQuantize(Imaging im, int colours, int mode, int kmeans);

 /* Threading */
 /* --------- */

-typedef void* ImagingSectionCookie;
-
-extern void ImagingSectionEnter(ImagingSectionCookie* cookie);
-extern void ImagingSectionLeave(ImagingSectionCookie* cookie);
+typedef void *ImagingSectionCookie;
+
+extern void
+ImagingSectionEnter(ImagingSectionCookie *cookie);
+extern void
+ImagingSectionLeave(ImagingSectionCookie *cookie);

 /* Exceptions */
 /* ---------- */

-extern void* ImagingError_OSError(void);
-extern void* ImagingError_MemoryError(void);
-extern void* ImagingError_ModeError(void); /* maps to ValueError by default */
-extern void* ImagingError_Mismatch(void); /* maps to ValueError by default */
-extern void* ImagingError_ValueError(const char* message);
-extern void ImagingError_Clear(void);
+extern void *
+ImagingError_OSError(void);
+extern void *
+ImagingError_MemoryError(void);
+extern void *
+ImagingError_ModeError(void); /* maps to ValueError by default */
+extern void *
+ImagingError_Mismatch(void); /* maps to ValueError by default */
+extern void *
+ImagingError_ValueError(const char *message);
+extern void
+ImagingError_Clear(void);

 /* Transform callbacks */
 /* ------------------- */
@@ -241,7 +259,6 @@
 #define IMAGING_TRANSFORM_AFFINE 0
 #define IMAGING_TRANSFORM_PERSPECTIVE 2
 #define IMAGING_TRANSFORM_QUAD 3
-

 /* standard filters */
 #define IMAGING_TRANSFORM_NEAREST 0
@@ -251,249 +268,391 @@
 #define IMAGING_TRANSFORM_BICUBIC 3
 #define IMAGING_TRANSFORM_LANCZOS 1

-typedef int (*ImagingTransformMap)(double* X, double* Y,
-                                   int x, int y, void* data);
-typedef int (*ImagingTransformFilter)(void* out, Imaging im,
-                                      double x, double y);
+typedef int (*ImagingTransformMap)(double *X, double *Y, int x, int y, void *data);
+typedef int (*ImagingTransformFilter)(void *out, Imaging im, double x, double y);

 /* Image Manipulation Methods */
 /* -------------------------- */

-extern Imaging ImagingAlphaComposite(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingBlend(Imaging imIn1, Imaging imIn2, float alpha);
-extern Imaging ImagingCopy(Imaging im);
-extern Imaging ImagingConvert(Imaging im, const char* mode, ImagingPalette palette, int dither);
-extern Imaging ImagingConvertInPlace(Imaging im, const char* mode);
-extern Imaging ImagingConvertMatrix(Imaging im, const char *mode, float m[]);
-extern Imaging ImagingConvertTransparent(Imaging im, const char *mode, int r, int g, int b);
-extern Imaging ImagingCrop(Imaging im, int x0, int y0, int x1, int y1);
-extern Imaging ImagingExpand(Imaging im, int x, int y, int mode);
-extern Imaging ImagingFill(Imaging im, const void* ink);
-extern int ImagingFill2(
-    Imaging into, const void* ink, Imaging mask,
-    int x0, int y0, int x1, int y1);
-extern Imaging ImagingFillBand(Imaging im, int band, int color);
-extern Imaging ImagingFillLinearGradient(const char* mode);
-extern Imaging ImagingFillRadialGradient(const char* mode);
-extern Imaging ImagingFilter(
-    Imaging im, int xsize, int ysize, const FLOAT32* kernel,
-    FLOAT32 offset);
-extern Imaging ImagingFlipLeftRight(Imaging imOut, Imaging imIn);
-extern Imaging ImagingFlipTopBottom(Imaging imOut, Imaging imIn);
-extern Imaging ImagingGaussianBlur(Imaging imOut, Imaging imIn, float radius,
-                                   int passes);
-extern Imaging ImagingGetBand(Imaging im, int band);
-extern Imaging ImagingMerge(const char* mode, Imaging bands[4]);
-extern int ImagingSplit(Imaging im, Imaging bands[4]);
-extern int ImagingGetBBox(Imaging im, int bbox[4]);
-typedef struct { int x, y; INT32 count; INT32 pixel; } ImagingColorItem;
-extern ImagingColorItem* ImagingGetColors(Imaging im, int maxcolors,
-                                          int *colors);
-extern int ImagingGetExtrema(Imaging im, void *extrema);
-extern int ImagingGetProjection(Imaging im, UINT8* xproj, UINT8* yproj);
-extern ImagingHistogram ImagingGetHistogram(
-    Imaging im, Imaging mask, void *extrema);
-extern Imaging ImagingModeFilter(Imaging im, int size);
-extern Imaging ImagingNegative(Imaging im);
-extern Imaging ImagingOffset(Imaging im, int xoffset, int yoffset);
-extern int ImagingPaste(
-    Imaging into, Imaging im, Imaging mask,
-    int x0, int y0, int x1, int y1);
-extern Imaging ImagingPoint(
-    Imaging im, const char* tablemode, const void* table);
-extern Imaging ImagingPointTransform(
-    Imaging imIn, double scale, double offset);
-extern Imaging ImagingPutBand(Imaging im, Imaging imIn, int band);
-extern Imaging ImagingRankFilter(Imaging im, int size, int rank);
-extern Imaging ImagingRotate90(Imaging imOut, Imaging imIn);
-extern Imaging ImagingRotate180(Imaging imOut, Imaging imIn);
-extern Imaging ImagingRotate270(Imaging imOut, Imaging imIn);
-extern Imaging ImagingTranspose(Imaging imOut, Imaging imIn);
-extern Imaging ImagingTransverse(Imaging imOut, Imaging imIn);
-extern Imaging ImagingResample(Imaging imIn, int xsize, int ysize, int filter, float box[4]);
-extern Imaging ImagingReduce(Imaging imIn, int xscale, int yscale, int box[4]);
-extern Imaging ImagingTransform(
-    Imaging imOut, Imaging imIn, int method, int x0, int y0, int x1, int y1,
-    double *a, int filter, int fill);
-extern Imaging ImagingUnsharpMask(
-    Imaging imOut, Imaging im, float radius, int percent, int threshold);
-extern Imaging ImagingBoxBlur(Imaging imOut, Imaging imIn, float radius, int n);
-extern Imaging ImagingColorLUT3D_linear(Imaging imOut, Imaging imIn,
-    int table_channels, int size1D, int size2D, int size3D, INT16* table);
-
-extern Imaging ImagingCopy2(Imaging imOut, Imaging imIn);
-extern Imaging ImagingConvert2(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingAlphaComposite(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingBlend(Imaging imIn1, Imaging imIn2, float alpha);
+extern Imaging
+ImagingCopy(Imaging im);
+extern Imaging
+ImagingConvert(Imaging im, const char *mode, ImagingPalette palette, int dither);
+extern Imaging
+ImagingConvertInPlace(Imaging im, const char *mode);
+extern Imaging
+ImagingConvertMatrix(Imaging im, const char *mode, float m[]);
+extern Imaging
+ImagingConvertTransparent(Imaging im, const char *mode, int r, int g, int b);
+extern Imaging
+ImagingCrop(Imaging im, int x0, int y0, int x1, int y1);
+extern Imaging
+ImagingExpand(Imaging im, int x, int y, int mode);
+extern Imaging
+ImagingFill(Imaging im, const void *ink);
+extern int
+ImagingFill2(
+    Imaging into, const void *ink, Imaging mask, int x0, int y0, int x1, int y1);
+extern Imaging
+ImagingFillBand(Imaging im, int band, int color);
+extern Imaging
+ImagingFillLinearGradient(const char *mode);
+extern Imaging
+ImagingFillRadialGradient(const char *mode);
+extern Imaging
+ImagingFilter(Imaging im, int xsize, int ysize, const FLOAT32 *kernel, FLOAT32 offset);
+extern Imaging
+ImagingFlipLeftRight(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingFlipTopBottom(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingGaussianBlur(Imaging imOut, Imaging imIn, float radius, int passes);
+extern Imaging
+ImagingGetBand(Imaging im, int band);
+extern Imaging
+ImagingMerge(const char *mode, Imaging bands[4]);
+extern int
+ImagingSplit(Imaging im, Imaging bands[4]);
+extern int
+ImagingGetBBox(Imaging im, int bbox[4]);
+typedef struct {
+    int x, y;
+    INT32 count;
+    INT32 pixel;
+} ImagingColorItem;
+extern ImagingColorItem *
+ImagingGetColors(Imaging im, int maxcolors, int *colors);
+extern int
+ImagingGetExtrema(Imaging im, void *extrema);
+extern int
+ImagingGetProjection(Imaging im, UINT8 *xproj, UINT8 *yproj);
+extern ImagingHistogram
+ImagingGetHistogram(Imaging im, Imaging mask, void *extrema);
+extern Imaging
+ImagingModeFilter(Imaging im, int size);
+extern Imaging
+ImagingNegative(Imaging im);
+extern Imaging
+ImagingOffset(Imaging im, int xoffset, int yoffset);
+extern int
+ImagingPaste(Imaging into, Imaging im, Imaging mask, int x0, int y0, int x1, int y1);
+extern Imaging
+ImagingPoint(Imaging im, const char *tablemode, const void *table);
+extern Imaging
+ImagingPointTransform(Imaging imIn, double scale, double offset);
+extern Imaging
+ImagingPutBand(Imaging im, Imaging imIn, int band);
+extern Imaging
+ImagingRankFilter(Imaging im, int size, int rank);
+extern Imaging
+ImagingRotate90(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingRotate180(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingRotate270(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingTranspose(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingTransverse(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingResample(Imaging imIn, int xsize, int ysize, int filter, float box[4]);
+extern Imaging
+ImagingReduce(Imaging imIn, int xscale, int yscale, int box[4]);
+extern Imaging
+ImagingTransform(
+    Imaging imOut,
+    Imaging imIn,
+    int method,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    double a[8],
+    int filter,
+    int fill);
+extern Imaging
+ImagingUnsharpMask(Imaging imOut, Imaging im, float radius, int percent, int threshold);
+extern Imaging
+ImagingBoxBlur(Imaging imOut, Imaging imIn, float radius, int n);
+extern Imaging
+ImagingColorLUT3D_linear(
+    Imaging imOut,
+    Imaging imIn,
+    int table_channels,
+    int size1D,
+    int size2D,
+    int size3D,
+    INT16 *table);
+
+extern Imaging
+ImagingCopy2(Imaging imOut, Imaging imIn);
+extern Imaging
+ImagingConvert2(Imaging imOut, Imaging imIn);

 /* Channel operations */
 /* any mode, except "F" */
-extern Imaging ImagingChopLighter(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopDarker(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopDifference(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopMultiply(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopScreen(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopAdd(
-    Imaging imIn1, Imaging imIn2, float scale, int offset);
-extern Imaging ImagingChopSubtract(
-    Imaging imIn1, Imaging imIn2, float scale, int offset);
-extern Imaging ImagingChopAddModulo(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopSubtractModulo(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopSoftLight(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopHardLight(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingOverlay(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopLighter(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopDarker(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopDifference(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopMultiply(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopScreen(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopAdd(Imaging imIn1, Imaging imIn2, float scale, int offset);
+extern Imaging
+ImagingChopSubtract(Imaging imIn1, Imaging imIn2, float scale, int offset);
+extern Imaging
+ImagingChopAddModulo(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopSubtractModulo(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopSoftLight(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopHardLight(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingOverlay(Imaging imIn1, Imaging imIn2);

 /* "1" images only */
-extern Imaging ImagingChopAnd(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopOr(Imaging imIn1, Imaging imIn2);
-extern Imaging ImagingChopXor(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopAnd(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopOr(Imaging imIn1, Imaging imIn2);
+extern Imaging
+ImagingChopXor(Imaging imIn1, Imaging imIn2);

 /* Graphics */
-extern int ImagingDrawArc(Imaging im, int x0, int y0, int x1, int y1,
-                          float start, float end, const void* ink, int width,
-                          int op);
-extern int ImagingDrawBitmap(Imaging im, int x0, int y0, Imaging bitmap,
-                             const void* ink, int op);
-extern int ImagingDrawChord(Imaging im, int x0, int y0, int x1, int y1,
-                            float start, float end, const void* ink, int fill,
-                            int width, int op);
-extern int ImagingDrawEllipse(Imaging im, int x0, int y0, int x1, int y1,
-                              const void* ink, int fill, int width, int op);
-extern int ImagingDrawLine(Imaging im, int x0, int y0, int x1, int y1,
-                           const void* ink, int op);
-extern int ImagingDrawWideLine(Imaging im, int x0, int y0, int x1, int y1,
-                               const void* ink, int width, int op);
-extern int ImagingDrawPieslice(Imaging im, int x0, int y0, int x1, int y1,
-                               float start, float end, const void* ink, int fill,
-                               int width, int op);
-extern int ImagingDrawPoint(Imaging im, int x, int y, const void* ink, int op);
-extern int ImagingDrawPolygon(Imaging im, int points, int *xy,
-                              const void* ink, int fill, int op);
-extern int ImagingDrawRectangle(Imaging im, int x0, int y0, int x1, int y1,
-                                const void* ink, int fill, int width, int op);
+extern int
+ImagingDrawArc(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink,
+    int width,
+    int op);
+extern int
+ImagingDrawBitmap(Imaging im, int x0, int y0, Imaging bitmap, const void *ink, int op);
+extern int
+ImagingDrawChord(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink,
+    int fill,
+    int width,
+    int op);
+extern int
+ImagingDrawEllipse(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    const void *ink,
+    int fill,
+    int width,
+    int op);
+extern int
+ImagingDrawLine(Imaging im, int x0, int y0, int x1, int y1, const void *ink, int op);
+extern int
+ImagingDrawWideLine(
+    Imaging im, int x0, int y0, int x1, int y1, const void *ink, int width, int op);
+extern int
+ImagingDrawPieslice(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    float start,
+    float end,
+    const void *ink,
+    int fill,
+    int width,
+    int op);
+extern int
+ImagingDrawPoint(Imaging im, int x, int y, const void *ink, int op);
+extern int
+ImagingDrawPolygon(Imaging im, int points, int *xy, const void *ink, int fill, int width, int op);
+extern int
+ImagingDrawRectangle(
+    Imaging im,
+    int x0,
+    int y0,
+    int x1,
+    int y1,
+    const void *ink,
+    int fill,
+    int width,
+    int op);

 /* Level 2 graphics (WORK IN PROGRESS) */
-extern ImagingOutline ImagingOutlineNew(void);
-extern void ImagingOutlineDelete(ImagingOutline outline);
-
-extern int ImagingDrawOutline(Imaging im, ImagingOutline outline,
-                              const void* ink, int fill, int op);
-
-extern int ImagingOutlineMove(ImagingOutline outline, float x, float y);
-extern int ImagingOutlineLine(ImagingOutline outline, float x, float y);
-extern int ImagingOutlineCurve(ImagingOutline outline, float x1, float y1,
-                               float x2, float y2, float x3, float y3);
-extern int ImagingOutlineTransform(ImagingOutline outline, double a[6]);
-
-extern int ImagingOutlineClose(ImagingOutline outline);
+extern ImagingOutline
+ImagingOutlineNew(void);
+extern void
+ImagingOutlineDelete(ImagingOutline outline);
+
+extern int
+ImagingDrawOutline(
+    Imaging im, ImagingOutline outline, const void *ink, int fill, int op);
+
+extern int
+ImagingOutlineMove(ImagingOutline outline, float x, float y);
+extern int
+ImagingOutlineLine(ImagingOutline outline, float x, float y);
+extern int
+ImagingOutlineCurve(
+    ImagingOutline outline, float x1, float y1, float x2, float y2, float x3, float y3);
+extern int
+ImagingOutlineTransform(ImagingOutline outline, double a[6]);
+
+extern int
+ImagingOutlineClose(ImagingOutline outline);

 /* Special effects */
-extern Imaging ImagingEffectSpread(Imaging imIn, int distance);
-extern Imaging ImagingEffectNoise(int xsize, int ysize, float sigma);
-extern Imaging ImagingEffectMandelbrot(int xsize, int ysize,
-                                       double extent[4], int quality);
-
+extern Imaging
+ImagingEffectSpread(Imaging imIn, int distance);
+extern Imaging
+ImagingEffectNoise(int xsize, int ysize, float sigma);
+extern Imaging
+ImagingEffectMandelbrot(int xsize, int ysize, double extent[4], int quality);

 /* File I/O */
 /* -------- */

 /* Built-in drivers */
-extern Imaging ImagingOpenPPM(const char* filename);
-extern int ImagingSavePPM(Imaging im, const char* filename);
+extern Imaging
+ImagingOpenPPM(const char *filename);
+extern int
+ImagingSavePPM(Imaging im, const char *filename);

 /* Codecs */
 typedef struct ImagingCodecStateInstance *ImagingCodecState;
-typedef int (*ImagingCodec)(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, int bytes);
-
-extern int ImagingBcnDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingBitDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingEpsEncode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, int bytes);
-extern int ImagingFliDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingGifDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingGifEncode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, int bytes);
-extern int ImagingHexDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-#ifdef  HAVE_LIBJPEG
-extern int ImagingJpegDecode(Imaging im, ImagingCodecState state,
-                             UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingJpegDecodeCleanup(ImagingCodecState state);
-extern int ImagingJpegUseJCSExtensions(void);
-
-extern int ImagingJpegEncode(Imaging im, ImagingCodecState state,
-                             UINT8* buffer, int bytes);
+typedef int (*ImagingCodec)(
+    Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+
+extern int
+ImagingBcnDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingBitDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingEpsEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+extern int
+ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingGifDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingGifEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+extern int
+ImagingHexDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+#ifdef HAVE_LIBJPEG
+extern int
+ImagingJpegDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingJpegDecodeCleanup(ImagingCodecState state);
+extern int
+ImagingJpegUseJCSExtensions(void);
+
+extern int
+ImagingJpegEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
 #endif
 #ifdef HAVE_OPENJPEG
-extern int ImagingJpeg2KDecode(Imaging im, ImagingCodecState state,
-                               UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingJpeg2KDecodeCleanup(ImagingCodecState state);
-extern int ImagingJpeg2KEncode(Imaging im, ImagingCodecState state,
-                               UINT8* buffer, int bytes);
-extern int ImagingJpeg2KEncodeCleanup(ImagingCodecState state);
-#endif
-#ifdef  HAVE_LIBTIFF
-extern int ImagingLibTiffDecode(Imaging im, ImagingCodecState state,
-                                UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingLibTiffEncode(Imaging im, ImagingCodecState state,
-                                UINT8* buffer, int bytes);
-#endif
-#ifdef  HAVE_LIBMPEG
-extern int ImagingMpegDecode(Imaging im, ImagingCodecState state,
-                             UINT8* buffer, Py_ssize_t bytes);
-#endif
-extern int ImagingMspDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingPackbitsDecode(Imaging im, ImagingCodecState state,
-                                 UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingPcdDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingPcxDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingPcxEncode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, int bytes);
-extern int ImagingRawDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingRawEncode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, int bytes);
-extern int ImagingSgiRleDecode(Imaging im, ImagingCodecState state,
-                               UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingSunRleDecode(Imaging im, ImagingCodecState state,
-                               UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingTgaRleDecode(Imaging im, ImagingCodecState state,
-                               UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingTgaRleEncode(Imaging im, ImagingCodecState state,
-                               UINT8* buffer, int bytes);
-extern int ImagingXbmDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingXbmEncode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, int bytes);
-#ifdef  HAVE_LIBZ
-extern int ImagingZipDecode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, Py_ssize_t bytes);
-extern int ImagingZipDecodeCleanup(ImagingCodecState state);
-extern int ImagingZipEncode(Imaging im, ImagingCodecState state,
-                            UINT8* buffer, int bytes);
-extern int ImagingZipEncodeCleanup(ImagingCodecState state);
-#endif
-
-typedef void (*ImagingShuffler)(UINT8* out, const UINT8* in, int pixels);
+extern int
+ImagingJpeg2KDecode(
+    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingJpeg2KDecodeCleanup(ImagingCodecState state);
+extern int
+ImagingJpeg2KEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+extern int
+ImagingJpeg2KEncodeCleanup(ImagingCodecState state);
+#endif
+#ifdef HAVE_LIBTIFF
+extern int
+ImagingLibTiffDecode(
+    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingLibTiffEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+#endif
+#ifdef HAVE_LIBMPEG
+extern int
+ImagingMpegDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+#endif
+extern int
+ImagingMspDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingPackbitsDecode(
+    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingPcxEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+extern int
+ImagingRawDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingRawEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+extern int
+ImagingSgiRleDecode(
+    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingSunRleDecode(
+    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingTgaRleDecode(
+    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingTgaRleEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+extern int
+ImagingXbmDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingXbmEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+#ifdef HAVE_LIBZ
+extern int
+ImagingZipDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes);
+extern int
+ImagingZipDecodeCleanup(ImagingCodecState state);
+extern int
+ImagingZipEncode(Imaging im, ImagingCodecState state, UINT8 *buffer, int bytes);
+extern int
+ImagingZipEncodeCleanup(ImagingCodecState state);
+#endif
+
+typedef void (*ImagingShuffler)(UINT8 *out, const UINT8 *in, int pixels);

 /* Public shufflers */
-extern void ImagingPackBGR(UINT8* out, const UINT8* in, int pixels);
-extern void ImagingUnpackYCC(UINT8* out, const UINT8* in, int pixels);
-extern void ImagingUnpackYCCA(UINT8* out, const UINT8* in, int pixels);
-
-extern void ImagingConvertRGB2YCbCr(UINT8* out, const UINT8* in, int pixels);
-extern void ImagingConvertYCbCr2RGB(UINT8* out, const UINT8* in, int pixels);
-
-extern ImagingShuffler ImagingFindUnpacker(const char* mode,
-                                           const char* rawmode, int* bits_out);
-extern ImagingShuffler ImagingFindPacker(const char* mode,
-                                         const char* rawmode, int* bits_out);
+extern void
+ImagingPackBGR(UINT8 *out, const UINT8 *in, int pixels);
+extern void
+ImagingUnpackYCC(UINT8 *out, const UINT8 *in, int pixels);
+extern void
+ImagingUnpackYCCA(UINT8 *out, const UINT8 *in, int pixels);
+
+extern void
+ImagingConvertRGB2YCbCr(UINT8 *out, const UINT8 *in, int pixels);
+extern void
+ImagingConvertYCbCr2RGB(UINT8 *out, const UINT8 *in, int pixels);
+
+extern ImagingShuffler
+ImagingFindUnpacker(const char *mode, const char *rawmode, int *bits_out);
+extern ImagingShuffler
+ImagingFindPacker(const char *mode, const char *rawmode, int *bits_out);

 struct ImagingCodecStateInstance {
     int count;
@@ -509,30 +668,27 @@
     PyObject *fd;
 };

-
-
 /* Codec read/write python fd */
-extern Py_ssize_t _imaging_read_pyFd(PyObject *fd, char* dest, Py_ssize_t bytes);
-extern Py_ssize_t _imaging_write_pyFd(PyObject *fd, char* src, Py_ssize_t bytes);
-extern int _imaging_seek_pyFd(PyObject *fd, Py_ssize_t offset, int whence);
-extern Py_ssize_t _imaging_tell_pyFd(PyObject *fd);
-
-
+extern Py_ssize_t
+_imaging_read_pyFd(PyObject *fd, char *dest, Py_ssize_t bytes);
+extern Py_ssize_t
+_imaging_write_pyFd(PyObject *fd, char *src, Py_ssize_t bytes);
+extern int
+_imaging_seek_pyFd(PyObject *fd, Py_ssize_t offset, int whence);
+extern Py_ssize_t
+_imaging_tell_pyFd(PyObject *fd);

 /* Errcodes */
-#define IMAGING_CODEC_END        1
-#define IMAGING_CODEC_OVERRUN   -1
-#define IMAGING_CODEC_BROKEN    -2
-#define IMAGING_CODEC_UNKNOWN   -3
-#define IMAGING_CODEC_CONFIG    -8
-#define IMAGING_CODEC_MEMORY    -9
-
-
+#define IMAGING_CODEC_END 1
+#define IMAGING_CODEC_OVERRUN -1
+#define IMAGING_CODEC_BROKEN -2
+#define IMAGING_CODEC_UNKNOWN -3
+#define IMAGING_CODEC_CONFIG -8
+#define IMAGING_CODEC_MEMORY -9

 #include "ImagingUtils.h"
 extern UINT8 *clip8_lookups;

-
 #if defined(__cplusplus)
 }
 #endif
('src/libImaging', 'Jpeg.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -12,12 +12,10 @@

 #include <setjmp.h>

-
 typedef struct {
-    struct jpeg_error_mgr pub;    /* "public" fields */
-    jmp_buf setjmp_buffer;        /* for return to caller */
+    struct jpeg_error_mgr pub; /* "public" fields */
+    jmp_buf setjmp_buffer;     /* for return to caller */
 } JPEGERROR;
-

 /* -------------------------------------------------------------------- */
 /* Decoder                                                              */
@@ -28,15 +26,14 @@
 } JPEGSOURCE;

 typedef struct {
-
     /* CONFIGURATION */

     /* Jpeg file mode (empty if not known) */
-    char jpegmode[8+1];
+    char jpegmode[8 + 1];

     /* Converter output mode (input to the shuffler).  If empty,
        convert conversions are disabled */
-    char rawmode[8+1];
+    char rawmode[8 + 1];

     /* If set, trade quality for speed */
     int draft;
@@ -54,7 +51,6 @@

 } JPEGSTATE;

-
 /* -------------------------------------------------------------------- */
 /* Encoder                                                              */

@@ -64,7 +60,6 @@
 } JPEGDESTINATION;

 typedef struct {
-
     /* CONFIGURATION */

     /* Quality (0-100, -1 means default) */
@@ -89,7 +84,7 @@
     int subsampling;

     /* Converter input mode (input to the shuffler) */
-    char rawmode[8+1];
+    char rawmode[8 + 1];

     /* Custom quantization tables () */
     unsigned int *qtables;
@@ -98,7 +93,8 @@
     int qtablesLen;

     /* Extra data (to be injected after header) */
-    char* extra; int extra_size;
+    char *extra;
+    int extra_size;

     /* PRIVATE CONTEXT (set by encoder) */

@@ -110,7 +106,7 @@

     int extra_offset;

-    size_t rawExifLen;   /* EXIF data length */
-    char* rawExif;  /* EXIF buffer pointer */
+    size_t rawExifLen; /* EXIF data length */
+    char *rawExif;     /* EXIF buffer pointer */

 } JPEGENCODERSTATE;
('src/libImaging', 'RawDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,22 +13,18 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #include "Raw.h"

+int
+ImagingRawDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
+    enum { LINE = 1, SKIP };
+    RAWSTATE *rawstate = state->context;

-int
-ImagingRawDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
-    enum { LINE = 1, SKIP };
-    RAWSTATE* rawstate = state->context;
-
-    UINT8* ptr;
+    UINT8 *ptr;

     if (state->state == 0) {
-
         /* Initialize context variables */

         /* get size of image data and padding */
@@ -45,22 +41,19 @@

         /* check image orientation */
         if (state->ystep < 0) {
-            state->y = state->ysize-1;
+            state->y = state->ysize - 1;
             state->ystep = -1;
         } else {
             state->ystep = 1;
         }

         state->state = LINE;
-
     }

     ptr = buf;

     for (;;) {
-
         if (state->state == SKIP) {
-
             /* Skip padding between lines */

             if (bytes < rawstate->skip) {
@@ -71,7 +64,6 @@
             bytes -= rawstate->skip;

             state->state = LINE;
-
         }

         if (bytes < state->bytes) {
@@ -79,8 +71,10 @@
         }

         /* Unpack data */
-        state->shuffle((UINT8*) im->image[state->y + state->yoff] +
-                   state->xoff * im->pixelsize, ptr, state->xsize);
+        state->shuffle(
+            (UINT8 *)im->image[state->y + state->yoff] + state->xoff * im->pixelsize,
+            ptr,
+            state->xsize);

         ptr += state->bytes;
         bytes -= state->bytes;
@@ -93,7 +87,5 @@
         }

         state->state = SKIP;
-
     }
-
 }
('src/libImaging', 'TgaRleEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,18 +4,15 @@
 #include <assert.h>
 #include <string.h>

-
-static int comparePixels(const UINT8* buf, int x, int bytesPerPixel)
-{
+static int
+comparePixels(const UINT8 *buf, int x, int bytesPerPixel) {
     buf += x * bytesPerPixel;
     return memcmp(buf, buf + bytesPerPixel, bytesPerPixel) == 0;
 }

-
 int
-ImagingTgaRleEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)
-{
-    UINT8* dst;
+ImagingTgaRleEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes) {
+    UINT8 *dst;
     int bytesPerPixel;

     if (state->state == 0) {
@@ -40,7 +37,7 @@
          * excluding the 1-byte descriptor.
          */
         if (state->count == 0) {
-            UINT8* row;
+            UINT8 *row;
             UINT8 descriptor;
             int startX;

@@ -64,8 +61,8 @@
             if (state->x == 0) {
                 state->shuffle(
                     state->buffer,
-                    (UINT8*)im->image[state->y + state->yoff]
-                        + state->xoff * im->pixelsize,
+                    (UINT8 *)im->image[state->y + state->yoff] +
+                        state->xoff * im->pixelsize,
                     state->xsize);
             }

@@ -149,9 +146,7 @@
         }

         memcpy(
-            dst,
-            state->buffer + (state->x * bytesPerPixel - state->count),
-            flushCount);
+            dst, state->buffer + (state->x * bytesPerPixel - state->count), flushCount);
         dst += flushCount;
         bytes -= flushCount;

('src/libImaging', 'Resample.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,36 +2,34 @@

 #include <math.h>

-
-#define ROUND_UP(f) ((int) ((f) >= 0.0 ? (f) + 0.5F : (f) - 0.5F))
-
+#define ROUND_UP(f) ((int)((f) >= 0.0 ? (f) + 0.5F : (f)-0.5F))

 struct filter {
     double (*filter)(double x);
     double support;
 };

-static inline double box_filter(double x)
-{
+static inline double
+box_filter(double x) {
     if (x > -0.5 && x <= 0.5) {
         return 1.0;
     }
     return 0.0;
 }

-static inline double bilinear_filter(double x)
-{
+static inline double
+bilinear_filter(double x) {
     if (x < 0.0) {
         x = -x;
     }
     if (x < 1.0) {
-        return 1.0-x;
+        return 1.0 - x;
     }
     return 0.0;
 }

-static inline double hamming_filter(double x)
-{
+static inline double
+hamming_filter(double x) {
     if (x < 0.0) {
         x = -x;
     }
@@ -45,15 +43,16 @@
     return sin(x) / x * (0.54f + 0.46f * cos(x));
 }

-static inline double bicubic_filter(double x)
-{
-    /* https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm */
+static inline double
+bicubic_filter(double x) {
+    /* https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm
+     */
 #define a -0.5
     if (x < 0.0) {
         x = -x;
     }
     if (x < 1.0) {
-        return ((a + 2.0) * x - (a + 3.0)) * x*x + 1;
+        return ((a + 2.0) * x - (a + 3.0)) * x * x + 1;
     }
     if (x < 2.0) {
         return (((x - 5) * x + 8) * x - 4) * a;
@@ -62,8 +61,8 @@
 #undef a
 }

-static inline double sinc_filter(double x)
-{
+static inline double
+sinc_filter(double x) {
     if (x == 0.0) {
         return 1.0;
     }
@@ -71,21 +70,20 @@
     return sin(x) / x;
 }

-static inline double lanczos_filter(double x)
-{
+static inline double
+lanczos_filter(double x) {
     /* truncated sinc */
     if (-3.0 <= x && x < 3.0) {
-        return sinc_filter(x) * sinc_filter(x/3);
+        return sinc_filter(x) * sinc_filter(x / 3);
     }
     return 0.0;
 }

-static struct filter BOX = { box_filter, 0.5 };
-static struct filter BILINEAR = { bilinear_filter, 1.0 };
-static struct filter HAMMING = { hamming_filter, 1.0 };
-static struct filter BICUBIC = { bicubic_filter, 2.0 };
-static struct filter LANCZOS = { lanczos_filter, 3.0 };
-
+static struct filter BOX = {box_filter, 0.5};
+static struct filter BILINEAR = {bilinear_filter, 1.0};
+static struct filter HAMMING = {hamming_filter, 1.0};
+static struct filter BICUBIC = {bicubic_filter, 2.0};
+static struct filter LANCZOS = {lanczos_filter, 3.0};

 /* 8 bits for result. Filter can have negative areas.
    In one cases the sum of the coefficients will be negative,
@@ -93,102 +91,102 @@
    two extra bits for overflow and int type. */
 #define PRECISION_BITS (32 - 8 - 2)

-
 /* Handles values form -640 to 639. */
 UINT8 _clip8_lookups[1280] = {
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
-    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
-    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
-    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
-    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
-    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
-    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
-    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
-    144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
-    160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
-    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
-    192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
-    208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
-    224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
-    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   2,   3,   4,   5,
+    6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,
+    23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
+    40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,
+    57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,
+    74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,
+    91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107,
+    108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124,
+    125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141,
+    142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,
+    159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
+    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192,
+    193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
+    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,
+    227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243,
+    244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255,
 };

 UINT8 *clip8_lookups = &_clip8_lookups[640];

-static inline UINT8 clip8(int in)
-{
+static inline UINT8
+clip8(int in) {
     return clip8_lookups[in >> PRECISION_BITS];
 }

-
 int
-precompute_coeffs(int inSize, float in0, float in1, int outSize,
-                  struct filter *filterp, int **boundsp, double **kkp) {
+precompute_coeffs(
+    int inSize,
+    float in0,
+    float in1,
+    int outSize,
+    struct filter *filterp,
+    int **boundsp,
+    double **kkp) {
     double support, scale, filterscale;
     double center, ww, ss;
     int xx, x, ksize, xmin, xmax;
@@ -196,7 +194,7 @@
     double *kk, *k;

     /* prepare for horizontal stretch */
-    filterscale = scale = (double) (in1 - in0) / outSize;
+    filterscale = scale = (double)(in1 - in0) / outSize;
     if (filterscale < 1.0) {
         filterscale = 1.0;
     }
@@ -205,7 +203,7 @@
     support = filterp->support * filterscale;

     /* maximum number of coeffs */
-    ksize = (int) ceil(support) * 2 + 1;
+    ksize = (int)ceil(support) * 2 + 1;

     // check for overflow
     if (outSize > INT_MAX / (ksize * (int)sizeof(double))) {
@@ -216,14 +214,14 @@
     /* coefficient buffer */
     /* malloc check ok, overflow checked above */
     kk = malloc(outSize * ksize * sizeof(double));
-    if ( ! kk) {
+    if (!kk) {
         ImagingError_MemoryError();
         return 0;
     }

     /* malloc check ok, ksize*sizeof(double) > 2*sizeof(int) */
     bounds = malloc(outSize * 2 * sizeof(int));
-    if ( ! bounds) {
+    if (!bounds) {
         free(kk);
         ImagingError_MemoryError();
         return 0;
@@ -234,12 +232,12 @@
         ww = 0.0;
         ss = 1.0 / filterscale;
         // Round the value
-        xmin = (int) (center - support + 0.5);
+        xmin = (int)(center - support + 0.5);
         if (xmin < 0) {
             xmin = 0;
         }
         // Round the value
-        xmax = (int) (center + support + 0.5);
+        xmax = (int)(center + support + 0.5);
         if (xmax > inSize) {
             xmax = inSize;
         }
@@ -267,38 +265,33 @@
     return ksize;
 }

-
 void
-normalize_coeffs_8bpc(int outSize, int ksize, double *prekk)
-{
+normalize_coeffs_8bpc(int outSize, int ksize, double *prekk) {
     int x;
     INT32 *kk;

     // use the same buffer for normalized coefficients
-    kk = (INT32 *) prekk;
+    kk = (INT32 *)prekk;

     for (x = 0; x < outSize * ksize; x++) {
         if (prekk[x] < 0) {
-            kk[x] = (int) (-0.5 + prekk[x] * (1 << PRECISION_BITS));
+            kk[x] = (int)(-0.5 + prekk[x] * (1 << PRECISION_BITS));
         } else {
-            kk[x] = (int) (0.5 + prekk[x] * (1 << PRECISION_BITS));
-        }
-    }
-}
-
-
+            kk[x] = (int)(0.5 + prekk[x] * (1 << PRECISION_BITS));
+        }
+    }
+}

 void
-ImagingResampleHorizontal_8bpc(Imaging imOut, Imaging imIn, int offset,
-                               int ksize, int *bounds, double *prekk)
-{
+ImagingResampleHorizontal_8bpc(
+    Imaging imOut, Imaging imIn, int offset, int ksize, int *bounds, double *prekk) {
     ImagingSectionCookie cookie;
     int ss0, ss1, ss2, ss3;
     int xx, yy, x, xmin, xmax;
     INT32 *k, *kk;

     // use the same buffer for normalized coefficients
-    kk = (INT32 *) prekk;
+    kk = (INT32 *)prekk;
     normalize_coeffs_8bpc(imOut->xsize, ksize, prekk);

     ImagingSectionEnter(&cookie);
@@ -308,9 +301,9 @@
                 xmin = bounds[xx * 2 + 0];
                 xmax = bounds[xx * 2 + 1];
                 k = &kk[xx * ksize];
-                ss0 = 1 << (PRECISION_BITS -1);
+                ss0 = 1 << (PRECISION_BITS - 1);
                 for (x = 0; x < xmax; x++) {
-                    ss0 += ((UINT8) imIn->image8[yy + offset][x + xmin]) * k[x];
+                    ss0 += ((UINT8)imIn->image8[yy + offset][x + xmin]) * k[x];
                 }
                 imOut->image8[yy][xx] = clip8(ss0);
             }
@@ -323,10 +316,12 @@
                     xmin = bounds[xx * 2 + 0];
                     xmax = bounds[xx * 2 + 1];
                     k = &kk[xx * ksize];
-                    ss0 = ss3 = 1 << (PRECISION_BITS -1);
+                    ss0 = ss3 = 1 << (PRECISION_BITS - 1);
                     for (x = 0; x < xmax; x++) {
-                        ss0 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 0]) * k[x];
-                        ss3 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 3]) * k[x];
+                        ss0 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 0]) *
+                               k[x];
+                        ss3 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 3]) *
+                               k[x];
                     }
                     v = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
                     memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
@@ -339,11 +334,14 @@
                     xmin = bounds[xx * 2 + 0];
                     xmax = bounds[xx * 2 + 1];
                     k = &kk[xx * ksize];
-                    ss0 = ss1 = ss2 = 1 << (PRECISION_BITS -1);
+                    ss0 = ss1 = ss2 = 1 << (PRECISION_BITS - 1);
                     for (x = 0; x < xmax; x++) {
-                        ss0 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 0]) * k[x];
-                        ss1 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 1]) * k[x];
-                        ss2 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 2]) * k[x];
+                        ss0 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 0]) *
+                               k[x];
+                        ss1 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 1]) *
+                               k[x];
+                        ss2 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 2]) *
+                               k[x];
                     }
                     v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), 0);
                     memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
@@ -356,12 +354,16 @@
                     xmin = bounds[xx * 2 + 0];
                     xmax = bounds[xx * 2 + 1];
                     k = &kk[xx * ksize];
-                    ss0 = ss1 = ss2 = ss3 = 1 << (PRECISION_BITS -1);
+                    ss0 = ss1 = ss2 = ss3 = 1 << (PRECISION_BITS - 1);
                     for (x = 0; x < xmax; x++) {
-                        ss0 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 0]) * k[x];
-                        ss1 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 1]) * k[x];
-                        ss2 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 2]) * k[x];
-                        ss3 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 3]) * k[x];
+                        ss0 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 0]) *
+                               k[x];
+                        ss1 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 1]) *
+                               k[x];
+                        ss2 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 2]) *
+                               k[x];
+                        ss3 += ((UINT8)imIn->image[yy + offset][(x + xmin) * 4 + 3]) *
+                               k[x];
                     }
                     v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
                     memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
@@ -372,18 +374,16 @@
     ImagingSectionLeave(&cookie);
 }

-
 void
-ImagingResampleVertical_8bpc(Imaging imOut, Imaging imIn, int offset,
-                             int ksize, int *bounds, double *prekk)
-{
+ImagingResampleVertical_8bpc(
+    Imaging imOut, Imaging imIn, int offset, int ksize, int *bounds, double *prekk) {
     ImagingSectionCookie cookie;
     int ss0, ss1, ss2, ss3;
     int xx, yy, y, ymin, ymax;
     INT32 *k, *kk;

     // use the same buffer for normalized coefficients
-    kk = (INT32 *) prekk;
+    kk = (INT32 *)prekk;
     normalize_coeffs_8bpc(imOut->ysize, ksize, prekk);

     ImagingSectionEnter(&cookie);
@@ -393,9 +393,9 @@
             ymin = bounds[yy * 2 + 0];
             ymax = bounds[yy * 2 + 1];
             for (xx = 0; xx < imOut->xsize; xx++) {
-                ss0 = 1 << (PRECISION_BITS -1);
+                ss0 = 1 << (PRECISION_BITS - 1);
                 for (y = 0; y < ymax; y++) {
-                    ss0 += ((UINT8) imIn->image8[y + ymin][xx]) * k[y];
+                    ss0 += ((UINT8)imIn->image8[y + ymin][xx]) * k[y];
                 }
                 imOut->image8[yy][xx] = clip8(ss0);
             }
@@ -408,10 +408,10 @@
                 ymax = bounds[yy * 2 + 1];
                 for (xx = 0; xx < imOut->xsize; xx++) {
                     UINT32 v;
-                    ss0 = ss3 = 1 << (PRECISION_BITS -1);
+                    ss0 = ss3 = 1 << (PRECISION_BITS - 1);
                     for (y = 0; y < ymax; y++) {
-                        ss0 += ((UINT8) imIn->image[y + ymin][xx*4 + 0]) * k[y];
-                        ss3 += ((UINT8) imIn->image[y + ymin][xx*4 + 3]) * k[y];
+                        ss0 += ((UINT8)imIn->image[y + ymin][xx * 4 + 0]) * k[y];
+                        ss3 += ((UINT8)imIn->image[y + ymin][xx * 4 + 3]) * k[y];
                     }
                     v = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
                     memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
@@ -424,11 +424,11 @@
                 ymax = bounds[yy * 2 + 1];
                 for (xx = 0; xx < imOut->xsize; xx++) {
                     UINT32 v;
-                    ss0 = ss1 = ss2 = 1 << (PRECISION_BITS -1);
+                    ss0 = ss1 = ss2 = 1 << (PRECISION_BITS - 1);
                     for (y = 0; y < ymax; y++) {
-                        ss0 += ((UINT8) imIn->image[y + ymin][xx*4 + 0]) * k[y];
-                        ss1 += ((UINT8) imIn->image[y + ymin][xx*4 + 1]) * k[y];
-                        ss2 += ((UINT8) imIn->image[y + ymin][xx*4 + 2]) * k[y];
+                        ss0 += ((UINT8)imIn->image[y + ymin][xx * 4 + 0]) * k[y];
+                        ss1 += ((UINT8)imIn->image[y + ymin][xx * 4 + 1]) * k[y];
+                        ss2 += ((UINT8)imIn->image[y + ymin][xx * 4 + 2]) * k[y];
                     }
                     v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), 0);
                     memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
@@ -441,12 +441,12 @@
                 ymax = bounds[yy * 2 + 1];
                 for (xx = 0; xx < imOut->xsize; xx++) {
                     UINT32 v;
-                    ss0 = ss1 = ss2 = ss3 = 1 << (PRECISION_BITS -1);
+                    ss0 = ss1 = ss2 = ss3 = 1 << (PRECISION_BITS - 1);
                     for (y = 0; y < ymax; y++) {
-                        ss0 += ((UINT8) imIn->image[y + ymin][xx*4 + 0]) * k[y];
-                        ss1 += ((UINT8) imIn->image[y + ymin][xx*4 + 1]) * k[y];
-                        ss2 += ((UINT8) imIn->image[y + ymin][xx*4 + 2]) * k[y];
-                        ss3 += ((UINT8) imIn->image[y + ymin][xx*4 + 3]) * k[y];
+                        ss0 += ((UINT8)imIn->image[y + ymin][xx * 4 + 0]) * k[y];
+                        ss1 += ((UINT8)imIn->image[y + ymin][xx * 4 + 1]) * k[y];
+                        ss2 += ((UINT8)imIn->image[y + ymin][xx * 4 + 2]) * k[y];
+                        ss3 += ((UINT8)imIn->image[y + ymin][xx * 4 + 3]) * k[y];
                     }
                     v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
                     memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
@@ -457,18 +457,16 @@
     ImagingSectionLeave(&cookie);
 }

-
 void
-ImagingResampleHorizontal_32bpc(Imaging imOut, Imaging imIn, int offset,
-                                int ksize, int *bounds, double *kk)
-{
+ImagingResampleHorizontal_32bpc(
+    Imaging imOut, Imaging imIn, int offset, int ksize, int *bounds, double *kk) {
     ImagingSectionCookie cookie;
     double ss;
     int xx, yy, x, xmin, xmax;
     double *k;

     ImagingSectionEnter(&cookie);
-    switch(imIn->type) {
+    switch (imIn->type) {
         case IMAGING_TYPE_INT32:
             for (yy = 0; yy < imOut->ysize; yy++) {
                 for (xx = 0; xx < imOut->xsize; xx++) {
@@ -502,18 +500,16 @@
     ImagingSectionLeave(&cookie);
 }

-
 void
-ImagingResampleVertical_32bpc(Imaging imOut, Imaging imIn, int offset,
-                              int ksize, int *bounds, double *kk)
-{
+ImagingResampleVertical_32bpc(
+    Imaging imOut, Imaging imIn, int offset, int ksize, int *bounds, double *kk) {
     ImagingSectionCookie cookie;
     double ss;
     int xx, yy, y, ymin, ymax;
     double *k;

     ImagingSectionEnter(&cookie);
-    switch(imIn->type) {
+    switch (imIn->type) {
         case IMAGING_TYPE_INT32:
             for (yy = 0; yy < imOut->ysize; yy++) {
                 ymin = bounds[yy * 2 + 0];
@@ -547,36 +543,36 @@
     ImagingSectionLeave(&cookie);
 }

-
-typedef void (*ResampleFunction)(Imaging imOut, Imaging imIn, int offset,
-                                 int ksize, int *bounds, double *kk);
-
+typedef void (*ResampleFunction)(
+    Imaging imOut, Imaging imIn, int offset, int ksize, int *bounds, double *kk);

 Imaging
-ImagingResampleInner(Imaging imIn, int xsize, int ysize,
-                     struct filter *filterp, float box[4],
-                     ResampleFunction ResampleHorizontal,
-                     ResampleFunction ResampleVertical);
-
+ImagingResampleInner(
+    Imaging imIn,
+    int xsize,
+    int ysize,
+    struct filter *filterp,
+    float box[4],
+    ResampleFunction ResampleHorizontal,
+    ResampleFunction ResampleVertical);

 Imaging
-ImagingResample(Imaging imIn, int xsize, int ysize, int filter, float box[4])
-{
+ImagingResample(Imaging imIn, int xsize, int ysize, int filter, float box[4]) {
     struct filter *filterp;
     ResampleFunction ResampleHorizontal;
     ResampleFunction ResampleVertical;

     if (strcmp(imIn->mode, "P") == 0 || strcmp(imIn->mode, "1") == 0) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (imIn->type == IMAGING_TYPE_SPECIAL) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     } else if (imIn->image8) {
         ResampleHorizontal = ImagingResampleHorizontal_8bpc;
         ResampleVertical = ImagingResampleVertical_8bpc;
     } else {
-        switch(imIn->type) {
+        switch (imIn->type) {
             case IMAGING_TYPE_UINT8:
                 ResampleHorizontal = ImagingResampleHorizontal_8bpc;
                 ResampleVertical = ImagingResampleVertical_8bpc;
@@ -587,44 +583,44 @@
                 ResampleVertical = ImagingResampleVertical_32bpc;
                 break;
             default:
-                return (Imaging) ImagingError_ModeError();
+                return (Imaging)ImagingError_ModeError();
         }
     }

     /* check filter */
     switch (filter) {
-    case IMAGING_TRANSFORM_BOX:
-        filterp = &BOX;
-        break;
-    case IMAGING_TRANSFORM_BILINEAR:
-        filterp = &BILINEAR;
-        break;
-    case IMAGING_TRANSFORM_HAMMING:
-        filterp = &HAMMING;
-        break;
-    case IMAGING_TRANSFORM_BICUBIC:
-        filterp = &BICUBIC;
-        break;
-    case IMAGING_TRANSFORM_LANCZOS:
-        filterp = &LANCZOS;
-        break;
-    default:
-        return (Imaging) ImagingError_ValueError(
-            "unsupported resampling filter"
-            );
-    }
-
-    return ImagingResampleInner(imIn, xsize, ysize, filterp, box,
-                                ResampleHorizontal, ResampleVertical);
-}
-
+        case IMAGING_TRANSFORM_BOX:
+            filterp = &BOX;
+            break;
+        case IMAGING_TRANSFORM_BILINEAR:
+            filterp = &BILINEAR;
+            break;
+        case IMAGING_TRANSFORM_HAMMING:
+            filterp = &HAMMING;
+            break;
+        case IMAGING_TRANSFORM_BICUBIC:
+            filterp = &BICUBIC;
+            break;
+        case IMAGING_TRANSFORM_LANCZOS:
+            filterp = &LANCZOS;
+            break;
+        default:
+            return (Imaging)ImagingError_ValueError("unsupported resampling filter");
+    }
+
+    return ImagingResampleInner(
+        imIn, xsize, ysize, filterp, box, ResampleHorizontal, ResampleVertical);
+}

 Imaging
-ImagingResampleInner(Imaging imIn, int xsize, int ysize,
-                     struct filter *filterp, float box[4],
-                     ResampleFunction ResampleHorizontal,
-                     ResampleFunction ResampleVertical)
-{
+ImagingResampleInner(
+    Imaging imIn,
+    int xsize,
+    int ysize,
+    struct filter *filterp,
+    float box[4],
+    ResampleFunction ResampleHorizontal,
+    ResampleFunction ResampleVertical) {
     Imaging imTemp = NULL;
     Imaging imOut = NULL;

@@ -637,15 +633,15 @@
     need_horizontal = xsize != imIn->xsize || box[0] || box[2] != xsize;
     need_vertical = ysize != imIn->ysize || box[1] || box[3] != ysize;

-    ksize_horiz = precompute_coeffs(imIn->xsize, box[0], box[2], xsize,
-                                    filterp, &bounds_horiz, &kk_horiz);
-    if ( ! ksize_horiz) {
+    ksize_horiz = precompute_coeffs(
+        imIn->xsize, box[0], box[2], xsize, filterp, &bounds_horiz, &kk_horiz);
+    if (!ksize_horiz) {
         return NULL;
     }

-    ksize_vert = precompute_coeffs(imIn->ysize, box[1], box[3], ysize,
-                                   filterp, &bounds_vert, &kk_vert);
-    if ( ! ksize_vert) {
+    ksize_vert = precompute_coeffs(
+        imIn->ysize, box[1], box[3], ysize, filterp, &bounds_vert, &kk_vert);
+    if (!ksize_vert) {
         free(bounds_horiz);
         free(kk_horiz);
         return NULL;
@@ -654,8 +650,7 @@
     // First used row in the source image
     ybox_first = bounds_vert[0];
     // Last used row in the source image
-    ybox_last = bounds_vert[ysize*2 - 2] + bounds_vert[ysize*2 - 1];
-
+    ybox_last = bounds_vert[ysize * 2 - 2] + bounds_vert[ysize * 2 - 1];

     /* two-pass resize, horizontal pass */
     if (need_horizontal) {
@@ -666,12 +661,12 @@

         imTemp = ImagingNewDirty(imIn->mode, xsize, ybox_last - ybox_first);
         if (imTemp) {
-            ResampleHorizontal(imTemp, imIn, ybox_first,
-                               ksize_horiz, bounds_horiz, kk_horiz);
+            ResampleHorizontal(
+                imTemp, imIn, ybox_first, ksize_horiz, bounds_horiz, kk_horiz);
         }
         free(bounds_horiz);
         free(kk_horiz);
-        if ( ! imTemp) {
+        if (!imTemp) {
             free(bounds_vert);
             free(kk_vert);
             return NULL;
@@ -688,15 +683,14 @@
         imOut = ImagingNewDirty(imIn->mode, imIn->xsize, ysize);
         if (imOut) {
             /* imIn can be the original image or horizontally resampled one */
-            ResampleVertical(imOut, imIn, 0,
-                             ksize_vert, bounds_vert, kk_vert);
+            ResampleVertical(imOut, imIn, 0, ksize_vert, bounds_vert, kk_vert);
         }
         /* it's safe to call ImagingDelete with empty value
            if previous step was not performed. */
         ImagingDelete(imTemp);
         free(bounds_vert);
         free(kk_vert);
-        if ( ! imOut) {
+        if (!imOut) {
             return NULL;
         }
     } else {
@@ -706,7 +700,7 @@
     }

     /* none of the previous steps are performed, copying */
-    if ( ! imOut) {
+    if (!imOut) {
         imOut = ImagingCopy(imIn);
     }

('src/libImaging', 'RawEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -17,16 +17,13 @@
  *
  * See the README file for information on usage and redistribution.  */

-
 #include "Imaging.h"

 int
-ImagingRawEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)
-{
-    UINT8* ptr;
+ImagingRawEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes) {
+    UINT8 *ptr;

     if (!state->state) {
-
         /* The "count" field holds the stride, if specified.  Fix
            things up so "bytes" is the full size, and "count" the
            packed size */
@@ -48,14 +45,13 @@
         /* The "ystep" field specifies the orientation */

         if (state->ystep < 0) {
-            state->y = state->ysize-1;
+            state->y = state->ysize - 1;
             state->ystep = -1;
         } else {
             state->ystep = 1;
         }

         state->state = 1;
-
     }

     if (bytes < state->bytes) {
@@ -66,9 +62,10 @@
     ptr = buf;

     while (bytes >= state->bytes) {
-
-        state->shuffle(ptr, (UINT8*) im->image[state->y + state->yoff] +
-                   state->xoff * im->pixelsize, state->xsize);
+        state->shuffle(
+            ptr,
+            (UINT8 *)im->image[state->y + state->yoff] + state->xoff * im->pixelsize,
+            state->xsize);

         if (state->bytes > state->count) {
             /* zero-pad the buffer, if necessary */
@@ -84,9 +81,7 @@
             state->errcode = IMAGING_CODEC_END;
             break;
         }
-
     }

     return ptr - buf;
-
 }
('src/libImaging', 'JpegEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,10 +19,9 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

-#ifdef  HAVE_LIBJPEG
+#ifdef HAVE_LIBJPEG

 #undef HAVE_PROTOTYPES
 #undef HAVE_STDLIB_H
@@ -40,51 +39,42 @@
 /* -------------------------------------------------------------------- */

 METHODDEF(void)
-stub(j_compress_ptr cinfo)
-{
-    /* empty */
-}
+stub(j_compress_ptr cinfo) { /* empty */ }

 METHODDEF(boolean)
-empty_output_buffer (j_compress_ptr cinfo)
-{
+empty_output_buffer(j_compress_ptr cinfo) {
     /* Suspension */
     return FALSE;
 }

 GLOBAL(void)
-jpeg_buffer_dest(j_compress_ptr cinfo, JPEGDESTINATION* destination)
-{
-    cinfo->dest = (void*) destination;
+jpeg_buffer_dest(j_compress_ptr cinfo, JPEGDESTINATION *destination) {
+    cinfo->dest = (void *)destination;

     destination->pub.init_destination = stub;
     destination->pub.empty_output_buffer = empty_output_buffer;
     destination->pub.term_destination = stub;
 }

-
 /* -------------------------------------------------------------------- */
 /* Error handler                                                        */
 /* -------------------------------------------------------------------- */

 METHODDEF(void)
-error(j_common_ptr cinfo)
-{
-    JPEGERROR* error;
-    error = (JPEGERROR*) cinfo->err;
-    (*cinfo->err->output_message) (cinfo);
+error(j_common_ptr cinfo) {
+    JPEGERROR *error;
+    error = (JPEGERROR *)cinfo->err;
+    (*cinfo->err->output_message)(cinfo);
     longjmp(error->setjmp_buffer, 1);
 }

-
 /* -------------------------------------------------------------------- */
 /* Encoder                                                              */
 /* -------------------------------------------------------------------- */

 int
-ImagingJpegEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)
-{
-    JPEGENCODERSTATE* context = (JPEGENCODERSTATE*) state->context;
+ImagingJpegEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes) {
+    JPEGENCODERSTATE *context = (JPEGENCODERSTATE *)state->context;
     int ok;

     if (setjmp(context->error.setjmp_buffer)) {
@@ -95,7 +85,6 @@
     }

     if (!state->state) {
-
         /* Setup compression context (very similar to the decoder) */
         context->cinfo.err = jpeg_std_error(&context->error.pub);
         context->error.pub.error_exit = error;
@@ -106,7 +95,6 @@

         /* Ready to encode */
         state->state = 1;
-
     }

     /* Load the destination buffer */
@@ -114,7 +102,6 @@
     context->destination.pub.free_in_buffer = bytes;

     switch (state->state) {
-
         case 1:

             context->cinfo.image_width = state->xsize;
@@ -136,11 +123,11 @@
                 case 32:
                     context->cinfo.input_components = 4;
                     context->cinfo.in_color_space = JCS_CMYK;
-                #ifdef JCS_EXTENSIONS
+#ifdef JCS_EXTENSIONS
                     if (strcmp(context->rawmode, "RGBX") == 0) {
                         context->cinfo.in_color_space = JCS_EXT_RGBX;
                     }
-                #endif
+#endif
                     break;
                 default:
                     state->errcode = IMAGING_CODEC_CONFIG;
@@ -159,15 +146,20 @@
                     quality = context->quality;
                 }
                 for (i = 0; i < context->qtablesLen; i++) {
-                    jpeg_add_quant_table(&context->cinfo, i, &context->qtables[i * DCTSIZE2],
-                                         quality, FALSE);
+                    jpeg_add_quant_table(
+                        &context->cinfo,
+                        i,
+                        &context->qtables[i * DCTSIZE2],
+                        quality,
+                        FALSE);
                     context->cinfo.comp_info[i].quant_tbl_no = i;
                     last_q = i;
                 }
                 if (context->qtablesLen == 1) {
-                    // jpeg_set_defaults created two qtables internally, but we only wanted one.
-                    jpeg_add_quant_table(&context->cinfo, 1, &context->qtables[0],
-                                         quality, FALSE);
+                    // jpeg_set_defaults created two qtables internally, but we only
+                    // wanted one.
+                    jpeg_add_quant_table(
+                        &context->cinfo, 1, &context->qtables[0], quality, FALSE);
                 }
                 for (i = last_q; i < context->cinfo.num_components; i++) {
                     context->cinfo.comp_info[i].quant_tbl_no = last_q;
@@ -177,9 +169,8 @@
             }

             /* Set subsampling options */
-            switch (context->subsampling)
-                {
-                case 0:  /* 1x1 1x1 1x1 (4:4:4) : None */
+            switch (context->subsampling) {
+                case 0: /* 1x1 1x1 1x1 (4:4:4) : None */
                 {
                     context->cinfo.comp_info[0].h_samp_factor = 1;
                     context->cinfo.comp_info[0].v_samp_factor = 1;
@@ -189,7 +180,7 @@
                     context->cinfo.comp_info[2].v_samp_factor = 1;
                     break;
                 }
-                case 1:  /* 2x1, 1x1, 1x1 (4:2:2) : Medium */
+                case 1: /* 2x1, 1x1, 1x1 (4:2:2) : Medium */
                 {
                     context->cinfo.comp_info[0].h_samp_factor = 2;
                     context->cinfo.comp_info[0].v_samp_factor = 1;
@@ -199,7 +190,7 @@
                     context->cinfo.comp_info[2].v_samp_factor = 1;
                     break;
                 }
-                case 2:  /* 2x2, 1x1, 1x1 (4:2:0) : High */
+                case 2: /* 2x2, 1x1, 1x1 (4:2:0) : High */
                 {
                     context->cinfo.comp_info[0].h_samp_factor = 2;
                     context->cinfo.comp_info[0].v_samp_factor = 2;
@@ -209,23 +200,22 @@
                     context->cinfo.comp_info[2].v_samp_factor = 1;
                     break;
                 }
-                default:
-                {
+                default: {
                     /* Use the lib's default */
                     break;
                 }
-                }
-                if (context->progressive) {
-                    jpeg_simple_progression(&context->cinfo);
-                }
-                context->cinfo.smoothing_factor = context->smooth;
-                context->cinfo.optimize_coding = (boolean) context->optimize;
-                if (context->xdpi > 0 && context->ydpi > 0) {
-                    context->cinfo.write_JFIF_header = TRUE;
-                    context->cinfo.density_unit = 1; /* dots per inch */
-                    context->cinfo.X_density = context->xdpi;
-                    context->cinfo.Y_density = context->ydpi;
-                }
+            }
+            if (context->progressive) {
+                jpeg_simple_progression(&context->cinfo);
+            }
+            context->cinfo.smoothing_factor = context->smooth;
+            context->cinfo.optimize_coding = (boolean)context->optimize;
+            if (context->xdpi > 0 && context->ydpi > 0) {
+                context->cinfo.write_JFIF_header = TRUE;
+                context->cinfo.density_unit = 1; /* dots per inch */
+                context->cinfo.X_density = context->xdpi;
+                context->cinfo.Y_density = context->ydpi;
+            }
             switch (context->streamtype) {
                 case 1:
                     /* tables only -- not yet implemented */
@@ -248,13 +238,16 @@

         case 2:
             // check for exif len + 'APP1' header bytes
-            if (context->rawExifLen + 5 >  context->destination.pub.free_in_buffer){
+            if (context->rawExifLen + 5 > context->destination.pub.free_in_buffer) {
                 break;
             }
-            //add exif header
-            if (context->rawExifLen > 0){
-                jpeg_write_marker(&context->cinfo, JPEG_APP0+1,
-                                  (unsigned char*)context->rawExif, context->rawExifLen);
+            // add exif header
+            if (context->rawExifLen > 0) {
+                jpeg_write_marker(
+                    &context->cinfo,
+                    JPEG_APP0 + 1,
+                    (unsigned char *)context->rawExif,
+                    context->rawExifLen);
             }

             state->state++;
@@ -267,8 +260,10 @@
                 if (n > context->destination.pub.free_in_buffer) {
                     n = context->destination.pub.free_in_buffer;
                 }
-                memcpy(context->destination.pub.next_output_byte,
-                       context->extra + context->extra_offset, n);
+                memcpy(
+                    context->destination.pub.next_output_byte,
+                    context->extra + context->extra_offset,
+                    n);
                 context->destination.pub.next_output_byte += n;
                 context->destination.pub.free_in_buffer -= n;
                 context->extra_offset += n;
@@ -282,15 +277,17 @@
             }

         case 4:
-            if (1024 > context->destination.pub.free_in_buffer){
+            if (1024 > context->destination.pub.free_in_buffer) {
                 break;
             }

             ok = 1;
             while (state->y < state->ysize) {
-                state->shuffle(state->buffer,
-                       (UINT8*) im->image[state->y + state->yoff] +
-                       state->xoff * im->pixelsize, state->xsize);
+                state->shuffle(
+                    state->buffer,
+                    (UINT8 *)im->image[state->y + state->yoff] +
+                        state->xoff * im->pixelsize,
+                    state->xsize);
                 ok = jpeg_write_scanlines(&context->cinfo, &state->buffer, 1);
                 if (ok != 1) {
                     break;
@@ -330,17 +327,14 @@
             /* if (jerr.pub.num_warnings) return BROKEN; */
             state->errcode = IMAGING_CODEC_END;
             break;
-
     }

     /* Return number of bytes in output buffer */
     return context->destination.pub.next_output_byte - buf;
-
-}
-
-const char*
-ImagingJpegVersion(void)
-{
+}
+
+const char *
+ImagingJpegVersion(void) {
     static char version[20];
     sprintf(version, "%d.%d", JPEG_LIB_VERSION / 10, JPEG_LIB_VERSION % 10);
     return version;
('src/libImaging', 'Jpeg2K.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,7 +24,7 @@
     int fd;

     /* File pointer, when opened */
-    FILE * pfile;
+    FILE *pfile;

     /* Length of data, if available; otherwise, -1 */
     off_t length;
@@ -33,13 +33,13 @@
     OPJ_CODEC_FORMAT format;

     /* Set to divide image resolution by 2**reduce. */
-    int            reduce;
+    int reduce;

     /* Set to limit the number of quality layers to decode (0 = all layers) */
-    int            layers;
+    int layers;

     /* PRIVATE CONTEXT (set by decoder) */
-    const char    *error_msg;
+    const char *error_msg;

 } JPEG2KDECODESTATE;

@@ -51,36 +51,39 @@
     /* CONFIGURATION */

     /* File descriptor, if available; otherwise, -1 */
-    int           fd;
+    int fd;

     /* File pointer, when opened */
-    FILE * pfile;
+    FILE *pfile;

     /* Specify the desired format */
     OPJ_CODEC_FORMAT format;

     /* Image offset */
-    int            offset_x, offset_y;
+    int offset_x, offset_y;

     /* Tile information */
-    int            tile_offset_x, tile_offset_y;
-    int            tile_size_x, tile_size_y;
+    int tile_offset_x, tile_offset_y;
+    int tile_size_x, tile_size_y;

     /* Quality layers (a sequence of numbers giving *either* rates or dB) */
-    int            quality_is_in_db;
-    PyObject      *quality_layers;
+    int quality_is_in_db;
+    PyObject *quality_layers;

     /* Number of resolutions (DWT decompositions + 1 */
-    int            num_resolutions;
+    int num_resolutions;

     /* Code block size */
-    int            cblk_width, cblk_height;
+    int cblk_width, cblk_height;

     /* Precinct size */
-    int            precinct_width, precinct_height;
+    int precinct_width, precinct_height;

     /* Compression style */
-    int            irreversible;
+    int irreversible;
+
+    /* Set multiple component transformation */
+    char mct;

     /* Progression order (LRCP/RLCP/RPCL/PCRL/CPRL) */
     OPJ_PROG_ORDER progression;
@@ -89,8 +92,7 @@
     OPJ_CINEMA_MODE cinema_mode;

     /* PRIVATE CONTEXT (set by decoder) */
-    const char    *error_msg;
-
+    const char *error_msg;

 } JPEG2KENCODESTATE;

('src/libImaging', 'QuantTypes.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -20,13 +20,13 @@
 #endif

 typedef union {
-   struct {
-      unsigned char r,g,b,a;
-   } c;
-   struct {
-      unsigned char v[4];
-   } a;
-   uint32_t v;
+    struct {
+        unsigned char r, g, b, a;
+    } c;
+    struct {
+        unsigned char v[4];
+    } a;
+    uint32_t v;
 } Pixel;

 #endif
('src/libImaging', 'Blend.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,27 +15,22 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 Imaging
-ImagingBlend(Imaging imIn1, Imaging imIn2, float alpha)
-{
+ImagingBlend(Imaging imIn1, Imaging imIn2, float alpha) {
     Imaging imOut;
     int x, y;

     /* Check arguments */
-    if (!imIn1 || !imIn2 || imIn1->type != IMAGING_TYPE_UINT8
-        || imIn1->palette || strcmp(imIn1->mode, "1") == 0
-        || imIn2->palette || strcmp(imIn2->mode, "1") == 0) {
+    if (!imIn1 || !imIn2 || imIn1->type != IMAGING_TYPE_UINT8 || imIn1->palette ||
+        strcmp(imIn1->mode, "1") == 0 || imIn2->palette ||
+        strcmp(imIn2->mode, "1") == 0) {
         return ImagingError_ModeError();
     }

-    if (imIn1->type  != imIn2->type  ||
-        imIn1->bands != imIn2->bands ||
-        imIn1->xsize != imIn2->xsize ||
-        imIn1->ysize != imIn2->ysize) {
+    if (imIn1->type != imIn2->type || imIn1->bands != imIn2->bands ||
+        imIn1->xsize != imIn2->xsize || imIn1->ysize != imIn2->ysize) {
         return ImagingError_Mismatch();
     }

@@ -54,29 +49,27 @@
     if (alpha >= 0 && alpha <= 1.0) {
         /* Interpolate between bands */
         for (y = 0; y < imIn1->ysize; y++) {
-            UINT8* in1 = (UINT8*) imIn1->image[y];
-            UINT8* in2 = (UINT8*) imIn2->image[y];
-            UINT8* out = (UINT8*) imOut->image[y];
+            UINT8 *in1 = (UINT8 *)imIn1->image[y];
+            UINT8 *in2 = (UINT8 *)imIn2->image[y];
+            UINT8 *out = (UINT8 *)imOut->image[y];
             for (x = 0; x < imIn1->linesize; x++) {
-                out[x] = (UINT8)
-                    ((int) in1[x] + alpha * ((int) in2[x] - (int) in1[x]));
+                out[x] = (UINT8)((int)in1[x] + alpha * ((int)in2[x] - (int)in1[x]));
             }
         }
     } else {
         /* Extrapolation; must make sure to clip resulting values */
         for (y = 0; y < imIn1->ysize; y++) {
-            UINT8* in1 = (UINT8*) imIn1->image[y];
-            UINT8* in2 = (UINT8*) imIn2->image[y];
-            UINT8* out = (UINT8*) imOut->image[y];
+            UINT8 *in1 = (UINT8 *)imIn1->image[y];
+            UINT8 *in2 = (UINT8 *)imIn2->image[y];
+            UINT8 *out = (UINT8 *)imOut->image[y];
             for (x = 0; x < imIn1->linesize; x++) {
-                float temp = (float)
-                    ((int) in1[x] + alpha * ((int) in2[x] - (int) in1[x]));
+                float temp = (float)((int)in1[x] + alpha * ((int)in2[x] - (int)in1[x]));
                 if (temp <= 0.0) {
                     out[x] = 0;
                 } else if (temp >= 255.0) {
                     out[x] = 255;
                 } else {
-                    out[x] = (UINT8) temp;
+                    out[x] = (UINT8)temp;
                 }
             }
         }
('src/libImaging', 'BitDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,20 +13,16 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #include "Bit.h"

-
 int
-ImagingBitDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
-    BITSTATE* bitstate = state->context;
-    UINT8* ptr;
+ImagingBitDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
+    BITSTATE *bitstate = state->context;
+    UINT8 *ptr;

     if (state->state == 0) {
-
         /* Initialize context variables */

         /* this decoder only works for float32 image buffers */
@@ -41,37 +37,35 @@
             return -1;
         }

-        bitstate->mask = (1<<bitstate->bits)-1;
+        bitstate->mask = (1 << bitstate->bits) - 1;

         if (bitstate->sign) {
-            bitstate->signmask = (1<<(bitstate->bits-1));
+            bitstate->signmask = (1 << (bitstate->bits - 1));
         }

         /* check image orientation */
         if (state->ystep < 0) {
-            state->y = state->ysize-1;
+            state->y = state->ysize - 1;
             state->ystep = -1;
         } else {
             state->ystep = 1;
         }

         state->state = 1;
-
     }

     ptr = buf;

     while (bytes > 0) {
-
         UINT8 byte = *ptr;

         ptr++;
         bytes--;

         /* get a byte from the input stream and insert in the bit buffer */
-        if (bitstate->fill&1) {
+        if (bitstate->fill & 1) {
             /* fill MSB first */
-            bitstate->bitbuffer |= (unsigned long) byte << bitstate->bitcount;
+            bitstate->bitbuffer |= (unsigned long)byte << bitstate->bitcount;
         } else {
             /* fill LSB first */
             bitstate->bitbuffer = (bitstate->bitbuffer << 8) | byte;
@@ -80,26 +74,24 @@
         bitstate->bitcount += 8;

         while (bitstate->bitcount >= bitstate->bits) {
-
             /* get a pixel from the bit buffer */
             unsigned long data;
             FLOAT32 pixel;

-            if (bitstate->fill&2) {
+            if (bitstate->fill & 2) {
                 /* store LSB first */
                 data = bitstate->bitbuffer & bitstate->mask;
                 if (bitstate->bitcount > 32) {
                     /* bitbuffer overflow; restore it from last input byte */
-                    bitstate->bitbuffer = byte >> (8 - (bitstate->bitcount -
-                                                        bitstate->bits));
+                    bitstate->bitbuffer =
+                        byte >> (8 - (bitstate->bitcount - bitstate->bits));
                 } else {
                     bitstate->bitbuffer >>= bitstate->bits;
                 }
             } else {
                 /* store MSB first */
-                data = (bitstate->bitbuffer >> (bitstate->bitcount -
-                                                bitstate->bits))
-                       & bitstate->mask;
+                data = (bitstate->bitbuffer >> (bitstate->bitcount - bitstate->bits)) &
+                       bitstate->mask;
             }

             bitstate->bitcount -= bitstate->bits;
@@ -109,7 +101,7 @@
                 if (data <= 0) {
                     pixel = bitstate->lut[0];
                 } else if (data >= bitstate->lutsize) {
-                    pixel = bitstate->lut[bitstate->lutsize-1];
+                    pixel = bitstate->lut[bitstate->lutsize - 1];
                 } else {
                     pixel = bitstate->lut[data];
                 }
@@ -117,13 +109,13 @@
                 /* convert */
                 if (data & bitstate->signmask) {
                     /* image memory contains signed data */
-                    pixel = (FLOAT32) (INT32) (data | ~bitstate->mask);
+                    pixel = (FLOAT32)(INT32)(data | ~bitstate->mask);
                 } else {
-                    pixel = (FLOAT32) data;
+                    pixel = (FLOAT32)data;
                 }
             }

-            *(FLOAT32*)(&im->image32[state->y][state->x]) = pixel;
+            *(FLOAT32 *)(&im->image32[state->y][state->x]) = pixel;

             /* step forward */
             if (++state->x >= state->xsize) {
('src/libImaging', 'TgaRleDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,50 +14,41 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 int
-ImagingTgaRleDecode(Imaging im, ImagingCodecState state,
-            UINT8* buf, Py_ssize_t bytes)
-{
+ImagingTgaRleDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
     int n, depth;
-    UINT8* ptr;
+    UINT8 *ptr;
+    int extra_bytes = 0;

     ptr = buf;

     if (state->state == 0) {
-
         /* check image orientation */
         if (state->ystep < 0) {
-            state->y = state->ysize-1;
+            state->y = state->ysize - 1;
             state->ystep = -1;
         } else {
             state->ystep = 1;
         }

         state->state = 1;
-
     }

     depth = state->count;

     for (;;) {
-
         if (bytes < 1) {
             return ptr - buf;
         }

+        n = depth * ((ptr[0] & 0x7f) + 1);
         if (ptr[0] & 0x80) {
-
             /* Run (1 + pixelsize bytes) */
-
             if (bytes < 1 + depth) {
                 break;
             }
-
-            n = depth * ((ptr[0] & 0x7f) + 1);

             if (state->x + n > state->bytes) {
                 state->errcode = IMAGING_CODEC_OVERRUN;
@@ -69,54 +60,68 @@
             } else {
                 int i;
                 for (i = 0; i < n; i += depth) {
-                    memcpy(state->buffer + state->x + i, ptr+1, depth);
+                    memcpy(state->buffer + state->x + i, ptr + 1, depth);
                 }
             }

             ptr += 1 + depth;
             bytes -= 1 + depth;
-
         } else {
-
             /* Literal (1+n+1 bytes block) */
-            n = depth * (ptr[0] + 1);
-
             if (bytes < 1 + n) {
                 break;
             }

             if (state->x + n > state->bytes) {
-                state->errcode = IMAGING_CODEC_OVERRUN;
-                return -1;
+                extra_bytes = n; /* full value */
+                n = state->bytes - state->x;
+                extra_bytes -= n;
             }

             memcpy(state->buffer + state->x, ptr + 1, n);

             ptr += 1 + n;
             bytes -= 1 + n;
-
         }

-        state->x += n;
+        for (;;) {
+            state->x += n;

-        if (state->x >= state->bytes) {
+            if (state->x >= state->bytes) {
+                /* Got a full line, unpack it */
+                state->shuffle(
+                    (UINT8 *)im->image[state->y + state->yoff] +
+                        state->xoff * im->pixelsize,
+                    state->buffer,
+                    state->xsize);

-            /* Got a full line, unpack it */
-            state->shuffle((UINT8*) im->image[state->y + state->yoff] +
-                   state->xoff * im->pixelsize, state->buffer,
-                   state->xsize);
+                state->x = 0;

-            state->x = 0;
+                state->y += state->ystep;

-            state->y += state->ystep;
-
-            if (state->y < 0 || state->y >= state->ysize) {
-                /* End of file (errcode = 0) */
-                return -1;
+                if (state->y < 0 || state->y >= state->ysize) {
+                    /* End of file (errcode = 0) */
+                    return -1;
+                }
             }

+            if (extra_bytes == 0) {
+                break;
+            }
+
+            if (state->x > 0) {
+                break;  // assert
+            }
+
+            if (extra_bytes >= state->bytes) {
+                n = state->bytes;
+            } else {
+                n = extra_bytes;
+            }
+            memcpy(state->buffer + state->x, ptr, n);
+            ptr += n;
+            extra_bytes -= n;
         }
-
     }

     return ptr - buf;
('src/libImaging', 'Raw.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,7 +1,6 @@
 /* Raw.h */

 typedef struct {
-
     /* CONFIGURATION */

     /* Distance between lines (0=no padding) */
('src/libImaging', 'Point.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,22 +19,20 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 typedef struct {
-    const void* table;
+    const void *table;
 } im_point_context;

 static void
-im_point_8_8(Imaging imOut, Imaging imIn, im_point_context* context)
-{
+im_point_8_8(Imaging imOut, Imaging imIn, im_point_context *context) {
     int x, y;
     /* 8-bit source, 8-bit destination */
-    UINT8* table = (UINT8*) context->table;
-    for (y = 0; y < imIn->ysize; y++) {
-        UINT8* in = imIn->image8[y];
-        UINT8* out = imOut->image8[y];
+    UINT8 *table = (UINT8 *)context->table;
+    for (y = 0; y < imIn->ysize; y++) {
+        UINT8 *in = imIn->image8[y];
+        UINT8 *out = imOut->image8[y];
         for (x = 0; x < imIn->xsize; x++) {
             out[x] = table[in[x]];
         }
@@ -42,68 +40,67 @@
 }

 static void
-im_point_2x8_2x8(Imaging imOut, Imaging imIn, im_point_context* context)
-{
+im_point_2x8_2x8(Imaging imOut, Imaging imIn, im_point_context *context) {
     int x, y;
     /* 2x8-bit source, 2x8-bit destination */
-    UINT8* table = (UINT8*) context->table;
-    for (y = 0; y < imIn->ysize; y++) {
-        UINT8* in = (UINT8*) imIn->image[y];
-        UINT8* out = (UINT8*) imOut->image[y];
+    UINT8 *table = (UINT8 *)context->table;
+    for (y = 0; y < imIn->ysize; y++) {
+        UINT8 *in = (UINT8 *)imIn->image[y];
+        UINT8 *out = (UINT8 *)imOut->image[y];
         for (x = 0; x < imIn->xsize; x++) {
             out[0] = table[in[0]];
-            out[3] = table[in[3]+256];
-            in += 4; out += 4;
-        }
-    }
-}
-
-static void
-im_point_3x8_3x8(Imaging imOut, Imaging imIn, im_point_context* context)
-{
+            out[3] = table[in[3] + 256];
+            in += 4;
+            out += 4;
+        }
+    }
+}
+
+static void
+im_point_3x8_3x8(Imaging imOut, Imaging imIn, im_point_context *context) {
     int x, y;
     /* 3x8-bit source, 3x8-bit destination */
-    UINT8* table = (UINT8*) context->table;
-    for (y = 0; y < imIn->ysize; y++) {
-        UINT8* in = (UINT8*) imIn->image[y];
-        UINT8* out = (UINT8*) imOut->image[y];
+    UINT8 *table = (UINT8 *)context->table;
+    for (y = 0; y < imIn->ysize; y++) {
+        UINT8 *in = (UINT8 *)imIn->image[y];
+        UINT8 *out = (UINT8 *)imOut->image[y];
         for (x = 0; x < imIn->xsize; x++) {
             out[0] = table[in[0]];
-            out[1] = table[in[1]+256];
-            out[2] = table[in[2]+512];
-            in += 4; out += 4;
-        }
-    }
-}
-
-static void
-im_point_4x8_4x8(Imaging imOut, Imaging imIn, im_point_context* context)
-{
+            out[1] = table[in[1] + 256];
+            out[2] = table[in[2] + 512];
+            in += 4;
+            out += 4;
+        }
+    }
+}
+
+static void
+im_point_4x8_4x8(Imaging imOut, Imaging imIn, im_point_context *context) {
     int x, y;
     /* 4x8-bit source, 4x8-bit destination */
-    UINT8* table = (UINT8*) context->table;
-    for (y = 0; y < imIn->ysize; y++) {
-        UINT8* in = (UINT8*) imIn->image[y];
-        UINT8* out = (UINT8*) imOut->image[y];
+    UINT8 *table = (UINT8 *)context->table;
+    for (y = 0; y < imIn->ysize; y++) {
+        UINT8 *in = (UINT8 *)imIn->image[y];
+        UINT8 *out = (UINT8 *)imOut->image[y];
         for (x = 0; x < imIn->xsize; x++) {
             out[0] = table[in[0]];
-            out[1] = table[in[1]+256];
-            out[2] = table[in[2]+512];
-            out[3] = table[in[3]+768];
-            in += 4; out += 4;
-        }
-    }
-}
-
-static void
-im_point_8_32(Imaging imOut, Imaging imIn, im_point_context* context)
-{
+            out[1] = table[in[1] + 256];
+            out[2] = table[in[2] + 512];
+            out[3] = table[in[3] + 768];
+            in += 4;
+            out += 4;
+        }
+    }
+}
+
+static void
+im_point_8_32(Imaging imOut, Imaging imIn, im_point_context *context) {
     int x, y;
     /* 8-bit source, 32-bit destination */
-    char* table = (char*) context->table;
-    for (y = 0; y < imIn->ysize; y++) {
-        UINT8* in = imIn->image8[y];
-        INT32* out = imOut->image32[y];
+    char *table = (char *)context->table;
+    for (y = 0; y < imIn->ysize; y++) {
+        UINT8 *in = imIn->image8[y];
+        INT32 *out = imOut->image32[y];
         for (x = 0; x < imIn->xsize; x++) {
             memcpy(out + x, table + in[x] * sizeof(INT32), sizeof(INT32));
         }
@@ -111,14 +108,13 @@
 }

 static void
-im_point_32_8(Imaging imOut, Imaging imIn, im_point_context* context)
-{
+im_point_32_8(Imaging imOut, Imaging imIn, im_point_context *context) {
     int x, y;
     /* 32-bit source, 8-bit destination */
-    UINT8* table = (UINT8*) context->table;
-    for (y = 0; y < imIn->ysize; y++) {
-        INT32* in = imIn->image32[y];
-        UINT8* out = imOut->image8[y];
+    UINT8 *table = (UINT8 *)context->table;
+    for (y = 0; y < imIn->ysize; y++) {
+        INT32 *in = imIn->image32[y];
+        UINT8 *out = imOut->image8[y];
         for (x = 0; x < imIn->xsize; x++) {
             int v = in[x];
             if (v < 0) {
@@ -132,17 +128,16 @@
 }

 Imaging
-ImagingPoint(Imaging imIn, const char* mode, const void* table)
-{
+ImagingPoint(Imaging imIn, const char *mode, const void *table) {
     /* lookup table transform */

     ImagingSectionCookie cookie;
     Imaging imOut;
     im_point_context context;
-    void (*point)(Imaging imIn, Imaging imOut, im_point_context* context);
+    void (*point)(Imaging imIn, Imaging imOut, im_point_context * context);

     if (!imIn) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (!mode) {
@@ -166,22 +161,22 @@
     if (imIn->type == IMAGING_TYPE_UINT8) {
         if (imIn->bands == imOut->bands && imIn->type == imOut->type) {
             switch (imIn->bands) {
-            case 1:
-                point = im_point_8_8;
-                break;
-            case 2:
-                point = im_point_2x8_2x8;
-                break;
-            case 3:
-                point = im_point_3x8_3x8;
-                break;
-            case 4:
-                point = im_point_4x8_4x8;
-                break;
-            default:
-                /* this cannot really happen */
-                point = im_point_8_8;
-                break;
+                case 1:
+                    point = im_point_8_8;
+                    break;
+                case 2:
+                    point = im_point_2x8_2x8;
+                    break;
+                case 3:
+                    point = im_point_3x8_3x8;
+                    break;
+                case 4:
+                    point = im_point_4x8_4x8;
+                    break;
+                default:
+                    /* this cannot really happen */
+                    point = im_point_8_8;
+                    break;
             }
         } else {
             point = im_point_8_32;
@@ -201,26 +196,22 @@

     return imOut;

-  mode_mismatch:
-    return (Imaging) ImagingError_ValueError(
-        "point operation not supported for this mode"
-        );
-}
-
+mode_mismatch:
+    return (Imaging)ImagingError_ValueError(
+        "point operation not supported for this mode");
+}

 Imaging
-ImagingPointTransform(Imaging imIn, double scale, double offset)
-{
+ImagingPointTransform(Imaging imIn, double scale, double offset) {
     /* scale/offset transform */

     ImagingSectionCookie cookie;
     Imaging imOut;
     int x, y;

-    if (!imIn || (strcmp(imIn->mode, "I") != 0 &&
-                  strcmp(imIn->mode, "I;16") != 0 &&
+    if (!imIn || (strcmp(imIn->mode, "I") != 0 && strcmp(imIn->mode, "I;16") != 0 &&
                   strcmp(imIn->mode, "F") != 0)) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     imOut = ImagingNew(imIn->mode, imIn->xsize, imIn->ysize);
@@ -229,50 +220,50 @@
     }

     switch (imIn->type) {
-    case IMAGING_TYPE_INT32:
-        ImagingSectionEnter(&cookie);
-        for (y = 0; y < imIn->ysize; y++) {
-            INT32* in  = imIn->image32[y];
-            INT32* out = imOut->image32[y];
-            /* FIXME: add clipping? */
-            for (x = 0; x < imIn->xsize; x++) {
-                out[x] = in[x] * scale + offset;
-            }
-        }
-        ImagingSectionLeave(&cookie);
-        break;
-    case IMAGING_TYPE_FLOAT32:
-        ImagingSectionEnter(&cookie);
-        for (y = 0; y < imIn->ysize; y++) {
-            FLOAT32* in  = (FLOAT32*) imIn->image32[y];
-            FLOAT32* out = (FLOAT32*) imOut->image32[y];
-            for (x = 0; x < imIn->xsize; x++) {
-                out[x] = in[x] * scale + offset;
-            }
-        }
-        ImagingSectionLeave(&cookie);
-        break;
-    case IMAGING_TYPE_SPECIAL:
-        if (strcmp(imIn->mode,"I;16") == 0) {
+        case IMAGING_TYPE_INT32:
             ImagingSectionEnter(&cookie);
             for (y = 0; y < imIn->ysize; y++) {
-                char* in  = (char*)imIn->image[y];
-                char* out = (char*)imOut->image[y];
+                INT32 *in = imIn->image32[y];
+                INT32 *out = imOut->image32[y];
                 /* FIXME: add clipping? */
                 for (x = 0; x < imIn->xsize; x++) {
-                    UINT16 v;
-                    memcpy(&v, in + x * sizeof(v), sizeof(v));
-                    v = v * scale + offset;
-                    memcpy(out + x * sizeof(UINT16), &v, sizeof(v));
+                    out[x] = in[x] * scale + offset;
                 }
             }
             ImagingSectionLeave(&cookie);
             break;
-        }
-        /* FALL THROUGH */
-    default:
-        ImagingDelete(imOut);
-        return (Imaging) ImagingError_ValueError("internal error");
+        case IMAGING_TYPE_FLOAT32:
+            ImagingSectionEnter(&cookie);
+            for (y = 0; y < imIn->ysize; y++) {
+                FLOAT32 *in = (FLOAT32 *)imIn->image32[y];
+                FLOAT32 *out = (FLOAT32 *)imOut->image32[y];
+                for (x = 0; x < imIn->xsize; x++) {
+                    out[x] = in[x] * scale + offset;
+                }
+            }
+            ImagingSectionLeave(&cookie);
+            break;
+        case IMAGING_TYPE_SPECIAL:
+            if (strcmp(imIn->mode, "I;16") == 0) {
+                ImagingSectionEnter(&cookie);
+                for (y = 0; y < imIn->ysize; y++) {
+                    char *in = (char *)imIn->image[y];
+                    char *out = (char *)imOut->image[y];
+                    /* FIXME: add clipping? */
+                    for (x = 0; x < imIn->xsize; x++) {
+                        UINT16 v;
+                        memcpy(&v, in + x * sizeof(v), sizeof(v));
+                        v = v * scale + offset;
+                        memcpy(out + x * sizeof(UINT16), &v, sizeof(v));
+                    }
+                }
+                ImagingSectionLeave(&cookie);
+                break;
+            }
+            /* FALL THROUGH */
+        default:
+            ImagingDelete(imOut);
+            return (Imaging)ImagingError_ValueError("internal error");
     }

     return imOut;
('src/libImaging', 'ZipCodecs.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -7,9 +7,7 @@
  * Copyright (c) Fredrik Lundh 1996.
  */

-
 #include "zlib.h"
-

 /* modes */
 #define ZIP_PNG 0            /* continuous, filtered image data */
@@ -17,9 +15,7 @@
 #define ZIP_TIFF_PREDICTOR 2 /* TIFF, with predictor */
 #define ZIP_TIFF 3           /* TIFF, without predictor */

-
 typedef struct {
-
     /* CONFIGURATION */

     /* Codec mode */
@@ -34,29 +30,29 @@
     int compress_type;

     /* Predefined dictionary (experimental) */
-    char* dictionary;
+    char *dictionary;
     int dictionary_size;

     /* PRIVATE CONTEXT (set by decoder/encoder) */

-    z_stream z_stream;      /* (de)compression stream */
+    z_stream z_stream; /* (de)compression stream */

-    UINT8* previous;        /* previous line (allocated) */
+    UINT8 *previous; /* previous line (allocated) */

-    int last_output;        /* # bytes last output by inflate */
+    int last_output; /* # bytes last output by inflate */

     /* Compressor specific stuff */
-    UINT8* prior;           /* filter storage (allocated) */
-    UINT8* up;
-    UINT8* average;
-    UINT8* paeth;
+    UINT8 *prior; /* filter storage (allocated) */
+    UINT8 *up;
+    UINT8 *average;
+    UINT8 *paeth;

-    UINT8* output;          /* output data */
+    UINT8 *output; /* output data */

-    int prefix;             /* size of filter prefix (0 for TIFF data) */
+    int prefix; /* size of filter prefix (0 for TIFF data) */

-    int interlaced;         /* is the image interlaced? (PNG) */
+    int interlaced; /* is the image interlaced? (PNG) */

-    int pass;               /* current pass of the interlaced image (PNG) */
+    int pass; /* current pass of the interlaced image (PNG) */

 } ZIPSTATE;
('src/libImaging', 'AlphaComposite.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -8,39 +8,30 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

 #define PRECISION_BITS 7

-typedef struct
-{
+typedef struct {
     UINT8 r;
     UINT8 g;
     UINT8 b;
     UINT8 a;
 } rgba8;

-
-
 Imaging
-ImagingAlphaComposite(Imaging imDst, Imaging imSrc)
-{
+ImagingAlphaComposite(Imaging imDst, Imaging imSrc) {
     Imaging imOut;
     int x, y;

     /* Check arguments */
-    if (!imDst || !imSrc ||
-        strcmp(imDst->mode, "RGBA") ||
-        imDst->type != IMAGING_TYPE_UINT8 ||
-        imDst->bands != 4) {
+    if (!imDst || !imSrc || strcmp(imDst->mode, "RGBA") ||
+        imDst->type != IMAGING_TYPE_UINT8 || imDst->bands != 4) {
         return ImagingError_ModeError();
     }

-    if (strcmp(imDst->mode, imSrc->mode) ||
-        imDst->type  != imSrc->type  ||
-        imDst->bands != imSrc->bands ||
-        imDst->xsize != imSrc->xsize ||
+    if (strcmp(imDst->mode, imSrc->mode) || imDst->type != imSrc->type ||
+        imDst->bands != imSrc->bands || imDst->xsize != imSrc->xsize ||
         imDst->ysize != imSrc->ysize) {
         return ImagingError_Mismatch();
     }
@@ -51,11 +42,11 @@
     }

     for (y = 0; y < imDst->ysize; y++) {
-        rgba8* dst = (rgba8*) imDst->image[y];
-        rgba8* src = (rgba8*) imSrc->image[y];
-        rgba8* out = (rgba8*) imOut->image[y];
+        rgba8 *dst = (rgba8 *)imDst->image[y];
+        rgba8 *src = (rgba8 *)imSrc->image[y];
+        rgba8 *out = (rgba8 *)imOut->image[y];

-        for (x = 0; x < imDst->xsize; x ++) {
+        for (x = 0; x < imDst->xsize; x++) {
             if (src->a == 0) {
                 // Copy 4 bytes at once.
                 *out = *dst;
@@ -69,21 +60,25 @@
                 UINT32 outa255 = src->a * 255 + blend;
                 // There we use 7 bits for precision.
                 // We could use more, but we go beyond 32 bits.
-                UINT32 coef1 = src->a * 255 * 255 * (1<<PRECISION_BITS) / outa255;
-                UINT32 coef2 = 255 * (1<<PRECISION_BITS) - coef1;
+                UINT32 coef1 = src->a * 255 * 255 * (1 << PRECISION_BITS) / outa255;
+                UINT32 coef2 = 255 * (1 << PRECISION_BITS) - coef1;

                 tmpr = src->r * coef1 + dst->r * coef2;
                 tmpg = src->g * coef1 + dst->g * coef2;
                 tmpb = src->b * coef1 + dst->b * coef2;
-                out->r = SHIFTFORDIV255(tmpr + (0x80<<PRECISION_BITS)) >> PRECISION_BITS;
-                out->g = SHIFTFORDIV255(tmpg + (0x80<<PRECISION_BITS)) >> PRECISION_BITS;
-                out->b = SHIFTFORDIV255(tmpb + (0x80<<PRECISION_BITS)) >> PRECISION_BITS;
+                out->r =
+                    SHIFTFORDIV255(tmpr + (0x80 << PRECISION_BITS)) >> PRECISION_BITS;
+                out->g =
+                    SHIFTFORDIV255(tmpg + (0x80 << PRECISION_BITS)) >> PRECISION_BITS;
+                out->b =
+                    SHIFTFORDIV255(tmpb + (0x80 << PRECISION_BITS)) >> PRECISION_BITS;
                 out->a = SHIFTFORDIV255(outa255 + 0x80);
             }

-            dst++; src++; out++;
+            dst++;
+            src++;
+            out++;
         }
-
     }

     return imOut;
('src/libImaging', 'SgiRleDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -20,18 +20,63 @@
 #define RLE_COPY_FLAG 0x80
 #define RLE_MAX_RUN 0x7f

-static void read4B(UINT32* dest, UINT8* buf)
-{
+static void
+read4B(UINT32 *dest, UINT8 *buf) {
     *dest = (UINT32)((buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3]);
 }

-static int expandrow(UINT8* dest, UINT8* src, int n, int z, int xsize)
-{
+/*
+   SgiRleDecoding is done in a single channel row oriented set of RLE chunks.
+
+   * The file is arranged as
+     - SGI Header
+     - Rle Offset Table
+     - Rle Length Table
+     - Scanline Data
+
+   * Each RLE atom is c->bpc bytes wide (1 or 2)
+
+   * Each RLE Chunk is [specifier atom] [ 1 or n data atoms ]
+
+   * Copy Atoms are a byte with the high bit set, and the low 7 are
+     the number of bytes to copy from the source to the
+     destination. e.g.
+
+         CBBBBBBBB or 0CHLHLHLHLHLHL   (B=byte, H/L = Hi low bytes)
+
+   * Run atoms do not have the high bit set, and the low 7 bits are
+     the number of copies of the next atom to copy to the
+     destination. e.g.:
+
+         RB -> BBBBB or RHL -> HLHLHLHLHL
+
+   The upshot of this is, there is no way to determine the required
+   length of the input buffer from reloffset and rlelength without
+   going through the data at that scan line.
+
+   Furthermore, there's no requirement that individual scan lines
+   pointed to from the rleoffset table are in any sort of order or
+   used only once, or even disjoint. There's also no requirement that
+   all of the data in the scan line area of the image file be used
+
+ */
+static int
+expandrow(UINT8 *dest, UINT8 *src, int n, int z, int xsize, UINT8 *end_of_buffer) {
+    /*
+     * n here is the number of rlechunks
+     * z is the number of channels, for calculating the interleave
+     *   offset to go to RGBA style pixels
+     * xsize is the row width
+     * end_of_buffer is the address of the end of the input buffer
+     */
+
     UINT8 pixel, count;
     int x = 0;

-    for (;n > 0; n--)
-    {
+    for (; n > 0; n--) {
+        if (src > end_of_buffer) {
+            return -1;
+        }
         pixel = *src++;
         if (n == 1 && pixel != 0) {
             return n;
@@ -45,34 +90,39 @@
         }
         x += count;
         if (pixel & RLE_COPY_FLAG) {
-            while(count--) {
+            if (src + count > end_of_buffer) {
+                return -1;
+            }
+            while (count--) {
                 *dest = *src++;
                 dest += z;
             }

-        }
-        else {
+        } else {
+            if (src > end_of_buffer) {
+                return -1;
+            }
             pixel = *src++;
             while (count--) {
                 *dest = pixel;
                 dest += z;
             }
         }
-
     }
     return 0;
 }

-static int expandrow2(UINT8* dest, const UINT8* src, int n, int z, int xsize)
-{
+static int
+expandrow2(UINT8 *dest, const UINT8 *src, int n, int z, int xsize, UINT8 *end_of_buffer) {
     UINT8 pixel, count;
-
     int x = 0;

-    for (;n > 0; n--)
-    {
+    for (; n > 0; n--) {
+        if (src + 1 > end_of_buffer) {
+            return -1;
+        }
         pixel = src[1];
-        src+=2;
+        src += 2;
         if (n == 1 && pixel != 0) {
             return n;
         }
@@ -85,42 +135,43 @@
         }
         x += count;
         if (pixel & RLE_COPY_FLAG) {
-            while(count--) {
+            if (src + 2 * count > end_of_buffer) {
+                return -1;
+            }
+            while (count--) {
                 memcpy(dest, src, 2);
                 src += 2;
                 dest += z * 2;
             }
-        }
-        else {
+        } else {
+            if (src + 2 > end_of_buffer) {
+                return -1;
+            }
             while (count--) {
                 memcpy(dest, src, 2);
                 dest += z * 2;
             }
-            src+=2;
+            src += 2;
         }
     }
     return 0;
 }

-
 int
-ImagingSgiRleDecode(Imaging im, ImagingCodecState state,
-            UINT8* buf, Py_ssize_t bytes)
-{
+ImagingSgiRleDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
     UINT8 *ptr;
     SGISTATE *c;
     int err = 0;
     int status;

     /* size check */
-    if (im->xsize > INT_MAX / im->bands ||
-        im->ysize > INT_MAX / im->bands) {
+    if (im->xsize > INT_MAX / im->bands || im->ysize > INT_MAX / im->bands) {
         state->errcode = IMAGING_CODEC_MEMORY;
         return -1;
     }

     /* Get all data from File descriptor */
-    c = (SGISTATE*)state->context;
+    c = (SGISTATE *)state->context;
     _imaging_seek_pyFd(state->fd, 0L, SEEK_END);
     c->bufsize = _imaging_tell_pyFd(state->fd);
     c->bufsize -= SGI_HEADER_SIZE;
@@ -130,7 +181,7 @@
        each with 4 bytes per element of tablen
        Check here before we allocate any memory
     */
-    if (c->bufsize < 8*c->tablen) {
+    if (c->bufsize < 8 * c->tablen) {
         state->errcode = IMAGING_CODEC_OVERRUN;
         return -1;
     }
@@ -141,7 +192,10 @@
         return -1;
     }
     _imaging_seek_pyFd(state->fd, SGI_HEADER_SIZE, SEEK_SET);
-    _imaging_read_pyFd(state->fd, (char*)ptr, c->bufsize);
+    if (_imaging_read_pyFd(state->fd, (char *)ptr, c->bufsize) != c->bufsize) {
+        state->errcode = IMAGING_CODEC_UNKNOWN;
+        return -1;
+    }


     /* decoder initialization */
@@ -160,43 +214,53 @@
     state->buffer = calloc(im->xsize * im->bands, sizeof(UINT8) * 2);
     c->starttab = calloc(c->tablen, sizeof(UINT32));
     c->lengthtab = calloc(c->tablen, sizeof(UINT32));
-    if (!state->buffer ||
-        !c->starttab ||
-        !c->lengthtab) {
+    if (!state->buffer || !c->starttab || !c->lengthtab) {
         err = IMAGING_CODEC_MEMORY;
         goto sgi_finish_decode;
     }
     /* populate offsets table */
-    for (c->tabindex = 0, c->bufindex = 0; c->tabindex < c->tablen; c->tabindex++, c->bufindex+=4) {
+    for (c->tabindex = 0, c->bufindex = 0; c->tabindex < c->tablen;
+         c->tabindex++, c->bufindex += 4) {
         read4B(&c->starttab[c->tabindex], &ptr[c->bufindex]);
     }
     /* populate lengths table */
-    for (c->tabindex = 0, c->bufindex = c->tablen * sizeof(UINT32); c->tabindex < c->tablen; c->tabindex++, c->bufindex+=4) {
+    for (c->tabindex = 0, c->bufindex = c->tablen * sizeof(UINT32);
+         c->tabindex < c->tablen;
+         c->tabindex++, c->bufindex += 4) {
         read4B(&c->lengthtab[c->tabindex], &ptr[c->bufindex]);
     }

-    state->count += c->tablen * sizeof(UINT32) * 2;
-
     /* read compressed rows */
-    for (c->rowno = 0; c->rowno < im->ysize; c->rowno++, state->y += state->ystep)
-    {
-        for (c->channo = 0; c->channo < im->bands; c->channo++)
-        {
+    for (c->rowno = 0; c->rowno < im->ysize; c->rowno++, state->y += state->ystep) {
+        for (c->channo = 0; c->channo < im->bands; c->channo++) {
             c->rleoffset = c->starttab[c->rowno + c->channo * im->ysize];
             c->rlelength = c->lengthtab[c->rowno + c->channo * im->ysize];
-            c->rleoffset -= SGI_HEADER_SIZE;
-
-            if (c->rleoffset + c->rlelength > c->bufsize) {
+
+            // Check for underflow of rleoffset-SGI_HEADER_SIZE
+            if (c->rleoffset < SGI_HEADER_SIZE) {
                 state->errcode = IMAGING_CODEC_OVERRUN;
                 goto sgi_finish_decode;
             }

+            c->rleoffset -= SGI_HEADER_SIZE;
+
             /* row decompression */
-            if (c->bpc ==1) {
-                status = expandrow(&state->buffer[c->channo], &ptr[c->rleoffset], c->rlelength, im->bands, im->xsize);
-            }
-            else {
-                status = expandrow2(&state->buffer[c->channo * 2], &ptr[c->rleoffset], c->rlelength, im->bands, im->xsize);
+            if (c->bpc == 1) {
+                status = expandrow(
+                    &state->buffer[c->channo],
+                    &ptr[c->rleoffset],
+                    c->rlelength,
+                    im->bands,
+                    im->xsize,
+                    &ptr[c->bufsize-1]);
+            } else {
+                status = expandrow2(
+                    &state->buffer[c->channo * 2],
+                    &ptr[c->rleoffset],
+                    c->rlelength,
+                    im->bands,
+                    im->xsize,
+                    &ptr[c->bufsize-1]);
             }
             if (status == -1) {
                 state->errcode = IMAGING_CODEC_OVERRUN;
@@ -205,24 +269,20 @@
                 goto sgi_finish_decode;
             }

-            state->count += c->rlelength;
         }

         /* store decompressed data in image */
-        state->shuffle((UINT8*)im->image[state->y], state->buffer, im->xsize);
-
-    }
-
-    c->bufsize++;
-
-sgi_finish_decode: ;
+        state->shuffle((UINT8 *)im->image[state->y], state->buffer, im->xsize);
+    }
+
+sgi_finish_decode:;

     free(c->starttab);
     free(c->lengthtab);
     free(ptr);
-    if (err != 0){
-        state->errcode=err;
-        return -1;
-    }
-    return state->count - c->bufsize;
-}
+    if (err != 0) {
+        state->errcode = err;
+        return -1;
+    }
+    return 0;
+}
('src/libImaging', 'Chops.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,62 +16,59 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

-#define CHOP(operation)\
-    int x, y;\
-    Imaging imOut;\
-    imOut = create(imIn1, imIn2, NULL);\
-    if (!imOut) {\
-        return NULL;\
-    }\
-    for (y = 0; y < imOut->ysize; y++) {\
-        UINT8* out = (UINT8*) imOut->image[y];\
-        UINT8* in1 = (UINT8*) imIn1->image[y];\
-        UINT8* in2 = (UINT8*) imIn2->image[y];\
-        for (x = 0; x < imOut->linesize; x++) {\
-            int temp = operation;\
-            if (temp <= 0) {\
-                out[x] = 0;\
-            } else if (temp >= 255) {\
-                out[x] = 255;\
-            } else {\
-                out[x] = temp;\
-            }\
-        }\
-    }\
+#define CHOP(operation)                         \
+    int x, y;                                   \
+    Imaging imOut;                              \
+    imOut = create(imIn1, imIn2, NULL);         \
+    if (!imOut) {                               \
+        return NULL;                            \
+    }                                           \
+    for (y = 0; y < imOut->ysize; y++) {        \
+        UINT8 *out = (UINT8 *)imOut->image[y];  \
+        UINT8 *in1 = (UINT8 *)imIn1->image[y];  \
+        UINT8 *in2 = (UINT8 *)imIn2->image[y];  \
+        for (x = 0; x < imOut->linesize; x++) { \
+            int temp = operation;               \
+            if (temp <= 0) {                    \
+                out[x] = 0;                     \
+            } else if (temp >= 255) {           \
+                out[x] = 255;                   \
+            } else {                            \
+                out[x] = temp;                  \
+            }                                   \
+        }                                       \
+    }                                           \
     return imOut;

-#define CHOP2(operation, mode)\
-    int x, y;\
-    Imaging imOut;\
-    imOut = create(imIn1, imIn2, mode);\
-    if (!imOut) {\
-        return NULL;\
-    }\
-    for (y = 0; y < imOut->ysize; y++) {\
-        UINT8* out = (UINT8*) imOut->image[y];\
-        UINT8* in1 = (UINT8*) imIn1->image[y];\
-        UINT8* in2 = (UINT8*) imIn2->image[y];\
-        for (x = 0; x < imOut->linesize; x++) {\
-            out[x] = operation;\
-        }\
-    }\
+#define CHOP2(operation, mode)                  \
+    int x, y;                                   \
+    Imaging imOut;                              \
+    imOut = create(imIn1, imIn2, mode);         \
+    if (!imOut) {                               \
+        return NULL;                            \
+    }                                           \
+    for (y = 0; y < imOut->ysize; y++) {        \
+        UINT8 *out = (UINT8 *)imOut->image[y];  \
+        UINT8 *in1 = (UINT8 *)imIn1->image[y];  \
+        UINT8 *in2 = (UINT8 *)imIn2->image[y];  \
+        for (x = 0; x < imOut->linesize; x++) { \
+            out[x] = operation;                 \
+        }                                       \
+    }                                           \
     return imOut;

 static Imaging
-create(Imaging im1, Imaging im2, char* mode)
-{
+create(Imaging im1, Imaging im2, char *mode) {
     int xsize, ysize;

     if (!im1 || !im2 || im1->type != IMAGING_TYPE_UINT8 ||
         (mode != NULL && (strcmp(im1->mode, "1") || strcmp(im2->mode, "1")))) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }
-    if (im1->type  != im2->type  ||
-        im1->bands != im2->bands) {
-        return (Imaging) ImagingError_Mismatch();
+    if (im1->type != im2->type || im1->bands != im2->bands) {
+        return (Imaging)ImagingError_Mismatch();
     }

     xsize = (im1->xsize < im2->xsize) ? im1->xsize : im2->xsize;
@@ -81,97 +78,85 @@
 }

 Imaging
-ImagingChopLighter(Imaging imIn1, Imaging imIn2)
-{
+ImagingChopLighter(Imaging imIn1, Imaging imIn2) {
     CHOP((in1[x] > in2[x]) ? in1[x] : in2[x]);
 }

 Imaging
-ImagingChopDarker(Imaging imIn1, Imaging imIn2)
-{
+ImagingChopDarker(Imaging imIn1, Imaging imIn2) {
     CHOP((in1[x] < in2[x]) ? in1[x] : in2[x]);
 }

 Imaging
-ImagingChopDifference(Imaging imIn1, Imaging imIn2)
-{
-    CHOP(abs((int) in1[x] - (int) in2[x]));
+ImagingChopDifference(Imaging imIn1, Imaging imIn2) {
+    CHOP(abs((int)in1[x] - (int)in2[x]));
 }

 Imaging
-ImagingChopMultiply(Imaging imIn1, Imaging imIn2)
-{
-    CHOP((int) in1[x] * (int) in2[x] / 255);
+ImagingChopMultiply(Imaging imIn1, Imaging imIn2) {
+    CHOP((int)in1[x] * (int)in2[x] / 255);
 }

 Imaging
-ImagingChopScreen(Imaging imIn1, Imaging imIn2)
-{
-    CHOP(255 - ((int) (255 - in1[x]) * (int) (255 - in2[x])) / 255);
+ImagingChopScreen(Imaging imIn1, Imaging imIn2) {
+    CHOP(255 - ((int)(255 - in1[x]) * (int)(255 - in2[x])) / 255);
 }

 Imaging
-ImagingChopAdd(Imaging imIn1, Imaging imIn2, float scale, int offset)
-{
-    CHOP(((int) in1[x] + (int) in2[x]) / scale + offset);
+ImagingChopAdd(Imaging imIn1, Imaging imIn2, float scale, int offset) {
+    CHOP(((int)in1[x] + (int)in2[x]) / scale + offset);
 }

 Imaging
-ImagingChopSubtract(Imaging imIn1, Imaging imIn2, float scale, int offset)
-{
-    CHOP(((int) in1[x] - (int) in2[x]) / scale + offset);
+ImagingChopSubtract(Imaging imIn1, Imaging imIn2, float scale, int offset) {
+    CHOP(((int)in1[x] - (int)in2[x]) / scale + offset);
 }

 Imaging
-ImagingChopAnd(Imaging imIn1, Imaging imIn2)
-{
+ImagingChopAnd(Imaging imIn1, Imaging imIn2) {
     CHOP2((in1[x] && in2[x]) ? 255 : 0, "1");
 }

 Imaging
-ImagingChopOr(Imaging imIn1, Imaging imIn2)
-{
+ImagingChopOr(Imaging imIn1, Imaging imIn2) {
     CHOP2((in1[x] || in2[x]) ? 255 : 0, "1");
 }

 Imaging
-ImagingChopXor(Imaging imIn1, Imaging imIn2)
-{
+ImagingChopXor(Imaging imIn1, Imaging imIn2) {
     CHOP2(((in1[x] != 0) ^ (in2[x] != 0)) ? 255 : 0, "1");
 }

 Imaging
-ImagingChopAddModulo(Imaging imIn1, Imaging imIn2)
-{
+ImagingChopAddModulo(Imaging imIn1, Imaging imIn2) {
     CHOP2(in1[x] + in2[x], NULL);
 }

 Imaging
-ImagingChopSubtractModulo(Imaging imIn1, Imaging imIn2)
-{
+ImagingChopSubtractModulo(Imaging imIn1, Imaging imIn2) {
     CHOP2(in1[x] - in2[x], NULL);
 }

 Imaging
-ImagingChopSoftLight(Imaging imIn1, Imaging imIn2)
-{
-    CHOP2( (((255-in1[x]) * (in1[x]*in2[x]) ) / 65536) +
-         (in1[x] * ( 255 - ( (255 - in1[x]) * (255 - in2[x] ) / 255) )) / 255
-         , NULL );
+ImagingChopSoftLight(Imaging imIn1, Imaging imIn2) {
+    CHOP2(
+        (((255 - in1[x]) * (in1[x] * in2[x])) / 65536) +
+            (in1[x] * (255 - ((255 - in1[x]) * (255 - in2[x]) / 255))) / 255,
+        NULL);
 }

 Imaging
-ImagingChopHardLight(Imaging imIn1, Imaging imIn2)
-{
-    CHOP2( (in2[x]<128) ? ( (in1[x]*in2[x])/127)
-                        : 255 - ( ((255-in2[x]) * (255-in1[x])) / 127)
-         , NULL);
+ImagingChopHardLight(Imaging imIn1, Imaging imIn2) {
+    CHOP2(
+        (in2[x] < 128) ? ((in1[x] * in2[x]) / 127)
+                       : 255 - (((255 - in2[x]) * (255 - in1[x])) / 127),
+        NULL);
 }

 Imaging
-ImagingOverlay(Imaging imIn1, Imaging imIn2)
-{
-    CHOP2( (in1[x]<128) ? ( (in1[x]*in2[x])/127)
-                        : 255 - ( ((255-in1[x]) * (255-in2[x])) / 127)
-         , NULL);
+ImagingOverlay(Imaging imIn1, Imaging imIn2) {
+    CHOP2(
+        (in1[x] < 128) ? ((in1[x] * in2[x]) / 127)
+                       : 255 - (((255 - in1[x]) * (255 - in2[x])) / 127),
+        NULL);
 }
('src/libImaging', 'Offset.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,18 +14,15 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 Imaging
-ImagingOffset(Imaging im, int xoffset, int yoffset)
-{
+ImagingOffset(Imaging im, int xoffset, int yoffset) {
     int x, y;
     Imaging imOut;

     if (!im) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     imOut = ImagingNewDirty(im->mode, im->xsize, im->ysize);
@@ -48,13 +45,13 @@
         yoffset += im->ysize;
     }

-#define OFFSET(image)\
-    for (y = 0; y < im->ysize; y++) {\
-        for (x = 0; x < im->xsize; x++) {\
-            int yi = (y + yoffset) % im->ysize;\
-            int xi = (x + xoffset) % im->xsize;\
-            imOut->image[y][x] = im->image[yi][xi];\
-        }\
+#define OFFSET(image)                               \
+    for (y = 0; y < im->ysize; y++) {               \
+        for (x = 0; x < im->xsize; x++) {           \
+            int yi = (y + yoffset) % im->ysize;     \
+            int xi = (x + xoffset) % im->xsize;     \
+            imOut->image[y][x] = im->image[yi][xi]; \
+        }                                           \
     }

     if (im->image8) {
('src/libImaging', 'QuantPngQuant.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -26,8 +26,7 @@
     Pixel **palette,
     uint32_t *paletteLength,
     uint32_t **quantizedPixels,
-    int withAlpha)
-{
+    int withAlpha) {
     int result = 0;
     liq_image *image = NULL;
     liq_attr *attr = NULL;
@@ -41,23 +40,24 @@

     /* configure pngquant */
     attr = liq_attr_create();
-    if (!attr) { goto err; }
+    if (!attr) {
+        goto err;
+    }
     if (quantPixels) {
         liq_set_max_colors(attr, quantPixels);
     }

     /* prepare input image */
-    image = liq_image_create_rgba(
-        attr,
-        pixelData,
-        width,
-        height,
-        0.45455 /* gamma */);
-    if (!image) { goto err; }
+    image = liq_image_create_rgba(attr, pixelData, width, height, 0.45455 /* gamma */);
+    if (!image) {
+        goto err;
+    }

     /* quantize the image */
     remap = liq_quantize_image(attr, image);
-    if (!remap) { goto err; }
+    if (!remap) {
+        goto err;
+    }
     liq_set_output_gamma(remap, 0.45455);
     liq_set_dithering_level(remap, 1);

@@ -65,7 +65,9 @@
     const liq_palette *l_palette = liq_get_palette(remap);
     *paletteLength = l_palette->count;
     *palette = malloc(sizeof(Pixel) * l_palette->count);
-    if (!*palette) { goto err; }
+    if (!*palette) {
+        goto err;
+    }
     for (i = 0; i < l_palette->count; i++) {
         (*palette)[i].c.b = l_palette->entries[i].b;
         (*palette)[i].c.g = l_palette->entries[i].g;
@@ -75,9 +77,13 @@

     /* write output pixels (pngquant uses char array) */
     charMatrix = malloc(width * height);
-    if (!charMatrix) { goto err; }
-    charMatrixRows = malloc(height * sizeof(unsigned char*));
-    if (!charMatrixRows) { goto err; }
+    if (!charMatrix) {
+        goto err;
+    }
+    charMatrixRows = malloc(height * sizeof(unsigned char *));
+    if (!charMatrixRows) {
+        goto err;
+    }
     for (y = 0; y < height; y++) {
         charMatrixRows[y] = &charMatrix[y * width];
     }
@@ -87,7 +93,9 @@

     /* transcribe output pixels (pillow uses uint32_t array) */
     *quantizedPixels = malloc(sizeof(uint32_t) * width * height);
-    if (!*quantizedPixels) { goto err; }
+    if (!*quantizedPixels) {
+        goto err;
+    }
     for (i = 0; i < width * height; i++) {
         (*quantizedPixels)[i] = charMatrix[i];
     }
@@ -106,16 +114,15 @@
     }
     free(charMatrix);
     free(charMatrixRows);
-    if (!result)  {
+    if (!result) {
         free(*quantizedPixels);
         free(*palette);
     }
     return result;
 }

-const char*
-ImagingImageQuantVersion(void)
-{
+const char *
+ImagingImageQuantVersion(void) {
     static char version[20];
     int number = liq_version();
     sprintf(version, "%d.%d.%d", number / 10000, (number / 100) % 100, number % 100);
('src/libImaging', 'FliDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,26 +14,21 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
-#define I16(ptr)\
-    ((ptr)[0] + ((ptr)[1] << 8))
-
-#define I32(ptr)\
-    ((ptr)[0] + ((ptr)[1] << 8) + ((ptr)[2] << 16) + ((ptr)[3] << 24))
-
-#define ERR_IF_DATA_OOB(offset) \
-  if ((data + (offset)) > ptr + bytes) {\
-    state->errcode = IMAGING_CODEC_OVERRUN; \
-    return -1; \
-  }
+#define I16(ptr) ((ptr)[0] + ((ptr)[1] << 8))
+
+#define I32(ptr) ((ptr)[0] + ((ptr)[1] << 8) + ((ptr)[2] << 16) + ((ptr)[3] << 24))
+
+#define ERR_IF_DATA_OOB(offset)                 \
+    if ((data + (offset)) > ptr + bytes) {      \
+        state->errcode = IMAGING_CODEC_OVERRUN; \
+        return -1;                              \
+    }

 int
-ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
-    UINT8* ptr;
+ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
+    UINT8 *ptr;
     int framesize;
     int c, chunks, advance;
     int l, lines;
@@ -51,7 +46,8 @@
     ptr = buf;

     framesize = I32(ptr);
-    if (framesize < I32(ptr)) {
+    // there can be one pad byte in the framesize
+    if (bytes + (bytes % 2) < framesize) {
         return 0;
     }

@@ -62,36 +58,39 @@
         state->errcode = IMAGING_CODEC_OVERRUN;
         return -1;
     }
-    if (I16(ptr+4) != 0xF1FA) {
+    if (I16(ptr + 4) != 0xF1FA) {
         state->errcode = IMAGING_CODEC_UNKNOWN;
         return -1;
     }

-    chunks = I16(ptr+6);
+    chunks = I16(ptr + 6);
     ptr += 16;
     bytes -= 16;

     /* Process subchunks */
     for (c = 0; c < chunks; c++) {
-        UINT8* data;
+        UINT8 *data;
         if (bytes < 10) {
             state->errcode = IMAGING_CODEC_OVERRUN;
             return -1;
         }
         data = ptr + 6;
-        switch (I16(ptr+4)) {
-            case 4: case 11:
+        switch (I16(ptr + 4)) {
+            case 4:
+            case 11:
                 /* FLI COLOR chunk */
                 break; /* ignored; handled by Python code */
             case 7:
                 /* FLI SS2 chunk (word delta) */
                 /* OOB ok, we've got 4 bytes min on entry */
-                lines = I16(data); data += 2;
+                lines = I16(data);
+                data += 2;
                 for (l = y = 0; l < lines && y < state->ysize; l++, y++) {
-                    UINT8* local_buf = (UINT8*) im->image[y];
+                    UINT8 *local_buf = (UINT8 *)im->image[y];
                     int p, packets;
                     ERR_IF_DATA_OOB(2)
-                    packets = I16(data); data += 2;
+                    packets = I16(data);
+                    data += 2;
                     while (packets & 0x8000) {
                         /* flag word */
                         if (packets & 0x4000) {
@@ -100,20 +99,21 @@
                                 state->errcode = IMAGING_CODEC_OVERRUN;
                                 return -1;
                             }
-                            local_buf = (UINT8*) im->image[y];
+                            local_buf = (UINT8 *)im->image[y];
                         } else {
                             /* store last byte (used if line width is odd) */
-                            local_buf[state->xsize-1] = (UINT8) packets;
-                        }
-                        ERR_IF_DATA_OOB(2)
-                        packets = I16(data); data += 2;
+                            local_buf[state->xsize - 1] = (UINT8)packets;
+                        }
+                        ERR_IF_DATA_OOB(2)
+                        packets = I16(data);
+                        data += 2;
                     }
                     for (p = x = 0; p < packets; p++) {
                         ERR_IF_DATA_OOB(2)
                         x += data[0]; /* pixel skip */
                         if (data[1] >= 128) {
                             ERR_IF_DATA_OOB(4)
-                            i = 256-data[1]; /* run */
+                            i = 256 - data[1]; /* run */
                             if (x + i + i > state->xsize) {
                                 break;
                             }
@@ -123,11 +123,11 @@
                             }
                             data += 2 + 2;
                         } else {
-                            i = 2 * (int) data[1]; /* chunk */
-                            if (x + i > state->xsize) {
-                                break;
-                            }
-                            ERR_IF_DATA_OOB(2+i)
+                            i = 2 * (int)data[1]; /* chunk */
+                            if (x + i > state->xsize) {
+                                break;
+                            }
+                            ERR_IF_DATA_OOB(2 + i)
                             memcpy(local_buf + x, data + 2, i);
                             data += 2 + i;
                             x += i;
@@ -146,16 +146,18 @@
             case 12:
                 /* FLI LC chunk (byte delta) */
                 /* OOB Check ok, we have 4 bytes min here */
-                y = I16(data); ymax = y + I16(data+2); data += 4;
+                y = I16(data);
+                ymax = y + I16(data + 2);
+                data += 4;
                 for (; y < ymax && y < state->ysize; y++) {
-                    UINT8* out = (UINT8*) im->image[y];
-                            ERR_IF_DATA_OOB(1)
+                    UINT8 *out = (UINT8 *)im->image[y];
+                    ERR_IF_DATA_OOB(1)
                     int p, packets = *data++;
                     for (p = x = 0; p < packets; p++, x += i) {
                         ERR_IF_DATA_OOB(2)
                         x += data[0]; /* skip pixels */
                         if (data[1] & 0x80) {
-                            i = 256-data[1]; /* run */
+                            i = 256 - data[1]; /* run */
                             if (x + i > state->xsize) {
                                 break;
                             }
@@ -167,7 +169,7 @@
                             if (x + i > state->xsize) {
                                 break;
                             }
-                            ERR_IF_DATA_OOB(2+i)
+                            ERR_IF_DATA_OOB(2 + i)
                             memcpy(out + x, data + 2, i);
                             data += i + 2;
                         }
@@ -192,7 +194,7 @@
                 /* FLI BRUN chunk */
                 /* OOB, ok, we've got 4 bytes min on entry */
                 for (y = 0; y < state->ysize; y++) {
-                    UINT8* out = (UINT8*) im->image[y];
+                    UINT8 *out = (UINT8 *)im->image[y];
                     data += 1; /* ignore packetcount byte */
                     for (x = 0; x < state->xsize; x += i) {
                         ERR_IF_DATA_OOB(2)
@@ -201,7 +203,7 @@
                             if (x + i > state->xsize) {
                                 break; /* safety first */
                             }
-                            ERR_IF_DATA_OOB(i+1)
+                            ERR_IF_DATA_OOB(i + 1)
                             memcpy(out + x, data + 1, i);
                             data += i + 1;
                         } else {
@@ -222,12 +224,19 @@
                 break;
             case 16:
                 /* COPY chunk */
-                if (state->xsize > bytes/state->ysize) {
+                if (INT32_MAX / state->xsize < state->ysize) {
+                    /* Integer overflow, bail */
+                    state->errcode = IMAGING_CODEC_OVERRUN;
+                    return -1;
+                }
+                /* Note, have to check Data + size, not just ptr + size) */
+                if (data + (state->xsize * state->ysize) > ptr + bytes) {
                     /* not enough data for frame */
+                    /* UNDONE Unclear that we're actually going to leave the buffer at the right place. */
                     return ptr - buf; /* bytes consumed */
                 }
                 for (y = 0; y < state->ysize; y++) {
-                    UINT8* local_buf = (UINT8*) im->image[y];
+                    UINT8 *local_buf = (UINT8 *)im->image[y];
                     memcpy(local_buf, data, state->xsize);
                     data += state->xsize;
                 }
@@ -242,6 +251,11 @@
                 return -1;
         }
         advance = I32(ptr);
+        if (advance == 0 ) {
+            // If there's no advance, we're in an infinite loop
+            state->errcode = IMAGING_CODEC_BROKEN;
+            return -1;
+        }
         if (advance < 0 || advance > bytes) {
             state->errcode = IMAGING_CODEC_OVERRUN;
             return -1;
('src/libImaging', 'TiffDecode.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -20,8 +20,8 @@
 */

 #ifndef min
-#define min(x,y) (( x > y ) ? y : x )
-#define max(x,y) (( x < y ) ? y : x )
+#define min(x, y) ((x > y) ? y : x)
+#define max(x, y) ((x < y) ? y : x)
 #endif

 #ifndef _PIL_LIBTIFF_
@@ -32,22 +32,24 @@
     toff_t loc;   /* toff_t == uint32 */
     tsize_t size; /* tsize_t == int32 */
     int fp;
-    uint32 ifd;   /* offset of the ifd, used for multipage
+    uint32_t ifd; /* offset of the ifd, used for multipage
                    * Should be uint32 for libtiff 3.9.x
                    * uint64 for libtiff 4.0.x
                    */
-    TIFF *tiff;   /* Used in write */
+    TIFF *tiff; /* Used in write */
     toff_t eof;
-    int flrealloc;/* may we realloc */
+    int flrealloc; /* may we realloc */
 } TIFFSTATE;

-
-
-extern int ImagingLibTiffInit(ImagingCodecState state, int fp, uint32 offset);
-extern int ImagingLibTiffEncodeInit(ImagingCodecState state, char *filename, int fp);
-extern int ImagingLibTiffMergeFieldInfo(ImagingCodecState state, TIFFDataType field_type, int key, int is_var_length);
-extern int ImagingLibTiffSetField(ImagingCodecState state, ttag_t tag, ...);
-
+extern int
+ImagingLibTiffInit(ImagingCodecState state, int fp, uint32_t offset);
+extern int
+ImagingLibTiffEncodeInit(ImagingCodecState state, char *filename, int fp);
+extern int
+ImagingLibTiffMergeFieldInfo(
+    ImagingCodecState state, TIFFDataType field_type, int key, int is_var_length);
+extern int
+ImagingLibTiffSetField(ImagingCodecState state, ttag_t tag, ...);

 /*
    Trace debugging
('src/libImaging', 'File.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,19 +15,15 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #include <ctype.h>

-
 int
-ImagingSaveRaw(Imaging im, FILE* fp)
-{
+ImagingSaveRaw(Imaging im, FILE *fp) {
     int x, y, i;

     if (strcmp(im->mode, "1") == 0 || strcmp(im->mode, "L") == 0) {
-
         /* @PIL227: FIXME: for mode "1", map != 0 to 255 */

         /* PGM "L" */
@@ -36,33 +32,29 @@
         }

     } else {
-
         /* PPM "RGB" or other internal format */
         for (y = 0; y < im->ysize; y++) {
             for (x = i = 0; x < im->xsize; x++, i += im->pixelsize) {
-                fwrite(im->image[y]+i, 1, im->bands, fp);
+                fwrite(im->image[y] + i, 1, im->bands, fp);
             }
         }
-
     }

     return 1;
 }

-
 int
-ImagingSavePPM(Imaging im, const char* outfile)
-{
-    FILE* fp;
+ImagingSavePPM(Imaging im, const char *outfile) {
+    FILE *fp;

     if (!im) {
-        (void) ImagingError_ValueError(NULL);
+        (void)ImagingError_ValueError(NULL);
         return 0;
     }

     fp = fopen(outfile, "wb");
     if (!fp) {
-        (void) ImagingError_OSError();
+        (void)ImagingError_OSError();
         return 0;
     }

@@ -74,7 +66,7 @@
         fprintf(fp, "P6\n%d %d\n255\n", im->xsize, im->ysize);
     } else {
         fclose(fp);
-        (void) ImagingError_ModeError();
+        (void)ImagingError_ModeError();
         return 0;
     }

@@ -84,4 +76,3 @@

     return 1;
 }
-
('src/libImaging', 'ColorLUT.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,51 +1,44 @@
 #include "Imaging.h"
 #include <math.h>
-

 /* 8 bits for result. Table can overflow [0, 1.0] range,
    so we need extra bits for overflow and negative values.
    NOTE: This value should be the same as in _imaging/_prepare_lut_table() */
 #define PRECISION_BITS (16 - 8 - 2)
-#define PRECISION_ROUNDING (1<<(PRECISION_BITS-1))
+#define PRECISION_ROUNDING (1 << (PRECISION_BITS - 1))

 /* 8 — scales are multiplied on byte.
    6 — max index in the table
        (max size is 65, but index 64 is not reachable) */
 #define SCALE_BITS (32 - 8 - 6)
-#define SCALE_MASK ((1<<SCALE_BITS) - 1)
+#define SCALE_MASK ((1 << SCALE_BITS) - 1)

 #define SHIFT_BITS (16 - 1)

-
-static inline UINT8 clip8(int in)
-{
+static inline UINT8
+clip8(int in) {
     return clip8_lookups[(in + PRECISION_ROUNDING) >> PRECISION_BITS];
 }

 static inline void
-interpolate3(INT16 out[3], const INT16 a[3], const INT16 b[3], INT16 shift)
-{
-    out[0] = (a[0] * ((1<<SHIFT_BITS)-shift) + b[0] * shift) >> SHIFT_BITS;
-    out[1] = (a[1] * ((1<<SHIFT_BITS)-shift) + b[1] * shift) >> SHIFT_BITS;
-    out[2] = (a[2] * ((1<<SHIFT_BITS)-shift) + b[2] * shift) >> SHIFT_BITS;
+interpolate3(INT16 out[3], const INT16 a[3], const INT16 b[3], INT16 shift) {
+    out[0] = (a[0] * ((1 << SHIFT_BITS) - shift) + b[0] * shift) >> SHIFT_BITS;
+    out[1] = (a[1] * ((1 << SHIFT_BITS) - shift) + b[1] * shift) >> SHIFT_BITS;
+    out[2] = (a[2] * ((1 << SHIFT_BITS) - shift) + b[2] * shift) >> SHIFT_BITS;
 }

 static inline void
-interpolate4(INT16 out[4], const INT16 a[4], const INT16 b[4], INT16 shift)
-{
-    out[0] = (a[0] * ((1<<SHIFT_BITS)-shift) + b[0] * shift) >> SHIFT_BITS;
-    out[1] = (a[1] * ((1<<SHIFT_BITS)-shift) + b[1] * shift) >> SHIFT_BITS;
-    out[2] = (a[2] * ((1<<SHIFT_BITS)-shift) + b[2] * shift) >> SHIFT_BITS;
-    out[3] = (a[3] * ((1<<SHIFT_BITS)-shift) + b[3] * shift) >> SHIFT_BITS;
+interpolate4(INT16 out[4], const INT16 a[4], const INT16 b[4], INT16 shift) {
+    out[0] = (a[0] * ((1 << SHIFT_BITS) - shift) + b[0] * shift) >> SHIFT_BITS;
+    out[1] = (a[1] * ((1 << SHIFT_BITS) - shift) + b[1] * shift) >> SHIFT_BITS;
+    out[2] = (a[2] * ((1 << SHIFT_BITS) - shift) + b[2] * shift) >> SHIFT_BITS;
+    out[3] = (a[3] * ((1 << SHIFT_BITS) - shift) + b[3] * shift) >> SHIFT_BITS;
 }

 static inline int
-table_index3D(int index1D, int index2D, int index3D,
-               int size1D, int size1D_2D)
-{
+table_index3D(int index1D, int index2D, int index3D, int size1D, int size1D_2D) {
     return index1D + index2D * size1D + index3D * size1D_2D;
 }
-

 /*
  Transforms colors of imIn using provided 3D lookup table
@@ -63,10 +56,14 @@
     and 255 << PRECISION_BITS (16320) is highest value.
 */
 Imaging
-ImagingColorLUT3D_linear(Imaging imOut, Imaging imIn, int table_channels,
-                         int size1D, int size2D, int size3D,
-                         INT16* table)
-{
+ImagingColorLUT3D_linear(
+    Imaging imOut,
+    Imaging imIn,
+    int table_channels,
+    int size1D,
+    int size2D,
+    int size3D,
+    INT16 *table) {
     /* This float to int conversion doesn't have rounding
        error compensation (+0.5) for two reasons:
        1. As we don't hit the highest value,
@@ -77,9 +74,9 @@
           +1 cells will be outside of the table.
           With this compensation we never hit the upper cells
           but this also doesn't introduce any noticeable difference. */
-    UINT32 scale1D = (size1D - 1) / 255.0 * (1<<SCALE_BITS);
-    UINT32 scale2D = (size2D - 1) / 255.0 * (1<<SCALE_BITS);
-    UINT32 scale3D = (size3D - 1) / 255.0 * (1<<SCALE_BITS);
+    UINT32 scale1D = (size1D - 1) / 255.0 * (1 << SCALE_BITS);
+    UINT32 scale2D = (size2D - 1) / 255.0 * (1 << SCALE_BITS);
+    UINT32 scale3D = (size3D - 1) / 255.0 * (1 << SCALE_BITS);
     int size1D_2D = size1D * size2D;
     int x, y;
     ImagingSectionCookie cookie;
@@ -89,75 +86,97 @@
         return NULL;
     }

-    if (imIn->type != IMAGING_TYPE_UINT8 ||
-        imOut->type != IMAGING_TYPE_UINT8 ||
-        imIn->bands < 3 ||
-        imOut->bands < table_channels
-    ) {
-        return (Imaging) ImagingError_ModeError();
+    if (imIn->type != IMAGING_TYPE_UINT8 || imOut->type != IMAGING_TYPE_UINT8 ||
+        imIn->bands < 3 || imOut->bands < table_channels) {
+        return (Imaging)ImagingError_ModeError();
     }

     /* In case we have one extra band in imOut and don't have in imIn.*/
     if (imOut->bands > table_channels && imOut->bands > imIn->bands) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     ImagingSectionEnter(&cookie);
     for (y = 0; y < imOut->ysize; y++) {
-        UINT8* rowIn = (UINT8 *)imIn->image[y];
-        char* rowOut = (char *)imOut->image[y];
+        UINT8 *rowIn = (UINT8 *)imIn->image[y];
+        char *rowOut = (char *)imOut->image[y];
         for (x = 0; x < imOut->xsize; x++) {
-            UINT32 index1D = rowIn[x*4 + 0] * scale1D;
-            UINT32 index2D = rowIn[x*4 + 1] * scale2D;
-            UINT32 index3D = rowIn[x*4 + 2] * scale3D;
+            UINT32 index1D = rowIn[x * 4 + 0] * scale1D;
+            UINT32 index2D = rowIn[x * 4 + 1] * scale2D;
+            UINT32 index3D = rowIn[x * 4 + 2] * scale3D;
             INT16 shift1D = (SCALE_MASK & index1D) >> (SCALE_BITS - SHIFT_BITS);
             INT16 shift2D = (SCALE_MASK & index2D) >> (SCALE_BITS - SHIFT_BITS);
             INT16 shift3D = (SCALE_MASK & index3D) >> (SCALE_BITS - SHIFT_BITS);
             int idx = table_channels * table_index3D(
-                index1D >> SCALE_BITS, index2D >> SCALE_BITS,
-                index3D >> SCALE_BITS, size1D, size1D_2D);
+                                           index1D >> SCALE_BITS,
+                                           index2D >> SCALE_BITS,
+                                           index3D >> SCALE_BITS,
+                                           size1D,
+                                           size1D_2D);
             INT16 result[4], left[4], right[4];
             INT16 leftleft[4], leftright[4], rightleft[4], rightright[4];

             if (table_channels == 3) {
                 UINT32 v;
                 interpolate3(leftleft, &table[idx + 0], &table[idx + 3], shift1D);
-                interpolate3(leftright, &table[idx + size1D*3],
-                             &table[idx + size1D*3 + 3], shift1D);
+                interpolate3(
+                    leftright,
+                    &table[idx + size1D * 3],
+                    &table[idx + size1D * 3 + 3],
+                    shift1D);
                 interpolate3(left, leftleft, leftright, shift2D);

-                interpolate3(rightleft, &table[idx + size1D_2D*3],
-                             &table[idx + size1D_2D*3 + 3], shift1D);
-                interpolate3(rightright, &table[idx + size1D_2D*3 + size1D*3],
-                             &table[idx + size1D_2D*3 + size1D*3 + 3], shift1D);
+                interpolate3(
+                    rightleft,
+                    &table[idx + size1D_2D * 3],
+                    &table[idx + size1D_2D * 3 + 3],
+                    shift1D);
+                interpolate3(
+                    rightright,
+                    &table[idx + size1D_2D * 3 + size1D * 3],
+                    &table[idx + size1D_2D * 3 + size1D * 3 + 3],
+                    shift1D);
                 interpolate3(right, rightleft, rightright, shift2D);

                 interpolate3(result, left, right, shift3D);

                 v = MAKE_UINT32(
-                        clip8(result[0]), clip8(result[1]),
-                        clip8(result[2]), rowIn[x*4 + 3]);
+                    clip8(result[0]),
+                    clip8(result[1]),
+                    clip8(result[2]),
+                    rowIn[x * 4 + 3]);
                 memcpy(rowOut + x * sizeof(v), &v, sizeof(v));
             }

             if (table_channels == 4) {
                 UINT32 v;
                 interpolate4(leftleft, &table[idx + 0], &table[idx + 4], shift1D);
-                interpolate4(leftright, &table[idx + size1D*4],
-                             &table[idx + size1D*4 + 4], shift1D);
+                interpolate4(
+                    leftright,
+                    &table[idx + size1D * 4],
+                    &table[idx + size1D * 4 + 4],
+                    shift1D);
                 interpolate4(left, leftleft, leftright, shift2D);

-                interpolate4(rightleft, &table[idx + size1D_2D*4],
-                             &table[idx + size1D_2D*4 + 4], shift1D);
-                interpolate4(rightright, &table[idx + size1D_2D*4 + size1D*4],
-                             &table[idx + size1D_2D*4 + size1D*4 + 4], shift1D);
+                interpolate4(
+                    rightleft,
+                    &table[idx + size1D_2D * 4],
+                    &table[idx + size1D_2D * 4 + 4],
+                    shift1D);
+                interpolate4(
+                    rightright,
+                    &table[idx + size1D_2D * 4 + size1D * 4],
+                    &table[idx + size1D_2D * 4 + size1D * 4 + 4],
+                    shift1D);
                 interpolate4(right, rightleft, rightright, shift2D);

                 interpolate4(result, left, right, shift3D);

                 v = MAKE_UINT32(
-                        clip8(result[0]), clip8(result[1]),
-                        clip8(result[2]), clip8(result[3]));
+                    clip8(result[0]),
+                    clip8(result[1]),
+                    clip8(result[2]),
+                    clip8(result[3]));
                 memcpy(rowOut + x * sizeof(v), &v, sizeof(v));
             }
         }
('src/libImaging', 'Dib.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,21 +19,18 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #ifdef _WIN32

 #include "ImDib.h"

-
-char*
-ImagingGetModeDIB(int size_out[2])
-{
+char *
+ImagingGetModeDIB(int size_out[2]) {
     /* Get device characteristics */

     HDC dc;
-    char* mode;
+    char *mode;

     dc = CreateCompatibleDC(NULL);

@@ -55,10 +52,8 @@
     return mode;
 }

-
 ImagingDIB
-ImagingNewDIB(const char *mode, int xsize, int ysize)
-{
+ImagingNewDIB(const char *mode, int xsize, int ysize) {
     /* Create a Windows bitmap */

     ImagingDIB dib;
@@ -66,23 +61,21 @@
     int i;

     /* Check mode */
-    if (strcmp(mode, "1") != 0 && strcmp(mode, "L") != 0 &&
-        strcmp(mode, "RGB") != 0) {
-        return (ImagingDIB) ImagingError_ModeError();
+    if (strcmp(mode, "1") != 0 && strcmp(mode, "L") != 0 && strcmp(mode, "RGB") != 0) {
+        return (ImagingDIB)ImagingError_ModeError();
     }

     /* Create DIB context and info header */
     /* malloc check ok, small constant allocation */
-    dib = (ImagingDIB) malloc(sizeof(*dib));
+    dib = (ImagingDIB)malloc(sizeof(*dib));
     if (!dib) {
-        return (ImagingDIB) ImagingError_MemoryError();
+        return (ImagingDIB)ImagingError_MemoryError();
     }
     /* malloc check ok, small constant allocation */
-    dib->info = (BITMAPINFO*) malloc(sizeof(BITMAPINFOHEADER) +
-                                     256 * sizeof(RGBQUAD));
+    dib->info = (BITMAPINFO *)malloc(sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
     if (!dib->info) {
         free(dib);
-        return (ImagingDIB) ImagingError_MemoryError();
+        return (ImagingDIB)ImagingError_MemoryError();
     }

     memset(dib->info, 0, sizeof(BITMAPINFOHEADER));
@@ -90,7 +83,7 @@
     dib->info->bmiHeader.biWidth = xsize;
     dib->info->bmiHeader.biHeight = ysize;
     dib->info->bmiHeader.biPlanes = 1;
-    dib->info->bmiHeader.biBitCount = strlen(mode)*8;
+    dib->info->bmiHeader.biBitCount = strlen(mode) * 8;
     dib->info->bmiHeader.biCompression = BI_RGB;

     /* Create DIB */
@@ -98,15 +91,15 @@
     if (!dib->dc) {
         free(dib->info);
         free(dib);
-        return (ImagingDIB) ImagingError_MemoryError();
-    }
-
-    dib->bitmap = CreateDIBSection(dib->dc, dib->info, DIB_RGB_COLORS,
-                                   &dib->bits, NULL, 0);
+        return (ImagingDIB)ImagingError_MemoryError();
+    }
+
+    dib->bitmap =
+        CreateDIBSection(dib->dc, dib->info, DIB_RGB_COLORS, &dib->bits, NULL, 0);
     if (!dib->bitmap) {
         free(dib->info);
         free(dib);
-        return (ImagingDIB) ImagingError_MemoryError();
+        return (ImagingDIB)ImagingError_MemoryError();
     }

     strcpy(dib->mode, mode);
@@ -117,7 +110,7 @@
     dib->linesize = (xsize * dib->pixelsize + 3) & -4;

     if (dib->pixelsize == 1) {
-        dib->pack = dib->unpack = (ImagingShuffler) memcpy;
+        dib->pack = dib->unpack = (ImagingShuffler)memcpy;
     } else {
         dib->pack = ImagingPackBGR;
         dib->unpack = ImagingPackBGR;
@@ -131,9 +124,7 @@
     /* Bind a palette to it as well (only required for 8-bit DIBs) */
     if (dib->pixelsize == 1) {
         for (i = 0; i < 256; i++) {
-            palette[i].rgbRed =
-            palette[i].rgbGreen =
-            palette[i].rgbBlue = i;
+            palette[i].rgbRed = palette[i].rgbGreen = palette[i].rgbBlue = i;
             palette[i].rgbReserved = 0;
         }
         SetDIBColorTable(dib->dc, 0, 256, palette);
@@ -141,9 +132,8 @@

     /* Create an associated palette (for 8-bit displays only) */
     if (strcmp(ImagingGetModeDIB(NULL), "P") == 0) {
-
-        char palbuf[sizeof(LOGPALETTE)+256*sizeof(PALETTEENTRY)];
-        LPLOGPALETTE pal = (LPLOGPALETTE) palbuf;
+        char palbuf[sizeof(LOGPALETTE) + 256 * sizeof(PALETTEENTRY)];
+        LPLOGPALETTE pal = (LPLOGPALETTE)palbuf;
         int i, r, g, b;

         /* Load system palette */
@@ -152,7 +142,6 @@
         GetSystemPaletteEntries(dib->dc, 0, 256, pal->palPalEntry);

         if (strcmp(mode, "L") == 0) {
-
             /* Greyscale DIB.  Fill all 236 slots with a greyscale ramp
              * (this is usually overkill on Windows since VGA only offers
              * 6 bits greyscale resolution).  Ignore the slots already
@@ -160,16 +149,14 @@

             i = 10;
             for (r = 0; r < 236; r++) {
-                pal->palPalEntry[i].peRed =
-                pal->palPalEntry[i].peGreen =
-                pal->palPalEntry[i].peBlue = i;
+                pal->palPalEntry[i].peRed = pal->palPalEntry[i].peGreen =
+                    pal->palPalEntry[i].peBlue = i;
                 i++;
             }

             dib->palette = CreatePalette(pal);

         } else if (strcmp(mode, "RGB") == 0) {
-
 #ifdef CUBE216

             /* Colour DIB.  Create a 6x6x6 colour cube (216 entries) and
@@ -187,11 +174,10 @@
                     }
                 }
             }
-            for (r = 1; r < 22-1; r++) {
+            for (r = 1; r < 22 - 1; r++) {
                 /* Black and white are already provided by the cube. */
-                pal->palPalEntry[i].peRed =
-                pal->palPalEntry[i].peGreen =
-                pal->palPalEntry[i].peBlue = r * 255 / (22-1);
+                pal->palPalEntry[i].peRed = pal->palPalEntry[i].peGreen =
+                    pal->palPalEntry[i].peBlue = r * 255 / (22 - 1);
                 i++;
             }

@@ -214,76 +200,91 @@
 #endif

             dib->palette = CreatePalette(pal);
-
         }
-
     }

     return dib;
 }

 void
-ImagingPasteDIB(ImagingDIB dib, Imaging im, int xy[4])
-{
+ImagingPasteDIB(ImagingDIB dib, Imaging im, int xy[4]) {
     /* Paste image data into a bitmap */

     /* FIXME: check size! */

     int y;
     for (y = 0; y < im->ysize; y++) {
-        dib->pack(dib->bits + dib->linesize*(dib->ysize-(xy[1]+y)-1) +
-                  xy[0]*dib->pixelsize, im->image[y], im->xsize);
-    }
-
+        dib->pack(
+            dib->bits + dib->linesize * (dib->ysize - (xy[1] + y) - 1) +
+                xy[0] * dib->pixelsize,
+            im->image[y],
+            im->xsize);
+    }
 }

 void
-ImagingExposeDIB(ImagingDIB dib, void *dc)
-{
+ImagingExposeDIB(ImagingDIB dib, void *dc) {
     /* Copy bitmap to display */

     if (dib->palette != 0) {
-        SelectPalette((HDC) dc, dib->palette, FALSE);
-    }
-    BitBlt((HDC) dc, 0, 0, dib->xsize, dib->ysize, dib->dc, 0, 0, SRCCOPY);
+        SelectPalette((HDC)dc, dib->palette, FALSE);
+    }
+    BitBlt((HDC)dc, 0, 0, dib->xsize, dib->ysize, dib->dc, 0, 0, SRCCOPY);
 }

 void
-ImagingDrawDIB(ImagingDIB dib, void *dc, int dst[4], int src[4])
-{
+ImagingDrawDIB(ImagingDIB dib, void *dc, int dst[4], int src[4]) {
     /* Copy bitmap to printer/display */

-    if (GetDeviceCaps((HDC) dc, RASTERCAPS) & RC_STRETCHDIB) {
+    if (GetDeviceCaps((HDC)dc, RASTERCAPS) & RC_STRETCHDIB) {
         /* stretchdib (printers) */
-        StretchDIBits((HDC) dc, dst[0], dst[1], dst[2]-dst[0], dst[3]-dst[1],
-                      src[0], src[1], src[2]-src[0], src[3]-src[1], dib->bits,
-                      dib->info, DIB_RGB_COLORS, SRCCOPY);
+        StretchDIBits(
+            (HDC)dc,
+            dst[0],
+            dst[1],
+            dst[2] - dst[0],
+            dst[3] - dst[1],
+            src[0],
+            src[1],
+            src[2] - src[0],
+            src[3] - src[1],
+            dib->bits,
+            dib->info,
+            DIB_RGB_COLORS,
+            SRCCOPY);
     } else {
         /* stretchblt (displays) */
         if (dib->palette != 0) {
-            SelectPalette((HDC) dc, dib->palette, FALSE);
+            SelectPalette((HDC)dc, dib->palette, FALSE);
         }
-        StretchBlt((HDC) dc, dst[0], dst[1], dst[2]-dst[0], dst[3]-dst[1],
-                   dib->dc, src[0], src[1], src[2]-src[0], src[3]-src[1],
-                   SRCCOPY);
+        StretchBlt(
+            (HDC)dc,
+            dst[0],
+            dst[1],
+            dst[2] - dst[0],
+            dst[3] - dst[1],
+            dib->dc,
+            src[0],
+            src[1],
+            src[2] - src[0],
+            src[3] - src[1],
+            SRCCOPY);
     }
 }

 int
-ImagingQueryPaletteDIB(ImagingDIB dib, void *dc)
-{
+ImagingQueryPaletteDIB(ImagingDIB dib, void *dc) {
     /* Install bitmap palette */

     int n;

     if (dib->palette != 0) {
-
         /* Realize associated palette */
-        HPALETTE now = SelectPalette((HDC) dc, dib->palette, FALSE);
-        n = RealizePalette((HDC) dc);
+        HPALETTE now = SelectPalette((HDC)dc, dib->palette, FALSE);
+        n = RealizePalette((HDC)dc);

         /* Restore palette */
-        SelectPalette((HDC) dc, now, FALSE);
+        SelectPalette((HDC)dc, now, FALSE);

     } else {
         n = 0;
@@ -293,8 +294,7 @@
 }

 void
-ImagingDeleteDIB(ImagingDIB dib)
-{
+ImagingDeleteDIB(ImagingDIB dib) {
     /* Clean up */

     if (dib->palette) {
('src/libImaging', 'QuantHeap.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,12 +16,16 @@

 typedef struct _Heap Heap;

-typedef int (*HeapCmpFunc)(const Heap *,const void *,const void *);
+typedef int (*HeapCmpFunc)(const Heap *, const void *, const void *);

-void ImagingQuantHeapFree(Heap *);
-int ImagingQuantHeapRemove(Heap *,void **);
-int ImagingQuantHeapAdd(Heap *,void *);
-int ImagingQuantHeapTop(Heap *,void **);
+void
+ImagingQuantHeapFree(Heap *);
+int
+ImagingQuantHeapRemove(Heap *, void **);
+int
+ImagingQuantHeapAdd(Heap *, void *);
+int
+ImagingQuantHeapTop(Heap *, void **);
 Heap *ImagingQuantHeapNew(HeapCmpFunc);

-#endif // __QUANTHEAP_H__
+#endif  // __QUANTHEAP_H__
('src/libImaging', 'Quant.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -43,168 +43,154 @@
 } PixelHashData;

 typedef struct _PixelList {
-    struct _PixelList *next[3],*prev[3];
+    struct _PixelList *next[3], *prev[3];
     Pixel p;
-    unsigned int flag:1;
+    unsigned int flag : 1;
     int count;
 } PixelList;

 typedef struct _BoxNode {
-    struct _BoxNode *l,*r;
-    PixelList *head[3],*tail[3];
+    struct _BoxNode *l, *r;
+    PixelList *head[3], *tail[3];
     int axis;
     int volume;
     uint32_t pixelCount;
 } BoxNode;

-#define _SQR(x) ((x)*(x))
-#define _DISTSQR(p1,p2) \
-    _SQR((int)((p1)->c.r)-(int)((p2)->c.r))+ \
-    _SQR((int)((p1)->c.g)-(int)((p2)->c.g))+ \
-    _SQR((int)((p1)->c.b)-(int)((p2)->c.b))
+#define _SQR(x) ((x) * (x))
+#define _DISTSQR(p1, p2)                            \
+    _SQR((int)((p1)->c.r) - (int)((p2)->c.r)) +     \
+        _SQR((int)((p1)->c.g) - (int)((p2)->c.g)) + \
+        _SQR((int)((p1)->c.b) - (int)((p2)->c.b))

 #define MAX_HASH_ENTRIES 65536

-#define PIXEL_HASH(r,g,b) \
-    (((unsigned int)(r)    )*463 ^ \
-     ((unsigned int)(g)<< 8)*10069 ^ \
-     ((unsigned int)(b)<<16)*64997)
-
-#define PIXEL_UNSCALE(p,q,s) \
-    ((q)->c.r=(p)->c.r<<(s)), \
-    ((q)->c.g=(p)->c.g<<(s)), \
-    ((q)->c.b=(p)->c.b<<(s))
-
-#define PIXEL_SCALE(p,q,s)\
-    ((q)->c.r=(p)->c.r>>(s)),              \
-    ((q)->c.g=(p)->c.g>>(s)),              \
-    ((q)->c.b=(p)->c.b>>(s))
+#define PIXEL_HASH(r, g, b)                                         \
+    (((unsigned int)(r)) * 463 ^ ((unsigned int)(g) << 8) * 10069 ^ \
+     ((unsigned int)(b) << 16) * 64997)
+
+#define PIXEL_UNSCALE(p, q, s)                                  \
+    ((q)->c.r = (p)->c.r << (s)), ((q)->c.g = (p)->c.g << (s)), \
+        ((q)->c.b = (p)->c.b << (s))
+
+#define PIXEL_SCALE(p, q, s)                                    \
+    ((q)->c.r = (p)->c.r >> (s)), ((q)->c.g = (p)->c.g >> (s)), \
+        ((q)->c.b = (p)->c.b >> (s))

 static uint32_t
-unshifted_pixel_hash(const HashTable *h, const Pixel pixel)
-{
-   return PIXEL_HASH(pixel.c.r, pixel.c.g, pixel.c.b);
-}
-
-static int
-unshifted_pixel_cmp(const HashTable *h, const Pixel pixel1, const Pixel pixel2)
-{
-    if (pixel1.c.r==pixel2.c.r) {
-        if (pixel1.c.g==pixel2.c.g) {
-            if (pixel1.c.b==pixel2.c.b) {
+unshifted_pixel_hash(const HashTable *h, const Pixel pixel) {
+    return PIXEL_HASH(pixel.c.r, pixel.c.g, pixel.c.b);
+}
+
+static int
+unshifted_pixel_cmp(const HashTable *h, const Pixel pixel1, const Pixel pixel2) {
+    if (pixel1.c.r == pixel2.c.r) {
+        if (pixel1.c.g == pixel2.c.g) {
+            if (pixel1.c.b == pixel2.c.b) {
                 return 0;
             } else {
-                return (int)(pixel1.c.b)-(int)(pixel2.c.b);
+                return (int)(pixel1.c.b) - (int)(pixel2.c.b);
             }
         } else {
-            return (int)(pixel1.c.g)-(int)(pixel2.c.g);
+            return (int)(pixel1.c.g) - (int)(pixel2.c.g);
         }
     } else {
-        return (int)(pixel1.c.r)-(int)(pixel2.c.r);
+        return (int)(pixel1.c.r) - (int)(pixel2.c.r);
     }
 }

 static uint32_t
-pixel_hash(const HashTable *h,const Pixel pixel)
-{
-    PixelHashData *d=(PixelHashData *)hashtable_get_user_data(h);
-    return PIXEL_HASH(pixel.c.r>>d->scale, pixel.c.g>>d->scale, pixel.c.b>>d->scale);
-}
-
-static int
-pixel_cmp(const HashTable *h,const Pixel pixel1, const Pixel pixel2)
-{
-    PixelHashData *d=(PixelHashData *)hashtable_get_user_data(h);
-    uint32_t A,B;
-    A=PIXEL_HASH(pixel1.c.r>>d->scale, pixel1.c.g>>d->scale, pixel1.c.b>>d->scale);
-    B=PIXEL_HASH(pixel2.c.r>>d->scale, pixel2.c.g>>d->scale, pixel2.c.b>>d->scale);
-    return (A==B)?0:((A<B)?-1:1);
+pixel_hash(const HashTable *h, const Pixel pixel) {
+    PixelHashData *d = (PixelHashData *)hashtable_get_user_data(h);
+    return PIXEL_HASH(
+        pixel.c.r >> d->scale, pixel.c.g >> d->scale, pixel.c.b >> d->scale);
+}
+
+static int
+pixel_cmp(const HashTable *h, const Pixel pixel1, const Pixel pixel2) {
+    PixelHashData *d = (PixelHashData *)hashtable_get_user_data(h);
+    uint32_t A, B;
+    A = PIXEL_HASH(
+        pixel1.c.r >> d->scale, pixel1.c.g >> d->scale, pixel1.c.b >> d->scale);
+    B = PIXEL_HASH(
+        pixel2.c.r >> d->scale, pixel2.c.g >> d->scale, pixel2.c.b >> d->scale);
+    return (A == B) ? 0 : ((A < B) ? -1 : 1);
 }

 static void
-exists_count_func(const HashTable *h, const Pixel key, uint32_t *val)
-{
-    *val+=1;
+exists_count_func(const HashTable *h, const Pixel key, uint32_t *val) {
+    *val += 1;
 }

 static void
-new_count_func(const HashTable *h, const Pixel key, uint32_t *val)
-{
-    *val=1;
+new_count_func(const HashTable *h, const Pixel key, uint32_t *val) {
+    *val = 1;
 }

 static void
-rehash_collide(const HashTable *h,
-               Pixel *keyp,
-               uint32_t *valp,
-               Pixel newkey,
-               uint32_t newval)
-{
+rehash_collide(
+    const HashTable *h, Pixel *keyp, uint32_t *valp, Pixel newkey, uint32_t newval) {
     *valp += newval;
 }

 /* %% */

 static HashTable *
-create_pixel_hash(Pixel *pixelData,uint32_t nPixels)
-{
-   PixelHashData *d;
-   HashTable *hash;
-   uint32_t i;
-#ifndef NO_OUTPUT
-   uint32_t timer,timer2,timer3;
-#endif
-
-   /* malloc check ok, small constant allocation */
-   d=malloc(sizeof(PixelHashData));
-   if (!d) {
-       return NULL;
-   }
-   hash=hashtable_new(pixel_hash,pixel_cmp);
-   hashtable_set_user_data(hash,d);
-   d->scale=0;
-#ifndef NO_OUTPUT
-   timer=timer3=clock();
-#endif
-   for (i=0;i<nPixels;i++) {
-      if (!hashtable_insert_or_update_computed(hash,
-                                              pixelData[i],
-                                              new_count_func,
-                                              exists_count_func)) {;
-      }
-      while (hashtable_get_count(hash)>MAX_HASH_ENTRIES) {
-         d->scale++;
-#ifndef NO_OUTPUT
-         printf ("rehashing - new scale: %d\n",(int)d->scale);
-         timer2=clock();
-#endif
-         hashtable_rehash_compute(hash,rehash_collide);
-#ifndef NO_OUTPUT
-         timer2=clock()-timer2;
-         printf ("rehash took %f sec\n",timer2/(double)CLOCKS_PER_SEC);
-         timer+=timer2;
-#endif
-      }
-   }
-#ifndef NO_OUTPUT
-   printf ("inserts took %f sec\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-#endif
-#ifndef NO_OUTPUT
-   printf ("total        %f sec\n",(clock()-timer3)/(double)CLOCKS_PER_SEC);
-#endif
-   return hash;
+create_pixel_hash(Pixel *pixelData, uint32_t nPixels) {
+    PixelHashData *d;
+    HashTable *hash;
+    uint32_t i;
+#ifndef NO_OUTPUT
+    uint32_t timer, timer2, timer3;
+#endif
+
+    /* malloc check ok, small constant allocation */
+    d = malloc(sizeof(PixelHashData));
+    if (!d) {
+        return NULL;
+    }
+    hash = hashtable_new(pixel_hash, pixel_cmp);
+    hashtable_set_user_data(hash, d);
+    d->scale = 0;
+#ifndef NO_OUTPUT
+    timer = timer3 = clock();
+#endif
+    for (i = 0; i < nPixels; i++) {
+        if (!hashtable_insert_or_update_computed(
+                hash, pixelData[i], new_count_func, exists_count_func)) {
+            ;
+        }
+        while (hashtable_get_count(hash) > MAX_HASH_ENTRIES) {
+            d->scale++;
+#ifndef NO_OUTPUT
+            printf("rehashing - new scale: %d\n", (int)d->scale);
+            timer2 = clock();
+#endif
+            hashtable_rehash_compute(hash, rehash_collide);
+#ifndef NO_OUTPUT
+            timer2 = clock() - timer2;
+            printf("rehash took %f sec\n", timer2 / (double)CLOCKS_PER_SEC);
+            timer += timer2;
+#endif
+        }
+    }
+#ifndef NO_OUTPUT
+    printf("inserts took %f sec\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+#endif
+#ifndef NO_OUTPUT
+    printf("total        %f sec\n", (clock() - timer3) / (double)CLOCKS_PER_SEC);
+#endif
+    return hash;
 }

 static void
-destroy_pixel_hash(HashTable *hash)
-{
-   PixelHashData *d=(PixelHashData *)hashtable_get_user_data(hash);
-   if (d) {
-       free(d);
-   }
-   hashtable_free(hash);
-}
-
+destroy_pixel_hash(HashTable *hash) {
+    PixelHashData *d = (PixelHashData *)hashtable_get_user_data(hash);
+    if (d) {
+        free(d);
+    }
+    hashtable_free(hash);
+}

 /* 1. hash quantized pixels.                                                  */
 /* 2. create R,G,B lists of sorted quantized pixels.                          */
@@ -215,659 +201,686 @@
 /* 7. map each pixel to nearest average.                                      */

 static int
-compute_box_volume(BoxNode *b)
-{
-   unsigned char rl,rh,gl,gh,bl,bh;
-   if (b->volume>=0) {
-      return b->volume;
-   }
-   if (!b->head[0]) {
-      b->volume=0;
-   } else {
-      rh=b->head[0]->p.c.r;
-      rl=b->tail[0]->p.c.r;
-      gh=b->head[1]->p.c.g;
-      gl=b->tail[1]->p.c.g;
-      bh=b->head[2]->p.c.b;
-      bl=b->tail[2]->p.c.b;
-      b->volume=(rh-rl+1)*(gh-gl+1)*(bh-bl+1);
-   }
-   return b->volume;
+compute_box_volume(BoxNode *b) {
+    unsigned char rl, rh, gl, gh, bl, bh;
+    if (b->volume >= 0) {
+        return b->volume;
+    }
+    if (!b->head[0]) {
+        b->volume = 0;
+    } else {
+        rh = b->head[0]->p.c.r;
+        rl = b->tail[0]->p.c.r;
+        gh = b->head[1]->p.c.g;
+        gl = b->tail[1]->p.c.g;
+        bh = b->head[2]->p.c.b;
+        bl = b->tail[2]->p.c.b;
+        b->volume = (rh - rl + 1) * (gh - gl + 1) * (bh - bl + 1);
+    }
+    return b->volume;
 }

 static void
-hash_to_list(const HashTable *h, const Pixel pixel, const uint32_t count, void *u)
-{
-   PixelHashData *d=(PixelHashData *)hashtable_get_user_data(h);
-   PixelList **pl=(PixelList **)u;
-   PixelList *p;
-   int i;
-   Pixel q;
-
-   PIXEL_SCALE(&pixel,&q,d->scale);
-
-   /* malloc check ok, small constant allocation */
-   p=malloc(sizeof(PixelList));
-   if (!p) {
-      return;
-   }
-
-   p->flag=0;
-   p->p=q;
-   p->count=count;
-   for (i=0;i<3;i++) {
-      p->next[i]=pl[i];
-      p->prev[i]=NULL;
-      if (pl[i]) {
-         pl[i]->prev[i]=p;
-      }
-      pl[i]=p;
-   }
+hash_to_list(const HashTable *h, const Pixel pixel, const uint32_t count, void *u) {
+    PixelHashData *d = (PixelHashData *)hashtable_get_user_data(h);
+    PixelList **pl = (PixelList **)u;
+    PixelList *p;
+    int i;
+    Pixel q;
+
+    PIXEL_SCALE(&pixel, &q, d->scale);
+
+    /* malloc check ok, small constant allocation */
+    p = malloc(sizeof(PixelList));
+    if (!p) {
+        return;
+    }
+
+    p->flag = 0;
+    p->p = q;
+    p->count = count;
+    for (i = 0; i < 3; i++) {
+        p->next[i] = pl[i];
+        p->prev[i] = NULL;
+        if (pl[i]) {
+            pl[i]->prev[i] = p;
+        }
+        pl[i] = p;
+    }
 }

 static PixelList *
-mergesort_pixels(PixelList *head, int i)
-{
-   PixelList *c,*t,*a,*b,*p;
-   if (!head||!head->next[i]) {
-      if (head) {
-         head->next[i]=NULL;
-         head->prev[i]=NULL;
-      }
-      return head;
-   }
-   for (c=t=head;c&&t;c=c->next[i],t=(t->next[i])?t->next[i]->next[i]:NULL);
-   if (c) {
-      if (c->prev[i]) {
-         c->prev[i]->next[i]=NULL;
-      }
-      c->prev[i]=NULL;
-   }
-   a=mergesort_pixels(head,i);
-   b=mergesort_pixels(c,i);
-   head=NULL;
-   p=NULL;
-   while (a&&b) {
-      if (a->p.a.v[i]>b->p.a.v[i]) {
-         c=a;
-         a=a->next[i];
-      } else {
-         c=b;
-         b=b->next[i];
-      }
-      c->prev[i]=p;
-      c->next[i]=NULL;
-      if (p) {
-         p->next[i]=c;
-      }
-      p=c;
-      if (!head) {
-         head=c;
-      }
-   }
-   if (a) {
-      c->next[i]=a;
-      a->prev[i]=c;
-   } else if (b) {
-      c->next[i]=b;
-      b->prev[i]=c;
-   }
-   return head;
+mergesort_pixels(PixelList *head, int i) {
+    PixelList *c, *t, *a, *b, *p;
+    if (!head || !head->next[i]) {
+        if (head) {
+            head->next[i] = NULL;
+            head->prev[i] = NULL;
+        }
+        return head;
+    }
+    for (c = t = head; c && t;
+         c = c->next[i], t = (t->next[i]) ? t->next[i]->next[i] : NULL)
+        ;
+    if (c) {
+        if (c->prev[i]) {
+            c->prev[i]->next[i] = NULL;
+        }
+        c->prev[i] = NULL;
+    }
+    a = mergesort_pixels(head, i);
+    b = mergesort_pixels(c, i);
+    head = NULL;
+    p = NULL;
+    while (a && b) {
+        if (a->p.a.v[i] > b->p.a.v[i]) {
+            c = a;
+            a = a->next[i];
+        } else {
+            c = b;
+            b = b->next[i];
+        }
+        c->prev[i] = p;
+        c->next[i] = NULL;
+        if (p) {
+            p->next[i] = c;
+        }
+        p = c;
+        if (!head) {
+            head = c;
+        }
+    }
+    if (a) {
+        c->next[i] = a;
+        a->prev[i] = c;
+    } else if (b) {
+        c->next[i] = b;
+        b->prev[i] = c;
+    }
+    return head;
 }

 #if defined(TEST_MERGESORT) || defined(TEST_SORTED)
 static int
-test_sorted(PixelList *pl[3])
-{
-   int i,n,l;
-   PixelList *t;
-
-   for(i=0;i<3;i++) {
-      n=0;
-      l=256;
-      for (t=pl[i];t;t=t->next[i]) {
-         if (l<t->p.a.v[i]) return 0;
-         l=t->p.a.v[i];
-      }
-   }
-   return 1;
-}
-#endif
-
-static int
-box_heap_cmp(const Heap *h, const void *A, const void *B)
-{
-   BoxNode *a=(BoxNode *)A;
-   BoxNode *b=(BoxNode *)B;
-   return (int)a->pixelCount-(int)b->pixelCount;
-}
-
-#define LUMINANCE(p) (77*(p)->c.r+150*(p)->c.g+29*(p)->c.b)
-
-static int
-splitlists(PixelList *h[3],
-           PixelList *t[3],
-           PixelList *nh[2][3],
-           PixelList *nt[2][3],
-           uint32_t nCount[2],
-           int axis,
-           uint32_t pixelCount)
-{
-   uint32_t left;
-
-   PixelList *l,*r,*c,*n;
-   int i;
-   int nRight,nLeft;
-   int splitColourVal;
+test_sorted(PixelList *pl[3]) {
+    int i, n, l;
+    PixelList *t;
+
+    for (i = 0; i < 3; i++) {
+        n = 0;
+        l = 256;
+        for (t = pl[i]; t; t = t->next[i]) {
+            if (l < t->p.a.v[i])
+                return 0;
+            l = t->p.a.v[i];
+        }
+    }
+    return 1;
+}
+#endif
+
+static int
+box_heap_cmp(const Heap *h, const void *A, const void *B) {
+    BoxNode *a = (BoxNode *)A;
+    BoxNode *b = (BoxNode *)B;
+    return (int)a->pixelCount - (int)b->pixelCount;
+}
+
+#define LUMINANCE(p) (77 * (p)->c.r + 150 * (p)->c.g + 29 * (p)->c.b)
+
+static int
+splitlists(
+    PixelList *h[3],
+    PixelList *t[3],
+    PixelList *nh[2][3],
+    PixelList *nt[2][3],
+    uint32_t nCount[2],
+    int axis,
+    uint32_t pixelCount) {
+    uint32_t left;
+
+    PixelList *l, *r, *c, *n;
+    int i;
+    int nRight, nLeft;
+    int splitColourVal;

 #ifdef TEST_SPLIT
-   {
-      PixelList *_prevTest,*_nextTest;
-      int _i,_nextCount[3],_prevCount[3];
-      for (_i=0;_i<3;_i++) {
-         for (_nextCount[_i]=0,_nextTest=h[_i];_nextTest&&_nextTest->next[_i];_nextTest=_nextTest->next[_i],_nextCount[_i]++);
-         for (_prevCount[_i]=0,_prevTest=t[_i];_prevTest&&_prevTest->prev[_i];_prevTest=_prevTest->prev[_i],_prevCount[_i]++);
-         if (_nextTest!=t[_i]) {
-            printf ("next-list of axis %d does not end at tail\n",_i);
-            exit(1);
-         }
-         if (_prevTest!=h[_i]) {
-            printf ("prev-list of axis %d does not end at head\n",_i);
-            exit(1);
-         }
-         for (;_nextTest&&_nextTest->prev[_i];_nextTest=_nextTest->prev[_i]);
-         for (;_prevTest&&_prevTest->next[_i];_prevTest=_prevTest->next[_i]);
-         if (_nextTest!=h[_i]) {
-            printf ("next-list of axis %d does not loop back to head\n",_i);
-            exit(1);
-         }
-         if (_prevTest!=t[_i]) {
-            printf ("prev-list of axis %d does not loop back to tail\n",_i);
-            exit(1);
-         }
-      }
-      for (_i=1;_i<3;_i++) {
-         if (_prevCount[_i]!=_prevCount[_i-1] ||
-             _nextCount[_i]!=_nextCount[_i-1] ||
-             _prevCount[_i]!=_nextCount[_i]) {
-            printf ("{%d %d %d} {%d %d %d}\n",
+    {
+        PixelList *_prevTest, *_nextTest;
+        int _i, _nextCount[3], _prevCount[3];
+        for (_i = 0; _i < 3; _i++) {
+            for (_nextCount[_i] = 0, _nextTest = h[_i];
+                 _nextTest && _nextTest->next[_i];
+                 _nextTest = _nextTest->next[_i], _nextCount[_i]++)
+                ;
+            for (_prevCount[_i] = 0, _prevTest = t[_i];
+                 _prevTest && _prevTest->prev[_i];
+                 _prevTest = _prevTest->prev[_i], _prevCount[_i]++)
+                ;
+            if (_nextTest != t[_i]) {
+                printf("next-list of axis %d does not end at tail\n", _i);
+                exit(1);
+            }
+            if (_prevTest != h[_i]) {
+                printf("prev-list of axis %d does not end at head\n", _i);
+                exit(1);
+            }
+            for (; _nextTest && _nextTest->prev[_i]; _nextTest = _nextTest->prev[_i])
+                ;
+            for (; _prevTest && _prevTest->next[_i]; _prevTest = _prevTest->next[_i])
+                ;
+            if (_nextTest != h[_i]) {
+                printf("next-list of axis %d does not loop back to head\n", _i);
+                exit(1);
+            }
+            if (_prevTest != t[_i]) {
+                printf("prev-list of axis %d does not loop back to tail\n", _i);
+                exit(1);
+            }
+        }
+        for (_i = 1; _i < 3; _i++) {
+            if (_prevCount[_i] != _prevCount[_i - 1] ||
+                _nextCount[_i] != _nextCount[_i - 1] ||
+                _prevCount[_i] != _nextCount[_i]) {
+                printf(
+                    "{%d %d %d} {%d %d %d}\n",
                     _prevCount[0],
                     _prevCount[1],
                     _prevCount[2],
                     _nextCount[0],
                     _nextCount[1],
                     _nextCount[2]);
-            exit(1);
-         }
-      }
-    }
-#endif
-   nCount[0]=nCount[1]=0;
-   nLeft=nRight=0;
-   for (left=0,c=h[axis];c;) {
-      left=left+c->count;
-      nCount[0]+=c->count;
-      c->flag=0;
-      nLeft++;
-      c=c->next[axis];
-      if (left*2>pixelCount) {
-         break;
-      }
-   }
-   if (c) {
-      splitColourVal=c->prev[axis]->p.a.v[axis];
-      for (;c;c=c->next[axis]) {
-         if (splitColourVal!=c->p.a.v[axis]) {
+                exit(1);
+            }
+        }
+    }
+#endif
+    nCount[0] = nCount[1] = 0;
+    nLeft = nRight = 0;
+    for (left = 0, c = h[axis]; c;) {
+        left = left + c->count;
+        nCount[0] += c->count;
+        c->flag = 0;
+        nLeft++;
+        c = c->next[axis];
+        if (left * 2 > pixelCount) {
             break;
-         }
-         c->flag=0;
-         nLeft++;
-         nCount[0]+=c->count;
-      }
-   }
-   for (;c;c=c->next[axis]) {
-      c->flag=1;
-      nRight++;
-      nCount[1]+=c->count;
-   }
-   if (!nRight) {
-      for (c=t[axis],splitColourVal=t[axis]->p.a.v[axis];c;c=c->prev[axis]) {
-         if (splitColourVal!=c->p.a.v[axis]) {
-            break;
-         }
-         c->flag=1;
-         nRight++;
-         nLeft--;
-         nCount[0]-=c->count;
-         nCount[1]+=c->count;
-      }
-   }
-#ifndef NO_OUTPUT
-   if (!nLeft) {
-      for (c=h[axis];c;c=c->next[axis]) {
-         printf ("[%d %d %d]\n",c->p.c.r,c->p.c.g,c->p.c.b);
-      }
-      printf ("warning... trivial split\n");
-   }
-#endif
-
-   for (i=0;i<3;i++) {
-      l=r=NULL;
-      nh[0][i]=nt[0][i]=NULL;
-      nh[1][i]=nt[1][i]=NULL;
-      for (c=h[i];c;c=n) {
-         n=c->next[i];
-         if (c->flag) {    /* move pixel to right  list*/
-            if (r) {
-               r->next[i]=c;
-            } else {
-               nh[1][i]=c;
-            }
-            c->prev[i]=r;
-            r=c;
-         } else {          /* move pixel to left list */
-            if (l) {
-               l->next[i]=c;
-            } else {
-               nh[0][i]=c;
-            }
-            c->prev[i]=l;
-            l=c;
-         }
-      }
-      if (l) {
-         l->next[i]=NULL;
-      }
-      if (r) {
-         r->next[i]=NULL;
-      }
-      nt[0][i]=l;
-      nt[1][i]=r;
-   }
-   return 1;
-}
-
-static int
-split(BoxNode *node)
-{
-   unsigned char rl,rh,gl,gh,bl,bh;
-   int f[3];
-   int best,axis;
-   int i;
-   PixelList *heads[2][3];
-   PixelList *tails[2][3];
-   uint32_t newCounts[2];
-   BoxNode *left,*right;
-
-   rh=node->head[0]->p.c.r;
-   rl=node->tail[0]->p.c.r;
-   gh=node->head[1]->p.c.g;
-   gl=node->tail[1]->p.c.g;
-   bh=node->head[2]->p.c.b;
-   bl=node->tail[2]->p.c.b;
+        }
+    }
+    if (c) {
+        splitColourVal = c->prev[axis]->p.a.v[axis];
+        for (; c; c = c->next[axis]) {
+            if (splitColourVal != c->p.a.v[axis]) {
+                break;
+            }
+            c->flag = 0;
+            nLeft++;
+            nCount[0] += c->count;
+        }
+    }
+    for (; c; c = c->next[axis]) {
+        c->flag = 1;
+        nRight++;
+        nCount[1] += c->count;
+    }
+    if (!nRight) {
+        for (c = t[axis], splitColourVal = t[axis]->p.a.v[axis]; c; c = c->prev[axis]) {
+            if (splitColourVal != c->p.a.v[axis]) {
+                break;
+            }
+            c->flag = 1;
+            nRight++;
+            nLeft--;
+            nCount[0] -= c->count;
+            nCount[1] += c->count;
+        }
+    }
+#ifndef NO_OUTPUT
+    if (!nLeft) {
+        for (c = h[axis]; c; c = c->next[axis]) {
+            printf("[%d %d %d]\n", c->p.c.r, c->p.c.g, c->p.c.b);
+        }
+        printf("warning... trivial split\n");
+    }
+#endif
+
+    for (i = 0; i < 3; i++) {
+        l = r = NULL;
+        nh[0][i] = nt[0][i] = NULL;
+        nh[1][i] = nt[1][i] = NULL;
+        for (c = h[i]; c; c = n) {
+            n = c->next[i];
+            if (c->flag) { /* move pixel to right  list*/
+                if (r) {
+                    r->next[i] = c;
+                } else {
+                    nh[1][i] = c;
+                }
+                c->prev[i] = r;
+                r = c;
+            } else { /* move pixel to left list */
+                if (l) {
+                    l->next[i] = c;
+                } else {
+                    nh[0][i] = c;
+                }
+                c->prev[i] = l;
+                l = c;
+            }
+        }
+        if (l) {
+            l->next[i] = NULL;
+        }
+        if (r) {
+            r->next[i] = NULL;
+        }
+        nt[0][i] = l;
+        nt[1][i] = r;
+    }
+    return 1;
+}
+
+static int
+split(BoxNode *node) {
+    unsigned char rl, rh, gl, gh, bl, bh;
+    int f[3];
+    int best, axis;
+    int i;
+    PixelList *heads[2][3];
+    PixelList *tails[2][3];
+    uint32_t newCounts[2];
+    BoxNode *left, *right;
+
+    rh = node->head[0]->p.c.r;
+    rl = node->tail[0]->p.c.r;
+    gh = node->head[1]->p.c.g;
+    gl = node->tail[1]->p.c.g;
+    bh = node->head[2]->p.c.b;
+    bl = node->tail[2]->p.c.b;
 #ifdef TEST_SPLIT
-   printf ("splitting node [%d %d %d] [%d %d %d] ",rl,gl,bl,rh,gh,bh);
-#endif
-   f[0]=(rh-rl)*77;
-   f[1]=(gh-gl)*150;
-   f[2]=(bh-bl)*29;
-
-   best=f[0];
-   axis=0;
-   for (i=1;i<3;i++) {
-      if (best<f[i]) { best=f[i]; axis=i; }
-   }
+    printf("splitting node [%d %d %d] [%d %d %d] ", rl, gl, bl, rh, gh, bh);
+#endif
+    f[0] = (rh - rl) * 77;
+    f[1] = (gh - gl) * 150;
+    f[2] = (bh - bl) * 29;
+
+    best = f[0];
+    axis = 0;
+    for (i = 1; i < 3; i++) {
+        if (best < f[i]) {
+            best = f[i];
+            axis = i;
+        }
+    }
 #ifdef TEST_SPLIT
-   printf ("along axis %d\n",axis+1);
+    printf("along axis %d\n", axis + 1);
 #endif

 #ifdef TEST_SPLIT
-   {
-      PixelList *_prevTest,*_nextTest;
-      int _i,_nextCount[3],_prevCount[3];
-      for (_i=0;_i<3;_i++) {
-         if (node->tail[_i]->next[_i]) {
-            printf ("tail is not tail\n");
-            printf ("node->tail[%d]->next[%d]=%p\n",_i,_i,node->tail[_i]->next[_i]);
-         }
-         if (node->head[_i]->prev[_i]) {
-            printf ("head is not head\n");
-            printf ("node->head[%d]->prev[%d]=%p\n",_i,_i,node->head[_i]->prev[_i]);
-         }
-      }
-
-      for (_i=0;_i<3;_i++) {
-         for (_nextCount[_i]=0,_nextTest=node->head[_i];_nextTest&&_nextTest->next[_i];_nextTest=_nextTest->next[_i],_nextCount[_i]++);
-         for (_prevCount[_i]=0,_prevTest=node->tail[_i];_prevTest&&_prevTest->prev[_i];_prevTest=_prevTest->prev[_i],_prevCount[_i]++);
-         if (_nextTest!=node->tail[_i]) {
-            printf ("next-list of axis %d does not end at tail\n",_i);
-         }
-         if (_prevTest!=node->head[_i]) {
-            printf ("prev-list of axis %d does not end at head\n",_i);
-         }
-         for (;_nextTest&&_nextTest->prev[_i];_nextTest=_nextTest->prev[_i]);
-         for (;_prevTest&&_prevTest->next[_i];_prevTest=_prevTest->next[_i]);
-         if (_nextTest!=node->head[_i]) {
-            printf ("next-list of axis %d does not loop back to head\n",_i);
-         }
-         if (_prevTest!=node->tail[_i]) {
-            printf ("prev-list of axis %d does not loop back to tail\n",_i);
-         }
-      }
-      for (_i=1;_i<3;_i++) {
-         if (_prevCount[_i]!=_prevCount[_i-1] ||
-             _nextCount[_i]!=_nextCount[_i-1] ||
-             _prevCount[_i]!=_nextCount[_i]) {
-            printf ("{%d %d %d} {%d %d %d}\n",
+    {
+        PixelList *_prevTest, *_nextTest;
+        int _i, _nextCount[3], _prevCount[3];
+        for (_i = 0; _i < 3; _i++) {
+            if (node->tail[_i]->next[_i]) {
+                printf("tail is not tail\n");
+                printf(
+                    "node->tail[%d]->next[%d]=%p\n", _i, _i, node->tail[_i]->next[_i]);
+            }
+            if (node->head[_i]->prev[_i]) {
+                printf("head is not head\n");
+                printf(
+                    "node->head[%d]->prev[%d]=%p\n", _i, _i, node->head[_i]->prev[_i]);
+            }
+        }
+
+        for (_i = 0; _i < 3; _i++) {
+            for (_nextCount[_i] = 0, _nextTest = node->head[_i];
+                 _nextTest && _nextTest->next[_i];
+                 _nextTest = _nextTest->next[_i], _nextCount[_i]++)
+                ;
+            for (_prevCount[_i] = 0, _prevTest = node->tail[_i];
+                 _prevTest && _prevTest->prev[_i];
+                 _prevTest = _prevTest->prev[_i], _prevCount[_i]++)
+                ;
+            if (_nextTest != node->tail[_i]) {
+                printf("next-list of axis %d does not end at tail\n", _i);
+            }
+            if (_prevTest != node->head[_i]) {
+                printf("prev-list of axis %d does not end at head\n", _i);
+            }
+            for (; _nextTest && _nextTest->prev[_i]; _nextTest = _nextTest->prev[_i])
+                ;
+            for (; _prevTest && _prevTest->next[_i]; _prevTest = _prevTest->next[_i])
+                ;
+            if (_nextTest != node->head[_i]) {
+                printf("next-list of axis %d does not loop back to head\n", _i);
+            }
+            if (_prevTest != node->tail[_i]) {
+                printf("prev-list of axis %d does not loop back to tail\n", _i);
+            }
+        }
+        for (_i = 1; _i < 3; _i++) {
+            if (_prevCount[_i] != _prevCount[_i - 1] ||
+                _nextCount[_i] != _nextCount[_i - 1] ||
+                _prevCount[_i] != _nextCount[_i]) {
+                printf(
+                    "{%d %d %d} {%d %d %d}\n",
                     _prevCount[0],
                     _prevCount[1],
                     _prevCount[2],
                     _nextCount[0],
                     _nextCount[1],
                     _nextCount[2]);
-         }
-      }
-    }
-#endif
-   node->axis=axis;
-   if (!splitlists(node->head,
-                   node->tail,
-                   heads,
-                   tails,
-                   newCounts,
-                   axis,
-                   node->pixelCount)) {
-#ifndef NO_OUTPUT
-      printf ("list split failed.\n");
-#endif
-      return 0;
-   }
+            }
+        }
+    }
+#endif
+    node->axis = axis;
+    if (!splitlists(
+            node->head, node->tail, heads, tails, newCounts, axis, node->pixelCount)) {
+#ifndef NO_OUTPUT
+        printf("list split failed.\n");
+#endif
+        return 0;
+    }
 #ifdef TEST_SPLIT
-   if (!test_sorted(heads[0])) {
-      printf ("bug in split");
-      exit(1);
-   }
-   if (!test_sorted(heads[1])) {
-      printf ("bug in split");
-      exit(1);
-   }
-#endif
-   /* malloc check ok, small constant allocation */
-   left=malloc(sizeof(BoxNode));
-   right=malloc(sizeof(BoxNode));
-   if (!left||!right) {
-      free(left);
-      free(right);
-      return 0;
-   }
-   for(i=0;i<3;i++) {
-      left->head[i]=heads[0][i];
-      left->tail[i]=tails[0][i];
-      right->head[i]=heads[1][i];
-      right->tail[i]=tails[1][i];
-      node->head[i]=NULL;
-      node->tail[i]=NULL;
-   }
+    if (!test_sorted(heads[0])) {
+        printf("bug in split");
+        exit(1);
+    }
+    if (!test_sorted(heads[1])) {
+        printf("bug in split");
+        exit(1);
+    }
+#endif
+    /* malloc check ok, small constant allocation */
+    left = malloc(sizeof(BoxNode));
+    right = malloc(sizeof(BoxNode));
+    if (!left || !right) {
+        free(left);
+        free(right);
+        return 0;
+    }
+    for (i = 0; i < 3; i++) {
+        left->head[i] = heads[0][i];
+        left->tail[i] = tails[0][i];
+        right->head[i] = heads[1][i];
+        right->tail[i] = tails[1][i];
+        node->head[i] = NULL;
+        node->tail[i] = NULL;
+    }
 #ifdef TEST_SPLIT
-   if (left->head[0]) {
-      rh=left->head[0]->p.c.r;
-      rl=left->tail[0]->p.c.r;
-      gh=left->head[1]->p.c.g;
-      gl=left->tail[1]->p.c.g;
-      bh=left->head[2]->p.c.b;
-      bl=left->tail[2]->p.c.b;
-      printf ("   left node  [%3d %3d %3d] [%3d %3d %3d]\n",rl,gl,bl,rh,gh,bh);
-   }
-   if (right->head[0]) {
-      rh=right->head[0]->p.c.r;
-      rl=right->tail[0]->p.c.r;
-      gh=right->head[1]->p.c.g;
-      gl=right->tail[1]->p.c.g;
-      bh=right->head[2]->p.c.b;
-      bl=right->tail[2]->p.c.b;
-      printf ("   right node [%3d %3d %3d] [%3d %3d %3d]\n",rl,gl,bl,rh,gh,bh);
-   }
-#endif
-   left->l=left->r=NULL;
-   right->l=right->r=NULL;
-   left->axis=right->axis=-1;
-   left->volume=right->volume=-1;
-   left->pixelCount=newCounts[0];
-   right->pixelCount=newCounts[1];
-   node->l=left;
-   node->r=right;
-   return 1;
+    if (left->head[0]) {
+        rh = left->head[0]->p.c.r;
+        rl = left->tail[0]->p.c.r;
+        gh = left->head[1]->p.c.g;
+        gl = left->tail[1]->p.c.g;
+        bh = left->head[2]->p.c.b;
+        bl = left->tail[2]->p.c.b;
+        printf("   left node  [%3d %3d %3d] [%3d %3d %3d]\n", rl, gl, bl, rh, gh, bh);
+    }
+    if (right->head[0]) {
+        rh = right->head[0]->p.c.r;
+        rl = right->tail[0]->p.c.r;
+        gh = right->head[1]->p.c.g;
+        gl = right->tail[1]->p.c.g;
+        bh = right->head[2]->p.c.b;
+        bl = right->tail[2]->p.c.b;
+        printf("   right node [%3d %3d %3d] [%3d %3d %3d]\n", rl, gl, bl, rh, gh, bh);
+    }
+#endif
+    left->l = left->r = NULL;
+    right->l = right->r = NULL;
+    left->axis = right->axis = -1;
+    left->volume = right->volume = -1;
+    left->pixelCount = newCounts[0];
+    right->pixelCount = newCounts[1];
+    node->l = left;
+    node->r = right;
+    return 1;
 }

 static BoxNode *
-median_cut(PixelList *hl[3],
-           uint32_t imPixelCount,
-           int nPixels)
-{
-   PixelList *tl[3];
-   int i;
-   BoxNode *root;
-   Heap* h;
-   BoxNode *thisNode;
-
-   h=ImagingQuantHeapNew(box_heap_cmp);
-   /* malloc check ok, small constant allocation */
-   root=malloc(sizeof(BoxNode));
-   if (!root) { ImagingQuantHeapFree(h); return NULL; }
-   for(i=0;i<3;i++) {
-      for (tl[i]=hl[i];tl[i]&&tl[i]->next[i];tl[i]=tl[i]->next[i]);
-      root->head[i]=hl[i];
-      root->tail[i]=tl[i];
-   }
-   root->l=root->r=NULL;
-   root->axis=-1;
-   root->volume=-1;
-   root->pixelCount=imPixelCount;
-
-   ImagingQuantHeapAdd(h,(void *)root);
-   while (--nPixels) {
-      do {
-         if (!ImagingQuantHeapRemove(h,(void **)&thisNode)) {
-            goto done;
-         }
-      } while (compute_box_volume(thisNode)==1);
-      if (!split(thisNode)) {
-#ifndef NO_OUTPUT
-         printf ("Oops, split failed...\n");
-#endif
-         exit (1);
-      }
-      ImagingQuantHeapAdd(h,(void *)(thisNode->l));
-      ImagingQuantHeapAdd(h,(void *)(thisNode->r));
-   }
+median_cut(PixelList *hl[3], uint32_t imPixelCount, int nPixels) {
+    PixelList *tl[3];
+    int i;
+    BoxNode *root;
+    Heap *h;
+    BoxNode *thisNode;
+
+    h = ImagingQuantHeapNew(box_heap_cmp);
+    /* malloc check ok, small constant allocation */
+    root = malloc(sizeof(BoxNode));
+    if (!root) {
+        ImagingQuantHeapFree(h);
+        return NULL;
+    }
+    for (i = 0; i < 3; i++) {
+        for (tl[i] = hl[i]; tl[i] && tl[i]->next[i]; tl[i] = tl[i]->next[i])
+            ;
+        root->head[i] = hl[i];
+        root->tail[i] = tl[i];
+    }
+    root->l = root->r = NULL;
+    root->axis = -1;
+    root->volume = -1;
+    root->pixelCount = imPixelCount;
+
+    ImagingQuantHeapAdd(h, (void *)root);
+    while (--nPixels) {
+        do {
+            if (!ImagingQuantHeapRemove(h, (void **)&thisNode)) {
+                goto done;
+            }
+        } while (compute_box_volume(thisNode) == 1);
+        if (!split(thisNode)) {
+#ifndef NO_OUTPUT
+            printf("Oops, split failed...\n");
+#endif
+            exit(1);
+        }
+        ImagingQuantHeapAdd(h, (void *)(thisNode->l));
+        ImagingQuantHeapAdd(h, (void *)(thisNode->r));
+    }
 done:
-   ImagingQuantHeapFree(h);
-   return root;
+    ImagingQuantHeapFree(h);
+    return root;
 }

 static void
-free_box_tree(BoxNode *n)
-{
-   PixelList *p,*pp;
-   if (n->l) {
-      free_box_tree(n->l);
-   }
-   if (n->r) {
-      free_box_tree(n->r);
-   }
-   for (p=n->head[0];p;p=pp) {
-      pp=p->next[0];
-      free(p);
-   }
-   free(n);
+free_box_tree(BoxNode *n) {
+    PixelList *p, *pp;
+    if (n->l) {
+        free_box_tree(n->l);
+    }
+    if (n->r) {
+        free_box_tree(n->r);
+    }
+    for (p = n->head[0]; p; p = pp) {
+        pp = p->next[0];
+        free(p);
+    }
+    free(n);
 }

 #ifdef TEST_SPLIT_INTEGRITY
 static int
-checkContained(BoxNode *n,Pixel *pp)
-{
-   if (n->l&&n->r) {
-      return checkContained(n->l,pp)+checkContained(n->r,pp);
-   }
-   if (n->l||n->r) {
-#ifndef NO_OUTPUT
-      printf ("box tree is dead\n");
-#endif
-      return 0;
-   }
-   if (
-       pp->c.r<=n->head[0]->p.c.r &&
-       pp->c.r>=n->tail[0]->p.c.r &&
-       pp->c.g<=n->head[1]->p.c.g &&
-       pp->c.g>=n->tail[1]->p.c.g &&
-       pp->c.b<=n->head[2]->p.c.b &&
-       pp->c.b>=n->tail[2]->p.c.b) {
-      return 1;
-   }
-   return 0;
-}
-#endif
-
-static int
-annotate_hash_table(BoxNode *n,HashTable *h,uint32_t *box)
-{
-   PixelList *p;
-   PixelHashData *d=(PixelHashData *)hashtable_get_user_data(h);
-   Pixel q;
-   if (n->l&&n->r) {
-      return annotate_hash_table(n->l,h,box) && annotate_hash_table(n->r,h,box);
-   }
-   if (n->l||n->r) {
-#ifndef NO_OUTPUT
-      printf ("box tree is dead\n");
-#endif
-      return 0;
-   }
-   for (p=n->head[0];p;p=p->next[0]) {
-      PIXEL_UNSCALE(&(p->p),&q,d->scale);
-      if (!hashtable_insert(h,q,*box)) {
-#ifndef NO_OUTPUT
-         printf ("hashtable insert failed\n");
-#endif
-         return 0;
-      }
-   }
-   if (n->head[0]) {
-      (*box)++;
-   }
-   return 1;
-}
-
-static int
-_sort_ulong_ptr_keys(const void *a, const void *b)
-{
-   uint32_t A=**(uint32_t **)a;
-   uint32_t B=**(uint32_t **)b;
-   return (A==B)?0:((A<B)?-1:+1);
-}
-
-static int
-resort_distance_tables(uint32_t *avgDist,
-                       uint32_t **avgDistSortKey,
-                       Pixel *p,
-                       uint32_t nEntries)
-{
-   uint32_t i,j,k;
-   uint32_t **skRow;
-   uint32_t *skElt;
-
-   for (i=0;i<nEntries;i++) {
-      avgDist[i*nEntries+i]=0;
-      for (j=0;j<i;j++) {
-         avgDist[j*nEntries+i]=
-         avgDist[i*nEntries+j]=_DISTSQR(p+i,p+j);
-      }
-   }
-   for (i=0;i<nEntries;i++) {
-      skRow=avgDistSortKey+i*nEntries;
-      for (j=1;j<nEntries;j++) {
-         skElt=skRow[j];
-         for (k=j;k&&(*(skRow[k-1])>*(skRow[k]));k--) {
-            skRow[k]=skRow[k-1];
-         }
-         if (k!=j) {
-            skRow[k]=skElt;
-         }
-      }
-   }
-   return 1;
-}
-
-static int
-build_distance_tables(uint32_t *avgDist,
-                      uint32_t **avgDistSortKey,
-                      Pixel *p,
-                      uint32_t nEntries)
-{
-   uint32_t i,j;
-
-   for (i=0;i<nEntries;i++) {
-      avgDist[i*nEntries+i]=0;
-      avgDistSortKey[i*nEntries+i]=&(avgDist[i*nEntries+i]);
-      for (j=0;j<i;j++) {
-         avgDist[j*nEntries+i]=
-         avgDist[i*nEntries+j]=_DISTSQR(p+i,p+j);
-         avgDistSortKey[j*nEntries+i]=&(avgDist[j*nEntries+i]);
-         avgDistSortKey[i*nEntries+j]=&(avgDist[i*nEntries+j]);
-      }
-   }
-   for (i=0;i<nEntries;i++) {
-      qsort(avgDistSortKey+i*nEntries,
+checkContained(BoxNode *n, Pixel *pp) {
+    if (n->l && n->r) {
+        return checkContained(n->l, pp) + checkContained(n->r, pp);
+    }
+    if (n->l || n->r) {
+#ifndef NO_OUTPUT
+        printf("box tree is dead\n");
+#endif
+        return 0;
+    }
+    if (pp->c.r <= n->head[0]->p.c.r && pp->c.r >= n->tail[0]->p.c.r &&
+        pp->c.g <= n->head[1]->p.c.g && pp->c.g >= n->tail[1]->p.c.g &&
+        pp->c.b <= n->head[2]->p.c.b && pp->c.b >= n->tail[2]->p.c.b) {
+        return 1;
+    }
+    return 0;
+}
+#endif
+
+static int
+annotate_hash_table(BoxNode *n, HashTable *h, uint32_t *box) {
+    PixelList *p;
+    PixelHashData *d = (PixelHashData *)hashtable_get_user_data(h);
+    Pixel q;
+    if (n->l && n->r) {
+        return annotate_hash_table(n->l, h, box) && annotate_hash_table(n->r, h, box);
+    }
+    if (n->l || n->r) {
+#ifndef NO_OUTPUT
+        printf("box tree is dead\n");
+#endif
+        return 0;
+    }
+    for (p = n->head[0]; p; p = p->next[0]) {
+        PIXEL_UNSCALE(&(p->p), &q, d->scale);
+        if (!hashtable_insert(h, q, *box)) {
+#ifndef NO_OUTPUT
+            printf("hashtable insert failed\n");
+#endif
+            return 0;
+        }
+    }
+    if (n->head[0]) {
+        (*box)++;
+    }
+    return 1;
+}
+
+typedef struct {
+    uint32_t *distance;
+    uint32_t index;
+} DistanceWithIndex;
+
+static int
+_distance_index_cmp(const void *a, const void *b) {
+    DistanceWithIndex *A = (DistanceWithIndex *)a;
+    DistanceWithIndex *B = (DistanceWithIndex *)b;
+    if (*A->distance == *B->distance) {
+        return A->index < B->index ? -1 : +1;
+    }
+    return *A->distance < *B->distance ? -1 : +1;
+}
+
+static int
+resort_distance_tables(
+    uint32_t *avgDist, uint32_t **avgDistSortKey, Pixel *p, uint32_t nEntries) {
+    uint32_t i, j, k;
+    uint32_t **skRow;
+    uint32_t *skElt;
+
+    for (i = 0; i < nEntries; i++) {
+        avgDist[i * nEntries + i] = 0;
+        for (j = 0; j < i; j++) {
+            avgDist[j * nEntries + i] = avgDist[i * nEntries + j] =
+                _DISTSQR(p + i, p + j);
+        }
+    }
+    for (i = 0; i < nEntries; i++) {
+        skRow = avgDistSortKey + i * nEntries;
+        for (j = 1; j < nEntries; j++) {
+            skElt = skRow[j];
+            for (k = j; k && (*(skRow[k - 1]) > *(skRow[k])); k--) {
+                skRow[k] = skRow[k - 1];
+            }
+            if (k != j) {
+                skRow[k] = skElt;
+            }
+        }
+    }
+    return 1;
+}
+
+static int
+build_distance_tables(
+    uint32_t *avgDist, uint32_t **avgDistSortKey, Pixel *p, uint32_t nEntries) {
+    uint32_t i, j;
+    DistanceWithIndex *dwi;
+
+    for (i = 0; i < nEntries; i++) {
+        avgDist[i * nEntries + i] = 0;
+        avgDistSortKey[i * nEntries + i] = &(avgDist[i * nEntries + i]);
+        for (j = 0; j < i; j++) {
+            avgDist[j * nEntries + i] = avgDist[i * nEntries + j] =
+                _DISTSQR(p + i, p + j);
+            avgDistSortKey[j * nEntries + i] = &(avgDist[j * nEntries + i]);
+            avgDistSortKey[i * nEntries + j] = &(avgDist[i * nEntries + j]);
+        }
+    }
+
+    dwi = calloc(nEntries, sizeof(DistanceWithIndex));
+    if (!dwi) {
+        return 0;
+    }
+    for (i = 0; i < nEntries; i++) {
+        for (j = 0; j < nEntries; j++) {
+            dwi[j] = (DistanceWithIndex){
+                &(avgDist[i * nEntries + j]),
+                j
+            };
+        }
+        qsort(
+            dwi,
             nEntries,
-            sizeof(uint32_t *),
-            _sort_ulong_ptr_keys);
-   }
-   return 1;
-}
-
-static int
-map_image_pixels(Pixel *pixelData,
-                 uint32_t nPixels,
-                 Pixel *paletteData,
-                 uint32_t nPaletteEntries,
-                 uint32_t *avgDist,
-                 uint32_t **avgDistSortKey,
-                 uint32_t *pixelArray)
-{
-   uint32_t *aD,**aDSK;
-   uint32_t idx;
-   uint32_t i,j;
-   uint32_t bestdist,bestmatch,dist;
-   uint32_t initialdist;
-   HashTable *h2;
-
-   h2=hashtable_new(unshifted_pixel_hash,unshifted_pixel_cmp);
-   for (i=0;i<nPixels;i++) {
-      if (!hashtable_lookup(h2,pixelData[i],&bestmatch)) {
-         bestmatch=0;
-         initialdist=_DISTSQR(paletteData+bestmatch,pixelData+i);
-         bestdist=initialdist;
-         initialdist<<=2;
-         aDSK=avgDistSortKey+bestmatch*nPaletteEntries;
-         aD=avgDist+bestmatch*nPaletteEntries;
-         for (j=0;j<nPaletteEntries;j++) {
-            idx=aDSK[j]-aD;
-            if (*(aDSK[j])<=initialdist)  {
-               dist=_DISTSQR(paletteData+idx,pixelData+i);
-               if (dist<bestdist) {
-                  bestdist=dist;
-                  bestmatch=idx;
-               }
-            } else {
-               break;
-            }
-         }
-         hashtable_insert(h2,pixelData[i],bestmatch);
-      }
-      pixelArray[i]=bestmatch;
-   }
-   hashtable_free(h2);
-   return 1;
+            sizeof(DistanceWithIndex),
+            _distance_index_cmp);
+        for (j = 0; j < nEntries; j++) {
+            avgDistSortKey[i * nEntries + j] = dwi[j].distance;
+        }
+    }
+    free(dwi);
+    return 1;
+}
+
+static int
+map_image_pixels(
+    Pixel *pixelData,
+    uint32_t nPixels,
+    Pixel *paletteData,
+    uint32_t nPaletteEntries,
+    uint32_t *avgDist,
+    uint32_t **avgDistSortKey,
+    uint32_t *pixelArray) {
+    uint32_t *aD, **aDSK;
+    uint32_t idx;
+    uint32_t i, j;
+    uint32_t bestdist, bestmatch, dist;
+    uint32_t initialdist;
+    HashTable *h2;
+
+    h2 = hashtable_new(unshifted_pixel_hash, unshifted_pixel_cmp);
+    for (i = 0; i < nPixels; i++) {
+        if (!hashtable_lookup(h2, pixelData[i], &bestmatch)) {
+            bestmatch = 0;
+            initialdist = _DISTSQR(paletteData + bestmatch, pixelData + i);
+            bestdist = initialdist;
+            initialdist <<= 2;
+            aDSK = avgDistSortKey + bestmatch * nPaletteEntries;
+            aD = avgDist + bestmatch * nPaletteEntries;
+            for (j = 0; j < nPaletteEntries; j++) {
+                idx = aDSK[j] - aD;
+                if (*(aDSK[j]) <= initialdist) {
+                    dist = _DISTSQR(paletteData + idx, pixelData + i);
+                    if (dist < bestdist) {
+                        bestdist = dist;
+                        bestmatch = idx;
+                    }
+                } else {
+                    break;
+                }
+            }
+            hashtable_insert(h2, pixelData[i], bestmatch);
+        }
+        pixelArray[i] = bestmatch;
+    }
+    hashtable_free(h2);
+    return 1;
 }

 static int
@@ -880,54 +893,53 @@
     uint32_t **avgDistSortKey,
     uint32_t *pixelArray,
     uint32_t *avg[3],
-    uint32_t *count)
-{
-   uint32_t *aD,**aDSK;
-   uint32_t idx;
-   uint32_t i,j;
-   uint32_t bestdist,bestmatch,dist;
-   uint32_t initialdist;
-   HashTable *h2;
-   int changes=0;
-
-   h2=hashtable_new(unshifted_pixel_hash,unshifted_pixel_cmp);
-   for (i=0;i<nPixels;i++) {
-      if (!hashtable_lookup(h2,pixelData[i],&bestmatch)) {
-         bestmatch=pixelArray[i];
-         initialdist=_DISTSQR(paletteData+bestmatch,pixelData+i);
-         bestdist=initialdist;
-         initialdist<<=2;
-         aDSK=avgDistSortKey+bestmatch*nPaletteEntries;
-         aD=avgDist+bestmatch*nPaletteEntries;
-         for (j=0;j<nPaletteEntries;j++) {
-            idx=aDSK[j]-aD;
-            if (*(aDSK[j])<=initialdist)  {
-               dist=_DISTSQR(paletteData+idx,pixelData+i);
-               if (dist<bestdist) {
-                  bestdist=dist;
-                  bestmatch=idx;
-               }
-            } else {
-               break;
-            }
-         }
-         hashtable_insert(h2,pixelData[i],bestmatch);
-      }
-      if (pixelArray[i]!=bestmatch) {
-         changes++;
-         avg[0][bestmatch]+=pixelData[i].c.r;
-         avg[1][bestmatch]+=pixelData[i].c.g;
-         avg[2][bestmatch]+=pixelData[i].c.b;
-         avg[0][pixelArray[i]]-=pixelData[i].c.r;
-         avg[1][pixelArray[i]]-=pixelData[i].c.g;
-         avg[2][pixelArray[i]]-=pixelData[i].c.b;
-         count[bestmatch]++;
-         count[pixelArray[i]]--;
-         pixelArray[i]=bestmatch;
-      }
-   }
-   hashtable_free(h2);
-   return changes;
+    uint32_t *count) {
+    uint32_t *aD, **aDSK;
+    uint32_t idx;
+    uint32_t i, j;
+    uint32_t bestdist, bestmatch, dist;
+    uint32_t initialdist;
+    HashTable *h2;
+    int changes = 0;
+
+    h2 = hashtable_new(unshifted_pixel_hash, unshifted_pixel_cmp);
+    for (i = 0; i < nPixels; i++) {
+        if (!hashtable_lookup(h2, pixelData[i], &bestmatch)) {
+            bestmatch = pixelArray[i];
+            initialdist = _DISTSQR(paletteData + bestmatch, pixelData + i);
+            bestdist = initialdist;
+            initialdist <<= 2;
+            aDSK = avgDistSortKey + bestmatch * nPaletteEntries;
+            aD = avgDist + bestmatch * nPaletteEntries;
+            for (j = 0; j < nPaletteEntries; j++) {
+                idx = aDSK[j] - aD;
+                if (*(aDSK[j]) <= initialdist) {
+                    dist = _DISTSQR(paletteData + idx, pixelData + i);
+                    if (dist < bestdist) {
+                        bestdist = dist;
+                        bestmatch = idx;
+                    }
+                } else {
+                    break;
+                }
+            }
+            hashtable_insert(h2, pixelData[i], bestmatch);
+        }
+        if (pixelArray[i] != bestmatch) {
+            changes++;
+            avg[0][bestmatch] += pixelData[i].c.r;
+            avg[1][bestmatch] += pixelData[i].c.g;
+            avg[2][bestmatch] += pixelData[i].c.b;
+            avg[0][pixelArray[i]] -= pixelData[i].c.r;
+            avg[1][pixelArray[i]] -= pixelData[i].c.g;
+            avg[2][pixelArray[i]] -= pixelData[i].c.b;
+            count[bestmatch]++;
+            count[pixelArray[i]]--;
+            pixelArray[i] = bestmatch;
+        }
+    }
+    hashtable_free(h2);
+    return changes;
 }

 static int
@@ -939,51 +951,50 @@
     HashTable *medianBoxHash,
     uint32_t *avgDist,
     uint32_t **avgDistSortKey,
-    uint32_t *pixelArray)
-{
-   uint32_t *aD,**aDSK;
-   uint32_t idx;
-   uint32_t i,j;
-   uint32_t bestdist,bestmatch,dist;
-   uint32_t initialdist;
-   HashTable *h2;
-   uint32_t pixelVal;
-
-   h2=hashtable_new(unshifted_pixel_hash,unshifted_pixel_cmp);
-   for (i=0;i<nPixels;i++) {
-      if (hashtable_lookup(h2,pixelData[i],&pixelVal)) {
-         pixelArray[i]=pixelVal;
-         continue;
-      }
-      if (!hashtable_lookup(medianBoxHash,pixelData[i],&pixelVal)) {
-#ifndef NO_OUTPUT
-         printf ("pixel lookup failed\n");
-#endif
-         return 0;
-      }
-      initialdist=_DISTSQR(paletteData+pixelVal,pixelData+i);
-      bestdist=initialdist;
-      bestmatch=pixelVal;
-      initialdist<<=2;
-      aDSK=avgDistSortKey+pixelVal*nPaletteEntries;
-      aD=avgDist+pixelVal*nPaletteEntries;
-      for (j=0;j<nPaletteEntries;j++) {
-         idx=aDSK[j]-aD;
-         if (*(aDSK[j])<=initialdist)  {
-            dist=_DISTSQR(paletteData+idx,pixelData+i);
-            if (dist<bestdist) {
-               bestdist=dist;
-               bestmatch=idx;
-            }
-         } else {
-            break;
-         }
-      }
-      pixelArray[i]=bestmatch;
-      hashtable_insert(h2,pixelData[i],bestmatch);
-   }
-   hashtable_free(h2);
-   return 1;
+    uint32_t *pixelArray) {
+    uint32_t *aD, **aDSK;
+    uint32_t idx;
+    uint32_t i, j;
+    uint32_t bestdist, bestmatch, dist;
+    uint32_t initialdist;
+    HashTable *h2;
+    uint32_t pixelVal;
+
+    h2 = hashtable_new(unshifted_pixel_hash, unshifted_pixel_cmp);
+    for (i = 0; i < nPixels; i++) {
+        if (hashtable_lookup(h2, pixelData[i], &pixelVal)) {
+            pixelArray[i] = pixelVal;
+            continue;
+        }
+        if (!hashtable_lookup(medianBoxHash, pixelData[i], &pixelVal)) {
+#ifndef NO_OUTPUT
+            printf("pixel lookup failed\n");
+#endif
+            return 0;
+        }
+        initialdist = _DISTSQR(paletteData + pixelVal, pixelData + i);
+        bestdist = initialdist;
+        bestmatch = pixelVal;
+        initialdist <<= 2;
+        aDSK = avgDistSortKey + pixelVal * nPaletteEntries;
+        aD = avgDist + pixelVal * nPaletteEntries;
+        for (j = 0; j < nPaletteEntries; j++) {
+            idx = aDSK[j] - aD;
+            if (*(aDSK[j]) <= initialdist) {
+                dist = _DISTSQR(paletteData + idx, pixelData + i);
+                if (dist < bestdist) {
+                    bestdist = dist;
+                    bestmatch = idx;
+                }
+            } else {
+                break;
+            }
+        }
+        pixelArray[i] = bestmatch;
+        hashtable_insert(h2, pixelData[i], bestmatch);
+    }
+    hashtable_free(h2);
+    return 1;
 }

 static int
@@ -992,106 +1003,107 @@
     uint32_t nPixels,
     HashTable *medianBoxHash,
     Pixel **palette,
-    uint32_t nPaletteEntries)
-{
-   uint32_t i;
-   uint32_t paletteEntry;
-   Pixel *p;
-   uint32_t *avg[3];
-   uint32_t *count;
-
-   *palette=NULL;
-   /* malloc check ok, using calloc */
-   if (!(count=calloc(nPaletteEntries, sizeof(uint32_t)))) {
-      return 0;
-   }
-   for(i=0;i<3;i++) {
-      avg[i]=NULL;
-   }
-   for(i=0;i<3;i++) {
-      /* malloc check ok, using calloc */
-      if (!(avg[i]=calloc(nPaletteEntries, sizeof(uint32_t)))) {
-         for(i=0;i<3;i++) {
-            if (avg[i]) {
-               free (avg[i]);
-            }
-         }
-         free(count);
-         return 0;
-      }
-   }
-   for (i=0;i<nPixels;i++) {
+    uint32_t nPaletteEntries) {
+    uint32_t i;
+    uint32_t paletteEntry;
+    Pixel *p;
+    uint32_t *avg[3];
+    uint32_t *count;
+
+    *palette = NULL;
+    /* malloc check ok, using calloc */
+    if (!(count = calloc(nPaletteEntries, sizeof(uint32_t)))) {
+        return 0;
+    }
+    for (i = 0; i < 3; i++) {
+        avg[i] = NULL;
+    }
+    for (i = 0; i < 3; i++) {
+        /* malloc check ok, using calloc */
+        if (!(avg[i] = calloc(nPaletteEntries, sizeof(uint32_t)))) {
+            for (i = 0; i < 3; i++) {
+                if (avg[i]) {
+                    free(avg[i]);
+                }
+            }
+            free(count);
+            return 0;
+        }
+    }
+    for (i = 0; i < nPixels; i++) {
 #ifdef TEST_SPLIT_INTEGRITY
-      if (!(i%100)) { printf ("%05d\r",i); fflush(stdout); }
-      if (checkContained(root,pixelData+i)>1) {
-         printf ("pixel in two boxes\n");
-         for(i=0;i<3;i++) {
-            free (avg[i]);
-         }
-         free(count);
-         return 0;
-      }
-#endif
-      if (!hashtable_lookup(medianBoxHash,pixelData[i],&paletteEntry)) {
-#ifndef NO_OUTPUT
-         printf ("pixel lookup failed\n");
-#endif
-         for(i=0;i<3;i++) {
-            free (avg[i]);
-         }
-         free(count);
-         return 0;
-      }
-      if (paletteEntry>=nPaletteEntries) {
-#ifndef NO_OUTPUT
-         printf ("panic - paletteEntry>=nPaletteEntries (%d>=%d)\n",(int)paletteEntry,(int)nPaletteEntries);
-#endif
-         for(i=0;i<3;i++) {
-            free (avg[i]);
-         }
-         free(count);
-         return 0;
-      }
-      avg[0][paletteEntry]+=pixelData[i].c.r;
-      avg[1][paletteEntry]+=pixelData[i].c.g;
-      avg[2][paletteEntry]+=pixelData[i].c.b;
-      count[paletteEntry]++;
-   }
-   /* malloc check ok, using calloc */
-   p=calloc(nPaletteEntries, sizeof(Pixel));
-   if (!p) {
-      for(i=0;i<3;i++) {
-         free (avg[i]);
-      }
-      free(count);
-      return 0;
-   }
-   for (i=0;i<nPaletteEntries;i++) {
-      p[i].c.r=(int)(.5+(double)avg[0][i]/(double)count[i]);
-      p[i].c.g=(int)(.5+(double)avg[1][i]/(double)count[i]);
-      p[i].c.b=(int)(.5+(double)avg[2][i]/(double)count[i]);
-   }
-   *palette=p;
-   for(i=0;i<3;i++) {
-      free (avg[i]);
-   }
-   free(count);
-   return 1;
+        if (!(i % 100)) {
+            printf("%05d\r", i);
+            fflush(stdout);
+        }
+        if (checkContained(root, pixelData + i) > 1) {
+            printf("pixel in two boxes\n");
+            for (i = 0; i < 3; i++) {
+                free(avg[i]);
+            }
+            free(count);
+            return 0;
+        }
+#endif
+        if (!hashtable_lookup(medianBoxHash, pixelData[i], &paletteEntry)) {
+#ifndef NO_OUTPUT
+            printf("pixel lookup failed\n");
+#endif
+            for (i = 0; i < 3; i++) {
+                free(avg[i]);
+            }
+            free(count);
+            return 0;
+        }
+        if (paletteEntry >= nPaletteEntries) {
+#ifndef NO_OUTPUT
+            printf(
+                "panic - paletteEntry>=nPaletteEntries (%d>=%d)\n",
+                (int)paletteEntry,
+                (int)nPaletteEntries);
+#endif
+            for (i = 0; i < 3; i++) {
+                free(avg[i]);
+            }
+            free(count);
+            return 0;
+        }
+        avg[0][paletteEntry] += pixelData[i].c.r;
+        avg[1][paletteEntry] += pixelData[i].c.g;
+        avg[2][paletteEntry] += pixelData[i].c.b;
+        count[paletteEntry]++;
+    }
+    /* malloc check ok, using calloc */
+    p = calloc(nPaletteEntries, sizeof(Pixel));
+    if (!p) {
+        for (i = 0; i < 3; i++) {
+            free(avg[i]);
+        }
+        free(count);
+        return 0;
+    }
+    for (i = 0; i < nPaletteEntries; i++) {
+        p[i].c.r = (int)(.5 + (double)avg[0][i] / (double)count[i]);
+        p[i].c.g = (int)(.5 + (double)avg[1][i] / (double)count[i]);
+        p[i].c.b = (int)(.5 + (double)avg[2][i] / (double)count[i]);
+    }
+    *palette = p;
+    for (i = 0; i < 3; i++) {
+        free(avg[i]);
+    }
+    free(count);
+    return 1;
 }

 static int
 recompute_palette_from_averages(
-    Pixel *palette,
-    uint32_t nPaletteEntries,
-    uint32_t *avg[3],
-    uint32_t *count)
-{
+    Pixel *palette, uint32_t nPaletteEntries, uint32_t *avg[3], uint32_t *count) {
     uint32_t i;

-    for (i=0;i<nPaletteEntries;i++) {
-        palette[i].c.r=(int)(.5+(double)avg[0][i]/(double)count[i]);
-        palette[i].c.g=(int)(.5+(double)avg[1][i]/(double)count[i]);
-        palette[i].c.b=(int)(.5+(double)avg[2][i]/(double)count[i]);
+    for (i = 0; i < nPaletteEntries; i++) {
+        palette[i].c.r = (int)(.5 + (double)avg[0][i] / (double)count[i]);
+        palette[i].c.g = (int)(.5 + (double)avg[1][i] / (double)count[i]);
+        palette[i].c.b = (int)(.5 + (double)avg[2][i] / (double)count[i]);
     }
     return 1;
 }
@@ -1104,301 +1116,331 @@
     uint32_t nPaletteEntries,
     uint32_t *avg[3],
     uint32_t *count,
-    uint32_t *qp)
-{
-   uint32_t i;
-
-   memset(count,0,sizeof(uint32_t)*nPaletteEntries);
-   for(i=0;i<3;i++) {
-      memset(avg[i],0,sizeof(uint32_t)*nPaletteEntries);
-   }
-   for (i=0;i<nPixels;i++) {
-      if (qp[i]>=nPaletteEntries) {
-#ifndef NO_OUTPUT
-         printf ("scream\n");
-#endif
-         return 0;
-      }
-      avg[0][qp[i]]+=pixelData[i].c.r;
-      avg[1][qp[i]]+=pixelData[i].c.g;
-      avg[2][qp[i]]+=pixelData[i].c.b;
-      count[qp[i]]++;
-   }
-   for (i=0;i<nPaletteEntries;i++) {
-      palette[i].c.r=(int)(.5+(double)avg[0][i]/(double)count[i]);
-      palette[i].c.g=(int)(.5+(double)avg[1][i]/(double)count[i]);
-      palette[i].c.b=(int)(.5+(double)avg[2][i]/(double)count[i]);
-   }
-   return 1;
-}
-
-static int
-k_means(Pixel *pixelData,
-        uint32_t nPixels,
-        Pixel *paletteData,
-        uint32_t nPaletteEntries,
-        uint32_t *qp,
-        int threshold)
-{
-   uint32_t *avg[3];
-   uint32_t *count;
-   uint32_t i;
-   uint32_t *avgDist;
-   uint32_t **avgDistSortKey;
-   int changes;
-   int built=0;
-
-   if (nPaletteEntries > UINT32_MAX / (sizeof(uint32_t))) {
-       return 0;
-   }
-   /* malloc check ok, using calloc */
-   if (!(count=calloc(nPaletteEntries, sizeof(uint32_t)))) {
-      return 0;
-   }
-   for(i=0;i<3;i++) {
-      avg[i]=NULL;
-   }
-   for(i=0;i<3;i++) {
-      /* malloc check ok, using calloc */
-      if (!(avg[i]=calloc(nPaletteEntries, sizeof(uint32_t)))) {
-         goto error_1;
-      }
-   }
-
-   /* this is enough of a check, since the multiplication n*size is done above */
-   if (nPaletteEntries > UINT32_MAX / nPaletteEntries) {
-       goto error_1;
-   }
-   /* malloc check ok, using calloc, checking n*n above */
-   avgDist=calloc(nPaletteEntries*nPaletteEntries, sizeof(uint32_t));
-   if (!avgDist) { goto error_1; }
-
-   /* malloc check ok, using calloc, checking n*n above */
-   avgDistSortKey=calloc(nPaletteEntries*nPaletteEntries, sizeof(uint32_t *));
-   if (!avgDistSortKey) { goto error_2; }
-
-#ifndef NO_OUTPUT
-   printf("[");fflush(stdout);
-#endif
-   while (1) {
-      if (!built) {
-         compute_palette_from_quantized_pixels(pixelData,nPixels,paletteData,nPaletteEntries,avg,count,qp);
-         build_distance_tables(avgDist,avgDistSortKey,paletteData,nPaletteEntries);
-         built=1;
-      } else {
-         recompute_palette_from_averages(paletteData,nPaletteEntries,avg,count);
-         resort_distance_tables(avgDist,avgDistSortKey,paletteData,nPaletteEntries);
-      }
-      changes=map_image_pixels_from_quantized_pixels(pixelData,
-                                                     nPixels,
-                                                     paletteData,
-                                                     nPaletteEntries,
-                                                     avgDist,
-                                                     avgDistSortKey,
-                                                     qp,
-                                                     avg,
-                                                     count);
-      if (changes<0) {
-         goto error_3;
-      }
-#ifndef NO_OUTPUT
-      printf (".(%d)",changes);fflush(stdout);
-#endif
-      if (changes<=threshold) {
-         break;
-      }
-   }
-#ifndef NO_OUTPUT
-   printf("]\n");
-#endif
-   if (avgDistSortKey) {
-      free(avgDistSortKey);
-   }
-   if (avgDist) {
-      free(avgDist);
-   }
-   for(i=0;i<3;i++) {
-      if (avg[i]) {
-         free (avg[i]);
-      }
-   }
-   if (count) {
-      free(count);
-   }
-   return 1;
+    uint32_t *qp) {
+    uint32_t i;
+
+    memset(count, 0, sizeof(uint32_t) * nPaletteEntries);
+    for (i = 0; i < 3; i++) {
+        memset(avg[i], 0, sizeof(uint32_t) * nPaletteEntries);
+    }
+    for (i = 0; i < nPixels; i++) {
+        if (qp[i] >= nPaletteEntries) {
+#ifndef NO_OUTPUT
+            printf("scream\n");
+#endif
+            return 0;
+        }
+        avg[0][qp[i]] += pixelData[i].c.r;
+        avg[1][qp[i]] += pixelData[i].c.g;
+        avg[2][qp[i]] += pixelData[i].c.b;
+        count[qp[i]]++;
+    }
+    for (i = 0; i < nPaletteEntries; i++) {
+        palette[i].c.r = (int)(.5 + (double)avg[0][i] / (double)count[i]);
+        palette[i].c.g = (int)(.5 + (double)avg[1][i] / (double)count[i]);
+        palette[i].c.b = (int)(.5 + (double)avg[2][i] / (double)count[i]);
+    }
+    return 1;
+}
+
+static int
+k_means(
+    Pixel *pixelData,
+    uint32_t nPixels,
+    Pixel *paletteData,
+    uint32_t nPaletteEntries,
+    uint32_t *qp,
+    int threshold) {
+    uint32_t *avg[3];
+    uint32_t *count;
+    uint32_t i;
+    uint32_t *avgDist;
+    uint32_t **avgDistSortKey;
+    int changes;
+    int built = 0;
+
+    if (nPaletteEntries > UINT32_MAX / (sizeof(uint32_t))) {
+        return 0;
+    }
+    /* malloc check ok, using calloc */
+    if (!(count = calloc(nPaletteEntries, sizeof(uint32_t)))) {
+        return 0;
+    }
+    for (i = 0; i < 3; i++) {
+        avg[i] = NULL;
+    }
+    for (i = 0; i < 3; i++) {
+        /* malloc check ok, using calloc */
+        if (!(avg[i] = calloc(nPaletteEntries, sizeof(uint32_t)))) {
+            goto error_1;
+        }
+    }
+
+    /* this is enough of a check, since the multiplication n*size is done above */
+    if (nPaletteEntries > UINT32_MAX / nPaletteEntries) {
+        goto error_1;
+    }
+    /* malloc check ok, using calloc, checking n*n above */
+    avgDist = calloc(nPaletteEntries * nPaletteEntries, sizeof(uint32_t));
+    if (!avgDist) {
+        goto error_1;
+    }
+
+    /* malloc check ok, using calloc, checking n*n above */
+    avgDistSortKey = calloc(nPaletteEntries * nPaletteEntries, sizeof(uint32_t *));
+    if (!avgDistSortKey) {
+        goto error_2;
+    }
+
+#ifndef NO_OUTPUT
+    printf("[");
+    fflush(stdout);
+#endif
+    while (1) {
+        if (!built) {
+            compute_palette_from_quantized_pixels(
+                pixelData, nPixels, paletteData, nPaletteEntries, avg, count, qp);
+            if (!build_distance_tables(
+                avgDist, avgDistSortKey, paletteData, nPaletteEntries)) {
+                goto error_3;
+            }
+            built = 1;
+        } else {
+            recompute_palette_from_averages(paletteData, nPaletteEntries, avg, count);
+            resort_distance_tables(
+                avgDist, avgDistSortKey, paletteData, nPaletteEntries);
+        }
+        changes = map_image_pixels_from_quantized_pixels(
+            pixelData,
+            nPixels,
+            paletteData,
+            nPaletteEntries,
+            avgDist,
+            avgDistSortKey,
+            qp,
+            avg,
+            count);
+        if (changes < 0) {
+            goto error_3;
+        }
+#ifndef NO_OUTPUT
+        printf(".(%d)", changes);
+        fflush(stdout);
+#endif
+        if (changes <= threshold) {
+            break;
+        }
+    }
+#ifndef NO_OUTPUT
+    printf("]\n");
+#endif
+    if (avgDistSortKey) {
+        free(avgDistSortKey);
+    }
+    if (avgDist) {
+        free(avgDist);
+    }
+    for (i = 0; i < 3; i++) {
+        if (avg[i]) {
+            free(avg[i]);
+        }
+    }
+    if (count) {
+        free(count);
+    }
+    return 1;

 error_3:
-   if (avgDistSortKey) {
-      free(avgDistSortKey);
-   }
+    if (avgDistSortKey) {
+        free(avgDistSortKey);
+    }
 error_2:
-   if (avgDist) {
-      free(avgDist);
-   }
+    if (avgDist) {
+        free(avgDist);
+    }
 error_1:
-   for(i=0;i<3;i++) {
-      if (avg[i]) {
-         free (avg[i]);
-      }
-   }
-   if (count) {
-      free(count);
-   }
-   return 0;
-}
-
-int
-quantize(Pixel *pixelData,
-         uint32_t nPixels,
-         uint32_t nQuantPixels,
-         Pixel **palette,
-         uint32_t *paletteLength,
-         uint32_t **quantizedPixels,
-         int kmeans)
-{
-   PixelList *hl[3];
-   HashTable *h;
-   BoxNode *root;
-   uint32_t i;
-   uint32_t *qp;
-   uint32_t nPaletteEntries;
-
-   uint32_t *avgDist;
-   uint32_t **avgDistSortKey;
-   Pixel *p;
-
-#ifndef NO_OUTPUT
-   uint32_t timer,timer2;
-#endif
-
-#ifndef NO_OUTPUT
-   timer2=clock();
-   printf ("create hash table..."); fflush(stdout); timer=clock();
-#endif
-   h=create_pixel_hash(pixelData,nPixels);
-#ifndef NO_OUTPUT
-   printf ("done (%f)\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-#endif
-   if (!h) {
-      goto error_0;
-   }
-
-#ifndef NO_OUTPUT
-   printf ("create lists from hash table..."); fflush(stdout); timer=clock();
-#endif
-   hl[0]=hl[1]=hl[2]=NULL;
-   hashtable_foreach(h,hash_to_list,hl);
-#ifndef NO_OUTPUT
-   printf ("done (%f)\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-#endif
-
-   if (!hl[0]) {
-      goto error_1;
-   }
-
-#ifndef NO_OUTPUT
-   printf ("mergesort lists..."); fflush(stdout); timer=clock();
-#endif
-   for(i=0;i<3;i++) {
-      hl[i]=mergesort_pixels(hl[i],i);
-   }
+    for (i = 0; i < 3; i++) {
+        if (avg[i]) {
+            free(avg[i]);
+        }
+    }
+    if (count) {
+        free(count);
+    }
+    return 0;
+}
+
+static int
+quantize(
+    Pixel *pixelData,
+    uint32_t nPixels,
+    uint32_t nQuantPixels,
+    Pixel **palette,
+    uint32_t *paletteLength,
+    uint32_t **quantizedPixels,
+    int kmeans) {
+    PixelList *hl[3];
+    HashTable *h;
+    BoxNode *root;
+    uint32_t i;
+    uint32_t *qp;
+    uint32_t nPaletteEntries;
+
+    uint32_t *avgDist;
+    uint32_t **avgDistSortKey;
+    Pixel *p;
+
+#ifndef NO_OUTPUT
+    uint32_t timer, timer2;
+#endif
+
+#ifndef NO_OUTPUT
+    timer2 = clock();
+    printf("create hash table...");
+    fflush(stdout);
+    timer = clock();
+#endif
+    h = create_pixel_hash(pixelData, nPixels);
+#ifndef NO_OUTPUT
+    printf("done (%f)\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+#endif
+    if (!h) {
+        goto error_0;
+    }
+
+#ifndef NO_OUTPUT
+    printf("create lists from hash table...");
+    fflush(stdout);
+    timer = clock();
+#endif
+    hl[0] = hl[1] = hl[2] = NULL;
+    hashtable_foreach(h, hash_to_list, hl);
+#ifndef NO_OUTPUT
+    printf("done (%f)\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+#endif
+
+    if (!hl[0]) {
+        goto error_1;
+    }
+
+#ifndef NO_OUTPUT
+    printf("mergesort lists...");
+    fflush(stdout);
+    timer = clock();
+#endif
+    for (i = 0; i < 3; i++) {
+        hl[i] = mergesort_pixels(hl[i], i);
+    }
 #ifdef TEST_MERGESORT
-   if (!test_sorted(hl)) {
-      printf ("bug in mergesort\n");
-      goto error_1;
-   }
-#endif
-#ifndef NO_OUTPUT
-   printf ("done (%f)\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-#endif
-
-#ifndef NO_OUTPUT
-   printf ("median cut..."); fflush(stdout); timer=clock();
-#endif
-   root=median_cut(hl,nPixels,nQuantPixels);
-#ifndef NO_OUTPUT
-   printf ("done (%f)\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-#endif
-   if (!root) {
-      goto error_1;
-   }
-   nPaletteEntries=0;
-#ifndef NO_OUTPUT
-   printf ("median cut tree to hash table..."); fflush(stdout); timer=clock();
-#endif
-   annotate_hash_table(root,h,&nPaletteEntries);
-#ifndef NO_OUTPUT
-   printf ("done (%f)\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-#endif
-#ifndef NO_OUTPUT
-   printf ("compute palette...\n"); fflush(stdout); timer=clock();
-#endif
-   if (!compute_palette_from_median_cut(pixelData,nPixels,h,&p,nPaletteEntries)) {
-      goto error_3;
-   }
-#ifndef NO_OUTPUT
-   printf ("done (%f)\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-#endif
-
-   free_box_tree(root);
-   root=NULL;
-
-   /* malloc check ok, using calloc for overflow */
-   qp=calloc(nPixels, sizeof(uint32_t));
-   if (!qp) { goto error_4; }
-
-   if (nPaletteEntries > UINT32_MAX / nPaletteEntries )  {
-       goto error_5;
-   }
-   /* malloc check ok, using calloc for overflow, check of n*n above */
-   avgDist=calloc(nPaletteEntries*nPaletteEntries, sizeof(uint32_t));
-   if (!avgDist) { goto error_5; }
-
-   /* malloc check ok, using calloc for overflow, check of n*n above */
-   avgDistSortKey=calloc(nPaletteEntries*nPaletteEntries, sizeof(uint32_t *));
-   if (!avgDistSortKey) { goto error_6; }
-
-   if (!build_distance_tables(avgDist,avgDistSortKey,p,nPaletteEntries)) {
-      goto error_7;
-   }
-
-   if (!map_image_pixels_from_median_box(pixelData,nPixels,p,nPaletteEntries,h,avgDist,avgDistSortKey,qp)) {
-      goto error_7;
-   }
+    if (!test_sorted(hl)) {
+        printf("bug in mergesort\n");
+        goto error_1;
+    }
+#endif
+#ifndef NO_OUTPUT
+    printf("done (%f)\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+#endif
+
+#ifndef NO_OUTPUT
+    printf("median cut...");
+    fflush(stdout);
+    timer = clock();
+#endif
+    root = median_cut(hl, nPixels, nQuantPixels);
+#ifndef NO_OUTPUT
+    printf("done (%f)\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+#endif
+    if (!root) {
+        goto error_1;
+    }
+    nPaletteEntries = 0;
+#ifndef NO_OUTPUT
+    printf("median cut tree to hash table...");
+    fflush(stdout);
+    timer = clock();
+#endif
+    annotate_hash_table(root, h, &nPaletteEntries);
+#ifndef NO_OUTPUT
+    printf("done (%f)\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+#endif
+#ifndef NO_OUTPUT
+    printf("compute palette...\n");
+    fflush(stdout);
+    timer = clock();
+#endif
+    if (!compute_palette_from_median_cut(pixelData, nPixels, h, &p, nPaletteEntries)) {
+        goto error_3;
+    }
+#ifndef NO_OUTPUT
+    printf("done (%f)\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+#endif
+
+    free_box_tree(root);
+    root = NULL;
+
+    /* malloc check ok, using calloc for overflow */
+    qp = calloc(nPixels, sizeof(uint32_t));
+    if (!qp) {
+        goto error_4;
+    }
+
+    if (nPaletteEntries > UINT32_MAX / nPaletteEntries) {
+        goto error_5;
+    }
+    /* malloc check ok, using calloc for overflow, check of n*n above */
+    avgDist = calloc(nPaletteEntries * nPaletteEntries, sizeof(uint32_t));
+    if (!avgDist) {
+        goto error_5;
+    }
+
+    /* malloc check ok, using calloc for overflow, check of n*n above */
+    avgDistSortKey = calloc(nPaletteEntries * nPaletteEntries, sizeof(uint32_t *));
+    if (!avgDistSortKey) {
+        goto error_6;
+    }
+
+    if (!build_distance_tables(avgDist, avgDistSortKey, p, nPaletteEntries)) {
+        goto error_7;
+    }
+
+    if (!map_image_pixels_from_median_box(
+            pixelData, nPixels, p, nPaletteEntries, h, avgDist, avgDistSortKey, qp)) {
+        goto error_7;
+    }

 #ifdef TEST_NEAREST_NEIGHBOUR
 #include <math.h>
-   {
-      uint32_t bestmatch,bestdist,dist;
-      HashTable *h2;
-      printf ("nearest neighbour search (full search)..."); fflush(stdout); timer=clock();
-      h2=hashtable_new(unshifted_pixel_hash,unshifted_pixel_cmp);
-      for (i=0;i<nPixels;i++) {
-         if (hashtable_lookup(h2,pixelData[i],&paletteEntry)) {
-            bestmatch=paletteEntry;
-         } else {
-            bestmatch=0;
-            bestdist=
-               _SQR(pixelData[i].c.r-p[0].c.r)+
-               _SQR(pixelData[i].c.g-p[0].c.g)+
-               _SQR(pixelData[i].c.b-p[0].c.b);
-            for (j=1;j<nPaletteEntries;j++) {
-               dist=
-                  _SQR(pixelData[i].c.r-p[j].c.r)+
-                  _SQR(pixelData[i].c.g-p[j].c.g)+
-                  _SQR(pixelData[i].c.b-p[j].c.b);
-               if (dist==bestdist && j==qp[i]) {
-                  bestmatch=j;
-               }
-               if (dist<bestdist) {
-                  bestdist=dist;
-                  bestmatch=j;
-               }
-            }
-            hashtable_insert(h2,pixelData[i],bestmatch);
-         }
-         if (qp[i]!=bestmatch ) {
-            printf ("discrepancy in matching algorithms pixel %d [%d %d] %f %f\n",
+    {
+        uint32_t bestmatch, bestdist, dist;
+        HashTable *h2;
+        printf("nearest neighbour search (full search)...");
+        fflush(stdout);
+        timer = clock();
+        h2 = hashtable_new(unshifted_pixel_hash, unshifted_pixel_cmp);
+        for (i = 0; i < nPixels; i++) {
+            if (hashtable_lookup(h2, pixelData[i], &paletteEntry)) {
+                bestmatch = paletteEntry;
+            } else {
+                bestmatch = 0;
+                bestdist = _SQR(pixelData[i].c.r - p[0].c.r) +
+                           _SQR(pixelData[i].c.g - p[0].c.g) +
+                           _SQR(pixelData[i].c.b - p[0].c.b);
+                for (j = 1; j < nPaletteEntries; j++) {
+                    dist = _SQR(pixelData[i].c.r - p[j].c.r) +
+                           _SQR(pixelData[i].c.g - p[j].c.g) +
+                           _SQR(pixelData[i].c.b - p[j].c.b);
+                    if (dist == bestdist && j == qp[i]) {
+                        bestmatch = j;
+                    }
+                    if (dist < bestdist) {
+                        bestdist = dist;
+                        bestmatch = j;
+                    }
+                }
+                hashtable_insert(h2, pixelData[i], bestmatch);
+            }
+            if (qp[i] != bestmatch) {
+                printf ("discrepancy in matching algorithms pixel %d [%d %d] %f %f\n",
                     i,qp[i],bestmatch,
                     sqrt((double)(_SQR(pixelData[i].c.r-p[qp[i]].c.r)+
                                   _SQR(pixelData[i].c.g-p[qp[i]].c.g)+
@@ -1407,194 +1449,203 @@
                                   _SQR(pixelData[i].c.g-p[bestmatch].c.g)+
                                   _SQR(pixelData[i].c.b-p[bestmatch].c.b)))
                    );
-         }
-      }
-      hashtable_free(h2);
-   }
-#endif
-#ifndef NO_OUTPUT
-   printf ("k means...\n"); fflush(stdout); timer=clock();
-#endif
-   if (kmeans) {
-      k_means(pixelData,nPixels,p,nPaletteEntries,qp,kmeans-1);
-   }
-#ifndef NO_OUTPUT
-   printf ("done (%f)\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-#endif
-
-   *quantizedPixels=qp;
-   *palette=p;
-   *paletteLength=nPaletteEntries;
-
-#ifndef NO_OUTPUT
-   printf ("cleanup..."); fflush(stdout); timer=clock();
-#endif
-   if (avgDist) {
-      free(avgDist);
-   }
-   if (avgDistSortKey) {
-      free(avgDistSortKey);
-   }
-   destroy_pixel_hash(h);
-#ifndef NO_OUTPUT
-   printf ("done (%f)\n",(clock()-timer)/(double)CLOCKS_PER_SEC);
-   printf ("-----\ntotal time %f\n",(clock()-timer2)/(double)CLOCKS_PER_SEC);
-#endif
-   return 1;
+            }
+        }
+        hashtable_free(h2);
+    }
+#endif
+#ifndef NO_OUTPUT
+    printf("k means...\n");
+    fflush(stdout);
+    timer = clock();
+#endif
+    if (kmeans) {
+        k_means(pixelData, nPixels, p, nPaletteEntries, qp, kmeans - 1);
+    }
+#ifndef NO_OUTPUT
+    printf("done (%f)\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+#endif
+
+    *quantizedPixels = qp;
+    *palette = p;
+    *paletteLength = nPaletteEntries;
+
+#ifndef NO_OUTPUT
+    printf("cleanup...");
+    fflush(stdout);
+    timer = clock();
+#endif
+    if (avgDist) {
+        free(avgDist);
+    }
+    if (avgDistSortKey) {
+        free(avgDistSortKey);
+    }
+    destroy_pixel_hash(h);
+#ifndef NO_OUTPUT
+    printf("done (%f)\n", (clock() - timer) / (double)CLOCKS_PER_SEC);
+    printf("-----\ntotal time %f\n", (clock() - timer2) / (double)CLOCKS_PER_SEC);
+#endif
+    return 1;

 error_7:
-   if (avgDistSortKey) {
-      free(avgDistSortKey);
-   }
+    if (avgDistSortKey) {
+        free(avgDistSortKey);
+    }
 error_6:
-   if (avgDist) {
-      free(avgDist);
-   }
+    if (avgDist) {
+        free(avgDist);
+    }
 error_5:
-   if (qp) {
-      free(qp);
-   }
+    if (qp) {
+        free(qp);
+    }
 error_4:
-   if (p) {
-      free(p);
-   }
+    if (p) {
+        free(p);
+    }
 error_3:
-   if (root) {
-      free_box_tree(root);
-   }
+    if (root) {
+        free_box_tree(root);
+    }
 error_1:
-   destroy_pixel_hash(h);
+    destroy_pixel_hash(h);
 error_0:
-   *quantizedPixels=NULL;
-   *paletteLength=0;
-   *palette=NULL;
-   return 0;
+    *quantizedPixels = NULL;
+    *paletteLength = 0;
+    *palette = NULL;
+    return 0;
 }

 typedef struct {
-   Pixel new;
-   Pixel furthest;
-   uint32_t furthestDistance;
-   int secondPixel;
+    Pixel new;
+    Pixel furthest;
+    uint32_t furthestDistance;
+    int secondPixel;
 } DistanceData;

 static void
-compute_distances(const HashTable *h, const Pixel pixel, uint32_t *dist, void *u)
-{
-   DistanceData *data=(DistanceData *)u;
-   uint32_t oldDist=*dist;
-   uint32_t newDist;
-   newDist=_DISTSQR(&(data->new),&pixel);
-   if (data->secondPixel || newDist<oldDist) {
-      *dist=newDist;
-      oldDist=newDist;
-   }
-   if (oldDist>data->furthestDistance) {
-      data->furthestDistance=oldDist;
-      data->furthest.v=pixel.v;
-   }
-}
-
-int
-quantize2(Pixel *pixelData,
-          uint32_t nPixels,
-          uint32_t nQuantPixels,
-          Pixel **palette,
-          uint32_t *paletteLength,
-          uint32_t **quantizedPixels,
-          int kmeans)
-{
-   HashTable *h;
-   uint32_t i;
-   uint32_t mean[3];
-   Pixel *p;
-   DistanceData data;
-
-   uint32_t *qp;
-   uint32_t *avgDist;
-   uint32_t **avgDistSortKey;
-
-   /* malloc check ok, using calloc */
-   p=calloc(nQuantPixels, sizeof(Pixel));
-   if (!p) {
-      return 0;
-   }
-   mean[0]=mean[1]=mean[2]=0;
-   h=hashtable_new(unshifted_pixel_hash,unshifted_pixel_cmp);
-   for (i=0;i<nPixels;i++) {
-      hashtable_insert(h,pixelData[i],0xffffffff);
-      mean[0]+=pixelData[i].c.r;
-      mean[1]+=pixelData[i].c.g;
-      mean[2]+=pixelData[i].c.b;
-   }
-   data.new.c.r=(int)(.5+(double)mean[0]/(double)nPixels);
-   data.new.c.g=(int)(.5+(double)mean[1]/(double)nPixels);
-   data.new.c.b=(int)(.5+(double)mean[2]/(double)nPixels);
-   for (i=0;i<nQuantPixels;i++) {
-      data.furthestDistance=0;
-      data.secondPixel=(i==1)?1:0;
-      hashtable_foreach_update(h,compute_distances,&data);
-      p[i].v=data.furthest.v;
-      data.new.v=data.furthest.v;
-   }
-   hashtable_free(h);
-
-   /* malloc check ok, using calloc */
-   qp=calloc(nPixels, sizeof(uint32_t));
-   if (!qp) { goto error_1; }
-
-   if (nQuantPixels > UINT32_MAX / nQuantPixels ) {
-       goto error_2;
-   }
-
-   /* malloc check ok, using calloc for overflow, check of n*n above */
-   avgDist=calloc(nQuantPixels*nQuantPixels, sizeof(uint32_t));
-   if (!avgDist) { goto error_2; }
-
-   /* malloc check ok, using calloc for overflow, check of n*n above */
-   avgDistSortKey=calloc(nQuantPixels*nQuantPixels, sizeof(uint32_t *));
-   if (!avgDistSortKey) { goto error_3; }
-
-   if (!build_distance_tables(avgDist,avgDistSortKey,p,nQuantPixels)) {
-      goto error_4;
-   }
-
-   if (!map_image_pixels(pixelData,nPixels,p,nQuantPixels,avgDist,avgDistSortKey,qp)) {
-      goto error_4;
-   }
-   if (kmeans) {
-      k_means(pixelData,nPixels,p,nQuantPixels,qp,kmeans-1);
-   }
-
-   *paletteLength=nQuantPixels;
-   *palette=p;
-   *quantizedPixels=qp;
-   free(avgDistSortKey);
-   free(avgDist);
-   return 1;
+compute_distances(const HashTable *h, const Pixel pixel, uint32_t *dist, void *u) {
+    DistanceData *data = (DistanceData *)u;
+    uint32_t oldDist = *dist;
+    uint32_t newDist;
+    newDist = _DISTSQR(&(data->new), &pixel);
+    if (data->secondPixel || newDist < oldDist) {
+        *dist = newDist;
+        oldDist = newDist;
+    }
+    if (oldDist > data->furthestDistance) {
+        data->furthestDistance = oldDist;
+        data->furthest.v = pixel.v;
+    }
+}
+
+static int
+quantize2(
+    Pixel *pixelData,
+    uint32_t nPixels,
+    uint32_t nQuantPixels,
+    Pixel **palette,
+    uint32_t *paletteLength,
+    uint32_t **quantizedPixels,
+    int kmeans) {
+    HashTable *h;
+    uint32_t i;
+    uint32_t mean[3];
+    Pixel *p;
+    DistanceData data;
+
+    uint32_t *qp;
+    uint32_t *avgDist;
+    uint32_t **avgDistSortKey;
+
+    /* malloc check ok, using calloc */
+    p = calloc(nQuantPixels, sizeof(Pixel));
+    if (!p) {
+        return 0;
+    }
+    mean[0] = mean[1] = mean[2] = 0;
+    h = hashtable_new(unshifted_pixel_hash, unshifted_pixel_cmp);
+    for (i = 0; i < nPixels; i++) {
+        hashtable_insert(h, pixelData[i], 0xffffffff);
+        mean[0] += pixelData[i].c.r;
+        mean[1] += pixelData[i].c.g;
+        mean[2] += pixelData[i].c.b;
+    }
+    data.new.c.r = (int)(.5 + (double)mean[0] / (double)nPixels);
+    data.new.c.g = (int)(.5 + (double)mean[1] / (double)nPixels);
+    data.new.c.b = (int)(.5 + (double)mean[2] / (double)nPixels);
+    for (i = 0; i < nQuantPixels; i++) {
+        data.furthestDistance = 0;
+        data.secondPixel = (i == 1) ? 1 : 0;
+        hashtable_foreach_update(h, compute_distances, &data);
+        p[i].v = data.furthest.v;
+        data.new.v = data.furthest.v;
+    }
+    hashtable_free(h);
+
+    /* malloc check ok, using calloc */
+    qp = calloc(nPixels, sizeof(uint32_t));
+    if (!qp) {
+        goto error_1;
+    }
+
+    if (nQuantPixels > UINT32_MAX / nQuantPixels) {
+        goto error_2;
+    }
+
+    /* malloc check ok, using calloc for overflow, check of n*n above */
+    avgDist = calloc(nQuantPixels * nQuantPixels, sizeof(uint32_t));
+    if (!avgDist) {
+        goto error_2;
+    }
+
+    /* malloc check ok, using calloc for overflow, check of n*n above */
+    avgDistSortKey = calloc(nQuantPixels * nQuantPixels, sizeof(uint32_t *));
+    if (!avgDistSortKey) {
+        goto error_3;
+    }
+
+    if (!build_distance_tables(avgDist, avgDistSortKey, p, nQuantPixels)) {
+        goto error_4;
+    }
+
+    if (!map_image_pixels(
+            pixelData, nPixels, p, nQuantPixels, avgDist, avgDistSortKey, qp)) {
+        goto error_4;
+    }
+    if (kmeans) {
+        k_means(pixelData, nPixels, p, nQuantPixels, qp, kmeans - 1);
+    }
+
+    *paletteLength = nQuantPixels;
+    *palette = p;
+    *quantizedPixels = qp;
+    free(avgDistSortKey);
+    free(avgDist);
+    return 1;

 error_4:
-   free(avgDistSortKey);
+    free(avgDistSortKey);
 error_3:
-   free(avgDist);
+    free(avgDist);
 error_2:
-   free(qp);
+    free(qp);
 error_1:
-   free(p);
-   return 0;
+    free(p);
+    return 0;
 }

 Imaging
-ImagingQuantize(Imaging im, int colors, int mode, int kmeans)
-{
+ImagingQuantize(Imaging im, int colors, int mode, int kmeans) {
     int i, j;
     int x, y, v;
-    UINT8* pp;
-    Pixel* p;
-    Pixel* palette;
+    UINT8 *pp;
+    Pixel *p;
+    Pixel *palette;
     uint32_t paletteLength;
     int result;
-    uint32_t* newData;
+    uint32_t *newData;
     Imaging imOut;
     int withAlpha = 0;
     ImagingSectionCookie cookie;
@@ -1605,17 +1656,17 @@
     if (colors < 1 || colors > 256) {
         /* FIXME: for colors > 256, consider returning an RGB image
            instead (see @PIL205) */
-        return (Imaging) ImagingError_ValueError("bad number of colors");
+        return (Imaging)ImagingError_ValueError("bad number of colors");
     }

     if (strcmp(im->mode, "L") != 0 && strcmp(im->mode, "P") != 0 &&
-        strcmp(im->mode, "RGB") != 0 && strcmp(im->mode, "RGBA") !=0) {
+        strcmp(im->mode, "RGB") != 0 && strcmp(im->mode, "RGBA") != 0) {
         return ImagingError_ModeError();
     }

     /* only octree and imagequant supports RGBA */
     if (!strcmp(im->mode, "RGBA") && mode != 2 && mode != 3) {
-       return ImagingError_ModeError();
+        return ImagingError_ModeError();
     }

     if (im->xsize > INT_MAX / im->ysize) {
@@ -1653,90 +1704,97 @@
         for (i = y = 0; y < im->ysize; y++) {
             for (x = 0; x < im->xsize; x++, i++) {
                 v = im->image8[y][x];
-                p[i].c.r = pp[v*4+0];
-                p[i].c.g = pp[v*4+1];
-                p[i].c.b = pp[v*4+2];
-                p[i].c.a = pp[v*4+3];
+                p[i].c.r = pp[v * 4 + 0];
+                p[i].c.g = pp[v * 4 + 1];
+                p[i].c.b = pp[v * 4 + 2];
+                p[i].c.a = pp[v * 4 + 3];
             }
         }

     } else if (!strcmp(im->mode, "RGB") || !strcmp(im->mode, "RGBA")) {
         /* true colour */

+        withAlpha = !strcmp(im->mode, "RGBA");
+        int transparency = 0;
+        unsigned char r, g, b;
         for (i = y = 0; y < im->ysize; y++) {
             for (x = 0; x < im->xsize; x++, i++) {
                 p[i].v = im->image32[y][x];
+                if (withAlpha && p[i].c.a == 0) {
+                    if (transparency == 0) {
+                        transparency = 1;
+                        r = p[i].c.r;
+                        g = p[i].c.g;
+                        b = p[i].c.b;
+                    } else {
+                        /* Set all subsequent transparent pixels
+                        to the same colour as the first */
+                        p[i].c.r = r;
+                        p[i].c.g = g;
+                        p[i].c.b = b;
+                    }
+                }
             }
         }

     } else {
         free(p);
-        return (Imaging) ImagingError_ValueError("internal error");
+        return (Imaging)ImagingError_ValueError("internal error");
     }

     ImagingSectionEnter(&cookie);

     switch (mode) {
-    case 0:
-        /* median cut */
-        result = quantize(
-            p,
-            im->xsize*im->ysize,
-            colors,
-            &palette,
-            &paletteLength,
-            &newData,
-            kmeans
-            );
-        break;
-    case 1:
-        /* maximum coverage */
-        result = quantize2(
-            p,
-            im->xsize*im->ysize,
-            colors,
-            &palette,
-            &paletteLength,
-            &newData,
-            kmeans
-            );
-        break;
-    case 2:
-        if (!strcmp(im->mode, "RGBA")) {
-            withAlpha = 1;
-        }
-        result = quantize_octree(
-            p,
-            im->xsize*im->ysize,
-            colors,
-            &palette,
-            &paletteLength,
-            &newData,
-            withAlpha
-            );
-        break;
-    case 3:
+        case 0:
+            /* median cut */
+            result = quantize(
+                p,
+                im->xsize * im->ysize,
+                colors,
+                &palette,
+                &paletteLength,
+                &newData,
+                kmeans);
+            break;
+        case 1:
+            /* maximum coverage */
+            result = quantize2(
+                p,
+                im->xsize * im->ysize,
+                colors,
+                &palette,
+                &paletteLength,
+                &newData,
+                kmeans);
+            break;
+        case 2:
+            result = quantize_octree(
+                p,
+                im->xsize * im->ysize,
+                colors,
+                &palette,
+                &paletteLength,
+                &newData,
+                withAlpha);
+            break;
+        case 3:
 #ifdef HAVE_LIBIMAGEQUANT
-        if (!strcmp(im->mode, "RGBA")) {
-            withAlpha = 1;
-        }
-        result = quantize_pngquant(
-            p,
-            im->xsize,
-            im->ysize,
-            colors,
-            &palette,
-            &paletteLength,
-            &newData,
-            withAlpha
-            );
+            result = quantize_pngquant(
+                p,
+                im->xsize,
+                im->ysize,
+                colors,
+                &palette,
+                &paletteLength,
+                &newData,
+                withAlpha);
 #else
-        result = -1;
-#endif
-        break;
-    default:
-        result = 0;
-        break;
+            result = -1;
+#endif
+            break;
+        default:
+            result = 0;
+            break;
     }

     free(p);
@@ -1748,7 +1806,7 @@

         for (i = y = 0; y < im->ysize; y++) {
             for (x = 0; x < im->xsize; x++) {
-                imOut->image8[y][x] = (unsigned char) newData[i++];
+                imOut->image8[y][x] = (unsigned char)newData[i++];
             }
         }

@@ -1756,14 +1814,14 @@

         pp = imOut->palette->palette;

-        for (i = j = 0; i < (int) paletteLength; i++) {
+        for (i = j = 0; i < (int)paletteLength; i++) {
             *pp++ = palette[i].c.r;
             *pp++ = palette[i].c.g;
             *pp++ = palette[i].c.b;
             if (withAlpha) {
-               *pp++ = palette[i].c.a;
+                *pp++ = palette[i].c.a;
             } else {
-               *pp++ = 255;
+                *pp++ = 255;
             }
         }
         for (; i < 256; i++) {
@@ -1783,14 +1841,12 @@
         return imOut;

     } else {
-
         if (result == -1) {
-            return (Imaging) ImagingError_ValueError(
+            return (Imaging)ImagingError_ValueError(
                 "dependency required by this method was not "
                 "enabled at compile time");
         }

-        return (Imaging) ImagingError_ValueError("quantization error");
-
-    }
-}
+        return (Imaging)ImagingError_ValueError("quantization error");
+    }
+}
('src/libImaging', 'Bands.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,23 +15,20 @@
  * See the README file for details on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 Imaging
-ImagingGetBand(Imaging imIn, int band)
-{
+ImagingGetBand(Imaging imIn, int band) {
     Imaging imOut;
     int x, y;

     /* Check arguments */
     if (!imIn || imIn->type != IMAGING_TYPE_UINT8) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (band < 0 || band >= imIn->bands) {
-        return (Imaging) ImagingError_ValueError("band index out of range");
+        return (Imaging)ImagingError_ValueError("band index out of range");
     }

     /* Shortcuts */
@@ -51,8 +48,8 @@

     /* Extract band from image */
     for (y = 0; y < imIn->ysize; y++) {
-        UINT8* in = (UINT8*) imIn->image[y] + band;
-        UINT8* out = imOut->image8[y];
+        UINT8 *in = (UINT8 *)imIn->image[y] + band;
+        UINT8 *out = imOut->image8[y];
         x = 0;
         for (; x < imIn->xsize - 3; x += 4) {
             UINT32 v = MAKE_UINT32(in[0], in[4], in[8], in[12]);
@@ -68,15 +65,13 @@
     return imOut;
 }

-
 int
-ImagingSplit(Imaging imIn, Imaging bands[4])
-{
+ImagingSplit(Imaging imIn, Imaging bands[4]) {
     int i, j, x, y;

     /* Check arguments */
     if (!imIn || imIn->type != IMAGING_TYPE_UINT8) {
-        (void) ImagingError_ModeError();
+        (void)ImagingError_ModeError();
         return 0;
     }

@@ -88,7 +83,7 @@

     for (i = 0; i < imIn->bands; i++) {
         bands[i] = ImagingNewDirty("L", imIn->xsize, imIn->ysize);
-        if ( ! bands[i]) {
+        if (!bands[i]) {
             for (j = 0; j < i; ++j) {
                 ImagingDelete(bands[j]);
             }
@@ -99,14 +94,14 @@
     /* Extract bands from image */
     if (imIn->bands == 2) {
         for (y = 0; y < imIn->ysize; y++) {
-            UINT8* in = (UINT8*) imIn->image[y];
-            UINT8* out0 = bands[0]->image8[y];
-            UINT8* out1 = bands[1]->image8[y];
+            UINT8 *in = (UINT8 *)imIn->image[y];
+            UINT8 *out0 = bands[0]->image8[y];
+            UINT8 *out1 = bands[1]->image8[y];
             x = 0;
             for (; x < imIn->xsize - 3; x += 4) {
                 UINT32 v = MAKE_UINT32(in[0], in[4], in[8], in[12]);
                 memcpy(out0 + x, &v, sizeof(v));
-                v = MAKE_UINT32(in[0+3], in[4+3], in[8+3], in[12+3]);
+                v = MAKE_UINT32(in[0 + 3], in[4 + 3], in[8 + 3], in[12 + 3]);
                 memcpy(out1 + x, &v, sizeof(v));
                 in += 16;
             }
@@ -118,17 +113,17 @@
         }
     } else if (imIn->bands == 3) {
         for (y = 0; y < imIn->ysize; y++) {
-            UINT8* in = (UINT8*) imIn->image[y];
-            UINT8* out0 = bands[0]->image8[y];
-            UINT8* out1 = bands[1]->image8[y];
-            UINT8* out2 = bands[2]->image8[y];
+            UINT8 *in = (UINT8 *)imIn->image[y];
+            UINT8 *out0 = bands[0]->image8[y];
+            UINT8 *out1 = bands[1]->image8[y];
+            UINT8 *out2 = bands[2]->image8[y];
             x = 0;
             for (; x < imIn->xsize - 3; x += 4) {
                 UINT32 v = MAKE_UINT32(in[0], in[4], in[8], in[12]);
                 memcpy(out0 + x, &v, sizeof(v));
-                v = MAKE_UINT32(in[0+1], in[4+1], in[8+1], in[12+1]);
+                v = MAKE_UINT32(in[0 + 1], in[4 + 1], in[8 + 1], in[12 + 1]);
                 memcpy(out1 + x, &v, sizeof(v));
-                v = MAKE_UINT32(in[0+2], in[4+2], in[8+2], in[12+2]);
+                v = MAKE_UINT32(in[0 + 2], in[4 + 2], in[8 + 2], in[12 + 2]);
                 memcpy(out2 + x, &v, sizeof(v));
                 in += 16;
             }
@@ -141,20 +136,20 @@
         }
     } else {
         for (y = 0; y < imIn->ysize; y++) {
-            UINT8* in = (UINT8*) imIn->image[y];
-            UINT8* out0 = bands[0]->image8[y];
-            UINT8* out1 = bands[1]->image8[y];
-            UINT8* out2 = bands[2]->image8[y];
-            UINT8* out3 = bands[3]->image8[y];
+            UINT8 *in = (UINT8 *)imIn->image[y];
+            UINT8 *out0 = bands[0]->image8[y];
+            UINT8 *out1 = bands[1]->image8[y];
+            UINT8 *out2 = bands[2]->image8[y];
+            UINT8 *out3 = bands[3]->image8[y];
             x = 0;
             for (; x < imIn->xsize - 3; x += 4) {
                 UINT32 v = MAKE_UINT32(in[0], in[4], in[8], in[12]);
                 memcpy(out0 + x, &v, sizeof(v));
-                v = MAKE_UINT32(in[0+1], in[4+1], in[8+1], in[12+1]);
+                v = MAKE_UINT32(in[0 + 1], in[4 + 1], in[8 + 1], in[12 + 1]);
                 memcpy(out1 + x, &v, sizeof(v));
-                v = MAKE_UINT32(in[0+2], in[4+2], in[8+2], in[12+2]);
+                v = MAKE_UINT32(in[0 + 2], in[4 + 2], in[8 + 2], in[12 + 2]);
                 memcpy(out2 + x, &v, sizeof(v));
-                v = MAKE_UINT32(in[0+3], in[4+3], in[8+3], in[12+3]);
+                v = MAKE_UINT32(in[0 + 3], in[4 + 3], in[8 + 3], in[12 + 3]);
                 memcpy(out3 + x, &v, sizeof(v));
                 in += 16;
             }
@@ -171,25 +166,22 @@
     return imIn->bands;
 }

-
 Imaging
-ImagingPutBand(Imaging imOut, Imaging imIn, int band)
-{
+ImagingPutBand(Imaging imOut, Imaging imIn, int band) {
     int x, y;

     /* Check arguments */
     if (!imIn || imIn->bands != 1 || !imOut) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (band < 0 || band >= imOut->bands) {
-        return (Imaging) ImagingError_ValueError("band index out of range");
-    }
-
-    if (imIn->type  != imOut->type  ||
-        imIn->xsize != imOut->xsize ||
+        return (Imaging)ImagingError_ValueError("band index out of range");
+    }
+
+    if (imIn->type != imOut->type || imIn->xsize != imOut->xsize ||
         imIn->ysize != imOut->ysize) {
-        return (Imaging) ImagingError_Mismatch();
+        return (Imaging)ImagingError_Mismatch();
     }

     /* Shortcuts */
@@ -204,8 +196,8 @@

     /* Insert band into image */
     for (y = 0; y < imIn->ysize; y++) {
-        UINT8* in = imIn->image8[y];
-        UINT8* out = (UINT8*) imOut->image[y] + band;
+        UINT8 *in = imIn->image8[y];
+        UINT8 *out = (UINT8 *)imOut->image[y] + band;
         for (x = 0; x < imIn->xsize; x++) {
             *out = in[x];
             out += 4;
@@ -216,17 +208,16 @@
 }

 Imaging
-ImagingFillBand(Imaging imOut, int band, int color)
-{
+ImagingFillBand(Imaging imOut, int band, int color) {
     int x, y;

     /* Check arguments */
     if (!imOut || imOut->type != IMAGING_TYPE_UINT8) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (band < 0 || band >= imOut->bands) {
-        return (Imaging) ImagingError_ValueError("band index out of range");
+        return (Imaging)ImagingError_ValueError("band index out of range");
     }

     /* Special case for LXXA etc */
@@ -238,9 +229,9 @@

     /* Insert color into image */
     for (y = 0; y < imOut->ysize; y++) {
-        UINT8* out = (UINT8*) imOut->image[y] + band;
+        UINT8 *out = (UINT8 *)imOut->image[y] + band;
         for (x = 0; x < imOut->xsize; x++) {
-            *out = (UINT8) color;
+            *out = (UINT8)color;
             out += 4;
         }
     }
@@ -249,40 +240,39 @@
 }

 Imaging
-ImagingMerge(const char* mode, Imaging bands[4])
-{
+ImagingMerge(const char *mode, Imaging bands[4]) {
     int i, x, y;
     int bandsCount = 0;
     Imaging imOut;
     Imaging firstBand;

     firstBand = bands[0];
-    if ( ! firstBand) {
-        return (Imaging) ImagingError_ValueError("wrong number of bands");
+    if (!firstBand) {
+        return (Imaging)ImagingError_ValueError("wrong number of bands");
     }

     for (i = 0; i < 4; ++i) {
-        if ( ! bands[i]) {
+        if (!bands[i]) {
             break;
         }
         if (bands[i]->bands != 1) {
-            return (Imaging) ImagingError_ModeError();
-        }
-        if (bands[i]->xsize != firstBand->xsize
-            || bands[i]->ysize != firstBand->ysize) {
-            return (Imaging) ImagingError_Mismatch();
+            return (Imaging)ImagingError_ModeError();
+        }
+        if (bands[i]->xsize != firstBand->xsize ||
+            bands[i]->ysize != firstBand->ysize) {
+            return (Imaging)ImagingError_Mismatch();
         }
     }
     bandsCount = i;

     imOut = ImagingNewDirty(mode, firstBand->xsize, firstBand->ysize);
-    if ( ! imOut) {
+    if (!imOut) {
         return NULL;
     }

     if (imOut->bands != bandsCount) {
         ImagingDelete(imOut);
-        return (Imaging) ImagingError_ValueError("wrong number of bands");
+        return (Imaging)ImagingError_ValueError("wrong number of bands");
     }

     if (imOut->bands == 1) {
@@ -291,30 +281,30 @@

     if (imOut->bands == 2) {
         for (y = 0; y < imOut->ysize; y++) {
-            UINT8* in0 = bands[0]->image8[y];
-            UINT8* in1 = bands[1]->image8[y];
-            UINT32* out = (UINT32*) imOut->image32[y];
+            UINT8 *in0 = bands[0]->image8[y];
+            UINT8 *in1 = bands[1]->image8[y];
+            UINT32 *out = (UINT32 *)imOut->image32[y];
             for (x = 0; x < imOut->xsize; x++) {
                 out[x] = MAKE_UINT32(in0[x], 0, 0, in1[x]);
             }
         }
     } else if (imOut->bands == 3) {
         for (y = 0; y < imOut->ysize; y++) {
-            UINT8* in0 = bands[0]->image8[y];
-            UINT8* in1 = bands[1]->image8[y];
-            UINT8* in2 = bands[2]->image8[y];
-            UINT32* out = (UINT32*) imOut->image32[y];
+            UINT8 *in0 = bands[0]->image8[y];
+            UINT8 *in1 = bands[1]->image8[y];
+            UINT8 *in2 = bands[2]->image8[y];
+            UINT32 *out = (UINT32 *)imOut->image32[y];
             for (x = 0; x < imOut->xsize; x++) {
                 out[x] = MAKE_UINT32(in0[x], in1[x], in2[x], 0);
             }
         }
     } else if (imOut->bands == 4) {
         for (y = 0; y < imOut->ysize; y++) {
-            UINT8* in0 = bands[0]->image8[y];
-            UINT8* in1 = bands[1]->image8[y];
-            UINT8* in2 = bands[2]->image8[y];
-            UINT8* in3 = bands[3]->image8[y];
-            UINT32* out = (UINT32*) imOut->image32[y];
+            UINT8 *in0 = bands[0]->image8[y];
+            UINT8 *in1 = bands[1]->image8[y];
+            UINT8 *in2 = bands[2]->image8[y];
+            UINT8 *in3 = bands[3]->image8[y];
+            UINT32 *out = (UINT32 *)imOut->image32[y];
             for (x = 0; x < imOut->xsize; x++) {
                 out[x] = MAKE_UINT32(in0[x], in1[x], in2[x], in3[x]);
             }
('src/libImaging', 'ImDib.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -35,20 +35,27 @@
     ImagingShuffler unpack;
 };

-typedef struct ImagingDIBInstance* ImagingDIB;
+typedef struct ImagingDIBInstance *ImagingDIB;

-extern char* ImagingGetModeDIB(int size_out[2]);
+extern char *
+ImagingGetModeDIB(int size_out[2]);

-extern ImagingDIB ImagingNewDIB(const char *mode, int xsize, int ysize);
+extern ImagingDIB
+ImagingNewDIB(const char *mode, int xsize, int ysize);

-extern void ImagingDeleteDIB(ImagingDIB im);
+extern void
+ImagingDeleteDIB(ImagingDIB im);

-extern void ImagingDrawDIB(ImagingDIB dib, void *dc, int dst[4], int src[4]);
-extern void ImagingExposeDIB(ImagingDIB dib, void *dc);
+extern void
+ImagingDrawDIB(ImagingDIB dib, void *dc, int dst[4], int src[4]);
+extern void
+ImagingExposeDIB(ImagingDIB dib, void *dc);

-extern int ImagingQueryPaletteDIB(ImagingDIB dib, void *dc);
+extern int
+ImagingQueryPaletteDIB(ImagingDIB dib, void *dc);

-extern void ImagingPasteDIB(ImagingDIB dib, Imaging im, int xy[4]);
+extern void
+ImagingPasteDIB(ImagingDIB dib, Imaging im, int xy[4]);

 #if defined(__cplusplus)
 }
('src/libImaging', 'Sgi.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,7 +1,6 @@
 /* Sgi.h */

 typedef struct {
-
     /* CONFIGURATION */

     /* Number of bytes per channel per pixel */
('src/libImaging', 'XbmEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,25 +13,20 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
 int
-ImagingXbmEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)
-{
+ImagingXbmEncode(Imaging im, ImagingCodecState state, UINT8 *buf, int bytes) {
     const char *hex = "0123456789abcdef";

-    UINT8* ptr = buf;
+    UINT8 *ptr = buf;
     int i, n;

     if (!state->state) {
-
         /* 8 pixels are stored in no more than 6 bytes */
-        state->bytes = 6*(state->xsize+7)/8;
+        state->bytes = 6 * (state->xsize + 7) / 8;

         state->state = 1;
-
     }

     if (bytes < state->bytes) {
@@ -42,60 +37,54 @@
     ptr = buf;

     while (bytes >= state->bytes) {
+        state->shuffle(
+            state->buffer,
+            (UINT8 *)im->image[state->y + state->yoff] + state->xoff * im->pixelsize,
+            state->xsize);

-        state->shuffle(state->buffer,
-                   (UINT8*) im->image[state->y + state->yoff] +
-                   state->xoff * im->pixelsize, state->xsize);
-
-        if (state->y < state->ysize-1) {
-
+        if (state->y < state->ysize - 1) {
             /* any line but the last */
             for (n = 0; n < state->xsize; n += 8) {
-
-                i = state->buffer[n/8];
+                i = state->buffer[n / 8];

                 *ptr++ = '0';
                 *ptr++ = 'x';
-                *ptr++ = hex[(i>>4)&15];
-                *ptr++ = hex[i&15];
+                *ptr++ = hex[(i >> 4) & 15];
+                *ptr++ = hex[i & 15];
                 *ptr++ = ',';
                 bytes -= 5;

-                if (++state->count >= 79/5) {
+                if (++state->count >= 79 / 5) {
                     *ptr++ = '\n';
                     bytes--;
                     state->count = 0;
                 }
-
             }

             state->y++;

         } else {
-
             /* last line */
             for (n = 0; n < state->xsize; n += 8) {
-
-                i = state->buffer[n/8];
+                i = state->buffer[n / 8];

                 *ptr++ = '0';
                 *ptr++ = 'x';
-                *ptr++ = hex[(i>>4)&15];
-                *ptr++ = hex[i&15];
+                *ptr++ = hex[(i >> 4) & 15];
+                *ptr++ = hex[i & 15];

-                if (n < state->xsize-8) {
+                if (n < state->xsize - 8) {
                     *ptr++ = ',';
-                    if (++state->count >= 79/5) {
-                    *ptr++ = '\n';
-                    bytes--;
-                    state->count = 0;
+                    if (++state->count >= 79 / 5) {
+                        *ptr++ = '\n';
+                        bytes--;
+                        state->count = 0;
                     }
                 } else {
                     *ptr++ = '\n';
                 }

                 bytes -= 5;
-
             }

             state->errcode = IMAGING_CODEC_END;
('src/libImaging', 'GifDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,7 +21,6 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

 #include <stdio.h>
@@ -29,48 +28,44 @@

 #include "Gif.h"

-
-#define NEWLINE(state, context) {\
-    state->x = 0;\
-    state->y += context->step;\
-    while (state->y >= state->ysize)\
-        switch (context->interlace) {\
-            case 1:\
-                context->repeat = state->y = 4;\
-                context->interlace = 2;\
-                break;\
-            case 2:\
-                context->step = 4;\
-                context->repeat = state->y = 2;\
-                context->interlace = 3;\
-                break;\
-            case 3:\
-                context->step = 2;\
-                context->repeat = state->y = 1;\
-                context->interlace = 0;\
-                break;\
-            default:\
-                return -1;\
-        }\
-    if (state->y < state->ysize) {\
-        out = im->image8[state->y + state->yoff] + state->xoff;\
-    }\
-}
-
+#define NEWLINE(state, context)                                        \
+    {                                                                  \
+        state->x = 0;                                                  \
+        state->y += context->step;                                     \
+        while (state->y >= state->ysize) switch (context->interlace) { \
+                case 1:                                                \
+                    context->repeat = state->y = 4;                    \
+                    context->interlace = 2;                            \
+                    break;                                             \
+                case 2:                                                \
+                    context->step = 4;                                 \
+                    context->repeat = state->y = 2;                    \
+                    context->interlace = 3;                            \
+                    break;                                             \
+                case 3:                                                \
+                    context->step = 2;                                 \
+                    context->repeat = state->y = 1;                    \
+                    context->interlace = 0;                            \
+                    break;                                             \
+                default:                                               \
+                    return -1;                                         \
+            }                                                          \
+        if (state->y < state->ysize) {                                 \
+            out = im->image8[state->y + state->yoff] + state->xoff;    \
+        }                                                              \
+    }

 int
-ImagingGifDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes)
-{
-    UINT8* p;
-    UINT8* out;
+ImagingGifDecode(Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes) {
+    UINT8 *p;
+    UINT8 *out;
     int c, i;
     int thiscode;
-    GIFDECODERSTATE *context = (GIFDECODERSTATE*) state->context;
+    GIFDECODERSTATE *context = (GIFDECODERSTATE *)state->context;

     UINT8 *ptr = buffer;

     if (!state->state) {
-
         /* Initialise state */
         if (context->bits < 0 || context->bits > 12) {
             state->errcode = IMAGING_CODEC_CONFIG;
@@ -97,9 +92,7 @@
     out = im->image8[state->y + state->yoff] + state->xoff + state->x;

     for (;;) {
-
         if (state->state == 1) {
-
             /* First free entry in table */
             context->next = context->clear + 2;

@@ -115,7 +108,6 @@
         }

         if (context->bufferindex < GIFBUFFER) {
-
             /* Return whole buffer in one chunk */
             i = GIFBUFFER - context->bufferindex;
             p = &context->buffer[context->bufferindex];
@@ -123,24 +115,21 @@
             context->bufferindex = GIFBUFFER;

         } else {
-
             /* Get current symbol */

             while (context->bitcount < context->codesize) {
-
                 if (context->blocksize > 0) {
-
                     /* Read next byte */
-                    c = *ptr++; bytes--;
+                    c = *ptr++;
+                    bytes--;

                     context->blocksize--;

                     /* New bits are shifted in from from the left. */
-                    context->bitbuffer |= (INT32) c << context->bitcount;
+                    context->bitbuffer |= (INT32)c << context->bitcount;
                     context->bitcount += 8;

                 } else {
-
                     /* New GIF block */

                     /* We don't start decoding unless we have a full block */
@@ -148,19 +137,19 @@
                         return ptr - buffer;
                     }
                     c = *ptr;
-                    if (bytes < c+1) {
+                    if (bytes < c + 1) {
                         return ptr - buffer;
                     }

                     context->blocksize = c;

-                    ptr++; bytes--;
-
+                    ptr++;
+                    bytes--;
                 }
             }

             /* Extract current symbol from bit buffer. */
-            c = (int) context->bitbuffer & context->codemask;
+            c = (int)context->bitbuffer & context->codemask;

             /* Adjust buffer */
             context->bitbuffer >>= context->codesize;
@@ -185,7 +174,6 @@
             p = &context->lastdata;

             if (state->state == 2) {
-
                 /* First valid symbol after clear; use as is */
                 if (c > context->clear) {
                     state->errcode = IMAGING_CODEC_BROKEN;
@@ -196,7 +184,6 @@
                 state->state = 3;

             } else {
-
                 thiscode = c;

                 if (c > context->next) {
@@ -205,7 +192,6 @@
                 }

                 if (c == context->next) {
-
                     /* c == next is allowed. not sure why. */

                     if (context->bufferindex <= 0) {
@@ -213,15 +199,12 @@
                         return -1;
                     }

-                    context->buffer[--context->bufferindex] =
-                    context->lastdata;
+                    context->buffer[--context->bufferindex] = context->lastdata;

                     c = context->lastcode;
-
                 }

                 while (c >= context->clear) {
-
                     /* Copy data string to buffer (beginning from right) */

                     if (context->bufferindex <= 0 || c >= GIFTABLE) {
@@ -229,8 +212,7 @@
                         return -1;
                     }

-                    context->buffer[--context->bufferindex] =
-                    context->data[c];
+                    context->buffer[--context->bufferindex] = context->data[c];

                     c = context->link[c];
                 }
@@ -238,26 +220,22 @@
                 context->lastdata = c;

                 if (context->next < GIFTABLE) {
-
                     /* We'll only add this symbol if we have room
-                       for it (take advise, Netscape!) */
+                       for it (take the advice, Netscape!) */
                     context->data[context->next] = c;
                     context->link[context->next] = context->lastcode;

                     if (context->next == context->codemask &&
-                    context->codesize < GIFBITS) {
-
+                        context->codesize < GIFBITS) {
                         /* Expand code size */
                         context->codesize++;
                         context->codemask = (1 << context->codesize) - 1;
                     }

                     context->next++;
-
                 }

                 context->lastcode = thiscode;
-
             }
         }

@@ -270,29 +248,33 @@
         /* To squeeze some extra pixels out of this loop, we test for
            some common cases and handle them separately. */

-        /* FIXME: should we handle the transparency index in here??? */
-
-        if (i == 1) {
-            if (state->x < state->xsize-1) {
-                /* Single pixel, not at the end of the line. */
-                *out++ = p[0];
-                state->x++;
+        /* This cannot be used if there is transparency */
+        if (context->transparency == -1) {
+            if (i == 1) {
+                if (state->x < state->xsize - 1) {
+                    /* Single pixel, not at the end of the line. */
+                    *out++ = p[0];
+                    state->x++;
+                    continue;
+                }
+            } else if (state->x + i <= state->xsize) {
+                /* This string fits into current line. */
+                memcpy(out, p, i);
+                out += i;
+                state->x += i;
+                if (state->x == state->xsize) {
+                    NEWLINE(state, context);
+                }
                 continue;
             }
-        } else if (state->x + i <= state->xsize) {
-            /* This string fits into current line. */
-            memcpy(out, p, i);
-                out += i;
-            state->x += i;
-            if (state->x == state->xsize) {
-                NEWLINE(state, context);
-            }
-            continue;
         }

         /* No shortcut, copy pixel by pixel */
         for (c = 0; c < i; c++) {
-            *out++ = p[c];
+            if (p[c] != context->transparency) {
+                *out = p[c];
+            }
+            out++;
             if (++state->x >= state->xsize) {
                 NEWLINE(state, context);
             }
('src/libImaging', 'Except.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,41 +19,34 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"
-

 /* exception state */

 void *
-ImagingError_OSError(void)
-{
+ImagingError_OSError(void) {
     fprintf(stderr, "*** exception: file access error\n");
     return NULL;
 }

 void *
-ImagingError_MemoryError(void)
-{
+ImagingError_MemoryError(void) {
     fprintf(stderr, "*** exception: out of memory\n");
     return NULL;
 }

 void *
-ImagingError_ModeError(void)
-{
+ImagingError_ModeError(void) {
     return ImagingError_ValueError("bad image mode");
 }

 void *
-ImagingError_Mismatch(void)
-{
+ImagingError_Mismatch(void) {
     return ImagingError_ValueError("images don't match");
 }

 void *
-ImagingError_ValueError(const char *message)
-{
+ImagingError_ValueError(const char *message) {
     if (!message) {
         message = "exception: bad argument to function";
     }
@@ -62,21 +55,18 @@
 }

 void
-ImagingError_Clear(void)
-{
+ImagingError_Clear(void) {
     /* nop */;
 }

 /* thread state */

 void
-ImagingSectionEnter(ImagingSectionCookie* cookie)
-{
+ImagingSectionEnter(ImagingSectionCookie *cookie) {
     /* pass */
 }

 void
-ImagingSectionLeave(ImagingSectionCookie* cookie)
-{
+ImagingSectionLeave(ImagingSectionCookie *cookie) {
     /* pass */
 }
('src/libImaging', 'QuantOctree.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -31,490 +31,508 @@
 #include "ImagingUtils.h"
 #include "QuantOctree.h"

-typedef struct _ColorBucket{
-   /* contains palette index when used for look up cube */
-   uint32_t count;
-   uint64_t r;
-   uint64_t g;
-   uint64_t b;
-   uint64_t a;
-} *ColorBucket;
-
-typedef struct _ColorCube{
-   unsigned int rBits, gBits, bBits, aBits;
-   unsigned int rWidth, gWidth, bWidth, aWidth;
-   unsigned int rOffset, gOffset, bOffset, aOffset;
-
-   unsigned long size;
-   ColorBucket buckets;
-} *ColorCube;
-
-#define MAX(a, b) (a)>(b) ? (a) : (b)
+typedef struct _ColorBucket {
+    /* contains palette index when used for look up cube */
+    uint32_t count;
+    uint64_t r;
+    uint64_t g;
+    uint64_t b;
+    uint64_t a;
+} * ColorBucket;
+
+typedef struct _ColorCube {
+    unsigned int rBits, gBits, bBits, aBits;
+    unsigned int rWidth, gWidth, bWidth, aWidth;
+    unsigned int rOffset, gOffset, bOffset, aOffset;
+
+    unsigned long size;
+    ColorBucket buckets;
+} * ColorCube;
+
+#define MAX(a, b) (a) > (b) ? (a) : (b)

 static ColorCube
 new_color_cube(int r, int g, int b, int a) {
-   ColorCube cube;
-
-   /* malloc check ok, small constant allocation */
-   cube = malloc(sizeof(struct _ColorCube));
-   if (!cube) {
-       return NULL;
-    }
-
-   cube->rBits = MAX(r, 0);
-   cube->gBits = MAX(g, 0);
-   cube->bBits = MAX(b, 0);
-   cube->aBits = MAX(a, 0);
-
-   /* overflow check for size multiplication below */
-   if (cube->rBits + cube->gBits + cube->bBits + cube->aBits > 31) {
-       free(cube);
-       return NULL;
-   }
-
-   /* the width of the cube for each dimension */
-   cube->rWidth = 1<<cube->rBits;
-   cube->gWidth = 1<<cube->gBits;
-   cube->bWidth = 1<<cube->bBits;
-   cube->aWidth = 1<<cube->aBits;
-
-   /* the offsets of each color */
-
-   cube->rOffset = cube->gBits + cube->bBits + cube->aBits;
-   cube->gOffset = cube->bBits + cube->aBits;
-   cube->bOffset = cube->aBits;
-   cube->aOffset = 0;
-
-   /* the number of color buckets */
-   cube->size = cube->rWidth * cube->gWidth * cube->bWidth * cube->aWidth;
-   /* malloc check ok, overflow checked above */
-   cube->buckets = calloc(cube->size, sizeof(struct _ColorBucket));
-
-   if (!cube->buckets) {
-      free(cube);
-      return NULL;
-   }
-   return cube;
+    ColorCube cube;
+
+    /* malloc check ok, small constant allocation */
+    cube = malloc(sizeof(struct _ColorCube));
+    if (!cube) {
+        return NULL;
+    }
+
+    cube->rBits = MAX(r, 0);
+    cube->gBits = MAX(g, 0);
+    cube->bBits = MAX(b, 0);
+    cube->aBits = MAX(a, 0);
+
+    /* overflow check for size multiplication below */
+    if (cube->rBits + cube->gBits + cube->bBits + cube->aBits > 31) {
+        free(cube);
+        return NULL;
+    }
+
+    /* the width of the cube for each dimension */
+    cube->rWidth = 1 << cube->rBits;
+    cube->gWidth = 1 << cube->gBits;
+    cube->bWidth = 1 << cube->bBits;
+    cube->aWidth = 1 << cube->aBits;
+
+    /* the offsets of each color */
+
+    cube->rOffset = cube->gBits + cube->bBits + cube->aBits;
+    cube->gOffset = cube->bBits + cube->aBits;
+    cube->bOffset = cube->aBits;
+    cube->aOffset = 0;
+
+    /* the number of color buckets */
+    cube->size = cube->rWidth * cube->gWidth * cube->bWidth * cube->aWidth;
+    /* malloc check ok, overflow checked above */
+    cube->buckets = calloc(cube->size, sizeof(struct _ColorBucket));
+
+    if (!cube->buckets) {
+        free(cube);
+        return NULL;
+    }
+    return cube;
 }

 static void
 free_color_cube(ColorCube cube) {
-   if (cube != NULL) {
-      free(cube->buckets);
-      free(cube);
-   }
+    if (cube != NULL) {
+        free(cube->buckets);
+        free(cube);
+    }
 }

 static long
-color_bucket_offset_pos(const ColorCube cube,
-   unsigned int r, unsigned int g, unsigned int b, unsigned int a)
-{
-   return r<<cube->rOffset | g<<cube->gOffset | b<<cube->bOffset | a<<cube->aOffset;
+color_bucket_offset_pos(
+    const ColorCube cube,
+    unsigned int r,
+    unsigned int g,
+    unsigned int b,
+    unsigned int a) {
+    return r << cube->rOffset | g << cube->gOffset | b << cube->bOffset |
+           a << cube->aOffset;
 }

 static long
 color_bucket_offset(const ColorCube cube, const Pixel *p) {
-   unsigned int r = p->c.r>>(8-cube->rBits);
-   unsigned int g = p->c.g>>(8-cube->gBits);
-   unsigned int b = p->c.b>>(8-cube->bBits);
-   unsigned int a = p->c.a>>(8-cube->aBits);
-   return color_bucket_offset_pos(cube, r, g, b, a);
+    unsigned int r = p->c.r >> (8 - cube->rBits);
+    unsigned int g = p->c.g >> (8 - cube->gBits);
+    unsigned int b = p->c.b >> (8 - cube->bBits);
+    unsigned int a = p->c.a >> (8 - cube->aBits);
+    return color_bucket_offset_pos(cube, r, g, b, a);
 }

 static ColorBucket
 color_bucket_from_cube(const ColorCube cube, const Pixel *p) {
-   unsigned int offset = color_bucket_offset(cube, p);
-   return &cube->buckets[offset];
+    unsigned int offset = color_bucket_offset(cube, p);
+    return &cube->buckets[offset];
 }

 static void
 add_color_to_color_cube(const ColorCube cube, const Pixel *p) {
-   ColorBucket bucket = color_bucket_from_cube(cube, p);
-   bucket->count += 1;
-   bucket->r += p->c.r;
-   bucket->g += p->c.g;
-   bucket->b += p->c.b;
-   bucket->a += p->c.a;
+    ColorBucket bucket = color_bucket_from_cube(cube, p);
+    bucket->count += 1;
+    bucket->r += p->c.r;
+    bucket->g += p->c.g;
+    bucket->b += p->c.b;
+    bucket->a += p->c.a;
 }

 static unsigned long
 count_used_color_buckets(const ColorCube cube) {
-   unsigned long usedBuckets = 0;
-   unsigned long i;
-   for (i=0; i < cube->size; i++) {
-      if (cube->buckets[i].count > 0) {
-         usedBuckets += 1;
-      }
-   }
-   return usedBuckets;
+    unsigned long usedBuckets = 0;
+    unsigned long i;
+    for (i = 0; i < cube->size; i++) {
+        if (cube->buckets[i].count > 0) {
+            usedBuckets += 1;
+        }
+    }
+    return usedBuckets;
 }

 static void
 avg_color_from_color_bucket(const ColorBucket bucket, Pixel *dst) {
-   float count = bucket->count;
-   if (count != 0) {
-       dst->c.r = CLIP8((int)(bucket->r / count));
-       dst->c.g = CLIP8((int)(bucket->g / count));
-       dst->c.b = CLIP8((int)(bucket->b / count));
-       dst->c.a = CLIP8((int)(bucket->a / count));
-   } else {
-       dst->c.r = 0;
-       dst->c.g = 0;
-       dst->c.b = 0;
-       dst->c.a = 0;
-   }
+    float count = bucket->count;
+    if (count != 0) {
+        dst->c.r = CLIP8((int)(bucket->r / count));
+        dst->c.g = CLIP8((int)(bucket->g / count));
+        dst->c.b = CLIP8((int)(bucket->b / count));
+        dst->c.a = CLIP8((int)(bucket->a / count));
+    } else {
+        dst->c.r = 0;
+        dst->c.g = 0;
+        dst->c.b = 0;
+        dst->c.a = 0;
+    }
 }

 static int
 compare_bucket_count(const ColorBucket a, const ColorBucket b) {
-   return b->count - a->count;
+    return b->count - a->count;
 }

 static ColorBucket
 create_sorted_color_palette(const ColorCube cube) {
-   ColorBucket buckets;
-   if (cube->size > LONG_MAX / sizeof(struct _ColorBucket)) {
-       return NULL;
-   }
-   /* malloc check ok, calloc + overflow check above for memcpy */
-   buckets = calloc(cube->size, sizeof(struct _ColorBucket));
-   if (!buckets) {
-       return NULL;
-   }
-   memcpy(buckets, cube->buckets, sizeof(struct _ColorBucket)*cube->size);
-
-   qsort(buckets, cube->size, sizeof(struct _ColorBucket),
-         (int (*)(void const *, void const *))&compare_bucket_count);
-
-   return buckets;
-}
-
-void add_bucket_values(ColorBucket src, ColorBucket dst) {
-   dst->count += src->count;
-   dst->r += src->r;
-   dst->g += src->g;
-   dst->b += src->b;
-   dst->a += src->a;
+    ColorBucket buckets;
+    if (cube->size > LONG_MAX / sizeof(struct _ColorBucket)) {
+        return NULL;
+    }
+    /* malloc check ok, calloc + overflow check above for memcpy */
+    buckets = calloc(cube->size, sizeof(struct _ColorBucket));
+    if (!buckets) {
+        return NULL;
+    }
+    memcpy(buckets, cube->buckets, sizeof(struct _ColorBucket) * cube->size);
+
+    qsort(
+        buckets,
+        cube->size,
+        sizeof(struct _ColorBucket),
+        (int (*)(void const *, void const *)) & compare_bucket_count);
+
+    return buckets;
+}
+
+void
+add_bucket_values(ColorBucket src, ColorBucket dst) {
+    dst->count += src->count;
+    dst->r += src->r;
+    dst->g += src->g;
+    dst->b += src->b;
+    dst->a += src->a;
 }

 /* expand or shrink a given cube to level */
-static ColorCube copy_color_cube(const ColorCube cube,
-   unsigned int rBits, unsigned int gBits, unsigned int bBits, unsigned int aBits)
-{
-   unsigned int r, g, b, a;
-   long src_pos, dst_pos;
-   unsigned int src_reduce[4] = {0}, dst_reduce[4] = {0};
-   unsigned int width[4];
-   ColorCube result;
-
-   result = new_color_cube(rBits, gBits, bBits, aBits);
-   if (!result) {
-       return NULL;
-   }
-
-   if (cube->rBits > rBits) {
-      dst_reduce[0] = cube->rBits - result->rBits;
-      width[0] = cube->rWidth;
-   } else {
-      src_reduce[0] = result->rBits - cube->rBits;
-      width[0] = result->rWidth;
-   }
-   if (cube->gBits > gBits) {
-      dst_reduce[1] = cube->gBits - result->gBits;
-      width[1] = cube->gWidth;
-   } else {
-      src_reduce[1] = result->gBits - cube->gBits;
-      width[1] = result->gWidth;
-   }
-   if (cube->bBits > bBits) {
-      dst_reduce[2] = cube->bBits - result->bBits;
-      width[2] = cube->bWidth;
-   } else {
-      src_reduce[2] = result->bBits - cube->bBits;
-      width[2] = result->bWidth;
-   }
-   if (cube->aBits > aBits) {
-      dst_reduce[3] = cube->aBits - result->aBits;
-      width[3] = cube->aWidth;
-   } else {
-      src_reduce[3] = result->aBits - cube->aBits;
-      width[3] = result->aWidth;
-   }
-
-   for (r=0; r<width[0]; r++) {
-      for (g=0; g<width[1]; g++) {
-         for (b=0; b<width[2]; b++) {
-            for (a=0; a<width[3]; a++) {
-               src_pos = color_bucket_offset_pos(cube,
-                                               r>>src_reduce[0],
-                                               g>>src_reduce[1],
-                                               b>>src_reduce[2],
-                                               a>>src_reduce[3]);
-               dst_pos = color_bucket_offset_pos(result,
-                                               r>>dst_reduce[0],
-                                               g>>dst_reduce[1],
-                                               b>>dst_reduce[2],
-                                               a>>dst_reduce[3]);
-               add_bucket_values(
-                  &cube->buckets[src_pos],
-                  &result->buckets[dst_pos]
-               );
+static ColorCube
+copy_color_cube(
+    const ColorCube cube,
+    unsigned int rBits,
+    unsigned int gBits,
+    unsigned int bBits,
+    unsigned int aBits) {
+    unsigned int r, g, b, a;
+    long src_pos, dst_pos;
+    unsigned int src_reduce[4] = {0}, dst_reduce[4] = {0};
+    unsigned int width[4];
+    ColorCube result;
+
+    result = new_color_cube(rBits, gBits, bBits, aBits);
+    if (!result) {
+        return NULL;
+    }
+
+    if (cube->rBits > rBits) {
+        dst_reduce[0] = cube->rBits - result->rBits;
+        width[0] = cube->rWidth;
+    } else {
+        src_reduce[0] = result->rBits - cube->rBits;
+        width[0] = result->rWidth;
+    }
+    if (cube->gBits > gBits) {
+        dst_reduce[1] = cube->gBits - result->gBits;
+        width[1] = cube->gWidth;
+    } else {
+        src_reduce[1] = result->gBits - cube->gBits;
+        width[1] = result->gWidth;
+    }
+    if (cube->bBits > bBits) {
+        dst_reduce[2] = cube->bBits - result->bBits;
+        width[2] = cube->bWidth;
+    } else {
+        src_reduce[2] = result->bBits - cube->bBits;
+        width[2] = result->bWidth;
+    }
+    if (cube->aBits > aBits) {
+        dst_reduce[3] = cube->aBits - result->aBits;
+        width[3] = cube->aWidth;
+    } else {
+        src_reduce[3] = result->aBits - cube->aBits;
+        width[3] = result->aWidth;
+    }
+
+    for (r = 0; r < width[0]; r++) {
+        for (g = 0; g < width[1]; g++) {
+            for (b = 0; b < width[2]; b++) {
+                for (a = 0; a < width[3]; a++) {
+                    src_pos = color_bucket_offset_pos(
+                        cube,
+                        r >> src_reduce[0],
+                        g >> src_reduce[1],
+                        b >> src_reduce[2],
+                        a >> src_reduce[3]);
+                    dst_pos = color_bucket_offset_pos(
+                        result,
+                        r >> dst_reduce[0],
+                        g >> dst_reduce[1],
+                        b >> dst_reduce[2],
+                        a >> dst_reduce[3]);
+                    add_bucket_values(
+                        &cube->buckets[src_pos], &result->buckets[dst_pos]);
+                }
             }
-         }
-      }
-   }
-   return result;
+        }
+    }
+    return result;
 }

 void
 subtract_color_buckets(ColorCube cube, ColorBucket buckets, long nBuckets) {
-   ColorBucket minuend, subtrahend;
-   long i;
-   Pixel p;
-   for (i=0; i<nBuckets; i++) {
-      subtrahend = &buckets[i];
-
-      // If the subtrahend contains no buckets, there is nothing to subtract.
-      if (subtrahend->count == 0) {
-          continue;
-      }
-
-      avg_color_from_color_bucket(subtrahend, &p);
-      minuend = color_bucket_from_cube(cube, &p);
-      minuend->count -= subtrahend->count;
-      minuend->r -= subtrahend->r;
-      minuend->g -= subtrahend->g;
-      minuend->b -= subtrahend->b;
-      minuend->a -= subtrahend->a;
-   }
+    ColorBucket minuend, subtrahend;
+    long i;
+    Pixel p;
+    for (i = 0; i < nBuckets; i++) {
+        subtrahend = &buckets[i];
+
+        // If the subtrahend contains no buckets, there is nothing to subtract.
+        if (subtrahend->count == 0) {
+            continue;
+        }
+
+        avg_color_from_color_bucket(subtrahend, &p);
+        minuend = color_bucket_from_cube(cube, &p);
+        minuend->count -= subtrahend->count;
+        minuend->r -= subtrahend->r;
+        minuend->g -= subtrahend->g;
+        minuend->b -= subtrahend->b;
+        minuend->a -= subtrahend->a;
+    }
 }

 static void
 set_lookup_value(const ColorCube cube, const Pixel *p, long value) {
-   ColorBucket bucket = color_bucket_from_cube(cube, p);
-   bucket->count = value;
+    ColorBucket bucket = color_bucket_from_cube(cube, p);
+    bucket->count = value;
 }

 uint64_t
 lookup_color(const ColorCube cube, const Pixel *p) {
-   ColorBucket bucket = color_bucket_from_cube(cube, p);
-   return bucket->count;
-}
-
-void add_lookup_buckets(ColorCube cube, ColorBucket palette, long nColors, long offset) {
-   long i;
-   Pixel p;
-   for (i=offset; i<offset+nColors; i++) {
-      avg_color_from_color_bucket(&palette[i], &p);
-      set_lookup_value(cube, &p, i);
-   }
+    ColorBucket bucket = color_bucket_from_cube(cube, p);
+    return bucket->count;
+}
+
+void
+add_lookup_buckets(ColorCube cube, ColorBucket palette, long nColors, long offset) {
+    long i;
+    Pixel p;
+    for (i = offset + nColors - 1; i >= offset; i--) {
+        avg_color_from_color_bucket(&palette[i], &p);
+        set_lookup_value(cube, &p, i);
+    }
 }

 ColorBucket
-combined_palette(ColorBucket bucketsA, unsigned long nBucketsA, ColorBucket bucketsB, unsigned long nBucketsB) {
-   ColorBucket result;
-   if (nBucketsA > LONG_MAX - nBucketsB ||
-       (nBucketsA+nBucketsB) > LONG_MAX / sizeof(struct _ColorBucket)) {
-       return NULL;
-   }
-   /* malloc check ok, overflow check above */
-   result = calloc(nBucketsA + nBucketsB, sizeof(struct _ColorBucket));
-   if (!result) {
-       return NULL;
-   }
-   memcpy(result, bucketsA, sizeof(struct _ColorBucket) * nBucketsA);
-   memcpy(&result[nBucketsA], bucketsB, sizeof(struct _ColorBucket) * nBucketsB);
-   return result;
+combined_palette(
+    ColorBucket bucketsA,
+    unsigned long nBucketsA,
+    ColorBucket bucketsB,
+    unsigned long nBucketsB) {
+    ColorBucket result;
+    if (nBucketsA > LONG_MAX - nBucketsB ||
+        (nBucketsA + nBucketsB) > LONG_MAX / sizeof(struct _ColorBucket)) {
+        return NULL;
+    }
+    /* malloc check ok, overflow check above */
+    result = calloc(nBucketsA + nBucketsB, sizeof(struct _ColorBucket));
+    if (!result) {
+        return NULL;
+    }
+    memcpy(result, bucketsA, sizeof(struct _ColorBucket) * nBucketsA);
+    memcpy(&result[nBucketsA], bucketsB, sizeof(struct _ColorBucket) * nBucketsB);
+    return result;
 }

 static Pixel *
 create_palette_array(const ColorBucket palette, unsigned int paletteLength) {
-   Pixel *paletteArray;
-   unsigned int i;
-
-   /* malloc check ok, calloc for overflow */
-   paletteArray = calloc(paletteLength, sizeof(Pixel));
-   if (!paletteArray) {
-       return NULL;
-   }
-
-   for (i=0; i<paletteLength; i++) {
-      avg_color_from_color_bucket(&palette[i], &paletteArray[i]);
-   }
-   return paletteArray;
+    Pixel *paletteArray;
+    unsigned int i;
+
+    /* malloc check ok, calloc for overflow */
+    paletteArray = calloc(paletteLength, sizeof(Pixel));
+    if (!paletteArray) {
+        return NULL;
+    }
+
+    for (i = 0; i < paletteLength; i++) {
+        avg_color_from_color_bucket(&palette[i], &paletteArray[i]);
+    }
+    return paletteArray;
 }

 static void
-map_image_pixels(const Pixel *pixelData,
-                 uint32_t nPixels,
-                 const ColorCube lookupCube,
-                 uint32_t *pixelArray)
-{
-   long i;
-   for (i=0; i<nPixels; i++) {
-      pixelArray[i] = lookup_color(lookupCube, &pixelData[i]);
-   }
-}
-
-const unsigned int CUBE_LEVELS[8]       = {4, 4, 4, 0, 2, 2, 2, 0};
+map_image_pixels(
+    const Pixel *pixelData,
+    uint32_t nPixels,
+    const ColorCube lookupCube,
+    uint32_t *pixelArray) {
+    long i;
+    for (i = 0; i < nPixels; i++) {
+        pixelArray[i] = lookup_color(lookupCube, &pixelData[i]);
+    }
+}
+
+const unsigned int CUBE_LEVELS[8] = {4, 4, 4, 0, 2, 2, 2, 0};
 const unsigned int CUBE_LEVELS_ALPHA[8] = {3, 4, 3, 3, 2, 2, 2, 2};

-int quantize_octree(Pixel *pixelData,
-          uint32_t nPixels,
-          uint32_t nQuantPixels,
-          Pixel **palette,
-          uint32_t *paletteLength,
-          uint32_t **quantizedPixels,
-          int withAlpha)
-{
-   ColorCube fineCube = NULL;
-   ColorCube coarseCube = NULL;
-   ColorCube lookupCube = NULL;
-   ColorCube coarseLookupCube = NULL;
-   ColorBucket paletteBucketsCoarse = NULL;
-   ColorBucket paletteBucketsFine = NULL;
-   ColorBucket paletteBuckets = NULL;
-   uint32_t *qp = NULL;
-   long i;
-   unsigned long nCoarseColors, nFineColors, nAlreadySubtracted;
-   const unsigned int *cubeBits;
-
-   if (withAlpha) {
-       cubeBits = CUBE_LEVELS_ALPHA;
-   }
-   else {
-       cubeBits = CUBE_LEVELS;
-   }
-
-   /*
-   Create two color cubes, one fine grained with 8x16x8=1024
-   colors buckets and a coarse with 4x4x4=64 color buckets.
-   The coarse one guarantees that there are color buckets available for
-   the whole color range (assuming nQuantPixels > 64).
-
-   For a quantization to 256 colors all 64 coarse colors will be used
-   plus the 192 most used color buckets from the fine color cube.
-   The average of all colors within one bucket is used as the actual
-   color for that bucket.
-
-    For images with alpha the cubes gets a forth dimension,
-    8x16x8x8 and 4x4x4x4.
-   */
-
-   /* create fine cube */
-   fineCube = new_color_cube(cubeBits[0], cubeBits[1],
-                             cubeBits[2], cubeBits[3]);
-   if (!fineCube) {
-       goto error;
-   }
-   for (i=0; i<nPixels; i++) {
-      add_color_to_color_cube(fineCube, &pixelData[i]);
-   }
-
-   /* create coarse cube */
-   coarseCube = copy_color_cube(fineCube, cubeBits[4], cubeBits[5],
-                                          cubeBits[6], cubeBits[7]);
-   if (!coarseCube) {
-       goto error;
-   }
-   nCoarseColors = count_used_color_buckets(coarseCube);
-
-   /* limit to nQuantPixels */
-   if (nCoarseColors > nQuantPixels) {
-      nCoarseColors = nQuantPixels;
-   }
-
-   /* how many space do we have in our palette for fine colors? */
-   nFineColors = nQuantPixels - nCoarseColors;
-
-   /* create fine color palette */
-   paletteBucketsFine = create_sorted_color_palette(fineCube);
-   if (!paletteBucketsFine) {
-       goto error;
-   }
-
-   /* remove the used fine colors from the coarse cube */
-   subtract_color_buckets(coarseCube, paletteBucketsFine, nFineColors);
-
-   /* did the subtraction cleared one or more coarse bucket? */
-   while (nCoarseColors > count_used_color_buckets(coarseCube)) {
-      /* then we can use the free buckets for fine colors */
-      nAlreadySubtracted = nFineColors;
-      nCoarseColors = count_used_color_buckets(coarseCube);
-      nFineColors = nQuantPixels - nCoarseColors;
-      subtract_color_buckets(coarseCube, &paletteBucketsFine[nAlreadySubtracted],
-                             nFineColors-nAlreadySubtracted);
-   }
-
-   /* create our palette buckets with fine and coarse combined */
-   paletteBucketsCoarse = create_sorted_color_palette(coarseCube);
-   if (!paletteBucketsCoarse) {
-       goto error;
-   }
-   paletteBuckets = combined_palette(paletteBucketsCoarse, nCoarseColors,
-                                     paletteBucketsFine, nFineColors);
-
-   free(paletteBucketsFine);
-   paletteBucketsFine = NULL;
-   free(paletteBucketsCoarse);
-   paletteBucketsCoarse = NULL;
-   if (!paletteBuckets) {
-       goto error;
-   }
-
-   /* add all coarse colors to our coarse lookup cube. */
-   coarseLookupCube = new_color_cube(cubeBits[4], cubeBits[5],
-                                     cubeBits[6], cubeBits[7]);
-   if (!coarseLookupCube) {
-       goto error;
-   }
-   add_lookup_buckets(coarseLookupCube, paletteBuckets, nCoarseColors, 0);
-
-   /* expand coarse cube (64) to larger fine cube (4k). the value of each
-      coarse bucket is then present in the according 64 fine buckets. */
-   lookupCube = copy_color_cube(coarseLookupCube, cubeBits[0], cubeBits[1],
-                                                  cubeBits[2], cubeBits[3]);
-   if (!lookupCube) {
-       goto error;
-   }
-
-   /* add fine colors to the lookup cube */
-   add_lookup_buckets(lookupCube, paletteBuckets, nFineColors, nCoarseColors);
-
-   /* create result pixels and map palette indices */
-   /* malloc check ok, calloc for overflow */
-   qp = calloc(nPixels, sizeof(Pixel));
-   if (!qp) {
-       goto error;
-   }
-   map_image_pixels(pixelData, nPixels, lookupCube, qp);
-
-   /* convert palette buckets to RGB pixel palette */
-   *palette = create_palette_array(paletteBuckets, nQuantPixels);
-   if (!(*palette)) {
-       goto error;
-   }
-
-   *quantizedPixels = qp;
-   *paletteLength = nQuantPixels;
-
-   free_color_cube(coarseCube);
-   free_color_cube(fineCube);
-   free_color_cube(lookupCube);
-   free_color_cube(coarseLookupCube);
-   free(paletteBuckets);
-   return 1;
+int
+quantize_octree(
+    Pixel *pixelData,
+    uint32_t nPixels,
+    uint32_t nQuantPixels,
+    Pixel **palette,
+    uint32_t *paletteLength,
+    uint32_t **quantizedPixels,
+    int withAlpha) {
+    ColorCube fineCube = NULL;
+    ColorCube coarseCube = NULL;
+    ColorCube lookupCube = NULL;
+    ColorCube coarseLookupCube = NULL;
+    ColorBucket paletteBucketsCoarse = NULL;
+    ColorBucket paletteBucketsFine = NULL;
+    ColorBucket paletteBuckets = NULL;
+    uint32_t *qp = NULL;
+    long i;
+    unsigned long nCoarseColors, nFineColors, nAlreadySubtracted;
+    const unsigned int *cubeBits;
+
+    if (withAlpha) {
+        cubeBits = CUBE_LEVELS_ALPHA;
+    } else {
+        cubeBits = CUBE_LEVELS;
+    }
+
+    /*
+    Create two color cubes, one fine grained with 8x16x8=1024
+    colors buckets and a coarse with 4x4x4=64 color buckets.
+    The coarse one guarantees that there are color buckets available for
+    the whole color range (assuming nQuantPixels > 64).
+
+    For a quantization to 256 colors all 64 coarse colors will be used
+    plus the 192 most used color buckets from the fine color cube.
+    The average of all colors within one bucket is used as the actual
+    color for that bucket.
+
+     For images with alpha the cubes gets a forth dimension,
+     8x16x8x8 and 4x4x4x4.
+    */
+
+    /* create fine cube */
+    fineCube = new_color_cube(cubeBits[0], cubeBits[1], cubeBits[2], cubeBits[3]);
+    if (!fineCube) {
+        goto error;
+    }
+    for (i = 0; i < nPixels; i++) {
+        add_color_to_color_cube(fineCube, &pixelData[i]);
+    }
+
+    /* create coarse cube */
+    coarseCube =
+        copy_color_cube(fineCube, cubeBits[4], cubeBits[5], cubeBits[6], cubeBits[7]);
+    if (!coarseCube) {
+        goto error;
+    }
+    nCoarseColors = count_used_color_buckets(coarseCube);
+
+    /* limit to nQuantPixels */
+    if (nCoarseColors > nQuantPixels) {
+        nCoarseColors = nQuantPixels;
+    }
+
+    /* how many space do we have in our palette for fine colors? */
+    nFineColors = nQuantPixels - nCoarseColors;
+
+    /* create fine color palette */
+    paletteBucketsFine = create_sorted_color_palette(fineCube);
+    if (!paletteBucketsFine) {
+        goto error;
+    }
+
+    /* remove the used fine colors from the coarse cube */
+    subtract_color_buckets(coarseCube, paletteBucketsFine, nFineColors);
+
+    /* did the subtraction cleared one or more coarse bucket? */
+    while (nCoarseColors > count_used_color_buckets(coarseCube)) {
+        /* then we can use the free buckets for fine colors */
+        nAlreadySubtracted = nFineColors;
+        nCoarseColors = count_used_color_buckets(coarseCube);
+        nFineColors = nQuantPixels - nCoarseColors;
+        subtract_color_buckets(
+            coarseCube,
+            &paletteBucketsFine[nAlreadySubtracted],
+            nFineColors - nAlreadySubtracted);
+    }
+
+    /* create our palette buckets with fine and coarse combined */
+    paletteBucketsCoarse = create_sorted_color_palette(coarseCube);
+    if (!paletteBucketsCoarse) {
+        goto error;
+    }
+    paletteBuckets = combined_palette(
+        paletteBucketsCoarse, nCoarseColors, paletteBucketsFine, nFineColors);
+
+    free(paletteBucketsFine);
+    paletteBucketsFine = NULL;
+    free(paletteBucketsCoarse);
+    paletteBucketsCoarse = NULL;
+    if (!paletteBuckets) {
+        goto error;
+    }
+
+    /* add all coarse colors to our coarse lookup cube. */
+    coarseLookupCube =
+        new_color_cube(cubeBits[4], cubeBits[5], cubeBits[6], cubeBits[7]);
+    if (!coarseLookupCube) {
+        goto error;
+    }
+    add_lookup_buckets(coarseLookupCube, paletteBuckets, nCoarseColors, 0);
+
+    /* expand coarse cube (64) to larger fine cube (4k). the value of each
+       coarse bucket is then present in the according 64 fine buckets. */
+    lookupCube = copy_color_cube(
+        coarseLookupCube, cubeBits[0], cubeBits[1], cubeBits[2], cubeBits[3]);
+    if (!lookupCube) {
+        goto error;
+    }
+
+    /* add fine colors to the lookup cube */
+    add_lookup_buckets(lookupCube, paletteBuckets, nFineColors, nCoarseColors);
+
+    /* create result pixels and map palette indices */
+    /* malloc check ok, calloc for overflow */
+    qp = calloc(nPixels, sizeof(Pixel));
+    if (!qp) {
+        goto error;
+    }
+    map_image_pixels(pixelData, nPixels, lookupCube, qp);
+
+    /* convert palette buckets to RGB pixel palette */
+    *palette = create_palette_array(paletteBuckets, nQuantPixels);
+    if (!(*palette)) {
+        goto error;
+    }
+
+    *quantizedPixels = qp;
+    *paletteLength = nQuantPixels;
+
+    free_color_cube(coarseCube);
+    free_color_cube(fineCube);
+    free_color_cube(lookupCube);
+    free_color_cube(coarseLookupCube);
+    free(paletteBuckets);
+    return 1;

 error:
-   /* everything is initialized to NULL
-      so we are safe to call free */
-   free(qp);
-   free_color_cube(lookupCube);
-   free_color_cube(coarseLookupCube);
-   free(paletteBuckets);
-   free(paletteBucketsCoarse);
-   free(paletteBucketsFine);
-   free_color_cube(coarseCube);
-   free_color_cube(fineCube);
-   return 0;
-}
+    /* everything is initialized to NULL
+       so we are safe to call free */
+    free(qp);
+    free_color_cube(lookupCube);
+    free_color_cube(coarseLookupCube);
+    free(paletteBuckets);
+    free(paletteBucketsCoarse);
+    free(paletteBucketsFine);
+    free_color_cube(coarseCube);
+    free_color_cube(fineCube);
+    return 0;
+}
('src/libImaging', 'Histo.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,9 +16,7 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"
-

 /* HISTOGRAM */
 /* --------------------------------------------------------------------
@@ -27,8 +25,7 @@
  */

 void
-ImagingHistogramDelete(ImagingHistogram h)
-{
+ImagingHistogramDelete(ImagingHistogram h) {
     if (h) {
         if (h->histogram) {
             free(h->histogram);
@@ -38,31 +35,29 @@
 }

 ImagingHistogram
-ImagingHistogramNew(Imaging im)
-{
+ImagingHistogramNew(Imaging im) {
     ImagingHistogram h;

     /* Create histogram descriptor */
     h = calloc(1, sizeof(struct ImagingHistogramInstance));
     if (!h) {
-        return (ImagingHistogram) ImagingError_MemoryError();
-    }
-    strncpy(h->mode, im->mode, IMAGING_MODE_LENGTH-1);
-    h->mode[IMAGING_MODE_LENGTH-1] = 0;
+        return (ImagingHistogram)ImagingError_MemoryError();
+    }
+    strncpy(h->mode, im->mode, IMAGING_MODE_LENGTH - 1);
+    h->mode[IMAGING_MODE_LENGTH - 1] = 0;

     h->bands = im->bands;
     h->histogram = calloc(im->pixelsize, 256 * sizeof(long));
     if (!h->histogram) {
         free(h);
-        return (ImagingHistogram) ImagingError_MemoryError();
+        return (ImagingHistogram)ImagingError_MemoryError();
     }

     return h;
 }

 ImagingHistogram
-ImagingGetHistogram(Imaging im, Imaging imMask, void* minmax)
-{
+ImagingGetHistogram(Imaging im, Imaging imMask, void *minmax) {
     ImagingSectionCookie cookie;
     int x, y, i;
     ImagingHistogram h;
@@ -107,13 +102,13 @@
             }
             ImagingSectionEnter(&cookie);
             for (y = 0; y < im->ysize; y++) {
-                UINT8* in = (UINT8*) im->image32[y];
+                UINT8 *in = (UINT8 *)im->image32[y];
                 for (x = 0; x < im->xsize; x++) {
                     if (imMask->image8[y][x] != 0) {
                         h->histogram[(*in++)]++;
-                        h->histogram[(*in++)+256]++;
-                        h->histogram[(*in++)+512]++;
-                        h->histogram[(*in++)+768]++;
+                        h->histogram[(*in++) + 256]++;
+                        h->histogram[(*in++) + 512]++;
+                        h->histogram[(*in++) + 768]++;
                     } else {
                         in += 4;
                     }
@@ -136,12 +131,12 @@
                 case IMAGING_TYPE_UINT8:
                     ImagingSectionEnter(&cookie);
                     for (y = 0; y < im->ysize; y++) {
-                        UINT8* in = (UINT8*) im->image[y];
+                        UINT8 *in = (UINT8 *)im->image[y];
                         for (x = 0; x < im->xsize; x++) {
                             h->histogram[(*in++)]++;
-                            h->histogram[(*in++)+256]++;
-                            h->histogram[(*in++)+512]++;
-                            h->histogram[(*in++)+768]++;
+                            h->histogram[(*in++) + 256]++;
+                            h->histogram[(*in++) + 512]++;
+                            h->histogram[(*in++) + 768]++;
                         }
                     }
                     ImagingSectionLeave(&cookie);
@@ -155,16 +150,16 @@
                         break;
                     }
                     memcpy(&imin, minmax, sizeof(imin));
-                    memcpy(&imax, ((char*)minmax) + sizeof(imin), sizeof(imax));
+                    memcpy(&imax, ((char *)minmax) + sizeof(imin), sizeof(imax));
                     if (imin >= imax) {
                         break;
                     }
                     ImagingSectionEnter(&cookie);
                     scale = 255.0F / (imax - imin);
                     for (y = 0; y < im->ysize; y++) {
-                        INT32* in = im->image32[y];
+                        INT32 *in = im->image32[y];
                         for (x = 0; x < im->xsize; x++) {
-                            i = (int) (((*in++)-imin)*scale);
+                            i = (int)(((*in++) - imin) * scale);
                             if (i >= 0 && i < 256) {
                                 h->histogram[i]++;
                             }
@@ -181,16 +176,16 @@
                         break;
                     }
                     memcpy(&fmin, minmax, sizeof(fmin));
-                    memcpy(&fmax, ((char*)minmax) + sizeof(fmin), sizeof(fmax));
+                    memcpy(&fmax, ((char *)minmax) + sizeof(fmin), sizeof(fmax));
                     if (fmin >= fmax) {
                         break;
                     }
                     ImagingSectionEnter(&cookie);
                     scale = 255.0F / (fmax - fmin);
                     for (y = 0; y < im->ysize; y++) {
-                        FLOAT32* in = (FLOAT32*) im->image32[y];
+                        FLOAT32 *in = (FLOAT32 *)im->image32[y];
                         for (x = 0; x < im->xsize; x++) {
-                            i = (int) (((*in++)-fmin)*scale);
+                            i = (int)(((*in++) - fmin) * scale);
                             if (i >= 0 && i < 256) {
                                 h->histogram[i]++;
                             }
('src/libImaging', 'GifEncode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -10,6 +10,7 @@
  * 98-07-09 fl added interlace write support
  * 99-02-07 fl rewritten, now uses a run-length encoding strategy
  * 99-02-08 fl improved run-length encoding for long runs
+ * 2020-12-12 rdg Reworked for LZW compression.
  *
  * Copyright (c) Secret Labs AB 1997-99.
  * Copyright (c) Fredrik Lundh 1997.
@@ -21,138 +22,206 @@

 #include "Gif.h"

-/* codes from 0 to 255 are literals */
-#define CLEAR_CODE 256
-#define EOF_CODE 257
-#define FIRST_CODE 258
-#define LAST_CODE 511
-
-enum { INIT, ENCODE, ENCODE_EOF, FLUSH, EXIT };
-
-/* to make things a little less complicated, we use a simple output
-   queue to hold completed blocks.  the following inlined function
-   adds a byte to the current block.  it allocates a new block if
-   necessary. */
-
-static inline int
-emit(GIFENCODERSTATE *context, int byte)
-{
-    /* write a byte to the output buffer */
-
-    if (!context->block || context->block->size == 255) {
-        GIFENCODERBLOCK* block;
-
-        /* no room in the current block (or no current block);
-           allocate a new one */
-
-        /* add current block to end of flush queue */
-        if (context->block) {
-            block = context->flush;
-            while (block && block->next) {
-                block = block->next;
-            }
-            if (block) {
-                block->next = context->block;
+enum { INIT, ENCODE, FINISH };
+
+/* GIF LZW encoder by Raymond Gardner. */
+/* Released here under PIL license. */
+
+/* This LZW encoder conforms to the GIF LZW format specified in the original
+ * Compuserve GIF 87a and GIF 89a specifications (see e.g.
+ * https://www.w3.org/Graphics/GIF/spec-gif87.txt Appendix C and
+ * https://www.w3.org/Graphics/GIF/spec-gif89a.txt Appendix F).
+ */
+
+/* Return values */
+#define GLZW_OK                 0
+#define GLZW_NO_INPUT_AVAIL     1
+#define GLZW_NO_OUTPUT_AVAIL    2
+#define GLZW_INTERNAL_ERROR     3
+
+#define CODE_LIMIT              4096
+
+/* Values of entry_state */
+enum { LZW_INITIAL, LZW_TRY_IN1, LZW_TRY_IN2, LZW_TRY_OUT1, LZW_TRY_OUT2,
+    LZW_FINISHED };
+
+/* Values of control_state */
+enum { PUT_HEAD, PUT_INIT_CLEAR, PUT_CLEAR, PUT_LAST_HEAD, PUT_END };
+
+static void glzwe_reset(GIFENCODERSTATE *st) {
+    st->next_code = st->end_code + 1;
+    st->max_code = 2 * st->clear_code - 1;
+    st->code_width = st->bits + 1;
+    memset(st->codes, 0, sizeof(st->codes));
+}
+
+static void glzwe_init(GIFENCODERSTATE *st) {
+    st->clear_code = 1 << st->bits;
+    st->end_code = st->clear_code + 1;
+    glzwe_reset(st);
+    st->entry_state = LZW_INITIAL;
+    st->buf_bits_left = 8;
+    st->code_buffer = 0;
+}
+
+static int glzwe(GIFENCODERSTATE *st, const UINT8 *in_ptr, UINT8 *out_ptr,
+        UINT32 *in_avail, UINT32 *out_avail,
+        UINT32 end_of_data) {
+    switch (st->entry_state) {
+
+    case LZW_TRY_IN1:
+get_first_byte:
+        if (!*in_avail) {
+            if (end_of_data) {
+                goto end_of_data;
+            }
+            st->entry_state = LZW_TRY_IN1;
+            return GLZW_NO_INPUT_AVAIL;
+        }
+        st->head = *in_ptr++;
+        (*in_avail)--;
+
+    case LZW_TRY_IN2:
+encode_loop:
+        if (!*in_avail) {
+            if (end_of_data) {
+                st->code = st->head;
+                st->put_state = PUT_LAST_HEAD;
+                goto put_code;
+            }
+            st->entry_state = LZW_TRY_IN2;
+            return GLZW_NO_INPUT_AVAIL;
+        }
+        st->tail = *in_ptr++;
+        (*in_avail)--;
+
+        /* Knuth TAOCP vol 3 sec. 6.4 algorithm D. */
+        /* Hash found experimentally to be pretty good. */
+        /* This works ONLY with TABLE_SIZE a power of 2. */
+        st->probe = ((st->head ^ (st->tail << 6)) * 31) & (TABLE_SIZE - 1);
+        while (st->codes[st->probe]) {
+            if ((st->codes[st->probe] & 0xFFFFF) ==
+                                        ((st->head << 8) | st->tail)) {
+                st->head = st->codes[st->probe] >> 20;
+                goto encode_loop;
             } else {
-                context->flush = context->block;
-            }
-        }
-
-        /* get a new block */
-        if (context->free) {
-            block = context->free;
-            context->free = NULL;
+        /* Reprobe decrement must be nonzero and relatively prime to table
+         * size. So, any odd positive number for power-of-2 size. */
+                if ((st->probe -= ((st->tail << 2) | 1)) < 0) {
+                    st->probe += TABLE_SIZE;
+                }
+            }
+        }
+        /* Key not found, probe is at empty slot. */
+        st->code = st->head;
+        st->put_state = PUT_HEAD;
+        goto put_code;
+insert_code_or_clear: /* jump here after put_code */
+        if (st->next_code < CODE_LIMIT) {
+            st->codes[st->probe] = (st->next_code << 20) |
+                                    (st->head << 8) | st->tail;
+            if (st->next_code > st->max_code) {
+                st->max_code = st->max_code * 2 + 1;
+                st->code_width++;
+            }
+            st->next_code++;
         } else {
-            /* malloc check ok, small constant allocation */
-            block = malloc(sizeof(GIFENCODERBLOCK));
-            if (!block) {
-                return 0;
-            }
-        }
-
-        block->size = 0;
-        block->next = NULL;
-
-        context->block = block;
-
+            st->code = st->clear_code;
+            st->put_state = PUT_CLEAR;
+            goto put_code;
+reset_after_clear: /* jump here after put_code */
+            glzwe_reset(st);
+        }
+        st->head = st->tail;
+        goto encode_loop;
+
+    case LZW_INITIAL:
+        glzwe_reset(st);
+        st->code = st->clear_code;
+        st->put_state = PUT_INIT_CLEAR;
+put_code:
+        st->code_bits_left = st->code_width;
+check_buf_bits:
+        if (!st->buf_bits_left) {   /* out buffer full */
+
+    case LZW_TRY_OUT1:
+            if (!*out_avail) {
+                st->entry_state = LZW_TRY_OUT1;
+                return GLZW_NO_OUTPUT_AVAIL;
+            }
+            *out_ptr++ = st->code_buffer;
+            (*out_avail)--;
+            st->code_buffer = 0;
+            st->buf_bits_left = 8;
+        }
+        /* code bits to pack */
+        UINT32 n = st->buf_bits_left < st->code_bits_left
+                        ? st->buf_bits_left : st->code_bits_left;
+        st->code_buffer |=
+                        (st->code & ((1 << n) - 1)) << (8 - st->buf_bits_left);
+        st->code >>= n;
+        st->buf_bits_left -= n;
+        st->code_bits_left -= n;
+        if (st->code_bits_left) {
+            goto check_buf_bits;
+        }
+        switch (st->put_state) {
+        case PUT_INIT_CLEAR:
+            goto get_first_byte;
+        case PUT_HEAD:
+            goto insert_code_or_clear;
+        case PUT_CLEAR:
+            goto reset_after_clear;
+        case PUT_LAST_HEAD:
+            goto end_of_data;
+        case PUT_END:
+            goto flush_code_buffer;
+        default:
+            return GLZW_INTERNAL_ERROR;
+        }
+
+end_of_data:
+        st->code = st->end_code;
+        st->put_state = PUT_END;
+        goto put_code;
+flush_code_buffer: /* jump here after put_code */
+        if (st->buf_bits_left < 8) {
+
+    case LZW_TRY_OUT2:
+            if (!*out_avail) {
+                st->entry_state = LZW_TRY_OUT2;
+                return GLZW_NO_OUTPUT_AVAIL;
+            }
+            *out_ptr++ = st->code_buffer;
+            (*out_avail)--;
+        }
+        st->entry_state = LZW_FINISHED;
+        return GLZW_OK;
+
+    case LZW_FINISHED:
+        return GLZW_OK;
+
+    default:
+        return GLZW_INTERNAL_ERROR;
     }
-
-    /* write new byte to block */
-    context->block->data[context->block->size++] = byte;
-
-    return 1;
 }
-
-/* write a code word to the current block.  this is a macro to make
-   sure it's inlined on all platforms */
-
-#define EMIT(code) {\
-    context->bitbuffer |= ((INT32) (code)) << context->bitcount;\
-    context->bitcount += 9;\
-    while (context->bitcount >= 8) {\
-        if (!emit(context, (UINT8) context->bitbuffer)) {\
-            state->errcode = IMAGING_CODEC_MEMORY;\
-            return 0;\
-        }\
-        context->bitbuffer >>= 8;\
-        context->bitcount -= 8;\
-    }\
-}
-
-/* write a run.  we use a combination of literals and combinations of
-   literals.  this can give quite decent compression for images with
-   long stretches of identical pixels.  but remember: if you want
-   really good compression, use another file format. */
-
-#define EMIT_RUN(label) {\
-label:\
-    while (context->count > 0) {\
-        int run = 2;\
-        EMIT(context->last);\
-        context->count--;\
-        if (state->count++ == LAST_CODE) {\
-            EMIT(CLEAR_CODE);\
-            state->count = FIRST_CODE;\
-            goto label;\
-        }\
-        while (context->count >= run) {\
-            EMIT(state->count - 1);\
-            context->count -= run;\
-            run++;\
-            if (state->count++ == LAST_CODE) {\
-                EMIT(CLEAR_CODE);\
-                state->count = FIRST_CODE;\
-                goto label;\
-            }\
-        }\
-        if (context->count > 1) {\
-            EMIT(state->count - 1 - (run - context->count));\
-            context->count = 0;\
-            if (state->count++ == LAST_CODE) {\
-                EMIT(CLEAR_CODE);\
-                state->count = FIRST_CODE;\
-            }\
-            break;\
-        }\
-    }\
-}
+/* -END- GIF LZW encoder. */

 int
-ImagingGifEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)
-{
+ImagingGifEncode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes) {
     UINT8* ptr;
-    int this;
-
-    GIFENCODERBLOCK* block;
+    UINT8* sub_block_ptr;
+    UINT8* sub_block_limit;
+    UINT8* buf_limit;
     GIFENCODERSTATE *context = (GIFENCODERSTATE*) state->context;
-
-    if (!state->state) {
-
-        /* place a clear code in the output buffer */
-        context->bitbuffer = CLEAR_CODE;
-        context->bitcount = 9;
-
-        state->count = FIRST_CODE;
+    int r;
+
+    UINT32 in_avail, in_used;
+    UINT32 out_avail, out_used;
+
+    if (state->state == INIT) {
+        state->state = ENCODE;
+        glzwe_init(context);

         if (context->interlace) {
             context->interlace = 1;
@@ -161,175 +230,132 @@
             context->step = 1;
         }

-        context->last = -1;
-
+        /* Need at least 2 bytes for data sub-block; 5 for empty image */
+        if (bytes < 5) {
+            state->errcode = IMAGING_CODEC_CONFIG;
+            return 0;
+        }
         /* sanity check */
         if (state->xsize <= 0 || state->ysize <= 0) {
-            state->state = ENCODE_EOF;
-        }
-
+            /* Is this better than an error return? */
+            /* This will handle any legal "LZW Minimum Code Size" */
+            memset(buf, 0, 5);
+            in_avail = 0;
+            out_avail = 5;
+            r = glzwe(context, (const UINT8 *)"", buf + 1, &in_avail, &out_avail, 1);
+            if (r == GLZW_OK) {
+                r = 5 - out_avail;
+                if (r < 1 || r > 3) {
+                    state->errcode = IMAGING_CODEC_BROKEN;
+                    return 0;
+                }
+                buf[0] = r;
+                state->errcode = IMAGING_CODEC_END;
+                return r + 2;
+            } else {
+                /* Should not be possible unless something external to this
+                 * routine messes with our state data */
+                state->errcode = IMAGING_CODEC_BROKEN;
+                return 0;
+            }
+        }
+        /* Init state->x to make if() below true the first time through. */
+        state->x = state->xsize;
     }

-    ptr = buf;
-
-    for (;;)
-
-        switch (state->state) {
-
-            case INIT:
-            case ENCODE:
-
-                /* identify and store a run of pixels */
-
-                if (state->x == 0 || state->x >= state->xsize) {
-
-                    if (!context->interlace && state->y >= state->ysize) {
-                        state->state = ENCODE_EOF;
+    buf_limit = buf + bytes;
+    sub_block_limit = sub_block_ptr = ptr = buf;
+
+    /* On entry, buf is output buffer, bytes is space available in buf.
+     * Loop here getting input until buf is full or image is all encoded. */
+    for (;;) {
+        /* Set up sub-block ptr and limit. sub_block_ptr stays at beginning
+         * of sub-block until it is full. ptr will advance when any data is
+         * placed in buf.
+         */
+        if (ptr >= sub_block_limit) {
+            if (buf_limit - ptr < 2) { /* Need at least 2 for data sub-block */
+                return ptr - buf;
+            }
+            sub_block_ptr = ptr;
+            sub_block_limit = sub_block_ptr +
+                (256 < buf_limit - sub_block_ptr ?
+                 256 : buf_limit - sub_block_ptr);
+            *ptr++ = 0;
+        }
+
+        /* Get next row of pixels. */
+        /* This if() originally tested state->x==0 for the first time through.
+         * This no longer works, as the loop will not advance state->x if
+         * glzwe() does not consume any input; this would advance the row
+         * spuriously.  Now pre-init state->x above for first time, and avoid
+         * entering if() when state->state is FINISH, or it will loop
+         * infinitely.
+         */
+        if (state->x >= state->xsize && state->state == ENCODE) {
+            if (!context->interlace && state->y >= state->ysize) {
+                state->state = FINISH;
+                continue;
+            }
+
+            /* get another line of data */
+            state->shuffle(
+                state->buffer,
+                (UINT8*) im->image[state->y + state->yoff] +
+                state->xoff * im->pixelsize, state->xsize
+            );
+            state->x = 0;
+
+            /* step forward, according to the interlace settings */
+            state->y += context->step;
+            while (context->interlace && state->y >= state->ysize) {
+                switch (context->interlace) {
+                    case 1:
+                        state->y = 4;
+                        context->interlace = 2;
                         break;
-                    }
-
-                    if (context->flush) {
-                        state->state = FLUSH;
+                    case 2:
+                        context->step = 4;
+                        state->y = 2;
+                        context->interlace = 3;
                         break;
-                    }
-
-                    /* get another line of data */
-                    state->shuffle(
-                        state->buffer,
-                        (UINT8*) im->image[state->y + state->yoff] +
-                        state->xoff * im->pixelsize, state->xsize
-                    );
-
-                    state->x = 0;
-
-                    if (state->state == INIT) {
-                        /* preload the run-length buffer and get going */
-                        context->last = state->buffer[0];
-                        context->count = state->x = 1;
-                        state->state = ENCODE;
-                    }
-
-                    /* step forward, according to the interlace settings */
-                    state->y += context->step;
-                    while (context->interlace && state->y >= state->ysize)
-                        switch (context->interlace) {
-                            case 1:
-                                state->y = 4;
-                                context->interlace = 2;
-                                break;
-                            case 2:
-                                context->step = 4;
-                                state->y = 2;
-                                context->interlace = 3;
-                                break;
-                            case 3:
-                                context->step = 2;
-                                state->y = 1;
-                                context->interlace = 0;
-                                break;
-                            default:
-                                /* just make sure we don't loop forever */
-                                context->interlace = 0;
-                        }
-
+                    case 3:
+                        context->step = 2;
+                        state->y = 1;
+                        context->interlace = 0;
+                        break;
+                    default:
+                        /* just make sure we don't loop forever */
+                        context->interlace = 0;
                 }
-                /* Potential special case for xsize==1 */
-                if (state->x < state->xsize) {
-                    this = state->buffer[state->x++];
-                } else {
-                    EMIT_RUN(label0);
-                    break;
-                }
-
-                if (this == context->last) {
-                    context->count++;
-                } else {
-                    EMIT_RUN(label1);
-                    context->last = this;
-                    context->count = 1;
-                }
-                break;
-
-
-            case ENCODE_EOF:
-
-                /* write the final run */
-                EMIT_RUN(label2);
-
-                /* write an end of image marker */
-                EMIT(EOF_CODE);
-
-                /* empty the bit buffer */
-                while (context->bitcount > 0) {
-                    if (!emit(context, (UINT8) context->bitbuffer)) {
-                        state->errcode = IMAGING_CODEC_MEMORY;
-                        return 0;
-                    }
-                    context->bitbuffer >>= 8;
-                    context->bitcount -= 8;
-                }
-
-                /* flush the last block, and exit */
-                if (context->block) {
-                    GIFENCODERBLOCK* block;
-                    block = context->flush;
-                    while (block && block->next) {
-                        block = block->next;
-                    }
-                    if (block) {
-                        block->next = context->block;
-                    } else {
-                        context->flush = context->block;
-                    }
-                    context->block = NULL;
-                }
-
-                state->state = EXIT;
-
-                /* fall through... */
-
-            case EXIT:
-            case FLUSH:
-
-                    while (context->flush) {
-
-                        /* get a block from the flush queue */
-                        block = context->flush;
-
-                        if (block->size > 0) {
-
-                            /* make sure it fits into the output buffer */
-                            if (bytes < block->size+1) {
-                                return ptr - buf;
-                            }
-
-                            ptr[0] = block->size;
-                            memcpy(ptr+1, block->data, block->size);
-
-                            ptr += block->size+1;
-                            bytes -= block->size+1;
-
-                        }
-
-                        context->flush = block->next;
-
-                        if (context->free) {
-                            free(context->free);
-                        }
-                        context->free = block;
-
-                    }
-
-                    if (state->state == EXIT) {
-                        /* this was the last block! */
-                        if (context->free) {
-                            free(context->free);
-                        }
-                        state->errcode = IMAGING_CODEC_END;
-                        return ptr - buf;
-                    }
-
-                    state->state = ENCODE;
-                    break;
+            }
+        }
+
+        in_avail = state->xsize - state->x;   /* bytes left in line */
+        out_avail = sub_block_limit - ptr;  /* bytes left in sub-block */
+        r = glzwe(context, &state->buffer[state->x], ptr, &in_avail,
+                &out_avail, state->state == FINISH);
+        out_used = sub_block_limit - ptr - out_avail;
+        *sub_block_ptr += out_used;
+        ptr += out_used;
+        in_used = state->xsize - state->x - in_avail;
+        state->x += in_used;
+
+        if (r == GLZW_OK) {
+            /* Should not be possible when end-of-data flag is false. */
+            state->errcode = IMAGING_CODEC_END;
+            return ptr - buf;
+        } else if (r == GLZW_NO_INPUT_AVAIL) {
+            /* Used all the input line; get another line */
+            continue;
+        } else if (r == GLZW_NO_OUTPUT_AVAIL) {
+            /* subblock is full */
+            continue;
+        } else {
+            /* Should not be possible unless something external to this
+             * routine messes with our state data */
+            state->errcode = IMAGING_CODEC_BROKEN;
+            return 0;
+        }
     }
 }
('src/libImaging', 'XbmDecode.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,19 +13,19 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-#define HEX(v) ((v >= '0' && v <= '9') ? v - '0' :\
-        (v >= 'a' && v <= 'f') ? v - 'a' + 10 :\
-        (v >= 'A' && v <= 'F') ? v - 'A' + 10 : 0)
+#define HEX(v)                               \
+    ((v >= '0' && v <= '9')   ? v - '0'      \
+     : (v >= 'a' && v <= 'f') ? v - 'a' + 10 \
+     : (v >= 'A' && v <= 'F') ? v - 'A' + 10 \
+                              : 0)

 int
-ImagingXbmDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
-{
+ImagingXbmDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {
     enum { BYTE = 1, SKIP };

-    UINT8* ptr;
+    UINT8 *ptr;

     if (!state->state) {
         state->state = SKIP;
@@ -34,9 +34,7 @@
     ptr = buf;

     for (;;) {
-
         if (state->state == SKIP) {
-
             /* Skip forward until next 'x' */

             while (bytes > 0) {
@@ -52,20 +50,17 @@
             }

             state->state = BYTE;
-
         }

         if (bytes < 3) {
             return ptr - buf;
         }

-        state->buffer[state->x] = (HEX(ptr[1])<<4) + HEX(ptr[2]);
+        state->buffer[state->x] = (HEX(ptr[1]) << 4) + HEX(ptr[2]);

         if (++state->x >= state->bytes) {
-
             /* Got a full line, unpack it */
-            state->shuffle((UINT8*) im->image[state->y], state->buffer,
-                   state->xsize);
+            state->shuffle((UINT8 *)im->image[state->y], state->buffer, state->xsize);

             state->x = 0;

@@ -79,7 +74,5 @@
         bytes -= 3;

         state->state = SKIP;
-
     }
-
 }
('src/libImaging', 'ModeFilter.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,8 +16,7 @@
 #include "Imaging.h"

 Imaging
-ImagingModeFilter(Imaging im, int size)
-{
+ImagingModeFilter(Imaging im, int size) {
     Imaging imOut;
     int x, y, i;
     int xx, yy;
@@ -26,7 +25,7 @@
     int histogram[256];

     if (!im || im->bands != 1 || im->type != IMAGING_TYPE_UINT8) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     imOut = ImagingNewDirty(im->mode, im->xsize, im->ysize);
@@ -37,9 +36,8 @@
     size = size / 2;

     for (y = 0; y < imOut->ysize; y++) {
-        UINT8* out = &IMAGING_PIXEL_L(imOut, 0, y);
+        UINT8 *out = &IMAGING_PIXEL_L(imOut, 0, y);
         for (x = 0; x < imOut->xsize; x++) {
-
             /* calculate histogram over current area */

             /* FIXME: brute force! to improve, update the histogram
@@ -50,7 +48,7 @@
             memset(histogram, 0, sizeof(histogram));
             for (yy = y - size; yy <= y + size; yy++) {
                 if (yy >= 0 && yy < imOut->ysize) {
-                    UINT8* in = &IMAGING_PIXEL_L(im, 0, yy);
+                    UINT8 *in = &IMAGING_PIXEL_L(im, 0, yy);
                     for (xx = x - size; xx <= x + size; xx++) {
                         if (xx >= 0 && xx < imOut->xsize) {
                             histogram[in[xx]]++;
@@ -65,7 +63,7 @@
             for (i = 1; i < 256; i++) {
                 if (histogram[i] > maxcount) {
                     maxcount = histogram[i];
-                    maxpixel = (UINT8) i;
+                    maxpixel = (UINT8)i;
                 }
             }

@@ -74,9 +72,7 @@
             } else {
                 out[x] = IMAGING_PIXEL_L(im, x, y);
             }
-
         }
-
     }

     ImagingCopyPalette(imOut, im);
('src/libImaging', 'Matrix.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,65 +13,60 @@
  * See the README file for information on usage and redistribution.
  */

-
 #include "Imaging.h"

-
-#define CLIPF(v) ((v <= 0.0) ? 0 : (v >= 255.0F) ? 255 : (UINT8) v)
-
+#define CLIPF(v) ((v <= 0.0) ? 0 : (v >= 255.0F) ? 255 : (UINT8)v)

 Imaging
-ImagingConvertMatrix(Imaging im, const char *mode, float m[])
-{
+ImagingConvertMatrix(Imaging im, const char *mode, float m[]) {
     Imaging imOut;
     int x, y;

     /* Assume there's enough data in the buffer */
     if (!im) {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     if (strcmp(mode, "L") == 0 && im->bands == 3) {
-
         imOut = ImagingNewDirty("L", im->xsize, im->ysize);
         if (!imOut) {
             return NULL;
         }

         for (y = 0; y < im->ysize; y++) {
-            UINT8* in = (UINT8*) im->image[y];
-            UINT8* out = (UINT8*) imOut->image[y];
+            UINT8 *in = (UINT8 *)im->image[y];
+            UINT8 *out = (UINT8 *)imOut->image[y];

             for (x = 0; x < im->xsize; x++) {
-                float v = m[0]*in[0] + m[1]*in[1] + m[2]*in[2] + m[3] + 0.5;
+                float v = m[0] * in[0] + m[1] * in[1] + m[2] * in[2] + m[3] + 0.5;
                 out[x] = CLIPF(v);
                 in += 4;
             }
         }

     } else if (strlen(mode) == 3 && im->bands == 3) {
-
         imOut = ImagingNewDirty(mode, im->xsize, im->ysize);
         if (!imOut) {
             return NULL;
         }

         for (y = 0; y < im->ysize; y++) {
-            UINT8* in = (UINT8*) im->image[y];
-            UINT8* out = (UINT8*) imOut->image[y];
+            UINT8 *in = (UINT8 *)im->image[y];
+            UINT8 *out = (UINT8 *)imOut->image[y];

             for (x = 0; x < im->xsize; x++) {
-                float v0 = m[0]*in[0] + m[1]*in[1] +  m[2]*in[2] +  m[3] + 0.5;
-                float v1 = m[4]*in[0] + m[5]*in[1] +  m[6]*in[2] +  m[7] + 0.5;
-                float v2 = m[8]*in[0] + m[9]*in[1] + m[10]*in[2] + m[11] + 0.5;
+                float v0 = m[0] * in[0] + m[1] * in[1] + m[2] * in[2] + m[3] + 0.5;
+                float v1 = m[4] * in[0] + m[5] * in[1] + m[6] * in[2] + m[7] + 0.5;
+                float v2 = m[8] * in[0] + m[9] * in[1] + m[10] * in[2] + m[11] + 0.5;
                 out[0] = CLIPF(v0);
                 out[1] = CLIPF(v1);
                 out[2] = CLIPF(v2);
-                in += 4; out += 4;
+                in += 4;
+                out += 4;
             }
         }
     } else {
-        return (Imaging) ImagingError_ModeError();
+        return (Imaging)ImagingError_ModeError();
     }

     return imOut;
('src/Tk', '_tkmini.h')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,7 +1,7 @@
 /* Small excerpts from the Tcl / Tk 8.6 headers
  *
  * License terms copied from:
- * http://www.tcl.tk/software/tcltk/license.html
+ * https://www.tcl.tk/software/tcltk/license.html
  * as of 20 May 2016.
  *
  * Copyright (c) 1987-1994 The Regents of the University of California.
@@ -79,18 +79,20 @@
 typedef struct Tcl_Command_ *Tcl_Command;
 typedef void *ClientData;

-typedef int (Tcl_CmdProc) (ClientData clientData, Tcl_Interp
-        *interp, int argc, const char *argv[]);
-typedef void (Tcl_CmdDeleteProc) (ClientData clientData);
+typedef int(Tcl_CmdProc)(
+    ClientData clientData, Tcl_Interp *interp, int argc, const char *argv[]);
+typedef void(Tcl_CmdDeleteProc)(ClientData clientData);

 /* Typedefs derived from function signatures in Tcl header */
 /* Tcl_CreateCommand */
-typedef Tcl_Command (*Tcl_CreateCommand_t)(Tcl_Interp *interp,
-        const char *cmdName, Tcl_CmdProc *proc,
-        ClientData clientData,
-        Tcl_CmdDeleteProc *deleteProc);
+typedef Tcl_Command (*Tcl_CreateCommand_t)(
+    Tcl_Interp *interp,
+    const char *cmdName,
+    Tcl_CmdProc *proc,
+    ClientData clientData,
+    Tcl_CmdDeleteProc *deleteProc);
 /* Tcl_AppendResult */
-typedef void (*Tcl_AppendResult_t) (Tcl_Interp *interp, ...);
+typedef void (*Tcl_AppendResult_t)(Tcl_Interp *interp, ...);

 /* Tk header excerpts */

@@ -107,8 +109,7 @@

 typedef void *Tk_PhotoHandle;

-typedef struct Tk_PhotoImageBlock
-{
+typedef struct Tk_PhotoImageBlock {
     unsigned char *pixelPtr;
     int width;
     int height;
@@ -119,23 +120,30 @@

 /* Typedefs derived from function signatures in Tk header */
 /* Tk_PhotoPutBlock for Tk <= 8.4 */
-typedef void (*Tk_PhotoPutBlock_84_t) (Tk_PhotoHandle handle,
-        Tk_PhotoImageBlock *blockPtr, int x, int y,
-        int width, int height, int compRule);
+typedef void (*Tk_PhotoPutBlock_84_t)(
+    Tk_PhotoHandle handle,
+    Tk_PhotoImageBlock *blockPtr,
+    int x,
+    int y,
+    int width,
+    int height,
+    int compRule);
 /* Tk_PhotoPutBlock for Tk >= 8.5 */
-typedef int (*Tk_PhotoPutBlock_85_t) (Tcl_Interp * interp,
-        Tk_PhotoHandle handle,
-        Tk_PhotoImageBlock * blockPtr, int x, int y,
-        int width, int height, int compRule);
+typedef int (*Tk_PhotoPutBlock_85_t)(
+    Tcl_Interp *interp,
+    Tk_PhotoHandle handle,
+    Tk_PhotoImageBlock *blockPtr,
+    int x,
+    int y,
+    int width,
+    int height,
+    int compRule);
 /* Tk_PhotoSetSize for Tk <= 8.4 */
-typedef void (*Tk_PhotoSetSize_84_t) (Tk_PhotoHandle handle,
-        int width, int height);
+typedef void (*Tk_PhotoSetSize_84_t)(Tk_PhotoHandle handle, int width, int height);
 /* Tk_FindPhoto */
-typedef Tk_PhotoHandle (*Tk_FindPhoto_t) (Tcl_Interp *interp,
-        const char *imageName);
+typedef Tk_PhotoHandle (*Tk_FindPhoto_t)(Tcl_Interp *interp, const char *imageName);
 /* Tk_PhotoGetImage */
-typedef int (*Tk_PhotoGetImage_t) (Tk_PhotoHandle handle,
-        Tk_PhotoImageBlock * blockPtr);
+typedef int (*Tk_PhotoGetImage_t)(Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr);

 /*
  * end block for C++
('src/Tk', 'tkImaging.c')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -29,7 +29,7 @@
  * 1995-09-12 fl  Created
  * 1996-04-08 fl  Ready for release
  * 1997-05-09 fl  Use command instead of image type
- * 2001-03-18 fl  Initialize alpha layer pointer (struct changed in 8.3)
+ * 2001-03-18 fl  Initialize alpha layer pointer (struct changed in Tk 8.3)
  * 2003-04-23 fl  Fixed building for Tk 8.4.1 and later (Jack Jansen)
  * 2004-06-24 fl  Fixed building for Tk 8.4.6 and later.
  *
@@ -58,8 +58,7 @@
 static Tk_PhotoPutBlock_85_t TK_PHOTO_PUT_BLOCK_85;

 static Imaging
-ImagingFind(const char* name)
-{
+ImagingFind(const char *name) {
     Py_ssize_t id;

     /* FIXME: use CObject instead? */
@@ -72,41 +71,37 @@
         return NULL;
     }

-    return (Imaging) id;
-}
-
+    return (Imaging)id;
+}

 static int
-PyImagingPhotoPut(ClientData clientdata, Tcl_Interp* interp,
-               int argc, const char **argv)
-{
+PyImagingPhotoPut(
+    ClientData clientdata, Tcl_Interp *interp, int argc, const char **argv) {
     Imaging im;
     Tk_PhotoHandle photo;
     Tk_PhotoImageBlock block;

     if (argc != 3) {
-        TCL_APPEND_RESULT(interp, "usage: ", argv[0],
-                         " destPhoto srcImage", (char *) NULL);
+        TCL_APPEND_RESULT(
+            interp, "usage: ", argv[0], " destPhoto srcImage", (char *)NULL);
         return TCL_ERROR;
     }

     /* get Tcl PhotoImage handle */
     photo = TK_FIND_PHOTO(interp, argv[1]);
     if (photo == NULL) {
-        TCL_APPEND_RESULT(
-            interp, "destination photo must exist", (char *) NULL
-            );
+        TCL_APPEND_RESULT(interp, "destination photo must exist", (char *)NULL);
         return TCL_ERROR;
     }

     /* get PIL Image handle */
     im = ImagingFind(argv[2]);
     if (!im) {
-        TCL_APPEND_RESULT(interp, "bad name", (char*) NULL);
+        TCL_APPEND_RESULT(interp, "bad name", (char *)NULL);
         return TCL_ERROR;
     }
     if (!im->block) {
-        TCL_APPEND_RESULT(interp, "bad display memory", (char*) NULL);
+        TCL_APPEND_RESULT(interp, "bad display memory", (char *)NULL);
         return TCL_ERROR;
     }

@@ -121,23 +116,23 @@
         block.offset[1] = 1;
         block.offset[2] = 2;
         if (strcmp(im->mode, "RGBA") == 0) {
-            block.offset[3] = 3; /* alpha (or reserved, under 8.2) */
+            block.offset[3] = 3; /* alpha (or reserved, under Tk 8.2) */
         } else {
             block.offset[3] = 0; /* no alpha */
         }
     } else {
-        TCL_APPEND_RESULT(interp, "Bad mode", (char*) NULL);
+        TCL_APPEND_RESULT(interp, "Bad mode", (char *)NULL);
         return TCL_ERROR;
     }

     block.width = im->xsize;
     block.height = im->ysize;
     block.pitch = im->linesize;
-    block.pixelPtr = (unsigned char*) im->block;
+    block.pixelPtr = (unsigned char *)im->block;

     if (TK_LT_85) { /* Tk 8.4 */
-        TK_PHOTO_PUT_BLOCK_84(photo, &block, 0, 0, block.width, block.height,
-                TK_PHOTO_COMPOSITE_SET);
+        TK_PHOTO_PUT_BLOCK_84(
+            photo, &block, 0, 0, block.width, block.height, TK_PHOTO_COMPOSITE_SET);
         if (strcmp(im->mode, "RGBA") == 0) {
             /* Tk workaround: we need apply ToggleComplexAlphaIfNeeded */
             /* (fixed in Tk 8.5a3) */
@@ -145,50 +140,54 @@
         }
     } else {
         /* Tk >=8.5 */
-        TK_PHOTO_PUT_BLOCK_85(interp, photo, &block, 0, 0, block.width,
-                block.height, TK_PHOTO_COMPOSITE_SET);
+        TK_PHOTO_PUT_BLOCK_85(
+            interp,
+            photo,
+            &block,
+            0,
+            0,
+            block.width,
+            block.height,
+            TK_PHOTO_COMPOSITE_SET);
     }

     return TCL_OK;
 }

 static int
-PyImagingPhotoGet(ClientData clientdata, Tcl_Interp* interp,
-               int argc, const char **argv)
-{
+PyImagingPhotoGet(
+    ClientData clientdata, Tcl_Interp *interp, int argc, const char **argv) {
     Imaging im;
     Tk_PhotoHandle photo;
     Tk_PhotoImageBlock block;
     int x, y, z;

     if (argc != 3) {
-        TCL_APPEND_RESULT(interp, "usage: ", argv[0],
-                         " srcPhoto destImage", (char *) NULL);
+        TCL_APPEND_RESULT(
+            interp, "usage: ", argv[0], " srcPhoto destImage", (char *)NULL);
         return TCL_ERROR;
     }

     /* get Tcl PhotoImage handle */
     photo = TK_FIND_PHOTO(interp, argv[1]);
     if (photo == NULL) {
-        TCL_APPEND_RESULT(
-            interp, "source photo must exist", (char *) NULL
-            );
+        TCL_APPEND_RESULT(interp, "source photo must exist", (char *)NULL);
         return TCL_ERROR;
     }

     /* get PIL Image handle */
     im = ImagingFind(argv[2]);
     if (!im) {
-        TCL_APPEND_RESULT(interp, "bad name", (char*) NULL);
+        TCL_APPEND_RESULT(interp, "bad name", (char *)NULL);
         return TCL_ERROR;
     }

     TK_PHOTO_GET_IMAGE(photo, &block);

     for (y = 0; y < block.height; y++) {
-        UINT8* out = (UINT8*)im->image32[y];
+        UINT8 *out = (UINT8 *)im->image32[y];
         for (x = 0; x < block.pitch; x += block.pixelSize) {
-            for (z=0; z < block.pixelSize; z++) {
+            for (z = 0; z < block.pixelSize; z++) {
                 int offset = block.offset[z];
                 out[x + offset] = block.pixelPtr[y * block.pitch + x + offset];
             }
@@ -198,14 +197,20 @@
     return TCL_OK;
 }

-
 void
-TkImaging_Init(Tcl_Interp* interp)
-{
-    TCL_CREATE_COMMAND(interp, "PyImagingPhoto", PyImagingPhotoPut,
-                      (ClientData) 0, (Tcl_CmdDeleteProc*) NULL);
-    TCL_CREATE_COMMAND(interp, "PyImagingPhotoGet", PyImagingPhotoGet,
-                      (ClientData) 0, (Tcl_CmdDeleteProc*) NULL);
+TkImaging_Init(Tcl_Interp *interp) {
+    TCL_CREATE_COMMAND(
+        interp,
+        "PyImagingPhoto",
+        PyImagingPhotoPut,
+        (ClientData)0,
+        (Tcl_CmdDeleteProc *)NULL);
+    TCL_CREATE_COMMAND(
+        interp,
+        "PyImagingPhotoGet",
+        PyImagingPhotoGet,
+        (ClientData)0,
+        (Tcl_CmdDeleteProc *)NULL);
 }

 /*
@@ -214,7 +219,7 @@

 #define TKINTER_FINDER "PIL._tkinter_finder"

-#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
+#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__CYGWIN__)

 /*
  * On Windows, we can't load the tkinter module to get the Tcl or Tk symbols,
@@ -230,13 +235,13 @@

 #define TKINTER_PKG "tkinter"

-FARPROC _dfunc(HMODULE lib_handle, const char *func_name)
-{
+FARPROC
+_dfunc(HMODULE lib_handle, const char *func_name) {
     /*
      * Load function `func_name` from `lib_handle`.
      * Set Python exception if we can't find `func_name` in `lib_handle`.
      * Returns function pointer or NULL if not present.
-    */
+     */

     char message[100];

@@ -248,24 +253,26 @@
     return func;
 }

-int get_tcl(HMODULE hMod)
-{
+int
+get_tcl(HMODULE hMod) {
     /*
      * Try to fill Tcl global vars with function pointers. Return 0 for no
      * functions found, 1 for all functions found, -1 for some but not all
      * functions found.
      */

-    if ((TCL_CREATE_COMMAND = (Tcl_CreateCommand_t)
-        GetProcAddress(hMod, "Tcl_CreateCommand")) == NULL) {
+    if ((TCL_CREATE_COMMAND =
+             (Tcl_CreateCommand_t)GetProcAddress(hMod, "Tcl_CreateCommand")) == NULL) {
         return 0; /* Maybe not Tcl module */
     }
-    return ((TCL_APPEND_RESULT = (Tcl_AppendResult_t) _dfunc(hMod,
-            "Tcl_AppendResult")) == NULL) ? -1 : 1;
-}
-
-int get_tk(HMODULE hMod)
-{
+    return ((TCL_APPEND_RESULT =
+                 (Tcl_AppendResult_t)_dfunc(hMod, "Tcl_AppendResult")) == NULL)
+               ? -1
+               : 1;
+}
+
+int
+get_tk(HMODULE hMod) {
     /*
      * Try to fill Tk global vars with function pointers. Return 0 for no
      * functions found, 1 for all functions found, -1 for some but not all
@@ -273,26 +280,31 @@
      */

     FARPROC func = GetProcAddress(hMod, "Tk_PhotoPutBlock");
-    if (func == NULL) {  /* Maybe not Tk module */
+    if (func == NULL) { /* Maybe not Tk module */
         return 0;
     }
-    if ((TK_PHOTO_GET_IMAGE = (Tk_PhotoGetImage_t)
-                _dfunc(hMod, "Tk_PhotoGetImage")) == NULL) { return -1; };
-    if ((TK_FIND_PHOTO = (Tk_FindPhoto_t)
-                _dfunc(hMod, "Tk_FindPhoto")) == NULL) { return -1; };
+    if ((TK_PHOTO_GET_IMAGE = (Tk_PhotoGetImage_t)_dfunc(hMod, "Tk_PhotoGetImage")) ==
+        NULL) {
+        return -1;
+    };
+    if ((TK_FIND_PHOTO = (Tk_FindPhoto_t)_dfunc(hMod, "Tk_FindPhoto")) == NULL) {
+        return -1;
+    };
     TK_LT_85 = GetProcAddress(hMod, "Tk_PhotoPutBlock_Panic") == NULL;
     /* Tk_PhotoPutBlock_Panic defined as of 8.5.0 */
     if (TK_LT_85) {
-        TK_PHOTO_PUT_BLOCK_84 = (Tk_PhotoPutBlock_84_t) func;
-        return ((TK_PHOTO_SET_SIZE_84 = (Tk_PhotoSetSize_84_t)
-                    _dfunc(hMod, "Tk_PhotoSetSize")) == NULL) ? -1 : 1;
-    }
-    TK_PHOTO_PUT_BLOCK_85 = (Tk_PhotoPutBlock_85_t) func;
+        TK_PHOTO_PUT_BLOCK_84 = (Tk_PhotoPutBlock_84_t)func;
+        return ((TK_PHOTO_SET_SIZE_84 =
+                     (Tk_PhotoSetSize_84_t)_dfunc(hMod, "Tk_PhotoSetSize")) == NULL)
+                   ? -1
+                   : 1;
+    }
+    TK_PHOTO_PUT_BLOCK_85 = (Tk_PhotoPutBlock_85_t)func;
     return 1;
 }

-int load_tkinter_funcs(void)
-{
+int
+load_tkinter_funcs(void) {
     /*
      * Load Tcl and Tk functions by searching all modules in current process.
      * Return 0 for success, non-zero for failure.
@@ -344,7 +356,7 @@
     return 1;
 }

-#else  /* not Windows */
+#else /* not Windows */

 /*
  * On Unix, we can get the Tcl and Tk symbols from the tkinter module, because
@@ -353,9 +365,9 @@
  */

 /* From module __file__ attribute to char *string for dlopen. */
-char *fname2char(PyObject *fname)
-{
-    PyObject* bytes;
+char *
+fname2char(PyObject *fname) {
+    PyObject *bytes;
     bytes = PyUnicode_EncodeFSDefault(fname);
     if (bytes == NULL) {
         return NULL;
@@ -365,15 +377,15 @@

 #include <dlfcn.h>

-void *_dfunc(void *lib_handle, const char *func_name)
-{
+void *
+_dfunc(void *lib_handle, const char *func_name) {
     /*
      * Load function `func_name` from `lib_handle`.
      * Set Python exception if we can't find `func_name` in `lib_handle`.
      * Returns function pointer or NULL if not present.
      */

-    void* func;
+    void *func;
     /* Reset errors. */
     dlerror();
     func = dlsym(lib_handle, func_name);
@@ -384,35 +396,44 @@
     return func;
 }

-int _func_loader(void *lib)
-{
+int
+_func_loader(void *lib) {
     /*
      * Fill global function pointers from dynamic lib.
      * Return 1 if any pointer is NULL, 0 otherwise.
      */

-    if ((TCL_CREATE_COMMAND = (Tcl_CreateCommand_t)
-            _dfunc(lib, "Tcl_CreateCommand")) == NULL) { return 1; }
-    if ((TCL_APPEND_RESULT = (Tcl_AppendResult_t) _dfunc(lib,
-                "Tcl_AppendResult")) == NULL) { return 1; }
-    if ((TK_PHOTO_GET_IMAGE = (Tk_PhotoGetImage_t)
-                _dfunc(lib, "Tk_PhotoGetImage")) == NULL) { return 1; }
-    if ((TK_FIND_PHOTO = (Tk_FindPhoto_t)
-                _dfunc(lib, "Tk_FindPhoto")) == NULL) { return 1; }
+    if ((TCL_CREATE_COMMAND = (Tcl_CreateCommand_t)_dfunc(lib, "Tcl_CreateCommand")) ==
+        NULL) {
+        return 1;
+    }
+    if ((TCL_APPEND_RESULT = (Tcl_AppendResult_t)_dfunc(lib, "Tcl_AppendResult")) ==
+        NULL) {
+        return 1;
+    }
+    if ((TK_PHOTO_GET_IMAGE = (Tk_PhotoGetImage_t)_dfunc(lib, "Tk_PhotoGetImage")) ==
+        NULL) {
+        return 1;
+    }
+    if ((TK_FIND_PHOTO = (Tk_FindPhoto_t)_dfunc(lib, "Tk_FindPhoto")) == NULL) {
+        return 1;
+    }
     /* Tk_PhotoPutBlock_Panic defined as of 8.5.0 */
     TK_LT_85 = (dlsym(lib, "Tk_PhotoPutBlock_Panic") == NULL);
     if (TK_LT_85) {
-        return (((TK_PHOTO_PUT_BLOCK_84 = (Tk_PhotoPutBlock_84_t)
-                        _dfunc(lib, "Tk_PhotoPutBlock")) == NULL) ||
-                ((TK_PHOTO_SET_SIZE_84 = (Tk_PhotoSetSize_84_t)
-                  _dfunc(lib, "Tk_PhotoSetSize")) == NULL));
-    }
-    return ((TK_PHOTO_PUT_BLOCK_85 = (Tk_PhotoPutBlock_85_t)
-                _dfunc(lib, "Tk_PhotoPutBlock")) == NULL);
-}
-
-int load_tkinter_funcs(void)
-{
+        return (
+            ((TK_PHOTO_PUT_BLOCK_84 =
+                  (Tk_PhotoPutBlock_84_t)_dfunc(lib, "Tk_PhotoPutBlock")) == NULL) ||
+            ((TK_PHOTO_SET_SIZE_84 =
+                  (Tk_PhotoSetSize_84_t)_dfunc(lib, "Tk_PhotoSetSize")) == NULL));
+    }
+    return (
+        (TK_PHOTO_PUT_BLOCK_85 =
+             (Tk_PhotoPutBlock_85_t)_dfunc(lib, "Tk_PhotoPutBlock")) == NULL);
+}
+
+int
+load_tkinter_funcs(void) {
     /*
      * Load tkinter global funcs from tkinter compiled module.
      * Return 0 for success, non-zero for failure.
@@ -447,8 +468,7 @@
     }
     tkinter_lib = dlopen(tkinter_libname, RTLD_LAZY);
     if (tkinter_lib == NULL) {
-        PyErr_SetString(PyExc_RuntimeError,
-                "Cannot dlopen tkinter module file");
+        PyErr_SetString(PyExc_RuntimeError, "Cannot dlopen tkinter module file");
         goto exit;
     }
     ret = _func_loader(tkinter_lib);
('src/PIL', 'MpoImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,9 +21,8 @@
 from . import Image, ImageFile, JpegImagePlugin
 from ._binary import i16be as i16

-
-def _accept(prefix):
-    return JpegImagePlugin._accept(prefix)
+# def _accept(prefix):
+#     return JpegImagePlugin._accept(prefix)


 def _save(im, fp, filename):
@@ -47,6 +46,7 @@
         self._after_jpeg_open()

     def _after_jpeg_open(self, mpheader=None):
+        self._initial_size = self.size
         self.mpinfo = mpheader if mpheader is not None else self._getmp()
         self.n_frames = self.mpinfo[0xB001]
         self.__mpoffsets = [
@@ -78,13 +78,16 @@
         segment = self.fp.read(2)
         if not segment:
             raise ValueError("No data found for frame")
+        self._size = self._initial_size
         if i16(segment) == 0xFFE1:  # APP1
             n = i16(self.fp.read(2)) - 2
             self.info["exif"] = ImageFile._safe_read(self.fp, n)

-            exif = self.getexif()
-            if 40962 in exif and 40963 in exif:
-                self._size = (exif[40962], exif[40963])
+            mptype = self.mpinfo[0xB002][frame]["Attribute"]["MPType"]
+            if mptype.startswith("Large Thumbnail"):
+                exif = self.getexif().get_ifd(0x8769)
+                if 40962 in exif and 40963 in exif:
+                    self._size = (exif[40962], exif[40963])
         elif "exif" in self.info:
             del self.info["exif"]

('src/PIL', 'ImageMode.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,6 +13,8 @@
 # See the README file for information on usage and redistribution.
 #

+import sys
+
 # mode descriptor cache
 _modes = None

@@ -20,11 +22,12 @@
 class ModeDescriptor:
     """Wrapper for mode strings."""

-    def __init__(self, mode, bands, basemode, basetype):
+    def __init__(self, mode, bands, basemode, basetype, typestr):
         self.mode = mode
         self.bands = bands
         self.basemode = basemode
         self.basetype = basetype
+        self.typestr = typestr

     def __str__(self):
         return self.mode
@@ -35,30 +38,54 @@
     global _modes
     if not _modes:
         # initialize mode cache
-
-        from . import Image
-
         modes = {}
-        # core modes
-        for m, (basemode, basetype, bands) in Image._MODEINFO.items():
-            modes[m] = ModeDescriptor(m, bands, basemode, basetype)
-        # extra experimental modes
-        modes["RGBa"] = ModeDescriptor("RGBa", ("R", "G", "B", "a"), "RGB", "L")
-        modes["LA"] = ModeDescriptor("LA", ("L", "A"), "L", "L")
-        modes["La"] = ModeDescriptor("La", ("L", "a"), "L", "L")
-        modes["PA"] = ModeDescriptor("PA", ("P", "A"), "RGB", "L")
+        endian = "<" if sys.byteorder == "little" else ">"
+        for m, (basemode, basetype, bands, typestr) in {
+            # core modes
+            # Bits need to be extended to bytes
+            "1": ("L", "L", ("1",), "|b1"),
+            "L": ("L", "L", ("L",), "|u1"),
+            "I": ("L", "I", ("I",), endian + "i4"),
+            "F": ("L", "F", ("F",), endian + "f4"),
+            "P": ("P", "L", ("P",), "|u1"),
+            "RGB": ("RGB", "L", ("R", "G", "B"), "|u1"),
+            "RGBX": ("RGB", "L", ("R", "G", "B", "X"), "|u1"),
+            "RGBA": ("RGB", "L", ("R", "G", "B", "A"), "|u1"),
+            "CMYK": ("RGB", "L", ("C", "M", "Y", "K"), "|u1"),
+            "YCbCr": ("RGB", "L", ("Y", "Cb", "Cr"), "|u1"),
+            # UNDONE - unsigned |u1i1i1
+            "LAB": ("RGB", "L", ("L", "A", "B"), "|u1"),
+            "HSV": ("RGB", "L", ("H", "S", "V"), "|u1"),
+            # extra experimental modes
+            "RGBa": ("RGB", "L", ("R", "G", "B", "a"), "|u1"),
+            "BGR;15": ("RGB", "L", ("B", "G", "R"), endian + "u2"),
+            "BGR;16": ("RGB", "L", ("B", "G", "R"), endian + "u2"),
+            "BGR;24": ("RGB", "L", ("B", "G", "R"), endian + "u3"),
+            "BGR;32": ("RGB", "L", ("B", "G", "R"), endian + "u4"),
+            "LA": ("L", "L", ("L", "A"), "|u1"),
+            "La": ("L", "L", ("L", "a"), "|u1"),
+            "PA": ("RGB", "L", ("P", "A"), "|u1"),
+        }.items():
+            modes[m] = ModeDescriptor(m, bands, basemode, basetype, typestr)
         # mapping modes
-        for i16mode in (
-            "I;16",
-            "I;16S",
-            "I;16L",
-            "I;16LS",
-            "I;16B",
-            "I;16BS",
-            "I;16N",
-            "I;16NS",
-        ):
-            modes[i16mode] = ModeDescriptor(i16mode, ("I",), "L", "L")
+        for i16mode, typestr in {
+            # I;16 == I;16L, and I;32 == I;32L
+            "I;16": "<u2",
+            "I;16S": "<i2",
+            "I;16L": "<u2",
+            "I;16LS": "<i2",
+            "I;16B": ">u2",
+            "I;16BS": ">i2",
+            "I;16N": endian + "u2",
+            "I;16NS": endian + "i2",
+            "I;32": "<u4",
+            "I;32B": ">u4",
+            "I;32L": "<u4",
+            "I;32S": "<i4",
+            "I;32BS": ">i4",
+            "I;32LS": "<i4",
+        }.items():
+            modes[i16mode] = ModeDescriptor(i16mode, ("I",), "L", "L", typestr)
         # set global mode cache atomically
         _modes = modes
     return _modes[mode]
('src/PIL', 'PngImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -37,6 +37,7 @@
 import struct
 import warnings
 import zlib
+from enum import IntEnum

 from . import Image, ImageChops, ImageFile, ImagePalette, ImageSequence
 from ._binary import i16be as i16
@@ -47,7 +48,7 @@

 logger = logging.getLogger(__name__)

-is_cid = re.compile(br"\w\w\w\w").match
+is_cid = re.compile(rb"\w\w\w\w").match


 _MAGIC = b"\211PNG\r\n\032\n"
@@ -94,36 +95,62 @@


 # APNG frame disposal modes
-APNG_DISPOSE_OP_NONE = 0
-"""
-No disposal is done on this frame before rendering the next frame.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
-APNG_DISPOSE_OP_BACKGROUND = 1
-"""
-This frame’s modified region is cleared to fully transparent black before rendering
-the next frame.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
-APNG_DISPOSE_OP_PREVIOUS = 2
-"""
-This frame’s modified region is reverted to the previous frame’s contents before
-rendering the next frame.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
+class Disposal(IntEnum):
+    OP_NONE = 0
+    """
+    No disposal is done on this frame before rendering the next frame.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+    OP_BACKGROUND = 1
+    """
+    This frame’s modified region is cleared to fully transparent black before rendering
+    the next frame.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+    OP_PREVIOUS = 2
+    """
+    This frame’s modified region is reverted to the previous frame’s contents before
+    rendering the next frame.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+

 # APNG frame blend modes
-APNG_BLEND_OP_SOURCE = 0
-"""
-All color components of this frame, including alpha, overwrite the previous output
-image contents.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
-APNG_BLEND_OP_OVER = 1
-"""
-This frame should be alpha composited with the previous output image contents.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
+class Blend(IntEnum):
+    OP_SOURCE = 0
+    """
+    All color components of this frame, including alpha, overwrite the previous output
+    image contents.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+    OP_OVER = 1
+    """
+    This frame should be alpha composited with the previous output image contents.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {Disposal: "APNG_DISPOSE_", Blend: "APNG_BLEND_"}.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")


 def _safe_zlib_decompress(s):
@@ -500,7 +527,7 @@
         px, py = i32(s, 0), i32(s, 4)
         unit = s[8]
         if unit == 1:  # meter
-            dpi = int(px * 0.0254 + 0.5), int(py * 0.0254 + 0.5)
+            dpi = px * 0.0254, py * 0.0254
             self.im_info["dpi"] = dpi
         elif unit == 0:
             self.im_info["aspect"] = px, py
@@ -861,13 +888,13 @@
                 raise EOFError

         # setup frame disposal (actual disposal done when needed in the next _seek())
-        if self._prev_im is None and self.dispose_op == APNG_DISPOSE_OP_PREVIOUS:
-            self.dispose_op = APNG_DISPOSE_OP_BACKGROUND
-
-        if self.dispose_op == APNG_DISPOSE_OP_PREVIOUS:
+        if self._prev_im is None and self.dispose_op == Disposal.OP_PREVIOUS:
+            self.dispose_op = Disposal.OP_BACKGROUND
+
+        if self.dispose_op == Disposal.OP_PREVIOUS:
             self.dispose = self._prev_im.copy()
             self.dispose = self._crop(self.dispose, self.dispose_extent)
-        elif self.dispose_op == APNG_DISPOSE_OP_BACKGROUND:
+        elif self.dispose_op == Disposal.OP_BACKGROUND:
             self.dispose = Image.core.fill(self.mode, self.size)
             self.dispose = self._crop(self.dispose, self.dispose_extent)
         else:
@@ -920,6 +947,8 @@

     def load_end(self):
         """internal: finished reading image data"""
+        if self.__idat != 0:
+            self.fp.read(self.__idat)
         while True:
             self.fp.read(4)  # CRC

@@ -954,7 +983,7 @@
             self.png.close()
             self.png = None
         else:
-            if self._prev_im and self.blend_op == APNG_BLEND_OP_OVER:
+            if self._prev_im and self.blend_op == Blend.OP_OVER:
                 updated = self._crop(self.im, self.dispose_extent)
                 self._prev_im.paste(
                     updated, self.dispose_extent, updated.convert("RGBA")
@@ -968,13 +997,26 @@
             self.load()
         if "exif" not in self.info and "Raw profile type exif" not in self.info:
             return None
-        return dict(self.getexif())
+        return self.getexif()._get_merged_dict()

     def getexif(self):
         if "exif" not in self.info:
             self.load()

         return super().getexif()
+
+    def getxmp(self):
+        """
+        Returns a dictionary containing the XMP tags.
+        Requires defusedxml to be installed.
+
+        :returns: XMP tags in a dictionary.
+        """
+        return (
+            self._getxmp(self.info["XML:com.adobe.xmp"])
+            if "XML:com.adobe.xmp" in self.info
+            else {}
+        )

     def _close__fp(self):
         try:
@@ -1047,8 +1089,8 @@
     default_image = im.encoderinfo.get("default_image", im.info.get("default_image"))
     duration = im.encoderinfo.get("duration", im.info.get("duration", 0))
     loop = im.encoderinfo.get("loop", im.info.get("loop", 0))
-    disposal = im.encoderinfo.get("disposal", im.info.get("disposal"))
-    blend = im.encoderinfo.get("blend", im.info.get("blend"))
+    disposal = im.encoderinfo.get("disposal", im.info.get("disposal", Disposal.OP_NONE))
+    blend = im.encoderinfo.get("blend", im.info.get("blend", Blend.OP_SOURCE))

     if default_image:
         chain = itertools.chain(im.encoderinfo.get("append_images", []))
@@ -1078,10 +1120,10 @@
                 previous = im_frames[-1]
                 prev_disposal = previous["encoderinfo"].get("disposal")
                 prev_blend = previous["encoderinfo"].get("blend")
-                if prev_disposal == APNG_DISPOSE_OP_PREVIOUS and len(im_frames) < 2:
-                    prev_disposal = APNG_DISPOSE_OP_BACKGROUND
-
-                if prev_disposal == APNG_DISPOSE_OP_BACKGROUND:
+                if prev_disposal == Disposal.OP_PREVIOUS and len(im_frames) < 2:
+                    prev_disposal = Disposal.OP_BACKGROUND
+
+                if prev_disposal == Disposal.OP_BACKGROUND:
                     base_im = previous["im"]
                     dispose = Image.core.fill("RGBA", im.size, (0, 0, 0, 0))
                     bbox = previous["bbox"]
@@ -1090,7 +1132,7 @@
                     else:
                         bbox = (0, 0) + im.size
                     base_im.paste(dispose, bbox)
-                elif prev_disposal == APNG_DISPOSE_OP_PREVIOUS:
+                elif prev_disposal == Disposal.OP_PREVIOUS:
                     base_im = im_frames[-2]["im"]
                 else:
                     base_im = previous["im"]
@@ -1103,12 +1145,8 @@
                     and prev_disposal == encoderinfo.get("disposal")
                     and prev_blend == encoderinfo.get("blend")
                 ):
-                    duration = encoderinfo.get("duration", 0)
-                    if duration:
-                        if "duration" in previous["encoderinfo"]:
-                            previous["encoderinfo"]["duration"] += duration
-                        else:
-                            previous["encoderinfo"]["duration"] = duration
+                    if isinstance(duration, (list, tuple)):
+                        previous["encoderinfo"]["duration"] += encoderinfo["duration"]
                     continue
             else:
                 bbox = None
@@ -1135,9 +1173,10 @@
             bbox = frame_data["bbox"]
             im_frame = im_frame.crop(bbox)
         size = im_frame.size
-        duration = int(round(frame_data["encoderinfo"].get("duration", 0)))
-        disposal = frame_data["encoderinfo"].get("disposal", APNG_DISPOSE_OP_NONE)
-        blend = frame_data["encoderinfo"].get("blend", APNG_BLEND_OP_SOURCE)
+        encoderinfo = frame_data["encoderinfo"]
+        frame_duration = int(round(encoderinfo.get("duration", duration)))
+        frame_disposal = encoderinfo.get("disposal", disposal)
+        frame_blend = encoderinfo.get("blend", blend)
         # frame control
         chunk(
             fp,
@@ -1147,10 +1186,10 @@
             o32(size[1]),  # height
             o32(bbox[0]),  # x_offset
             o32(bbox[1]),  # y_offset
-            o16(duration),  # delay_numerator
+            o16(frame_duration),  # delay_numerator
             o16(1000),  # delay_denominator
-            o8(disposal),  # dispose_op
-            o8(blend),  # blend_op
+            o8(frame_disposal),  # dispose_op
+            o8(frame_blend),  # blend_op
         )
         seq_num += 1
         # frame data
@@ -1186,23 +1225,21 @@
         # attempt to minimize storage requirements for palette images
         if "bits" in im.encoderinfo:
             # number of bits specified by user
-            colors = 1 << im.encoderinfo["bits"]
+            colors = min(1 << im.encoderinfo["bits"], 256)
         else:
             # check palette contents
             if im.palette:
-                colors = max(min(len(im.palette.getdata()[1]) // 3, 256), 2)
+                colors = max(min(len(im.palette.getdata()[1]) // 3, 256), 1)
             else:
                 colors = 256

-        if colors <= 2:
-            bits = 1
-        elif colors <= 4:
-            bits = 2
-        elif colors <= 16:
-            bits = 4
-        else:
-            bits = 8
-        if bits != 8:
+        if colors <= 16:
+            if colors <= 2:
+                bits = 1
+            elif colors <= 4:
+                bits = 2
+            else:
+                bits = 4
             mode = f"{mode};{bits}"

     # encoder options
@@ -1270,7 +1307,7 @@
                     chunk(fp, cid, data)

     if im.mode == "P":
-        palette_byte_number = (2 ** bits) * 3
+        palette_byte_number = colors * 3
         palette_bytes = im.im.getpalette("RGB")[:palette_byte_number]
         while len(palette_bytes) < palette_byte_number:
             palette_bytes += b"\0"
@@ -1281,7 +1318,7 @@
     if transparency or transparency == 0:
         if im.mode == "P":
             # limit to actual palette size
-            alpha_bytes = 2 ** bits
+            alpha_bytes = colors
             if isinstance(transparency, bytes):
                 chunk(fp, b"tRNS", transparency[:alpha_bytes])
             else:
@@ -1302,7 +1339,7 @@
     else:
         if im.mode == "P" and im.im.getpalettemode() == "RGBA":
             alpha = im.im.getpalette("RGBA", "A")
-            alpha_bytes = 2 ** bits
+            alpha_bytes = colors
             chunk(fp, b"tRNS", alpha[:alpha_bytes])

     dpi = im.encoderinfo.get("dpi")
('src/PIL', 'XbmImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -25,7 +25,7 @@

 # XBM header
 xbm_head = re.compile(
-    br"\s*#define[ \t]+.*_width[ \t]+(?P<width>[0-9]+)[\r\n]+"
+    rb"\s*#define[ \t]+.*_width[ \t]+(?P<width>[0-9]+)[\r\n]+"
     b"#define[ \t]+.*_height[ \t]+(?P<height>[0-9]+)[\r\n]+"
     b"(?P<hotspot>"
     b"#define[ \t]+[^_]*_x_hot[ \t]+(?P<xhot>[0-9]+)[\r\n]+"
@@ -52,18 +52,19 @@

         m = xbm_head.match(self.fp.read(512))

-        if m:
+        if not m:
+            raise SyntaxError("not a XBM file")

-            xsize = int(m.group("width"))
-            ysize = int(m.group("height"))
+        xsize = int(m.group("width"))
+        ysize = int(m.group("height"))

-            if m.group("hotspot"):
-                self.info["hotspot"] = (int(m.group("xhot")), int(m.group("yhot")))
+        if m.group("hotspot"):
+            self.info["hotspot"] = (int(m.group("xhot")), int(m.group("yhot")))

-            self.mode = "1"
-            self._size = xsize, ysize
+        self.mode = "1"
+        self._size = xsize, ysize

-            self.tile = [("xbm", (0, 0) + self.size, m.end(), None)]
+        self.tile = [("xbm", (0, 0) + self.size, m.end(), None)]


 def _save(im, fp, filename):
('src/PIL', 'PcxImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -66,13 +66,13 @@
         version = s[1]
         bits = s[3]
         planes = s[65]
-        ignored_stride = i16(s, 66)
+        provided_stride = i16(s, 66)
         logger.debug(
             "PCX version %s, bits %s, planes %s, stride %s",
             version,
             bits,
             planes,
-            ignored_stride,
+            provided_stride,
         )

         self.info["dpi"] = i16(s, 12), i16(s, 14)
@@ -110,10 +110,15 @@
         self.mode = mode
         self._size = bbox[2] - bbox[0], bbox[3] - bbox[1]

-        # don't trust the passed in stride. Calculate for ourselves.
-        # CVE-2020-35655
+        # Don't trust the passed in stride.
+        # Calculate the approximate position for ourselves.
+        # CVE-2020-35653
         stride = (self._size[0] * bits + 7) // 8
-        stride += stride % 2
+
+        # While the specification states that this must be even,
+        # not all images follow this
+        if provided_stride != stride:
+            stride += stride % 2

         bbox = (0, 0) + self.size
         logger.debug("size: %sx%s", *self.size)
('src/PIL', 'ImageFile.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -28,9 +28,9 @@
 #

 import io
+import itertools
 import struct
 import sys
-import warnings

 from . import Image
 from ._util import isPath
@@ -49,7 +49,11 @@
     -8: "bad configuration",
     -9: "out of memory error",
 }
-"""Dict of known error codes returned from :meth:`.PyDecoder.decode`."""
+"""
+Dict of known error codes returned from :meth:`.PyDecoder.decode`,
+:meth:`.PyEncoder.encode` :meth:`.PyEncoder.encode_to_pyfd` and
+:meth:`.PyEncoder.encode_to_file`.
+"""


 #
@@ -65,15 +69,6 @@
     if not message:
         message = f"decoder error {error}"
     raise OSError(message + " when reading image file")
-
-
-def raise_ioerror(error):
-    warnings.warn(
-        "raise_ioerror is deprecated and will be removed in Pillow 9 (2022-01-02). "
-        "Use raise_oserror instead.",
-        DeprecationWarning,
-    )
-    return raise_oserror(error)


 def _tilesort(t):
@@ -192,24 +187,14 @@
                 and args[0] in Image._MAPMODES
             ):
                 try:
-                    if hasattr(Image.core, "map"):
-                        # use built-in mapper  WIN32 only
-                        self.map = Image.core.map(self.filename)
-                        self.map.seek(offset)
-                        self.im = self.map.readimage(
-                            self.mode, self.size, args[1], args[2]
-                        )
-                    else:
-                        # use mmap, if possible
-                        import mmap
-
-                        with open(self.filename) as fp:
-                            self.map = mmap.mmap(
-                                fp.fileno(), 0, access=mmap.ACCESS_READ
-                            )
-                        self.im = Image.core.map_buffer(
-                            self.map, self.size, decoder_name, offset, args
-                        )
+                    # use mmap, if possible
+                    import mmap
+
+                    with open(self.filename) as fp:
+                        self.map = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)
+                    self.im = Image.core.map_buffer(
+                        self.map, self.size, decoder_name, offset, args
+                    )
                     readonly = 1
                     # After trashing self.im,
                     # we might need to reload the palette data.
@@ -230,16 +215,23 @@
             except AttributeError:
                 prefix = b""

+            # Remove consecutive duplicates that only differ by their offset
+            self.tile = [
+                list(tiles)[-1]
+                for _, tiles in itertools.groupby(
+                    self.tile, lambda tile: (tile[0], tile[1], tile[3])
+                )
+            ]
             for decoder_name, extents, offset, args in self.tile:
+                seek(offset)
                 decoder = Image._getdecoder(
                     self.mode, decoder_name, args, self.decoderconfig
                 )
                 try:
-                    seek(offset)
                     decoder.setimage(self.im, extents)
                     if decoder.pulls_fd:
                         decoder.setfd(self.fp)
-                        status, err_code = decoder.decode(b"")
+                        err_code = decoder.decode(b"")[1]
                     else:
                         b = prefix
                         while True:
@@ -340,6 +332,7 @@
         # become the other object (!)
         self.__class__ = image.__class__
         self.__dict__ = image.__dict__
+        return image.load()

     def _load(self):
         """(Hook) Find actual image loader."""
@@ -503,46 +496,36 @@
     # But, it would need at least the image size in most cases. RawEncode is
     # a tricky case.
     bufsize = max(MAXBLOCK, bufsize, im.size[0] * 4)  # see RawEncode.c
-    if fp == sys.stdout:
-        fp.flush()
-        return
     try:
         fh = fp.fileno()
         fp.flush()
-    except (AttributeError, io.UnsupportedOperation) as exc:
-        # compress to Python file-compatible object
-        for e, b, o, a in tile:
-            e = Image._getencoder(im.mode, e, a, im.encoderconfig)
-            if o > 0:
-                fp.seek(o)
-            e.setimage(im.im, b)
-            if e.pushes_fd:
-                e.setfd(fp)
-                l, s = e.encode_to_pyfd()
+        exc = None
+    except (AttributeError, io.UnsupportedOperation) as e:
+        exc = e
+    for e, b, o, a in tile:
+        if o > 0:
+            fp.seek(o)
+        encoder = Image._getencoder(im.mode, e, a, im.encoderconfig)
+        try:
+            encoder.setimage(im.im, b)
+            if encoder.pushes_fd:
+                encoder.setfd(fp)
+                l, s = encoder.encode_to_pyfd()
             else:
-                while True:
-                    l, s, d = e.encode(bufsize)
-                    fp.write(d)
-                    if s:
-                        break
+                if exc:
+                    # compress to Python file-compatible object
+                    while True:
+                        l, s, d = encoder.encode(bufsize)
+                        fp.write(d)
+                        if s:
+                            break
+                else:
+                    # slight speedup: compress to real file object
+                    s = encoder.encode_to_file(fh, bufsize)
             if s < 0:
                 raise OSError(f"encoder error {s} when writing image file") from exc
-            e.cleanup()
-    else:
-        # slight speedup: compress to real file object
-        for e, b, o, a in tile:
-            e = Image._getencoder(im.mode, e, a, im.encoderconfig)
-            if o > 0:
-                fp.seek(o)
-            e.setimage(im.im, b)
-            if e.pushes_fd:
-                e.setfd(fp)
-                l, s = e.encode_to_pyfd()
-            else:
-                s = e.encode_to_file(fh, bufsize)
-            if s < 0:
-                raise OSError(f"encoder error {s} when writing image file")
-            e.cleanup()
+        finally:
+            encoder.cleanup()
     if hasattr(fp, "flush"):
         fp.flush()

@@ -555,19 +538,28 @@

     :param fp: File handle.  Must implement a <b>read</b> method.
     :param size: Number of bytes to read.
-    :returns: A string containing up to <i>size</i> bytes of data.
+    :returns: A string containing <i>size</i> bytes of data.
+
+    Raises an OSError if the file is truncated and the read cannot be completed
+
     """
     if size <= 0:
         return b""
     if size <= SAFEBLOCK:
-        return fp.read(size)
+        data = fp.read(size)
+        if len(data) < size:
+            raise OSError("Truncated File Read")
+        return data
     data = []
-    while size > 0:
-        block = fp.read(min(size, SAFEBLOCK))
+    remaining_size = size
+    while remaining_size > 0:
+        block = fp.read(min(remaining_size, SAFEBLOCK))
         if not block:
             break
         data.append(block)
-        size -= len(block)
+        remaining_size -= len(block)
+    if sum(len(d) for d in data) < size:
+        raise OSError("Truncated File Read")
     return b"".join(data)


@@ -582,16 +574,7 @@
         return (self.xoff, self.yoff, self.xoff + self.xsize, self.yoff + self.ysize)


-class PyDecoder:
-    """
-    Python implementation of a format decoder. Override this class and
-    add the decoding logic in the :meth:`decode` method.
-
-    See :ref:`Writing Your Own File Decoder in Python<file-decoders-py>`
-    """
-
-    _pulls_fd = False
-
+class PyCodec:
     def __init__(self, mode, *args):
         self.im = None
         self.state = PyCodecState()
@@ -601,31 +584,16 @@

     def init(self, args):
         """
-        Override to perform decoder specific initialization
+        Override to perform codec specific initialization

         :param args: Array of args items from the tile entry
         :returns: None
         """
         self.args = args

-    @property
-    def pulls_fd(self):
-        return self._pulls_fd
-
-    def decode(self, buffer):
-        """
-        Override to perform the decoding process.
-
-        :param buffer: A bytes object with the data to be decoded.
-        :returns: A tuple of ``(bytes consumed, errcode)``.
-            If finished with decoding return <0 for the bytes consumed.
-            Err codes are from :data:`.ImageFile.ERRORS`.
-        """
-        raise NotImplementedError()
-
     def cleanup(self):
         """
-        Override to perform decoder specific cleanup
+        Override to perform codec specific cleanup

         :returns: None
         """
@@ -633,16 +601,16 @@

     def setfd(self, fd):
         """
-        Called from ImageFile to set the python file-like object
-
-        :param fd: A python file-like object
+        Called from ImageFile to set the Python file-like object
+
+        :param fd: A Python file-like object
         :returns: None
         """
         self.fd = fd

     def setimage(self, im, extents=None):
         """
-        Called from ImageFile to set the core output image for the decoder
+        Called from ImageFile to set the core output image for the codec

         :param im: A core image object
         :param extents: a 4 tuple of (x0, y0, x1, y1) defining the rectangle
@@ -675,6 +643,32 @@
         ):
             raise ValueError("Tile cannot extend outside image")

+
+class PyDecoder(PyCodec):
+    """
+    Python implementation of a format decoder. Override this class and
+    add the decoding logic in the :meth:`decode` method.
+
+    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`
+    """
+
+    _pulls_fd = False
+
+    @property
+    def pulls_fd(self):
+        return self._pulls_fd
+
+    def decode(self, buffer):
+        """
+        Override to perform the decoding process.
+
+        :param buffer: A bytes object with the data to be decoded.
+        :returns: A tuple of ``(bytes consumed, errcode)``.
+            If finished with decoding return -1 for the bytes consumed.
+            Err codes are from :data:`.ImageFile.ERRORS`.
+        """
+        raise NotImplementedError()
+
     def set_as_raw(self, data, rawmode=None):
         """
         Convenience method to set the internal image from a stream of raw data
@@ -695,3 +689,60 @@
             raise ValueError("not enough image data")
         if s[1] != 0:
             raise ValueError("cannot decode image data")
+
+
+class PyEncoder(PyCodec):
+    """
+    Python implementation of a format encoder. Override this class and
+    add the decoding logic in the :meth:`encode` method.
+
+    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`
+    """
+
+    _pushes_fd = False
+
+    @property
+    def pushes_fd(self):
+        return self._pushes_fd
+
+    def encode(self, bufsize):
+        """
+        Override to perform the encoding process.
+
+        :param bufsize: Buffer size.
+        :returns: A tuple of ``(bytes encoded, errcode, bytes)``.
+            If finished with encoding return 1 for the error code.
+            Err codes are from :data:`.ImageFile.ERRORS`.
+        """
+        raise NotImplementedError()
+
+    def encode_to_pyfd(self):
+        """
+        If ``pushes_fd`` is ``True``, then this method will be used,
+        and ``encode()`` will only be called once.
+
+        :returns: A tuple of ``(bytes consumed, errcode)``.
+            Err codes are from :data:`.ImageFile.ERRORS`.
+        """
+        if not self.pushes_fd:
+            return 0, -8  # bad configuration
+        bytes_consumed, errcode, data = self.encode(0)
+        if data:
+            self.fd.write(data)
+        return bytes_consumed, errcode
+
+    def encode_to_file(self, fh, bufsize):
+        """
+        :param fh: File handle.
+        :param bufsize: Buffer size.
+
+        :returns: If finished successfully, return 0.
+            Otherwise, return an error code. Err codes are from
+            :data:`.ImageFile.ERRORS`.
+        """
+        errcode = 0
+        while errcode == 0:
+            status, errcode, buf = self.encode(bufsize)
+            if status > 0:
+                fh.write(buf[status:])
+        return errcode
('src/PIL', 'SpiderImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -238,17 +238,18 @@
     if 1024 % lenbyt != 0:
         labrec += 1
     labbyt = labrec * lenbyt
+    nvalues = int(labbyt / 4)
+    if nvalues < 23:
+        return []
+
     hdr = []
-    nvalues = int(labbyt / 4)
     for i in range(nvalues):
         hdr.append(0.0)
-
-    if len(hdr) < 23:
-        return []

     # NB these are Fortran indices
     hdr[1] = 1.0  # nslice (=1 for an image)
     hdr[2] = float(nrow)  # number of rows per slice
+    hdr[3] = float(nrow)  # number of records in the image
     hdr[5] = 1.0  # iform for 2D image
     hdr[12] = float(nsam)  # number of pixels per line
     hdr[13] = float(labrec)  # number of records in file header
@@ -259,10 +260,7 @@
     hdr = hdr[1:]
     hdr.append(0.0)
     # pack binary data into a string
-    hdrstr = []
-    for v in hdr:
-        hdrstr.append(struct.pack("f", v))
-    return hdrstr
+    return [struct.pack("f", v) for v in hdr]


 def _save(im, fp, filename):
@@ -296,7 +294,7 @@
 if __name__ == "__main__":

     if len(sys.argv) < 2:
-        print("Syntax: python SpiderImagePlugin.py [infile] [outfile]")
+        print("Syntax: python3 SpiderImagePlugin.py [infile] [outfile]")
         sys.exit()

     filename = sys.argv[1]
@@ -316,7 +314,7 @@
             outfile = sys.argv[2]

             # perform some image operation
-            im = im.transpose(Image.FLIP_LEFT_RIGHT)
+            im = im.transpose(Image.Transpose.FLIP_LEFT_RIGHT)
             print(
                 f"saving a flipped version of {os.path.basename(filename)} "
                 f"as {outfile} "
('src/PIL', 'FitsStubImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -9,7 +9,9 @@
 # See the README file for information on usage and redistribution.
 #

-from . import Image, ImageFile
+import warnings
+
+from . import FitsImagePlugin, Image, ImageFile

 _handler = None

@@ -23,35 +25,39 @@
     global _handler
     _handler = handler

+    warnings.warn(
+        "FitsStubImagePlugin is deprecated and will be removed in Pillow "
+        "10 (2023-07-01). FITS images can now be read without a handler through "
+        "FitsImagePlugin instead.",
+        DeprecationWarning,
+    )

-# --------------------------------------------------------------------
-# Image adapter
+    # Override FitsImagePlugin with this handler
+    # for backwards compatibility
+    try:
+        Image.ID.remove(FITSStubImageFile.format)
+    except ValueError:
+        pass

-
-def _accept(prefix):
-    return prefix[:6] == b"SIMPLE"
+    Image.register_open(
+        FITSStubImageFile.format, FITSStubImageFile, FitsImagePlugin._accept
+    )


 class FITSStubImageFile(ImageFile.StubImageFile):

-    format = "FITS"
-    format_description = "FITS"
+    format = FitsImagePlugin.FitsImageFile.format
+    format_description = FitsImagePlugin.FitsImageFile.format_description

     def _open(self):
-
         offset = self.fp.tell()

-        if not _accept(self.fp.read(6)):
-            raise SyntaxError("Not a FITS file")
-
-        # FIXME: add more sanity checks here; mandatory header items
-        # include SIMPLE, BITPIX, NAXIS, etc.
+        im = FitsImagePlugin.FitsImageFile(self.fp)
+        self._size = im.size
+        self.mode = im.mode
+        self.tile = []

         self.fp.seek(offset)
-
-        # make something up
-        self.mode = "F"
-        self._size = 1, 1

         loader = self._load()
         if loader:
@@ -62,15 +68,10 @@


 def _save(im, fp, filename):
-    if _handler is None or not hasattr("_handler", "save"):
-        raise OSError("FITS save handler not installed")
-    _handler.save(im, fp, filename)
+    raise OSError("FITS save handler not installed")


 # --------------------------------------------------------------------
 # Registry

-Image.register_open(FITSStubImageFile.format, FITSStubImageFile, _accept)
 Image.register_save(FITSStubImageFile.format, _save)
-
-Image.register_extensions(FITSStubImageFile.format, [".fit", ".fits"])
('src/PIL', 'GribStubImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -59,7 +59,7 @@


 def _save(im, fp, filename):
-    if _handler is None or not hasattr("_handler", "save"):
+    if _handler is None or not hasattr(_handler, "save"):
         raise OSError("GRIB save handler not installed")
     _handler.save(im, fp, filename)

('src/PIL', 'ImageStat.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -91,7 +91,7 @@
         for i in range(0, len(self.h), 256):
             sum2 = 0.0
             for j in range(256):
-                sum2 += (j ** 2) * float(self.h[i + j])
+                sum2 += (j**2) * float(self.h[i + j])
             v.append(sum2)
         return v

('src/PIL', 'GimpPaletteFile.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -38,7 +38,7 @@
                 break

             # skip fields and comment lines
-            if re.match(br"\w+:|#", s):
+            if re.match(rb"\w+:|#", s):
                 continue
             if len(s) > 100:
                 raise SyntaxError("bad palette file")
('src/PIL', 'ImageColor.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,14 +24,16 @@

 def getrgb(color):
     """
-     Convert a color string to an RGB tuple. If the string cannot be parsed,
-     this function raises a :py:exc:`ValueError` exception.
+     Convert a color string to an RGB or RGBA tuple. If the string cannot be
+     parsed, this function raises a :py:exc:`ValueError` exception.

     .. versionadded:: 1.1.4

     :param color: A color string
     :return: ``(red, green, blue[, alpha])``
     """
+    if len(color) > 100:
+        raise ValueError("color specifier is too long")
     color = color.lower()

     rgb = colormap.get(color, None)
('src/PIL', 'MspImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,7 +21,7 @@
 # Figure 205. Windows Paint Version 1: "DanM" Format
 # Figure 206. Windows Paint Version 2: "LinS" Format. Used in Windows V2.03
 #
-# See also: http://www.fileformat.info/format/mspaint/egff.htm
+# See also: https://www.fileformat.info/format/mspaint/egff.htm

 import io
 import struct
@@ -73,7 +73,7 @@

 class MspDecoder(ImageFile.PyDecoder):
     # The algo for the MSP decoder is from
-    # http://www.fileformat.info/format/mspaint/egff.htm
+    # https://www.fileformat.info/format/mspaint/egff.htm
     # cc-by-attribution -- That page references is taken from the
     # Encyclopedia of Graphics File Formats and is licensed by
     # O'Reilly under the Creative Common/Attribution license
@@ -148,7 +148,7 @@

         self.set_as_raw(img.getvalue(), ("1", 0, 1))

-        return 0, 0
+        return -1, 0


 Image.register_decoder("MSP", MspDecoder)
('src/PIL', 'MicImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -68,7 +68,7 @@
         self.is_animated = self._n_frames > 1

         if len(self.images) > 1:
-            self.category = Image.CONTAINER
+            self._category = Image.CONTAINER

         self.seek(0)

('src/PIL', '_version.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,2 +1,2 @@
 # Master version for Pillow
-__version__ = "8.1.0"
+__version__ = "9.1.0"
('src/PIL', 'ImtImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -22,7 +22,7 @@
 #
 # --------------------------------------------------------------------

-field = re.compile(br"([a-z]*) ([^ \r\n]*)")
+field = re.compile(rb"([a-z]*) ([^ \r\n]*)")


 ##
('src/PIL', 'GifImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -28,11 +28,24 @@
 import math
 import os
 import subprocess
+from enum import IntEnum

 from . import Image, ImageChops, ImageFile, ImagePalette, ImageSequence
 from ._binary import i16le as i16
 from ._binary import o8
 from ._binary import o16le as o16
+
+
+class LoadingStrategy(IntEnum):
+    """.. versionadded:: 9.1.0"""
+
+    RGB_AFTER_FIRST = 0
+    RGB_AFTER_DIFFERENT_PALETTE_ONLY = 1
+    RGB_ALWAYS = 2
+
+
+#: .. versionadded:: 9.1.0
+LOADING_STRATEGY = LoadingStrategy.RGB_AFTER_FIRST

 # --------------------------------------------------------------------
 # Identify/read GIF files
@@ -61,6 +74,12 @@
             return self.fp.read(s[0])
         return None

+    def _is_palette_needed(self, p):
+        for i in range(0, len(p), 3):
+            if not (i // 3 == p[i] == p[i + 1] == p[i + 2]):
+                return True
+        return False
+
     def _open(self):

         # Screen
@@ -79,11 +98,9 @@
             self.info["background"] = s[11]
             # check if palette contains colour indices
             p = self.fp.read(3 << bits)
-            for i in range(0, len(p), 3):
-                if not (i // 3 == p[i] == p[i + 1] == p[i + 2]):
-                    p = ImagePalette.raw("RGB", p)
-                    self.global_palette = self.palette = p
-                    break
+            if self._is_palette_needed(p):
+                p = ImagePalette.raw("RGB", p)
+                self.global_palette = self.palette = p

         self.__fp = self.fp  # FIXME: hack
         self.__rewind = self.fp.tell()
@@ -97,7 +114,7 @@
             current = self.tell()
             try:
                 while True:
-                    self.seek(self.tell() + 1)
+                    self._seek(self.tell() + 1, False)
             except EOFError:
                 self._n_frames = self.tell() + 1
             self.seek(current)
@@ -110,22 +127,23 @@
                 self._is_animated = self._n_frames != 1
             else:
                 current = self.tell()
-
-                try:
-                    self.seek(1)
+                if current:
                     self._is_animated = True
-                except EOFError:
-                    self._is_animated = False
-
-                self.seek(current)
+                else:
+                    try:
+                        self._seek(1, False)
+                        self._is_animated = True
+                    except EOFError:
+                        self._is_animated = False
+
+                    self.seek(current)
         return self._is_animated

     def seek(self, frame):
         if not self._seek_check(frame):
             return
         if frame < self.__frame:
-            if frame != 0:
-                self.im = None
+            self.im = None
             self._seek(0)

         last_frame = self.__frame
@@ -136,27 +154,22 @@
                 self.seek(last_frame)
                 raise EOFError("no more images in GIF file") from e

-    def _seek(self, frame):
+    def _seek(self, frame, update_image=True):

         if frame == 0:
             # rewind
             self.__offset = 0
             self.dispose = None
-            self.dispose_extent = [0, 0, 0, 0]  # x0, y0, x1, y1
             self.__frame = -1
             self.__fp.seek(self.__rewind)
-            self._prev_im = None
             self.disposal_method = 0
         else:
             # ensure that the previous frame was loaded
-            if not self.im:
+            if self.tile and update_image:
                 self.load()

         if frame != self.__frame + 1:
             raise ValueError(f"cannot seek to frame {frame}")
-        self.__frame = frame
-
-        self.tile = []

         self.fp = self.__fp
         if self.__offset:
@@ -166,17 +179,24 @@
                 pass
             self.__offset = 0

-        if self.dispose:
-            self.im.paste(self.dispose, self.dispose_extent)
-
-        from copy import copy
-
-        self.palette = copy(self.global_palette)
+        s = self.fp.read(1)
+        if not s or s == b";":
+            raise EOFError
+
+        self.__frame = frame
+
+        self.tile = []
+
+        palette = None

         info = {}
+        frame_transparency = None
+        interlace = None
+        frame_dispose_extent = None
         while True:

-            s = self.fp.read(1)
+            if not s:
+                s = self.fp.read(1)
             if not s or s == b";":
                 break

@@ -192,7 +212,7 @@
                     #
                     flags = block[0]
                     if flags & 1:
-                        info["transparency"] = block[3]
+                        frame_transparency = block[3]
                     info["duration"] = i16(block, 1) * 10

                     # disposal method - find the value of bits 4 - 6
@@ -214,6 +234,7 @@
                         else:
                             info["comment"] = block
                         block = self.data()
+                    s = None
                     continue
                 elif s[0] == 255:
                     #
@@ -236,78 +257,191 @@
                 # extent
                 x0, y0 = i16(s, 0), i16(s, 2)
                 x1, y1 = x0 + i16(s, 4), y0 + i16(s, 6)
-                if x1 > self.size[0] or y1 > self.size[1]:
+                if (x1 > self.size[0] or y1 > self.size[1]) and update_image:
                     self._size = max(x1, self.size[0]), max(y1, self.size[1])
-                self.dispose_extent = x0, y0, x1, y1
+                frame_dispose_extent = x0, y0, x1, y1
                 flags = s[8]

                 interlace = (flags & 64) != 0

                 if flags & 128:
                     bits = (flags & 7) + 1
-                    self.palette = ImagePalette.raw("RGB", self.fp.read(3 << bits))
+                    p = self.fp.read(3 << bits)
+                    if self._is_palette_needed(p):
+                        palette = ImagePalette.raw("RGB", p)

                 # image data
                 bits = self.fp.read(1)[0]
                 self.__offset = self.fp.tell()
-                self.tile = [
-                    ("gif", (x0, y0, x1, y1), self.__offset, (bits, interlace))
-                ]
                 break

             else:
                 pass
                 # raise OSError, "illegal GIF tag `%x`" % s[0]
-
+            s = None
+
+        if interlace is None:
+            # self.__fp = None
+            raise EOFError
+        if not update_image:
+            return
+
+        if self.dispose:
+            self.im.paste(self.dispose, self.dispose_extent)
+
+        self._frame_palette = palette or self.global_palette
+        if frame == 0:
+            if self._frame_palette:
+                self.mode = (
+                    "RGB" if LOADING_STRATEGY == LoadingStrategy.RGB_ALWAYS else "P"
+                )
+            else:
+                self.mode = "L"
+
+            if not palette and self.global_palette:
+                from copy import copy
+
+                palette = copy(self.global_palette)
+            self.palette = palette
+        else:
+            self._frame_transparency = frame_transparency
+            if self.mode == "P":
+                if (
+                    LOADING_STRATEGY != LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY
+                    or palette
+                ):
+                    self.pyaccess = None
+                    if "transparency" in self.info:
+                        self.im.putpalettealpha(self.info["transparency"], 0)
+                        self.im = self.im.convert("RGBA", Image.Dither.FLOYDSTEINBERG)
+                        self.mode = "RGBA"
+                        del self.info["transparency"]
+                    else:
+                        self.mode = "RGB"
+                        self.im = self.im.convert("RGB", Image.Dither.FLOYDSTEINBERG)
+
+        def _rgb(color):
+            if self._frame_palette:
+                color = tuple(self._frame_palette.palette[color * 3 : color * 3 + 3])
+            else:
+                color = (color, color, color)
+            return color
+
+        self.dispose_extent = frame_dispose_extent
         try:
             if self.disposal_method < 2:
                 # do not dispose or none specified
                 self.dispose = None
             elif self.disposal_method == 2:
                 # replace with background colour
-                Image._decompression_bomb_check(self.size)
-                self.dispose = Image.core.fill("P", self.size, self.info["background"])
+
+                # only dispose the extent in this frame
+                x0, y0, x1, y1 = self.dispose_extent
+                dispose_size = (x1 - x0, y1 - y0)
+
+                Image._decompression_bomb_check(dispose_size)
+
+                # by convention, attempt to use transparency first
+                dispose_mode = "P"
+                color = self.info.get("transparency", frame_transparency)
+                if color is not None:
+                    if self.mode in ("RGB", "RGBA"):
+                        dispose_mode = "RGBA"
+                        color = _rgb(color) + (0,)
+                else:
+                    color = self.info.get("background", 0)
+                    if self.mode in ("RGB", "RGBA"):
+                        dispose_mode = "RGB"
+                        color = _rgb(color)
+                self.dispose = Image.core.fill(dispose_mode, dispose_size, color)
             else:
                 # replace with previous contents
-                if self.im:
-                    self.dispose = self.im.copy()
-
-            # only dispose the extent in this frame
-            if self.dispose:
-                self.dispose = self._crop(self.dispose, self.dispose_extent)
-        except (AttributeError, KeyError):
+                if self.im is not None:
+                    # only dispose the extent in this frame
+                    self.dispose = self._crop(self.im, self.dispose_extent)
+                elif frame_transparency is not None:
+                    x0, y0, x1, y1 = self.dispose_extent
+                    dispose_size = (x1 - x0, y1 - y0)
+
+                    Image._decompression_bomb_check(dispose_size)
+                    dispose_mode = "P"
+                    color = frame_transparency
+                    if self.mode in ("RGB", "RGBA"):
+                        dispose_mode = "RGBA"
+                        color = _rgb(frame_transparency) + (0,)
+                    self.dispose = Image.core.fill(dispose_mode, dispose_size, color)
+        except AttributeError:
             pass

-        if not self.tile:
-            # self.__fp = None
-            raise EOFError
-
-        for k in ["transparency", "duration", "comment", "extension", "loop"]:
+        if interlace is not None:
+            transparency = -1
+            if frame_transparency is not None:
+                if frame == 0:
+                    self.info["transparency"] = frame_transparency
+                elif self.mode not in ("RGB", "RGBA"):
+                    transparency = frame_transparency
+            self.tile = [
+                (
+                    "gif",
+                    (x0, y0, x1, y1),
+                    self.__offset,
+                    (bits, interlace, transparency),
+                )
+            ]
+
+        for k in ["duration", "comment", "extension", "loop"]:
             if k in info:
                 self.info[k] = info[k]
             elif k in self.info:
                 del self.info[k]

-        self.mode = "L"
-        if self.palette:
-            self.mode = "P"
+    def load_prepare(self):
+        temp_mode = "P" if self._frame_palette else "L"
+        self._prev_im = None
+        if self.__frame == 0:
+            if "transparency" in self.info:
+                self.im = Image.core.fill(
+                    temp_mode, self.size, self.info["transparency"]
+                )
+        elif self.mode in ("RGB", "RGBA"):
+            self._prev_im = self.im
+            if self._frame_palette:
+                self.im = Image.core.fill("P", self.size, self._frame_transparency or 0)
+                self.im.putpalette(*self._frame_palette.getdata())
+            else:
+                self.im = None
+        self.mode = temp_mode
+        self._frame_palette = None
+
+        super().load_prepare()
+
+    def load_end(self):
+        if self.__frame == 0:
+            if self.mode == "P" and LOADING_STRATEGY == LoadingStrategy.RGB_ALWAYS:
+                self.mode = "RGB"
+                self.im = self.im.convert("RGB", Image.Dither.FLOYDSTEINBERG)
+            return
+        if self.mode == "P" and self._prev_im:
+            if self._frame_transparency is not None:
+                self.im.putpalettealpha(self._frame_transparency, 0)
+                frame_im = self.im.convert("RGBA")
+            else:
+                frame_im = self.im.convert("RGB")
+        else:
+            if not self._prev_im:
+                return
+            frame_im = self.im
+        frame_im = self._crop(frame_im, self.dispose_extent)
+
+        self.im = self._prev_im
+        self.mode = self.im.mode
+        if frame_im.mode == "RGBA":
+            self.im.paste(frame_im, self.dispose_extent, frame_im)
+        else:
+            self.im.paste(frame_im, self.dispose_extent)

     def tell(self):
         return self.__frame
-
-    def load_end(self):
-        ImageFile.ImageFile.load_end(self)
-
-        # if the disposal method is 'do not dispose', transparent
-        # pixels should show the content of the previous frame
-        if self._prev_im and self._prev_disposal_method == 1:
-            # we do this by pasting the updated area onto the previous
-            # frame which we then use as the current image content
-            updated = self._crop(self.im, self.dispose_extent)
-            self._prev_im.paste(updated, self.dispose_extent, updated.convert("RGBA"))
-            self.im = self._prev_im
-        self._prev_im = self.im.copy()
-        self._prev_disposal_method = self.disposal_method

     def _close__fp(self):
         try:
@@ -326,7 +460,7 @@
 RAWMODE = {"1": "L", "L": "L", "P": "P"}


-def _normalize_mode(im, initial_call=False):
+def _normalize_mode(im):
     """
     Takes an image (or frame), returns an image in a mode that is appropriate
     for saving in a Gif.
@@ -334,25 +468,20 @@
     It may return the original image, or it may return an image converted to
     palette or 'L' mode.

-    UNDONE: What is the point of mucking with the initial call palette, for
-    an image that shouldn't have a palette, or it would be a mode 'P' and
-    get returned in the RAWMODE clause.
-
     :param im: Image object
-    :param initial_call: Default false, set to true for a single frame.
     :returns: Image object
     """
     if im.mode in RAWMODE:
         im.load()
         return im
     if Image.getmodebase(im.mode) == "RGB":
-        if initial_call:
-            palette_size = 256
-            if im.palette:
-                palette_size = len(im.palette.getdata()[1]) // 3
-            return im.convert("P", palette=Image.ADAPTIVE, colors=palette_size)
-        else:
-            return im.convert("P")
+        im = im.convert("P", palette=Image.Palette.ADAPTIVE)
+        if im.palette.mode == "RGBA":
+            for rgba in im.palette.colors.keys():
+                if rgba[3] == 0:
+                    im.info["transparency"] = im.palette.colors[rgba]
+                    break
+        return im
     return im.convert("L")


@@ -374,15 +503,7 @@
         if isinstance(palette, (bytes, bytearray, list)):
             source_palette = bytearray(palette[:768])
         if isinstance(palette, ImagePalette.ImagePalette):
-            source_palette = bytearray(
-                itertools.chain.from_iterable(
-                    zip(
-                        palette.palette[:256],
-                        palette.palette[256:512],
-                        palette.palette[512:768],
-                    )
-                )
-            )
+            source_palette = bytearray(palette.palette)

     if im.mode == "P":
         if not source_palette:
@@ -392,16 +513,33 @@
             source_palette = bytearray(i // 3 for i in range(768))
         im.palette = ImagePalette.ImagePalette("RGB", palette=source_palette)

-    used_palette_colors = _get_optimize(im, info)
-    if used_palette_colors is not None:
-        return im.remap_palette(used_palette_colors, source_palette)
+    if palette:
+        used_palette_colors = []
+        for i in range(0, len(source_palette), 3):
+            source_color = tuple(source_palette[i : i + 3])
+            try:
+                index = im.palette.colors[source_color]
+            except KeyError:
+                index = None
+            used_palette_colors.append(index)
+        for i, index in enumerate(used_palette_colors):
+            if index is None:
+                for j in range(len(used_palette_colors)):
+                    if j not in used_palette_colors:
+                        used_palette_colors[i] = j
+                        break
+        im = im.remap_palette(used_palette_colors)
+    else:
+        used_palette_colors = _get_optimize(im, info)
+        if used_palette_colors is not None:
+            return im.remap_palette(used_palette_colors, source_palette)

     im.palette.palette = source_palette
     return im


 def _write_single_frame(im, fp, palette):
-    im_out = _normalize_mode(im, True)
+    im_out = _normalize_mode(im)
     for k, v in im_out.info.items():
         im.encoderinfo.setdefault(k, v)
     im_out = _normalize_palette(im_out, palette, im.encoderinfo)
@@ -450,10 +588,10 @@
                 previous = im_frames[-1]
                 if encoderinfo.get("disposal") == 2:
                     if background_im is None:
-                        background = _get_background(
-                            im,
-                            im.encoderinfo.get("background", im.info.get("background")),
+                        color = im.encoderinfo.get(
+                            "transparency", im.info.get("transparency", (0, 0, 0))
                         )
+                        background = _get_background(im_frame, color)
                         background_im = Image.new("P", im_frame.size, background)
                         background_im.putpalette(im_frames[0]["im"].palette)
                     base_im = background_im
@@ -485,7 +623,8 @@
                 offset = (0, 0)
             else:
                 # compress difference
-                frame_data["encoderinfo"]["include_color_table"] = True
+                if not palette:
+                    frame_data["encoderinfo"]["include_color_table"] = True

                 im_frame = im_frame.crop(frame_data["bbox"])
                 offset = frame_data["bbox"][:2]
@@ -532,11 +671,14 @@
 def _write_local_header(fp, im, offset, flags):
     transparent_color_exists = False
     try:
-        transparency = im.encoderinfo["transparency"]
-    except KeyError:
+        if "transparency" in im.encoderinfo:
+            transparency = im.encoderinfo["transparency"]
+        else:
+            transparency = im.info["transparency"]
+        transparency = int(transparency)
+    except (KeyError, ValueError):
         pass
     else:
-        transparency = int(transparency)
         # optimize the block away if transparent color is not used
         transparent_color_exists = True

@@ -749,7 +891,15 @@
             # WebPImagePlugin stores an RGBA value in info["background"]
             # So it must be converted to the same format as GifImagePlugin's
             # info["background"] - a global color table index
-            background = im.palette.getcolor(background)
+            try:
+                background = im.palette.getcolor(background, im)
+            except ValueError as e:
+                if str(e) == "cannot allocate more than 256 colors":
+                    # If all 256 colors are in use,
+                    # then there is no need for the background color
+                    return 0
+                else:
+                    raise
     return background


@@ -757,7 +907,7 @@
     """Return a list of strings representing a GIF header"""

     # Header Block
-    # http://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp
+    # https://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp

     version = b"87a"
     for extensionKey in ["transparency", "duration", "loop", "comment"]:
('src/PIL', 'ImageQt.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,6 +23,7 @@
 from ._util import isPath

 qt_versions = [
+    ["6", "PyQt6"],
     ["side6", "PySide6"],
     ["5", "PyQt5"],
     ["side2", "PySide2"],
@@ -32,7 +33,10 @@
 qt_versions.sort(key=lambda qt_version: qt_version[1] in sys.modules, reverse=True)
 for qt_version, qt_module in qt_versions:
     try:
-        if qt_module == "PySide6":
+        if qt_module == "PyQt6":
+            from PyQt6.QtCore import QBuffer, QIODevice
+            from PyQt6.QtGui import QImage, QPixmap, qRgba
+        elif qt_module == "PySide6":
             from PySide6.QtCore import QBuffer, QIODevice
             from PySide6.QtGui import QImage, QPixmap, qRgba
         elif qt_module == "PyQt5":
@@ -59,11 +63,17 @@

 def fromqimage(im):
     """
-    :param im: A PIL Image object, or a file name
-    (given either as Python string or a PyQt string object)
+    :param im: QImage or PIL ImageQt object
     """
     buffer = QBuffer()
-    buffer.open(QIODevice.ReadWrite)
+    if qt_version == "6":
+        try:
+            qt_openmode = QIODevice.OpenModeFlag
+        except AttributeError:
+            qt_openmode = QIODevice.OpenMode
+    else:
+        qt_openmode = QIODevice
+    buffer.open(qt_openmode.ReadWrite)
     # preserve alpha channel with png
     # otherwise ppm is more friendly with Image.open
     if im.hasAlphaChannel():
@@ -98,7 +108,7 @@
     converts each scanline of data from 8 bit to 32 bit aligned
     """

-    bits_per_pixel = {"1": 1, "L": 8, "P": 8}[mode]
+    bits_per_pixel = {"1": 1, "L": 8, "P": 8, "I;16": 16}[mode]

     # calculate bytes per line and the extra padding if needed
     bits_per_line = bits_per_pixel * width
@@ -124,6 +134,7 @@
 def _toqclass_helper(im):
     data = None
     colortable = None
+    exclusive_fp = False

     # handle filename, if given instead of image name
     if hasattr(im, "toUtf8"):
@@ -131,31 +142,45 @@
         im = str(im.toUtf8(), "utf-8")
     if isPath(im):
         im = Image.open(im)
-
+        exclusive_fp = True
+
+    qt_format = QImage.Format if qt_version == "6" else QImage
     if im.mode == "1":
-        format = QImage.Format_Mono
+        format = qt_format.Format_Mono
     elif im.mode == "L":
-        format = QImage.Format_Indexed8
+        format = qt_format.Format_Indexed8
         colortable = []
         for i in range(256):
             colortable.append(rgb(i, i, i))
     elif im.mode == "P":
-        format = QImage.Format_Indexed8
+        format = qt_format.Format_Indexed8
         colortable = []
         palette = im.getpalette()
         for i in range(0, len(palette), 3):
             colortable.append(rgb(*palette[i : i + 3]))
     elif im.mode == "RGB":
-        data = im.tobytes("raw", "BGRX")
-        format = QImage.Format_RGB32
+        # Populate the 4th channel with 255
+        im = im.convert("RGBA")
+
+        data = im.tobytes("raw", "BGRA")
+        format = qt_format.Format_RGB32
     elif im.mode == "RGBA":
         data = im.tobytes("raw", "BGRA")
-        format = QImage.Format_ARGB32
+        format = qt_format.Format_ARGB32
+    elif im.mode == "I;16" and hasattr(qt_format, "Format_Grayscale16"):  # Qt 5.13+
+        im = im.point(lambda i: i * 256)
+
+        format = qt_format.Format_Grayscale16
     else:
+        if exclusive_fp:
+            im.close()
         raise ValueError(f"unsupported image mode {repr(im.mode)}")

-    __data = data or align8to32(im.tobytes(), im.size[0], im.mode)
-    return {"data": __data, "im": im, "format": format, "colortable": colortable}
+    size = im.size
+    __data = data or align8to32(im.tobytes(), size[0], im.mode)
+    if exclusive_fp:
+        im.close()
+    return {"data": __data, "size": size, "format": format, "colortable": colortable}


 if qt_is_installed:
@@ -177,8 +202,8 @@
             self.__data = im_data["data"]
             super().__init__(
                 self.__data,
-                im_data["im"].size[0],
-                im_data["im"].size[1],
+                im_data["size"][0],
+                im_data["size"][1],
                 im_data["format"],
             )
             if im_data["colortable"]:
@@ -192,11 +217,7 @@
 def toqpixmap(im):
     # # This doesn't work. For now using a dumb approach.
     # im_data = _toqclass_helper(im)
-    # result = QPixmap(im_data['im'].size[0], im_data['im'].size[1])
-    # result.loadFromData(im_data['data'])
-    # Fix some strange bug that causes
-    if im.mode == "RGB":
-        im = im.convert("RGBA")
-
+    # result = QPixmap(im_data["size"][0], im_data["size"][1])
+    # result.loadFromData(im_data["data"])
     qimage = toqimage(im)
     return QPixmap.fromImage(qimage)
('src/PIL', 'ImageMath.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -18,8 +18,6 @@
 import builtins

 from . import Image, _imagingmath
-
-VERBOSE = 0


 def _isconstant(v):
@@ -69,8 +67,6 @@
                     im1 = im1.convert("F")
                 if im2.mode != "F":
                     im2 = im2.convert("F")
-                if im1.mode != im2.mode:
-                    raise ValueError("mode mismatch")
             if im1.size != im2.size:
                 # crop both arguments to a common size
                 size = (min(im1.size[0], im2.size[0]), min(im1.size[1], im2.size[1]))
@@ -78,9 +74,7 @@
                     im1 = im1.crop((0, 0) + size)
                 if im2.size != size:
                     im2 = im2.crop((0, 0) + size)
-                out = Image.new(mode or im1.mode, size, None)
-            else:
-                out = Image.new(mode or im1.mode, im1.size, None)
+            out = Image.new(mode or im1.mode, im1.size, None)
             im1.load()
             im2.load()
             try:
@@ -246,7 +240,19 @@
         if hasattr(v, "im"):
             args[k] = _Operand(v)

-    out = builtins.eval(expression, args)
+    compiled_code = compile(expression, "<string>", "eval")
+
+    def scan(code):
+        for const in code.co_consts:
+            if type(const) == type(compiled_code):
+                scan(const)
+
+        for name in code.co_names:
+            if name not in args and name != "abs":
+                raise ValueError(f"'{name}' not allowed")
+
+    scan(compiled_code)
+    out = builtins.eval(expression, {"__builtins": {"abs": abs}}, args)
     try:
         return out.im
     except AttributeError:
('src/PIL', 'PdfParser.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -330,6 +330,8 @@
         return bytes(x)
     elif isinstance(x, int):
         return str(x).encode("us-ascii")
+    elif isinstance(x, float):
+        return str(x).encode("us-ascii")
     elif isinstance(x, time.struct_time):
         return b"(D:" + time.strftime("%Y%m%d%H%M%SZ", x).encode("us-ascii") + b")"
     elif isinstance(x, dict):
@@ -423,7 +425,7 @@
         self.f.write(b"%PDF-1.4\n")

     def write_comment(self, s):
-        self.f.write(f"% {s}\n".encode("utf-8"))
+        self.f.write(f"% {s}\n".encode())

     def write_catalog(self):
         self.del_root()
@@ -574,40 +576,42 @@
             self.xref_table[reference.object_id] = (offset, 0)
         return reference

-    delimiter = br"[][()<>{}/%]"
-    delimiter_or_ws = br"[][()<>{}/%\000\011\012\014\015\040]"
-    whitespace = br"[\000\011\012\014\015\040]"
-    whitespace_or_hex = br"[\000\011\012\014\015\0400-9a-fA-F]"
+    delimiter = rb"[][()<>{}/%]"
+    delimiter_or_ws = rb"[][()<>{}/%\000\011\012\014\015\040]"
+    whitespace = rb"[\000\011\012\014\015\040]"
+    whitespace_or_hex = rb"[\000\011\012\014\015\0400-9a-fA-F]"
     whitespace_optional = whitespace + b"*"
     whitespace_mandatory = whitespace + b"+"
-    newline_only = br"[\r\n]+"
-    newline = whitespace_optional + newline_only + whitespace_optional
+    # No "\012" aka "\n" or "\015" aka "\r":
+    whitespace_optional_no_nl = rb"[\000\011\014\040]*"
+    newline_only = rb"[\r\n]+"
+    newline = whitespace_optional_no_nl + newline_only + whitespace_optional_no_nl
     re_trailer_end = re.compile(
         whitespace_mandatory
-        + br"trailer"
+        + rb"trailer"
         + whitespace_optional
-        + br"\<\<(.*\>\>)"
+        + rb"\<\<(.*\>\>)"
         + newline
-        + br"startxref"
+        + rb"startxref"
         + newline
-        + br"([0-9]+)"
+        + rb"([0-9]+)"
         + newline
-        + br"%%EOF"
+        + rb"%%EOF"
         + whitespace_optional
-        + br"$",
+        + rb"$",
         re.DOTALL,
     )
     re_trailer_prev = re.compile(
         whitespace_optional
-        + br"trailer"
+        + rb"trailer"
         + whitespace_optional
-        + br"\<\<(.*?\>\>)"
+        + rb"\<\<(.*?\>\>)"
         + newline
-        + br"startxref"
+        + rb"startxref"
         + newline
-        + br"([0-9]+)"
+        + rb"([0-9]+)"
         + newline
-        + br"%%EOF"
+        + rb"%%EOF"
         + whitespace_optional,
         re.DOTALL,
     )
@@ -651,12 +655,12 @@
     re_whitespace_optional = re.compile(whitespace_optional)
     re_name = re.compile(
         whitespace_optional
-        + br"/([!-$&'*-.0-;=?-Z\\^-z|~]+)(?="
+        + rb"/([!-$&'*-.0-;=?-Z\\^-z|~]+)(?="
         + delimiter_or_ws
-        + br")"
-    )
-    re_dict_start = re.compile(whitespace_optional + br"\<\<")
-    re_dict_end = re.compile(whitespace_optional + br"\>\>" + whitespace_optional)
+        + rb")"
+    )
+    re_dict_start = re.compile(whitespace_optional + rb"\<\<")
+    re_dict_end = re.compile(whitespace_optional + rb"\>\>" + whitespace_optional)

     @classmethod
     def interpret_trailer(cls, trailer_data):
@@ -685,7 +689,7 @@
         )
         return trailer

-    re_hashes_in_name = re.compile(br"([^#]*)(#([0-9a-fA-F]{2}))?")
+    re_hashes_in_name = re.compile(rb"([^#]*)(#([0-9a-fA-F]{2}))?")

     @classmethod
     def interpret_name(cls, raw, as_text=False):
@@ -700,53 +704,53 @@
         else:
             return bytes(name)

-    re_null = re.compile(whitespace_optional + br"null(?=" + delimiter_or_ws + br")")
-    re_true = re.compile(whitespace_optional + br"true(?=" + delimiter_or_ws + br")")
-    re_false = re.compile(whitespace_optional + br"false(?=" + delimiter_or_ws + br")")
+    re_null = re.compile(whitespace_optional + rb"null(?=" + delimiter_or_ws + rb")")
+    re_true = re.compile(whitespace_optional + rb"true(?=" + delimiter_or_ws + rb")")
+    re_false = re.compile(whitespace_optional + rb"false(?=" + delimiter_or_ws + rb")")
     re_int = re.compile(
-        whitespace_optional + br"([-+]?[0-9]+)(?=" + delimiter_or_ws + br")"
+        whitespace_optional + rb"([-+]?[0-9]+)(?=" + delimiter_or_ws + rb")"
     )
     re_real = re.compile(
         whitespace_optional
-        + br"([-+]?([0-9]+\.[0-9]*|[0-9]*\.[0-9]+))(?="
+        + rb"([-+]?([0-9]+\.[0-9]*|[0-9]*\.[0-9]+))(?="
         + delimiter_or_ws
-        + br")"
-    )
-    re_array_start = re.compile(whitespace_optional + br"\[")
-    re_array_end = re.compile(whitespace_optional + br"]")
+        + rb")"
+    )
+    re_array_start = re.compile(whitespace_optional + rb"\[")
+    re_array_end = re.compile(whitespace_optional + rb"]")
     re_string_hex = re.compile(
-        whitespace_optional + br"\<(" + whitespace_or_hex + br"*)\>"
-    )
-    re_string_lit = re.compile(whitespace_optional + br"\(")
+        whitespace_optional + rb"\<(" + whitespace_or_hex + rb"*)\>"
+    )
+    re_string_lit = re.compile(whitespace_optional + rb"\(")
     re_indirect_reference = re.compile(
         whitespace_optional
-        + br"([-+]?[0-9]+)"
+        + rb"([-+]?[0-9]+)"
         + whitespace_mandatory
-        + br"([-+]?[0-9]+)"
+        + rb"([-+]?[0-9]+)"
         + whitespace_mandatory
-        + br"R(?="
+        + rb"R(?="
         + delimiter_or_ws
-        + br")"
+        + rb")"
     )
     re_indirect_def_start = re.compile(
         whitespace_optional
-        + br"([-+]?[0-9]+)"
+        + rb"([-+]?[0-9]+)"
         + whitespace_mandatory
-        + br"([-+]?[0-9]+)"
+        + rb"([-+]?[0-9]+)"
         + whitespace_mandatory
-        + br"obj(?="
+        + rb"obj(?="
         + delimiter_or_ws
-        + br")"
+        + rb")"
     )
     re_indirect_def_end = re.compile(
-        whitespace_optional + br"endobj(?=" + delimiter_or_ws + br")"
+        whitespace_optional + rb"endobj(?=" + delimiter_or_ws + rb")"
     )
     re_comment = re.compile(
-        br"(" + whitespace_optional + br"%[^\r\n]*" + newline + br")*"
-    )
-    re_stream_start = re.compile(whitespace_optional + br"stream\r?\n")
+        rb"(" + whitespace_optional + rb"%[^\r\n]*" + newline + rb")*"
+    )
+    re_stream_start = re.compile(whitespace_optional + rb"stream\r?\n")
     re_stream_end = re.compile(
-        whitespace_optional + br"endstream(?=" + delimiter_or_ws + br")"
+        whitespace_optional + rb"endstream(?=" + delimiter_or_ws + rb")"
     )

     @classmethod
@@ -859,7 +863,7 @@
         if m:
             # filter out whitespace
             hex_string = bytearray(
-                [b for b in m.group(1) if b in b"0123456789abcdefABCDEF"]
+                b for b in m.group(1) if b in b"0123456789abcdefABCDEF"
             )
             if len(hex_string) % 2 == 1:
                 # append a 0 if the length is not even - yes, at the end
@@ -872,7 +876,7 @@
         raise PdfFormatError("unrecognized object: " + repr(data[offset : offset + 32]))

     re_lit_str_token = re.compile(
-        br"(\\[nrtbf()\\])|(\\[0-9]{1,3})|(\\(\r\n|\r|\n))|(\r\n|\r|\n)|(\()|(\))"
+        rb"(\\[nrtbf()\\])|(\\[0-9]{1,3})|(\\(\r\n|\r|\n))|(\r\n|\r|\n)|(\()|(\))"
     )
     escaped_chars = {
         b"n": b"\n",
@@ -918,16 +922,16 @@
             offset = m.end()
         raise PdfFormatError("unfinished literal string")

-    re_xref_section_start = re.compile(whitespace_optional + br"xref" + newline)
+    re_xref_section_start = re.compile(whitespace_optional + rb"xref" + newline)
     re_xref_subsection_start = re.compile(
         whitespace_optional
-        + br"([0-9]+)"
+        + rb"([0-9]+)"
         + whitespace_mandatory
-        + br"([0-9]+)"
+        + rb"([0-9]+)"
         + whitespace_optional
         + newline_only
     )
-    re_xref_entry = re.compile(br"([0-9]{10}) ([0-9]{5}) ([fn])( \r| \n|\r\n)")
+    re_xref_entry = re.compile(rb"([0-9]{10}) ([0-9]{5}) ([fn])( \r| \n|\r\n)")

     def read_xref_table(self, xref_section_offset):
         subsection_found = False
('src/PIL', 'ExifTags.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -17,6 +17,7 @@

 TAGS = {
     # possibly incomplete
+    0x0001: "InteropIndex",
     0x000B: "ProcessingSoftware",
     0x00FE: "NewSubfileType",
     0x00FF: "SubfileType",
@@ -121,9 +122,18 @@
     0x8829: "Interlace",
     0x882A: "TimeZoneOffset",
     0x882B: "SelfTimerMode",
+    0x8830: "SensitivityType",
+    0x8831: "StandardOutputSensitivity",
+    0x8832: "RecommendedExposureIndex",
+    0x8833: "ISOSpeed",
+    0x8834: "ISOSpeedLatitudeyyy",
+    0x8835: "ISOSpeedLatitudezzz",
     0x9000: "ExifVersion",
     0x9003: "DateTimeOriginal",
     0x9004: "DateTimeDigitized",
+    0x9010: "OffsetTime",
+    0x9011: "OffsetTimeOriginal",
+    0x9012: "OffsetTimeDigitized",
     0x9101: "ComponentsConfiguration",
     0x9102: "CompressedBitsPerPixel",
     0x9201: "ShutterSpeedValue",
@@ -197,6 +207,9 @@
     0xA433: "LensMake",
     0xA434: "LensModel",
     0xA435: "LensSerialNumber",
+    0xA460: "CompositeImage",
+    0xA461: "CompositeImageCount",
+    0xA462: "CompositeImageExposureTimes",
     0xA500: "Gamma",
     0xC4A5: "PrintImageMatching",
     0xC612: "DNGVersion",
('src/PIL', 'ImageCms.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,6 +16,8 @@
 # below for the original description.

 import sys
+import warnings
+from enum import IntEnum

 from PIL import Image

@@ -34,10 +36,10 @@
     a Python / PIL interface to the littleCMS ICC Color Management System
     Copyright (C) 2002-2003 Kevin Cazabon
     kevin@cazabon.com
-    http://www.cazabon.com
-
-    pyCMS home page:  http://www.cazabon.com/pyCMS
-    littleCMS home page:  http://www.littlecms.com
+    https://www.cazabon.com
+
+    pyCMS home page:  https://www.cazabon.com/pyCMS
+    littleCMS home page:  https://www.littlecms.com
     (littleCMS is Copyright (C) 1998-2001 Marti Maria)

     Originally released under LGPL.  Graciously donated to PIL in
@@ -100,14 +102,42 @@
 #
 # intent/direction values

-INTENT_PERCEPTUAL = 0
-INTENT_RELATIVE_COLORIMETRIC = 1
-INTENT_SATURATION = 2
-INTENT_ABSOLUTE_COLORIMETRIC = 3
-
-DIRECTION_INPUT = 0
-DIRECTION_OUTPUT = 1
-DIRECTION_PROOF = 2
+
+class Intent(IntEnum):
+    PERCEPTUAL = 0
+    RELATIVE_COLORIMETRIC = 1
+    SATURATION = 2
+    ABSOLUTE_COLORIMETRIC = 3
+
+
+class Direction(IntEnum):
+    INPUT = 0
+    OUTPUT = 1
+    PROOF = 2
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {Intent: "INTENT_", Direction: "DIRECTION_"}.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
+

 #
 # flags
@@ -211,9 +241,9 @@
         output,
         input_mode,
         output_mode,
-        intent=INTENT_PERCEPTUAL,
+        intent=Intent.PERCEPTUAL,
         proof=None,
-        proof_intent=INTENT_ABSOLUTE_COLORIMETRIC,
+        proof_intent=Intent.ABSOLUTE_COLORIMETRIC,
         flags=0,
     ):
         if proof is None:
@@ -295,7 +325,7 @@
     im,
     inputProfile,
     outputProfile,
-    renderingIntent=INTENT_PERCEPTUAL,
+    renderingIntent=Intent.PERCEPTUAL,
     outputMode=None,
     inPlace=False,
     flags=0,
@@ -331,10 +361,10 @@
     :param renderingIntent: Integer (0-3) specifying the rendering intent you
         wish to use for the transform

-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3

         see the pyCMS documentation for details on rendering intents and what
         they do.
@@ -412,7 +442,7 @@
     outputProfile,
     inMode,
     outMode,
-    renderingIntent=INTENT_PERCEPTUAL,
+    renderingIntent=Intent.PERCEPTUAL,
     flags=0,
 ):
     """
@@ -458,10 +488,10 @@
     :param renderingIntent: Integer (0-3) specifying the rendering intent you
         wish to use for the transform

-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3

         see the pyCMS documentation for details on rendering intents and what
         they do.
@@ -494,8 +524,8 @@
     proofProfile,
     inMode,
     outMode,
-    renderingIntent=INTENT_PERCEPTUAL,
-    proofRenderingIntent=INTENT_ABSOLUTE_COLORIMETRIC,
+    renderingIntent=Intent.PERCEPTUAL,
+    proofRenderingIntent=Intent.ABSOLUTE_COLORIMETRIC,
     flags=FLAGS["SOFTPROOFING"],
 ):
     """
@@ -550,20 +580,20 @@
     :param renderingIntent: Integer (0-3) specifying the rendering intent you
         wish to use for the input->proof (simulated) transform

-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3

         see the pyCMS documentation for details on rendering intents and what
         they do.
     :param proofRenderingIntent: Integer (0-3) specifying the rendering intent
         you wish to use for proof->output transform

-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3

         see the pyCMS documentation for details on rendering intents and what
         they do.
@@ -922,10 +952,10 @@
     :returns: Integer 0-3 specifying the default rendering intent for this
         profile.

-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3

         see the pyCMS documentation for details on rendering intents and what
             they do.
@@ -960,19 +990,19 @@
     :param intent: Integer (0-3) specifying the rendering intent you wish to
         use with this profile

-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3

         see the pyCMS documentation for details on rendering intents and what
             they do.
     :param direction: Integer specifying if the profile is to be used for
         input, output, or proof

-            INPUT  = 0 (or use ImageCms.DIRECTION_INPUT)
-            OUTPUT = 1 (or use ImageCms.DIRECTION_OUTPUT)
-            PROOF  = 2 (or use ImageCms.DIRECTION_PROOF)
+            INPUT  = 0 (or use ImageCms.Direction.INPUT)
+            OUTPUT = 1 (or use ImageCms.Direction.OUTPUT)
+            PROOF  = 2 (or use ImageCms.Direction.PROOF)

     :returns: 1 if the intent/direction are supported, -1 if they are not.
     :exception PyCMSError:
('src/PIL', 'BufrStubImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -59,7 +59,7 @@


 def _save(im, fp, filename):
-    if _handler is None or not hasattr("_handler", "save"):
+    if _handler is None or not hasattr(_handler, "save"):
         raise OSError("BUFR save handler not installed")
     _handler.save(im, fp, filename)

('src/PIL', 'PSDraw.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -26,39 +26,36 @@
 class PSDraw:
     """
     Sets up printing to the given file. If ``fp`` is omitted,
-    :py:data:`sys.stdout` is assumed.
+    ``sys.stdout.buffer`` or ``sys.stdout`` is assumed.
     """

     def __init__(self, fp=None):
         if not fp:
-            fp = sys.stdout
+            try:
+                fp = sys.stdout.buffer
+            except AttributeError:
+                fp = sys.stdout
         self.fp = fp
-
-    def _fp_write(self, to_write):
-        if self.fp == sys.stdout:
-            self.fp.write(to_write)
-        else:
-            self.fp.write(bytes(to_write, "UTF-8"))

     def begin_document(self, id=None):
         """Set up printing of a document. (Write PostScript DSC header.)"""
         # FIXME: incomplete
-        self._fp_write(
-            "%!PS-Adobe-3.0\n"
-            "save\n"
-            "/showpage { } def\n"
-            "%%EndComments\n"
-            "%%BeginDocument\n"
+        self.fp.write(
+            b"%!PS-Adobe-3.0\n"
+            b"save\n"
+            b"/showpage { } def\n"
+            b"%%EndComments\n"
+            b"%%BeginDocument\n"
         )
-        # self._fp_write(ERROR_PS)  # debugging!
-        self._fp_write(EDROFF_PS)
-        self._fp_write(VDI_PS)
-        self._fp_write("%%EndProlog\n")
+        # self.fp.write(ERROR_PS)  # debugging!
+        self.fp.write(EDROFF_PS)
+        self.fp.write(VDI_PS)
+        self.fp.write(b"%%EndProlog\n")
         self.isofont = {}

     def end_document(self):
         """Ends printing. (Write PostScript DSC footer.)"""
-        self._fp_write("%%EndDocument\nrestore showpage\n%%End\n")
+        self.fp.write(b"%%EndDocument\nrestore showpage\n%%End\n")
         if hasattr(self.fp, "flush"):
             self.fp.flush()

@@ -69,12 +66,13 @@
         :param font: A PostScript font name
         :param size: Size in points.
         """
+        font = bytes(font, "UTF-8")
         if font not in self.isofont:
             # reencode font
-            self._fp_write(f"/PSDraw-{font} ISOLatin1Encoding /{font} E\n")
+            self.fp.write(b"/PSDraw-%s ISOLatin1Encoding /%s E\n" % (font, font))
             self.isofont[font] = 1
         # rough
-        self._fp_write(f"/F0 {size} /PSDraw-{font} F\n")
+        self.fp.write(b"/F0 %d /PSDraw-%s F\n" % (size, font))

     def line(self, xy0, xy1):
         """
@@ -82,7 +80,7 @@
         PostScript point coordinates (72 points per inch, (0, 0) is the lower
         left corner of the page).
         """
-        self._fp_write("%d %d %d %d Vl\n" % (*xy0, *xy1))
+        self.fp.write(b"%d %d %d %d Vl\n" % (*xy0, *xy1))

     def rectangle(self, box):
         """
@@ -97,16 +95,18 @@

                         %d %d M %d %d 0 Vr\n
         """
-        self._fp_write("%d %d M %d %d 0 Vr\n" % box)
+        self.fp.write(b"%d %d M %d %d 0 Vr\n" % box)

     def text(self, xy, text):
         """
         Draws text at the given position. You must use
         :py:meth:`~PIL.PSDraw.PSDraw.setfont` before calling this method.
         """
-        text = "\\(".join(text.split("("))
-        text = "\\)".join(text.split(")"))
-        self._fp_write(f"{xy[0]} {xy[1]} M ({text}) S\n")
+        text = bytes(text, "UTF-8")
+        text = b"\\(".join(text.split(b"("))
+        text = b"\\)".join(text.split(b")"))
+        xy += (text,)
+        self.fp.write(b"%d %d M (%s) S\n" % xy)

     def image(self, box, im, dpi=None):
         """Draw a PIL image, centered in the given box."""
@@ -130,14 +130,14 @@
             y = ymax
         dx = (xmax - x) / 2 + box[0]
         dy = (ymax - y) / 2 + box[1]
-        self._fp_write(f"gsave\n{dx:f} {dy:f} translate\n")
+        self.fp.write(b"gsave\n%f %f translate\n" % (dx, dy))
         if (x, y) != im.size:
             # EpsImagePlugin._save prints the image at (0,0,xsize,ysize)
             sx = x / im.size[0]
             sy = y / im.size[1]
-            self._fp_write(f"{sx:f} {sy:f} scale\n")
+            self.fp.write(b"%f %f scale\n" % (sx, sy))
         EpsImagePlugin._save(im, self.fp, None, 0)
-        self._fp_write("\ngrestore\n")
+        self.fp.write(b"\ngrestore\n")


 # --------------------------------------------------------------------
@@ -153,7 +153,7 @@
 #


-EDROFF_PS = """\
+EDROFF_PS = b"""\
 /S { show } bind def
 /P { moveto show } bind def
 /M { moveto } bind def
@@ -182,7 +182,7 @@
 # Copyright (c) Fredrik Lundh 1994.
 #

-VDI_PS = """\
+VDI_PS = b"""\
 /Vm { moveto } bind def
 /Va { newpath arcn stroke } bind def
 /Vl { moveto lineto stroke } bind def
@@ -207,7 +207,7 @@
 # 89-11-21 fl: created (pslist 1.10)
 #

-ERROR_PS = """\
+ERROR_PS = b"""\
 /landscape false def
 /errorBUF 200 string def
 /errorNL { currentpoint 10 sub exch pop 72 exch moveto } def
('src/PIL', 'ImageFilter.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,11 +16,6 @@
 #
 import functools

-try:
-    import numpy
-except ImportError:  # pragma: no cover
-    numpy = None
-

 class Filter:
     pass
@@ -154,9 +149,11 @@


 class GaussianBlur(MultibandFilter):
-    """Gaussian blur filter.
-
-    :param radius: Blur radius.
+    """Blurs the image with a sequence of extended box filters, which
+    approximates a Gaussian kernel. For details on accuracy see
+    <https://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf>
+
+    :param radius: Standard deviation of the Gaussian kernel.
     """

     name = "GaussianBlur"
@@ -368,6 +365,13 @@
         copy_table = kwargs.get("_copy_table", True)
         items = size[0] * size[1] * size[2]
         wrong_size = False
+
+        numpy = None
+        if hasattr(table, "shape"):
+            try:
+                import numpy
+            except ImportError:  # pragma: no cover
+                pass

         if numpy and isinstance(table, numpy.ndarray):
             if copy_table:
@@ -525,7 +529,7 @@

         return image.color_lut_3d(
             self.mode or image.mode,
-            Image.LINEAR,
+            Image.Resampling.BILINEAR,
             self.channels,
             self.size[0],
             self.size[1],
('src/PIL', '__init__.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,72 +13,12 @@
 ;-)
 """

-import sys
-import warnings
-
 from . import _version

 # VERSION was removed in Pillow 6.0.0.
+# PILLOW_VERSION was removed in Pillow 9.0.0.
+# Use __version__ instead.
 __version__ = _version.__version__
-
-
-# PILLOW_VERSION is deprecated and will be removed in a future release.
-# Use __version__ instead.
-def _raise_version_warning():
-    warnings.warn(
-        "PILLOW_VERSION is deprecated and will be removed in Pillow 9 (2022-01-02). "
-        "Use __version__ instead.",
-        DeprecationWarning,
-        stacklevel=3,
-    )
-
-
-if sys.version_info >= (3, 7):
-
-    def __getattr__(name):
-        if name == "PILLOW_VERSION":
-            _raise_version_warning()
-            return __version__
-        raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
-
-
-else:
-
-    class _Deprecated_Version(str):
-        def __str__(self):
-            _raise_version_warning()
-            return super().__str__()
-
-        def __getitem__(self, key):
-            _raise_version_warning()
-            return super().__getitem__(key)
-
-        def __eq__(self, other):
-            _raise_version_warning()
-            return super().__eq__(other)
-
-        def __ne__(self, other):
-            _raise_version_warning()
-            return super().__ne__(other)
-
-        def __gt__(self, other):
-            _raise_version_warning()
-            return super().__gt__(other)
-
-        def __lt__(self, other):
-            _raise_version_warning()
-            return super().__lt__(other)
-
-        def __ge__(self, other):
-            _raise_version_warning()
-            return super().__gt__(other)
-
-        def __le__(self, other):
-            _raise_version_warning()
-            return super().__lt__(other)
-
-    PILLOW_VERSION = _Deprecated_Version(__version__)
-
 del _version


@@ -90,6 +30,7 @@
     "DcxImagePlugin",
     "DdsImagePlugin",
     "EpsImagePlugin",
+    "FitsImagePlugin",
     "FitsStubImagePlugin",
     "FliImagePlugin",
     "FpxImagePlugin",
('src/PIL', 'JpegPresets.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -52,19 +52,11 @@

   im.quantization

-This will return a dict with a number of arrays. You can pass this dict
+This will return a dict with a number of lists. You can pass this dict
 directly as the qtables argument when saving a JPEG.

-The tables format between im.quantization and quantization in presets differ in
-3 ways:
-
-1. The base container of the preset is a list with sublists instead of dict.
-   dict[0] -> list[0], dict[1] -> list[1], ...
-2. Each table in a preset is a list instead of an array.
-3. The zigzag order is remove in the preset (needed by libjpeg >= 6a).
-
-You can convert the dict format to the preset format with the
-:func:`.JpegImagePlugin.convert_dict_qtables()` function.
+The quantization table format in presets is a list with sublists. These formats
+are interchangeable.

 Libjpeg ref.:
 https://web.archive.org/web/20120328125543/http://www.jpegcameras.com/libjpeg/libjpeg-3.html
('src/PIL', 'Hdf5StubImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -59,7 +59,7 @@


 def _save(im, fp, filename):
-    if _handler is None or not hasattr("_handler", "save"):
+    if _handler is None or not hasattr(_handler, "save"):
         raise OSError("HDF5 save handler not installed")
     _handler.save(im, fp, filename)

('src/PIL', 'features.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -9,7 +9,7 @@

 modules = {
     "pil": ("PIL._imaging", "PILLOW_VERSION"),
-    "tkinter": ("PIL._tkinter_finder", None),
+    "tkinter": ("PIL._tkinter_finder", "tk_version"),
     "freetype2": ("PIL._imagingft", "freetype2_version"),
     "littlecms2": ("PIL._imagingcms", "littlecms_version"),
     "webp": ("PIL._webp", "webpdecoder_version"),
@@ -118,6 +118,8 @@
     "webp_mux": ("PIL._webp", "HAVE_WEBPMUX", None),
     "transp_webp": ("PIL._webp", "HAVE_TRANSPARENCY", None),
     "raqm": ("PIL._imagingft", "HAVE_RAQM", "raqm_version"),
+    "fribidi": ("PIL._imagingft", "HAVE_FRIBIDI", "fribidi_version"),
+    "harfbuzz": ("PIL._imagingft", "HAVE_HARFBUZZ", "harfbuzz_version"),
     "libjpeg_turbo": ("PIL._imaging", "HAVE_LIBJPEGTURBO", "libjpeg_turbo_version"),
     "libimagequant": ("PIL._imaging", "HAVE_LIBIMAGEQUANT", "imagequant_version"),
     "xcb": ("PIL._imaging", "HAVE_XCB", None),
@@ -216,7 +218,7 @@
 def pilinfo(out=None, supported_formats=True):
     """
     Prints information about this installation of Pillow.
-    This function can be called with ``python -m PIL``.
+    This function can be called with ``python3 -m PIL``.

     :param out:
         The output stream to print to. Defaults to ``sys.stdout`` if ``None``.
@@ -274,6 +276,11 @@
                     # this check is also in src/_imagingcms.c:setup_module()
                     version_static = tuple(int(x) for x in v.split(".")) < (2, 7)
                 t = "compiled for" if version_static else "loaded"
+                if name == "raqm":
+                    for f in ("fribidi", "harfbuzz"):
+                        v2 = version_feature(f)
+                        if v2 is not None:
+                            v += f", {f} {v2}"
                 print("---", feature, "support ok,", t, v, file=out)
             else:
                 print("---", feature, "support ok", file=out)
('src/PIL', 'ImageDraw.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -33,7 +33,7 @@
 import math
 import numbers

-from . import Image, ImageColor
+from . import Image, ImageColor, ImageFont

 """
 A simple 2D drawing interface for PIL images.
@@ -70,6 +70,7 @@
             self.palette = im.palette
         else:
             self.palette = None
+        self._image = im
         self.im = im.im
         self.draw = Image.core.draw(self.im, blend)
         self.mode = mode
@@ -108,13 +109,13 @@
                 if isinstance(ink, str):
                     ink = ImageColor.getcolor(ink, self.mode)
                 if self.palette and not isinstance(ink, numbers.Number):
-                    ink = self.palette.getcolor(ink)
+                    ink = self.palette.getcolor(ink, self._image)
                 ink = self.draw.draw_ink(ink)
             if fill is not None:
                 if isinstance(fill, str):
                     fill = ImageColor.getcolor(fill, self.mode)
                 if self.palette and not isinstance(fill, numbers.Number):
-                    fill = self.palette.getcolor(fill)
+                    fill = self.palette.getcolor(fill, self._image)
                 fill = self.draw.draw_ink(fill)
         return ink, fill

@@ -173,13 +174,11 @@
                         angle -= 90
                         distance = width / 2 - 1
                         return tuple(
-                            [
-                                p + (math.floor(p_d) if p_d > 0 else math.ceil(p_d))
-                                for p, p_d in (
-                                    (x, distance * math.cos(math.radians(angle))),
-                                    (y, distance * math.sin(math.radians(angle))),
-                                )
-                            ]
+                            p + (math.floor(p_d) if p_d > 0 else math.ceil(p_d))
+                            for p, p_d in (
+                                (x, distance * math.cos(math.radians(angle))),
+                                (y, distance * math.sin(math.radians(angle))),
+                            )
                         )

                     flipped = (
@@ -234,13 +233,35 @@
         if ink is not None:
             self.draw.draw_points(xy, ink)

-    def polygon(self, xy, fill=None, outline=None):
+    def polygon(self, xy, fill=None, outline=None, width=1):
         """Draw a polygon."""
         ink, fill = self._getink(outline, fill)
         if fill is not None:
             self.draw.draw_polygon(xy, fill, 1)
-        if ink is not None and ink != fill:
-            self.draw.draw_polygon(xy, ink, 0)
+        if ink is not None and ink != fill and width != 0:
+            if width == 1:
+                self.draw.draw_polygon(xy, ink, 0, width)
+            else:
+                # To avoid expanding the polygon outwards,
+                # use the fill as a mask
+                mask = Image.new("1", self.im.size)
+                mask_ink = self._getink(1)[0]
+
+                fill_im = mask.copy()
+                draw = Draw(fill_im)
+                draw.draw.draw_polygon(xy, mask_ink, 1)
+
+                ink_im = mask.copy()
+                draw = Draw(ink_im)
+                width = width * 2 - 1
+                draw.draw.draw_polygon(xy, mask_ink, 0, width)
+
+                mask.paste(ink_im, mask=fill_im)
+
+                im = Image.new(self.mode, self.im.size)
+                draw = Draw(im)
+                draw.draw.draw_polygon(xy, ink, 0, width)
+                self.im.paste(im.im, (0, 0) + im.size, mask.im)

     def regular_polygon(
         self, bounding_circle, n_sides, rotation=0, fill=None, outline=None
@@ -256,6 +277,89 @@
             self.draw.draw_rectangle(xy, fill, 1)
         if ink is not None and ink != fill and width != 0:
             self.draw.draw_rectangle(xy, ink, 0, width)
+
+    def rounded_rectangle(self, xy, radius=0, fill=None, outline=None, width=1):
+        """Draw a rounded rectangle."""
+        if isinstance(xy[0], (list, tuple)):
+            (x0, y0), (x1, y1) = xy
+        else:
+            x0, y0, x1, y1 = xy
+
+        d = radius * 2
+
+        full_x = d >= x1 - x0
+        if full_x:
+            # The two left and two right corners are joined
+            d = x1 - x0
+        full_y = d >= y1 - y0
+        if full_y:
+            # The two top and two bottom corners are joined
+            d = y1 - y0
+        if full_x and full_y:
+            # If all corners are joined, that is a circle
+            return self.ellipse(xy, fill, outline, width)
+
+        if d == 0:
+            # If the corners have no curve, that is a rectangle
+            return self.rectangle(xy, fill, outline, width)
+
+        r = d // 2
+        ink, fill = self._getink(outline, fill)
+
+        def draw_corners(pieslice):
+            if full_x:
+                # Draw top and bottom halves
+                parts = (
+                    ((x0, y0, x0 + d, y0 + d), 180, 360),
+                    ((x0, y1 - d, x0 + d, y1), 0, 180),
+                )
+            elif full_y:
+                # Draw left and right halves
+                parts = (
+                    ((x0, y0, x0 + d, y0 + d), 90, 270),
+                    ((x1 - d, y0, x1, y0 + d), 270, 90),
+                )
+            else:
+                # Draw four separate corners
+                parts = (
+                    ((x1 - d, y0, x1, y0 + d), 270, 360),
+                    ((x1 - d, y1 - d, x1, y1), 0, 90),
+                    ((x0, y1 - d, x0 + d, y1), 90, 180),
+                    ((x0, y0, x0 + d, y0 + d), 180, 270),
+                )
+            for part in parts:
+                if pieslice:
+                    self.draw.draw_pieslice(*(part + (fill, 1)))
+                else:
+                    self.draw.draw_arc(*(part + (ink, width)))
+
+        if fill is not None:
+            draw_corners(True)
+
+            if full_x:
+                self.draw.draw_rectangle((x0, y0 + r + 1, x1, y1 - r - 1), fill, 1)
+            else:
+                self.draw.draw_rectangle((x0 + r + 1, y0, x1 - r - 1, y1), fill, 1)
+            if not full_x and not full_y:
+                self.draw.draw_rectangle((x0, y0 + r + 1, x0 + r, y1 - r - 1), fill, 1)
+                self.draw.draw_rectangle((x1 - r, y0 + r + 1, x1, y1 - r - 1), fill, 1)
+        if ink is not None and ink != fill and width != 0:
+            draw_corners(False)
+
+            if not full_x:
+                self.draw.draw_rectangle(
+                    (x0 + r + 1, y0, x1 - r - 1, y0 + width - 1), ink, 1
+                )
+                self.draw.draw_rectangle(
+                    (x0 + r + 1, y1 - width + 1, x1 - r - 1, y1), ink, 1
+                )
+            if not full_y:
+                self.draw.draw_rectangle(
+                    (x0, y0 + r + 1, x0 + width - 1, y1 - r - 1), ink, 1
+                )
+                self.draw.draw_rectangle(
+                    (x1 - width + 1, y0 + r + 1, x1, y1 - r - 1), ink, 1
+                )

     def _multiline_check(self, text):
         """Draw text."""
@@ -563,6 +667,8 @@

         if font is None:
             font = self.getfont()
+        if not isinstance(font, ImageFont.FreeTypeFont):
+            raise ValueError("Only supported for TrueType fonts")
         mode = "RGBA" if embedded_color else self.fontmode
         bbox = font.getbbox(
             text, mode, direction, features, language, stroke_width, anchor
@@ -893,6 +999,6 @@
     Uses 1-norm distance to calculate difference between two values.
     """
     if isinstance(color2, tuple):
-        return sum([abs(color1[i] - color2[i]) for i in range(0, len(color2))])
+        return sum(abs(color1[i] - color2[i]) for i in range(0, len(color2)))
     else:
         return abs(color1 - color2)
('src/PIL', 'IcoImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -22,7 +22,6 @@
 #   * https://msdn.microsoft.com/en-us/library/ms997538.aspx


-import struct
 import warnings
 from io import BytesIO
 from math import ceil, log
@@ -30,6 +29,9 @@
 from . import BmpImagePlugin, Image, ImageFile, PngImagePlugin
 from ._binary import i16le as i16
 from ._binary import i32le as i32
+from ._binary import o8
+from ._binary import o16le as o16
+from ._binary import o32le as o32

 #
 # --------------------------------------------------------------------
@@ -39,43 +41,72 @@

 def _save(im, fp, filename):
     fp.write(_MAGIC)  # (2+2)
+    bmp = im.encoderinfo.get("bitmap_format") == "bmp"
     sizes = im.encoderinfo.get(
         "sizes",
         [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],
     )
+    frames = []
+    provided_ims = [im] + im.encoderinfo.get("append_images", [])
     width, height = im.size
-    sizes = filter(
-        lambda x: False
-        if (x[0] > width or x[1] > height or x[0] > 256 or x[1] > 256)
-        else True,
-        sizes,
-    )
-    sizes = list(sizes)
-    fp.write(struct.pack("<H", len(sizes)))  # idCount(2)
-    offset = fp.tell() + len(sizes) * 16
-    provided_images = {im.size: im for im in im.encoderinfo.get("append_images", [])}
-    for size in sizes:
-        width, height = size
+    for size in sorted(set(sizes)):
+        if size[0] > width or size[1] > height or size[0] > 256 or size[1] > 256:
+            continue
+
+        for provided_im in provided_ims:
+            if provided_im.size != size:
+                continue
+            frames.append(provided_im)
+            if bmp:
+                bits = BmpImagePlugin.SAVE[provided_im.mode][1]
+                bits_used = [bits]
+                for other_im in provided_ims:
+                    if other_im.size != size:
+                        continue
+                    bits = BmpImagePlugin.SAVE[other_im.mode][1]
+                    if bits not in bits_used:
+                        # Another image has been supplied for this size
+                        # with a different bit depth
+                        frames.append(other_im)
+                        bits_used.append(bits)
+            break
+        else:
+            # TODO: invent a more convenient method for proportional scalings
+            frame = provided_im.copy()
+            frame.thumbnail(size, Image.Resampling.LANCZOS, reducing_gap=None)
+            frames.append(frame)
+    fp.write(o16(len(frames)))  # idCount(2)
+    offset = fp.tell() + len(frames) * 16
+    for frame in frames:
+        width, height = frame.size
         # 0 means 256
-        fp.write(struct.pack("B", width if width < 256 else 0))  # bWidth(1)
-        fp.write(struct.pack("B", height if height < 256 else 0))  # bHeight(1)
-        fp.write(b"\0")  # bColorCount(1)
+        fp.write(o8(width if width < 256 else 0))  # bWidth(1)
+        fp.write(o8(height if height < 256 else 0))  # bHeight(1)
+
+        bits, colors = BmpImagePlugin.SAVE[frame.mode][1:] if bmp else (32, 0)
+        fp.write(o8(colors))  # bColorCount(1)
         fp.write(b"\0")  # bReserved(1)
         fp.write(b"\0\0")  # wPlanes(2)
-        fp.write(struct.pack("<H", 32))  # wBitCount(2)
+        fp.write(o16(bits))  # wBitCount(2)

         image_io = BytesIO()
-        tmp = provided_images.get(size)
-        if not tmp:
-            # TODO: invent a more convenient method for proportional scalings
-            tmp = im.copy()
-            tmp.thumbnail(size, Image.LANCZOS, reducing_gap=None)
-        tmp.save(image_io, "png")
+        if bmp:
+            frame.save(image_io, "dib")
+
+            if bits != 32:
+                and_mask = Image.new("1", size)
+                ImageFile._save(
+                    and_mask, image_io, [("raw", (0, 0) + size, 0, ("1", 0, -1))]
+                )
+        else:
+            frame.save(image_io, "png")
         image_io.seek(0)
         image_bytes = image_io.read()
+        if bmp:
+            image_bytes = image_bytes[:8] + o32(height * 2) + image_bytes[12:]
         bytes_len = len(image_bytes)
-        fp.write(struct.pack("<I", bytes_len))  # dwBytesInRes(4)
-        fp.write(struct.pack("<I", offset))  # dwImageOffset(4)
+        fp.write(o32(bytes_len))  # dwBytesInRes(4)
+        fp.write(o32(offset))  # dwImageOffset(4)
         current = fp.tell()
         fp.seek(offset)
         fp.write(image_bytes)
@@ -178,6 +209,7 @@
         if data[:8] == PngImagePlugin._MAGIC:
             # png frame
             im = PngImagePlugin.PngImageFile(self.buf)
+            Image._decompression_bomb_check(im.size)
         else:
             # XOR + AND mask bmp frame
             im = BmpImagePlugin.DibImageFile(self.buf)
@@ -189,13 +221,7 @@
             im.tile[0] = d, (0, 0) + im.size, o, a

             # figure out where AND mask image starts
-            mode = a[0]
-            bpp = 8
-            for k, v in BmpImagePlugin.BIT2MODE.items():
-                if mode == v[1]:
-                    bpp = k
-                    break
-
+            bpp = header["bpp"]
             if 32 == bpp:
                 # 32-bit color depth icon image allows semitransparent areas
                 # PIL's DIB format ignores transparency bits, recover them.
@@ -225,8 +251,8 @@
                 # the total mask data is
                 # padded row size * height / bits per char

-                and_mask_offset = o + int(im.size[0] * im.size[1] * (bpp / 8.0))
                 total_bytes = int((w * im.size[1]) / 8)
+                and_mask_offset = header["offset"] + header["size"] - total_bytes

                 self.buf.seek(and_mask_offset)
                 mask_data = self.buf.read(total_bytes)
@@ -266,7 +292,8 @@
     Handles classic, XP and Vista icon formats.

     When saving, PNG compression is used. Support for this was only added in
-    Windows Vista.
+    Windows Vista. If you are unable to view the icon in Windows, convert the
+    image to "RGBA" mode before saving.

     This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis
     <casadebender@gmail.com>.
@@ -293,9 +320,9 @@
         self._size = value

     def load(self):
-        if self.im and self.im.size == self.size:
+        if self.im is not None and self.im.size == self.size:
             # Already loaded
-            return
+            return Image.Image.load(self)
         im = self.ico.getimage(self.size)
         # if tile is PNG, it won't really be loaded yet
         im.load()
('src/PIL', '_tkinter_finder.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,9 +1,25 @@
 """ Find compiled module linking to Tcl / Tk libraries
 """
 import sys
+import tkinter
+import warnings
 from tkinter import _tkinter as tk

-if hasattr(sys, "pypy_find_executable"):
-    TKINTER_LIB = tk.tklib_cffi.__file__
-else:
-    TKINTER_LIB = tk.__file__
+try:
+    if hasattr(sys, "pypy_find_executable"):
+        TKINTER_LIB = tk.tklib_cffi.__file__
+    else:
+        TKINTER_LIB = tk.__file__
+except AttributeError:
+    # _tkinter may be compiled directly into Python, in which case __file__ is
+    # not available. load_tkinter_funcs will check the binary first in any case.
+    TKINTER_LIB = None
+
+tk_version = str(tkinter.TkVersion)
+if tk_version == "8.4":
+    warnings.warn(
+        "Support for Tk/Tcl 8.4 is deprecated and will be removed"
+        " in Pillow 10 (2023-07-01). Please upgrade to Tk/Tcl 8.5 "
+        "or newer.",
+        DeprecationWarning,
+    )
('src/PIL', 'EpsImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -61,7 +61,7 @@
     return False


-def Ghostscript(tile, size, fp, scale=1):
+def Ghostscript(tile, size, fp, scale=1, transparency=False):
     """Render an image using Ghostscript"""

     # Unpack decoder tile
@@ -108,6 +108,8 @@
                 lengthfile -= len(s)
                 f.write(s)

+    device = "pngalpha" if transparency else "ppmraw"
+
     # Build Ghostscript command
     command = [
         "gs",
@@ -117,7 +119,7 @@
         "-dBATCH",  # exit after processing
         "-dNOPAUSE",  # don't pause between pages
         "-dSAFER",  # safe mode
-        "-sDEVICE=ppmraw",  # ppm driver
+        f"-sDEVICE={device}",
         f"-sOutputFile={outfile}",  # output file
         # adjust for image origin
         "-c",
@@ -170,12 +172,12 @@
         self.fp.seek(offset, whence)

     def readline(self):
-        s = self.char or b""
+        s = [self.char or b""]
         self.char = None

         c = self.fp.read(1)
-        while c not in b"\r\n":
-            s = s + c
+        while (c not in b"\r\n") and len(c):
+            s.append(c)
             c = self.fp.read(1)

         self.char = self.fp.read(1)
@@ -183,7 +185,7 @@
         if self.char in b"\r\n":
             self.char = None

-        return s.decode("latin-1")
+        return b"".join(s).decode("latin-1")


 def _accept(prefix):
@@ -325,14 +327,14 @@

         return (length, offset)

-    def load(self, scale=1):
+    def load(self, scale=1, transparency=False):
         # Load EPS via Ghostscript
-        if not self.tile:
-            return
-        self.im = Ghostscript(self.tile, self.size, self.fp, scale)
-        self.mode = self.im.mode
-        self._size = self.im.size
-        self.tile = []
+        if self.tile:
+            self.im = Ghostscript(self.tile, self.size, self.fp, scale, transparency)
+            self.mode = self.im.mode
+            self._size = self.im.size
+            self.tile = []
+        return Image.Image.load(self)

     def load_seek(self, *args, **kwargs):
         # we can't incrementally load, so force ImageFile.parser to
@@ -354,56 +356,46 @@
     #
     # determine PostScript image mode
     if im.mode == "L":
-        operator = (8, 1, "image")
+        operator = (8, 1, b"image")
     elif im.mode == "RGB":
-        operator = (8, 3, "false 3 colorimage")
+        operator = (8, 3, b"false 3 colorimage")
     elif im.mode == "CMYK":
-        operator = (8, 4, "false 4 colorimage")
+        operator = (8, 4, b"false 4 colorimage")
     else:
         raise ValueError("image mode is not supported")

-    base_fp = fp
-    wrapped_fp = False
-    if fp != sys.stdout:
-        fp = io.TextIOWrapper(fp, encoding="latin-1")
-        wrapped_fp = True
-
-    try:
-        if eps:
-            #
-            # write EPS header
-            fp.write("%!PS-Adobe-3.0 EPSF-3.0\n")
-            fp.write("%%Creator: PIL 0.1 EpsEncode\n")
-            # fp.write("%%CreationDate: %s"...)
-            fp.write("%%%%BoundingBox: 0 0 %d %d\n" % im.size)
-            fp.write("%%Pages: 1\n")
-            fp.write("%%EndComments\n")
-            fp.write("%%Page: 1 1\n")
-            fp.write("%%ImageData: %d %d " % im.size)
-            fp.write('%d %d 0 1 1 "%s"\n' % operator)
-
+    if eps:
         #
-        # image header
-        fp.write("gsave\n")
-        fp.write("10 dict begin\n")
-        fp.write(f"/buf {im.size[0] * operator[1]} string def\n")
-        fp.write("%d %d scale\n" % im.size)
-        fp.write("%d %d 8\n" % im.size)  # <= bits
-        fp.write(f"[{im.size[0]} 0 0 -{im.size[1]} 0 {im.size[1]}]\n")
-        fp.write("{ currentfile buf readhexstring pop } bind\n")
-        fp.write(operator[2] + "\n")
-        if hasattr(fp, "flush"):
-            fp.flush()
-
-        ImageFile._save(im, base_fp, [("eps", (0, 0) + im.size, 0, None)])
-
-        fp.write("\n%%%%EndBinary\n")
-        fp.write("grestore end\n")
-        if hasattr(fp, "flush"):
-            fp.flush()
-    finally:
-        if wrapped_fp:
-            fp.detach()
+        # write EPS header
+        fp.write(b"%!PS-Adobe-3.0 EPSF-3.0\n")
+        fp.write(b"%%Creator: PIL 0.1 EpsEncode\n")
+        # fp.write("%%CreationDate: %s"...)
+        fp.write(b"%%%%BoundingBox: 0 0 %d %d\n" % im.size)
+        fp.write(b"%%Pages: 1\n")
+        fp.write(b"%%EndComments\n")
+        fp.write(b"%%Page: 1 1\n")
+        fp.write(b"%%ImageData: %d %d " % im.size)
+        fp.write(b'%d %d 0 1 1 "%s"\n' % operator)
+
+    #
+    # image header
+    fp.write(b"gsave\n")
+    fp.write(b"10 dict begin\n")
+    fp.write(b"/buf %d string def\n" % (im.size[0] * operator[1]))
+    fp.write(b"%d %d scale\n" % im.size)
+    fp.write(b"%d %d 8\n" % im.size)  # <= bits
+    fp.write(b"[%d 0 0 -%d 0 %d]\n" % (im.size[0], im.size[1], im.size[1]))
+    fp.write(b"{ currentfile buf readhexstring pop } bind\n")
+    fp.write(operator[2] + b"\n")
+    if hasattr(fp, "flush"):
+        fp.flush()
+
+    ImageFile._save(im, fp, [("eps", (0, 0) + im.size, 0, None)])
+
+    fp.write(b"\n%%%%EndBinary\n")
+    fp.write(b"grestore end\n")
+    if hasattr(fp, "flush"):
+        fp.flush()


 #
('src/PIL', 'TgaImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -93,9 +93,10 @@

         # orientation
         orientation = flags & 0x30
-        if orientation == 0x20:
+        self._flip_horizontally = orientation in [0x10, 0x30]
+        if orientation in [0x20, 0x30]:
             orientation = 1
-        elif not orientation:
+        elif orientation in [0, 0x10]:
             orientation = -1
         else:
             raise SyntaxError("unknown TGA orientation")
@@ -110,10 +111,10 @@

         if colormaptype:
             # read palette
-            start, size, mapdepth = i16(s, 3), i16(s, 5), i16(s, 7)
+            start, size, mapdepth = i16(s, 3), i16(s, 5), s[7]
             if mapdepth == 16:
                 self.palette = ImagePalette.raw(
-                    "BGR;16", b"\0" * 2 * start + self.fp.read(2 * size)
+                    "BGR;15", b"\0" * 2 * start + self.fp.read(2 * size)
                 )
             elif mapdepth == 24:
                 self.palette = ImagePalette.raw(
@@ -149,6 +150,10 @@
         except KeyError:
             pass  # cannot decode

+    def load_end(self):
+        if self._flip_horizontally:
+            self.im = self.im.transpose(Image.Transpose.FLIP_LEFT_RIGHT)
+

 #
 # --------------------------------------------------------------------
('src/PIL', 'ImageMorph.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -196,7 +196,7 @@
             raise Exception("No operator loaded")

         if image.mode != "L":
-            raise Exception("Image must be binary, meaning it must use mode L")
+            raise ValueError("Image mode must be L")
         outimage = Image.new(image.mode, image.size, None)
         count = _imagingmorph.apply(bytes(self.lut), image.im.id, outimage.im.id)
         return count, outimage
@@ -211,7 +211,7 @@
             raise Exception("No operator loaded")

         if image.mode != "L":
-            raise Exception("Image must be binary, meaning it must use mode L")
+            raise ValueError("Image mode must be L")
         return _imagingmorph.match(bytes(self.lut), image.im.id)

     def get_on_pixels(self, image):
@@ -221,7 +221,7 @@
         of all matching pixels. See :ref:`coordinate-system`."""

         if image.mode != "L":
-            raise Exception("Image must be binary, meaning it must use mode L")
+            raise ValueError("Image mode must be L")
         return _imagingmorph.get_on_pixels(image.im.id)

     def load_lut(self, filename):
('src/PIL', 'Jpeg2KImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,6 +6,7 @@
 #
 # History:
 # 2014-03-12 ajh  Created
+# 2021-06-30 rogermb  Extract dpi information from the 'resc' header box
 #
 # Copyright (c) 2014 Coriolis Systems Limited
 # Copyright (c) 2014 Alastair Houghton
@@ -17,6 +18,79 @@
 import struct

 from . import Image, ImageFile
+
+
+class BoxReader:
+    """
+    A small helper class to read fields stored in JPEG2000 header boxes
+    and to easily step into and read sub-boxes.
+    """
+
+    def __init__(self, fp, length=-1):
+        self.fp = fp
+        self.has_length = length >= 0
+        self.length = length
+        self.remaining_in_box = -1
+
+    def _can_read(self, num_bytes):
+        if self.has_length and self.fp.tell() + num_bytes > self.length:
+            # Outside box: ensure we don't read past the known file length
+            return False
+        if self.remaining_in_box >= 0:
+            # Inside box contents: ensure read does not go past box boundaries
+            return num_bytes <= self.remaining_in_box
+        else:
+            return True  # No length known, just read
+
+    def _read_bytes(self, num_bytes):
+        if not self._can_read(num_bytes):
+            raise SyntaxError("Not enough data in header")
+
+        data = self.fp.read(num_bytes)
+        if len(data) < num_bytes:
+            raise OSError(
+                f"Expected to read {num_bytes} bytes but only got {len(data)}."
+            )
+
+        if self.remaining_in_box > 0:
+            self.remaining_in_box -= num_bytes
+        return data
+
+    def read_fields(self, field_format):
+        size = struct.calcsize(field_format)
+        data = self._read_bytes(size)
+        return struct.unpack(field_format, data)
+
+    def read_boxes(self):
+        size = self.remaining_in_box
+        data = self._read_bytes(size)
+        return BoxReader(io.BytesIO(data), size)
+
+    def has_next_box(self):
+        if self.has_length:
+            return self.fp.tell() + self.remaining_in_box < self.length
+        else:
+            return True
+
+    def next_box_type(self):
+        # Skip the rest of the box if it has not been read
+        if self.remaining_in_box > 0:
+            self.fp.seek(self.remaining_in_box, os.SEEK_CUR)
+        self.remaining_in_box = -1
+
+        # Read the length and type of the next box
+        lbox, tbox = self.read_fields(">I4s")
+        if lbox == 1:
+            lbox = self.read_fields(">Q")[0]
+            hlen = 16
+        else:
+            hlen = 8
+
+        if lbox < hlen or not self._can_read(lbox - hlen):
+            raise SyntaxError("Invalid header length")
+
+        self.remaining_in_box = lbox - hlen
+        return tbox


 def _parse_codestream(fp):
@@ -53,101 +127,71 @@
     return (size, mode)


+def _res_to_dpi(num, denom, exp):
+    """Convert JPEG2000's (numerator, denominator, exponent-base-10) resolution,
+    calculated as (num / denom) * 10^exp and stored in dots per meter,
+    to floating-point dots per inch."""
+    if denom != 0:
+        return (254 * num * (10**exp)) / (10000 * denom)
+
+
 def _parse_jp2_header(fp):
-    """Parse the JP2 header box to extract size, component count and
-    color space information, returning a (size, mode, mimetype) tuple."""
+    """Parse the JP2 header box to extract size, component count,
+    color space information, and optionally DPI information,
+    returning a (size, mode, mimetype, dpi) tuple."""

     # Find the JP2 header box
+    reader = BoxReader(fp)
     header = None
     mimetype = None
-    while True:
-        lbox, tbox = struct.unpack(">I4s", fp.read(8))
-        if lbox == 1:
-            lbox = struct.unpack(">Q", fp.read(8))[0]
-            hlen = 16
-        else:
-            hlen = 8
-
-        if lbox < hlen:
-            raise SyntaxError("Invalid JP2 header length")
+    while reader.has_next_box():
+        tbox = reader.next_box_type()

         if tbox == b"jp2h":
-            header = fp.read(lbox - hlen)
+            header = reader.read_boxes()
             break
         elif tbox == b"ftyp":
-            if fp.read(4) == b"jpx ":
+            if reader.read_fields(">4s")[0] == b"jpx ":
                 mimetype = "image/jpx"
-            fp.seek(lbox - hlen - 4, os.SEEK_CUR)
-        else:
-            fp.seek(lbox - hlen, os.SEEK_CUR)
-
-    if header is None:
-        raise SyntaxError("could not find JP2 header")

     size = None
     mode = None
     bpc = None
     nc = None
-
-    hio = io.BytesIO(header)
-    while True:
-        lbox, tbox = struct.unpack(">I4s", hio.read(8))
-        if lbox == 1:
-            lbox = struct.unpack(">Q", hio.read(8))[0]
-            hlen = 16
-        else:
-            hlen = 8
-
-        content = hio.read(lbox - hlen)
+    dpi = None  # 2-tuple of DPI info, or None
+
+    while header.has_next_box():
+        tbox = header.next_box_type()

         if tbox == b"ihdr":
-            height, width, nc, bpc, c, unkc, ipr = struct.unpack(">IIHBBBB", content)
+            height, width, nc, bpc = header.read_fields(">IIHB")
             size = (width, height)
-            if unkc:
-                if nc == 1 and (bpc & 0x7F) > 8:
-                    mode = "I;16"
-                elif nc == 1:
-                    mode = "L"
-                elif nc == 2:
-                    mode = "LA"
-                elif nc == 3:
-                    mode = "RGB"
-                elif nc == 4:
-                    mode = "RGBA"
-                break
-        elif tbox == b"colr":
-            meth, prec, approx = struct.unpack_from(">BBB", content)
-            if meth == 1:
-                cs = struct.unpack_from(">I", content, 3)[0]
-                if cs == 16:  # sRGB
-                    if nc == 1 and (bpc & 0x7F) > 8:
-                        mode = "I;16"
-                    elif nc == 1:
-                        mode = "L"
-                    elif nc == 3:
-                        mode = "RGB"
-                    elif nc == 4:
-                        mode = "RGBA"
+            if nc == 1 and (bpc & 0x7F) > 8:
+                mode = "I;16"
+            elif nc == 1:
+                mode = "L"
+            elif nc == 2:
+                mode = "LA"
+            elif nc == 3:
+                mode = "RGB"
+            elif nc == 4:
+                mode = "RGBA"
+        elif tbox == b"res ":
+            res = header.read_boxes()
+            while res.has_next_box():
+                tres = res.next_box_type()
+                if tres == b"resc":
+                    vrcn, vrcd, hrcn, hrcd, vrce, hrce = res.read_fields(">HHHHBB")
+                    hres = _res_to_dpi(hrcn, hrcd, hrce)
+                    vres = _res_to_dpi(vrcn, vrcd, vrce)
+                    if hres is not None and vres is not None:
+                        dpi = (hres, vres)
                     break
-                elif cs == 17:  # grayscale
-                    if nc == 1 and (bpc & 0x7F) > 8:
-                        mode = "I;16"
-                    elif nc == 1:
-                        mode = "L"
-                    elif nc == 2:
-                        mode = "LA"
-                    break
-                elif cs == 18:  # sYCC
-                    if nc == 3:
-                        mode = "RGB"
-                    elif nc == 4:
-                        mode = "RGBA"
-                    break

     if size is None or mode is None:
-        raise SyntaxError("Malformed jp2 header")
-
-    return (size, mode, mimetype)
+        raise SyntaxError("Malformed JP2 header")
+
+    return (size, mode, mimetype, dpi)


 ##
@@ -169,7 +213,9 @@
             if sig == b"\x00\x00\x00\x0cjP  \x0d\x0a\x87\x0a":
                 self.codec = "jp2"
                 header = _parse_jp2_header(self.fp)
-                self._size, self.mode, self.custom_mimetype = header
+                self._size, self.mode, self.custom_mimetype, dpi = header
+                if dpi is not None:
+                    self.info["dpi"] = dpi
             else:
                 raise SyntaxError("not a JPEG 2000 file")

@@ -244,13 +290,13 @@


 def _save(im, fp, filename):
-    if filename.endswith(".j2k"):
+    # Get the keyword arguments
+    info = im.encoderinfo
+
+    if filename.endswith(".j2k") or info.get("no_jp2", False):
         kind = "j2k"
     else:
         kind = "jp2"
-
-    # Get the keyword arguments
-    info = im.encoderinfo

     offset = info.get("offset", None)
     tile_offset = info.get("tile_offset", None)
@@ -274,6 +320,7 @@
     irreversible = info.get("irreversible", False)
     progression = info.get("progression", "LRCP")
     cinema_mode = info.get("cinema_mode", "no")
+    mct = info.get("mct", 0)
     fd = -1

     if hasattr(fp, "fileno"):
@@ -294,6 +341,7 @@
         irreversible,
         progression,
         cinema_mode,
+        mct,
         fd,
     )

('src/PIL', 'WalImageFile.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,10 +23,39 @@
     To open a WAL file, use the :py:func:`PIL.WalImageFile.open()` function instead.
 """

-import builtins
+from . import Image, ImageFile
+from ._binary import i32le as i32

-from . import Image
-from ._binary import i32le as i32
+
+class WalImageFile(ImageFile.ImageFile):
+
+    format = "WAL"
+    format_description = "Quake2 Texture"
+
+    def _open(self):
+        self.mode = "P"
+
+        # read header fields
+        header = self.fp.read(32 + 24 + 32 + 12)
+        self._size = i32(header, 32), i32(header, 36)
+        Image._decompression_bomb_check(self.size)
+
+        # load pixel data
+        offset = i32(header, 40)
+        self.fp.seek(offset)
+
+        # strings are null-terminated
+        self.info["name"] = header[:32].split(b"\0", 1)[0]
+        next_name = header[56 : 56 + 32].split(b"\0", 1)[0]
+        if next_name:
+            self.info["next_name"] = next_name
+
+    def load(self):
+        if not self.im:
+            self.im = Image.core.new(self.mode, self.size)
+            self.frombytes(self.fp.read(self.size[0] * self.size[1]))
+            self.putpalette(quake2palette)
+        return Image.Image.load(self)


 def open(filename):
@@ -39,38 +68,7 @@
     :param filename: WAL file name, or an opened file handle.
     :returns: An image instance.
     """
-    # FIXME: modify to return a WalImageFile instance instead of
-    # plain Image object ?
-
-    def imopen(fp):
-        # read header fields
-        header = fp.read(32 + 24 + 32 + 12)
-        size = i32(header, 32), i32(header, 36)
-        offset = i32(header, 40)
-
-        # load pixel data
-        fp.seek(offset)
-
-        Image._decompression_bomb_check(size)
-        im = Image.frombytes("P", size, fp.read(size[0] * size[1]))
-        im.putpalette(quake2palette)
-
-        im.format = "WAL"
-        im.format_description = "Quake2 Texture"
-
-        # strings are null-terminated
-        im.info["name"] = header[:32].split(b"\0", 1)[0]
-        next_name = header[56 : 56 + 32].split(b"\0", 1)[0]
-        if next_name:
-            im.info["next_name"] = next_name
-
-        return im
-
-    if hasattr(filename, "read"):
-        return imopen(filename)
-    else:
-        with builtins.open(filename, "rb") as fp:
-            return imopen(fp)
+    return WalImageFile(filename)


 quake2palette = (
('src/PIL', 'BlpImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -29,20 +29,56 @@
   - DXT5 compression is used if alpha_encoding == 7.
 """

+import os
 import struct
+import warnings
+from enum import IntEnum
 from io import BytesIO

 from . import Image, ImageFile

-BLP_FORMAT_JPEG = 0
-
-BLP_ENCODING_UNCOMPRESSED = 1
-BLP_ENCODING_DXT = 2
-BLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3
-
-BLP_ALPHA_ENCODING_DXT1 = 0
-BLP_ALPHA_ENCODING_DXT3 = 1
-BLP_ALPHA_ENCODING_DXT5 = 7
+
+class Format(IntEnum):
+    JPEG = 0
+
+
+class Encoding(IntEnum):
+    UNCOMPRESSED = 1
+    DXT = 2
+    UNCOMPRESSED_RAW_BGRA = 3
+
+
+class AlphaEncoding(IntEnum):
+    DXT1 = 0
+    DXT3 = 1
+    DXT5 = 7
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {
+        Format: "BLP_FORMAT_",
+        Encoding: "BLP_ENCODING_",
+        AlphaEncoding: "BLP_ALPHA_ENCODING_",
+    }.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")


 def unpack_565(i):
@@ -231,6 +267,10 @@
     pass


+def _accept(prefix):
+    return prefix[:4] in (b"BLP1", b"BLP2")
+
+
 class BlpImageFile(ImageFile.ImageFile):
     """
     Blizzard Mipmap Format
@@ -241,36 +281,20 @@

     def _open(self):
         self.magic = self.fp.read(4)
-        self._read_blp_header()
-
-        if self.magic == b"BLP1":
-            decoder = "BLP1"
-            self.mode = "RGB"
-        elif self.magic == b"BLP2":
-            decoder = "BLP2"
-            self.mode = "RGBA" if self._blp_alpha_depth else "RGB"
+
+        self.fp.seek(5, os.SEEK_CUR)
+        (self._blp_alpha_depth,) = struct.unpack("<b", self.fp.read(1))
+
+        self.fp.seek(2, os.SEEK_CUR)
+        self._size = struct.unpack("<II", self.fp.read(8))
+
+        if self.magic in (b"BLP1", b"BLP2"):
+            decoder = self.magic.decode()
         else:
             raise BLPFormatError(f"Bad BLP magic {repr(self.magic)}")

+        self.mode = "RGBA" if self._blp_alpha_depth else "RGB"
         self.tile = [(decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]
-
-    def _read_blp_header(self):
-        (self._blp_compression,) = struct.unpack("<i", self.fp.read(4))
-
-        (self._blp_encoding,) = struct.unpack("<b", self.fp.read(1))
-        (self._blp_alpha_depth,) = struct.unpack("<b", self.fp.read(1))
-        (self._blp_alpha_encoding,) = struct.unpack("<b", self.fp.read(1))
-        (self._blp_mips,) = struct.unpack("<b", self.fp.read(1))
-
-        self._size = struct.unpack("<II", self.fp.read(8))
-
-        if self.magic == b"BLP1":
-            # Only present for BLP1
-            (self._blp_encoding,) = struct.unpack("<i", self.fp.read(4))
-            (self._blp_subtype,) = struct.unpack("<i", self.fp.read(4))
-
-        self._blp_offsets = struct.unpack("<16I", self.fp.read(16 * 4))
-        self._blp_lengths = struct.unpack("<16I", self.fp.read(16 * 4))


 class _BLPBaseDecoder(ImageFile.PyDecoder):
@@ -278,61 +302,69 @@

     def decode(self, buffer):
         try:
-            self.fd.seek(0)
-            self.magic = self.fd.read(4)
             self._read_blp_header()
             self._load()
         except struct.error as e:
-            raise OSError("Truncated Blp file") from e
-        return 0, 0
+            raise OSError("Truncated BLP file") from e
+        return -1, 0
+
+    def _read_blp_header(self):
+        self.fd.seek(4)
+        (self._blp_compression,) = struct.unpack("<i", self._safe_read(4))
+
+        (self._blp_encoding,) = struct.unpack("<b", self._safe_read(1))
+        (self._blp_alpha_depth,) = struct.unpack("<b", self._safe_read(1))
+        (self._blp_alpha_encoding,) = struct.unpack("<b", self._safe_read(1))
+        self.fd.seek(1, os.SEEK_CUR)  # mips
+
+        self.size = struct.unpack("<II", self._safe_read(8))
+
+        if isinstance(self, BLP1Decoder):
+            # Only present for BLP1
+            (self._blp_encoding,) = struct.unpack("<i", self._safe_read(4))
+            self.fd.seek(4, os.SEEK_CUR)  # subtype
+
+        self._blp_offsets = struct.unpack("<16I", self._safe_read(16 * 4))
+        self._blp_lengths = struct.unpack("<16I", self._safe_read(16 * 4))
+
+    def _safe_read(self, length):
+        return ImageFile._safe_read(self.fd, length)

     def _read_palette(self):
         ret = []
         for i in range(256):
             try:
-                b, g, r, a = struct.unpack("<4B", self.fd.read(4))
+                b, g, r, a = struct.unpack("<4B", self._safe_read(4))
             except struct.error:
                 break
             ret.append((b, g, r, a))
         return ret

-    def _read_blp_header(self):
-        (self._blp_compression,) = struct.unpack("<i", self.fd.read(4))
-
-        (self._blp_encoding,) = struct.unpack("<b", self.fd.read(1))
-        (self._blp_alpha_depth,) = struct.unpack("<b", self.fd.read(1))
-        (self._blp_alpha_encoding,) = struct.unpack("<b", self.fd.read(1))
-        (self._blp_mips,) = struct.unpack("<b", self.fd.read(1))
-
-        self.size = struct.unpack("<II", self.fd.read(8))
-
-        if self.magic == b"BLP1":
-            # Only present for BLP1
-            (self._blp_encoding,) = struct.unpack("<i", self.fd.read(4))
-            (self._blp_subtype,) = struct.unpack("<i", self.fd.read(4))
-
-        self._blp_offsets = struct.unpack("<16I", self.fd.read(16 * 4))
-        self._blp_lengths = struct.unpack("<16I", self.fd.read(16 * 4))
+    def _read_bgra(self, palette):
+        data = bytearray()
+        _data = BytesIO(self._safe_read(self._blp_lengths[0]))
+        while True:
+            try:
+                (offset,) = struct.unpack("<B", _data.read(1))
+            except struct.error:
+                break
+            b, g, r, a = palette[offset]
+            d = (r, g, b)
+            if self._blp_alpha_depth:
+                d += (a,)
+            data.extend(d)
+        return data


 class BLP1Decoder(_BLPBaseDecoder):
     def _load(self):
-        if self._blp_compression == BLP_FORMAT_JPEG:
+        if self._blp_compression == Format.JPEG:
             self._decode_jpeg_stream()

         elif self._blp_compression == 1:
             if self._blp_encoding in (4, 5):
-                data = bytearray()
                 palette = self._read_palette()
-                _data = BytesIO(self.fd.read(self._blp_lengths[0]))
-                while True:
-                    try:
-                        (offset,) = struct.unpack("<B", _data.read(1))
-                    except struct.error:
-                        break
-                    b, g, r, a = palette[offset]
-                    data.extend([r, g, b])
-
+                data = self._read_bgra(palette)
                 self.set_as_raw(bytes(data))
             else:
                 raise BLPFormatError(
@@ -344,59 +376,53 @@
             )

     def _decode_jpeg_stream(self):
-        from PIL.JpegImagePlugin import JpegImageFile
-
-        (jpeg_header_size,) = struct.unpack("<I", self.fd.read(4))
-        jpeg_header = self.fd.read(jpeg_header_size)
-        self.fd.read(self._blp_offsets[0] - self.fd.tell())  # What IS this?
-        data = self.fd.read(self._blp_lengths[0])
+        from .JpegImagePlugin import JpegImageFile
+
+        (jpeg_header_size,) = struct.unpack("<I", self._safe_read(4))
+        jpeg_header = self._safe_read(jpeg_header_size)
+        self._safe_read(self._blp_offsets[0] - self.fd.tell())  # What IS this?
+        data = self._safe_read(self._blp_lengths[0])
         data = jpeg_header + data
         data = BytesIO(data)
         image = JpegImageFile(data)
-        self.tile = image.tile  # :/
-        self.fd = image.fp
-        self.mode = image.mode
+        Image._decompression_bomb_check(image.size)
+        image.mode = "RGB"
+        image.tile = [("jpeg", (0, 0) + self.size, 0, ("BGRX", ""))]
+        self.set_as_raw(image.tobytes())


 class BLP2Decoder(_BLPBaseDecoder):
     def _load(self):
         palette = self._read_palette()

-        data = bytearray()
         self.fd.seek(self._blp_offsets[0])

         if self._blp_compression == 1:
             # Uncompressed or DirectX compression

-            if self._blp_encoding == BLP_ENCODING_UNCOMPRESSED:
-                _data = BytesIO(self.fd.read(self._blp_lengths[0]))
-                while True:
-                    try:
-                        (offset,) = struct.unpack("<B", _data.read(1))
-                    except struct.error:
-                        break
-                    b, g, r, a = palette[offset]
-                    data.extend((r, g, b))
-
-            elif self._blp_encoding == BLP_ENCODING_DXT:
-                if self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT1:
+            if self._blp_encoding == Encoding.UNCOMPRESSED:
+                data = self._read_bgra(palette)
+
+            elif self._blp_encoding == Encoding.DXT:
+                data = bytearray()
+                if self._blp_alpha_encoding == AlphaEncoding.DXT1:
                     linesize = (self.size[0] + 3) // 4 * 8
                     for yb in range((self.size[1] + 3) // 4):
                         for d in decode_dxt1(
-                            self.fd.read(linesize), alpha=bool(self._blp_alpha_depth)
+                            self._safe_read(linesize), alpha=bool(self._blp_alpha_depth)
                         ):
                             data += d

-                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT3:
+                elif self._blp_alpha_encoding == AlphaEncoding.DXT3:
                     linesize = (self.size[0] + 3) // 4 * 16
                     for yb in range((self.size[1] + 3) // 4):
-                        for d in decode_dxt3(self.fd.read(linesize)):
+                        for d in decode_dxt3(self._safe_read(linesize)):
                             data += d

-                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT5:
+                elif self._blp_alpha_encoding == AlphaEncoding.DXT5:
                     linesize = (self.size[0] + 3) // 4 * 16
                     for yb in range((self.size[1] + 3) // 4):
-                        for d in decode_dxt5(self.fd.read(linesize)):
+                        for d in decode_dxt5(self._safe_read(linesize)):
                             data += d
                 else:
                     raise BLPFormatError(
@@ -413,10 +439,59 @@
         self.set_as_raw(bytes(data))


-Image.register_open(
-    BlpImageFile.format, BlpImageFile, lambda p: p[:4] in (b"BLP1", b"BLP2")
-)
+class BLPEncoder(ImageFile.PyEncoder):
+    _pushes_fd = True
+
+    def _write_palette(self):
+        data = b""
+        palette = self.im.getpalette("RGBA", "RGBA")
+        for i in range(256):
+            r, g, b, a = palette[i * 4 : (i + 1) * 4]
+            data += struct.pack("<4B", b, g, r, a)
+        return data
+
+    def encode(self, bufsize):
+        palette_data = self._write_palette()
+
+        offset = 20 + 16 * 4 * 2 + len(palette_data)
+        data = struct.pack("<16I", offset, *((0,) * 15))
+
+        w, h = self.im.size
+        data += struct.pack("<16I", w * h, *((0,) * 15))
+
+        data += palette_data
+
+        for y in range(h):
+            for x in range(w):
+                data += struct.pack("<B", self.im.getpixel((x, y)))
+
+        return len(data), 0, data
+
+
+def _save(im, fp, filename, save_all=False):
+    if im.mode != "P":
+        raise ValueError("Unsupported BLP image mode")
+
+    magic = b"BLP1" if im.encoderinfo.get("blp_version") == "BLP1" else b"BLP2"
+    fp.write(magic)
+
+    fp.write(struct.pack("<i", 1))  # Uncompressed or DirectX compression
+    fp.write(struct.pack("<b", Encoding.UNCOMPRESSED))
+    fp.write(struct.pack("<b", 1 if im.palette.mode == "RGBA" else 0))
+    fp.write(struct.pack("<b", 0))  # alpha encoding
+    fp.write(struct.pack("<b", 0))  # mips
+    fp.write(struct.pack("<II", *im.size))
+    if magic == b"BLP1":
+        fp.write(struct.pack("<i", 5))
+        fp.write(struct.pack("<i", 0))
+
+    ImageFile._save(im, fp, [("BLP", (0, 0) + im.size, 0, im.mode)])
+
+
+Image.register_open(BlpImageFile.format, BlpImageFile, _accept)
 Image.register_extension(BlpImageFile.format, ".blp")
-
 Image.register_decoder("BLP1", BLP1Decoder)
 Image.register_decoder("BLP2", BLP2Decoder)
+
+Image.register_save(BlpImageFile.format, _save)
+Image.register_encoder("BLP", BLPEncoder)
('src/PIL', 'ImageTk.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -56,6 +56,33 @@
         source = BytesIO(kw.pop("data"))
     if source:
         return Image.open(source)
+
+
+def _pyimagingtkcall(command, photo, id):
+    tk = photo.tk
+    try:
+        tk.call(command, photo, id)
+    except tkinter.TclError:
+        # activate Tkinter hook
+        # may raise an error if it cannot attach to Tkinter
+        from . import _imagingtk
+
+        try:
+            if hasattr(tk, "interp"):
+                # Required for PyPy, which always has CFFI installed
+                from cffi import FFI
+
+                ffi = FFI()
+
+                # PyPy is using an FFI CDATA element
+                # (Pdb) self.tk.interp
+                #  <cdata 'Tcl_Interp *' 0x3061b50>
+                _imagingtk.tkinit(int(ffi.cast("uintptr_t", tk.interp)), 1)
+            else:
+                _imagingtk.tkinit(tk.interpaddr(), 1)
+        except AttributeError:
+            _imagingtk.tkinit(id(tk), 0)
+        tk.call(command, photo, id)


 # --------------------------------------------------------------------
@@ -170,33 +197,7 @@
             block = image.new_block(self.__mode, im.size)
             image.convert2(block, image)  # convert directly between buffers

-        tk = self.__photo.tk
-
-        try:
-            tk.call("PyImagingPhoto", self.__photo, block.id)
-        except tkinter.TclError:
-            # activate Tkinter hook
-            try:
-                from . import _imagingtk
-
-                try:
-                    if hasattr(tk, "interp"):
-                        # Required for PyPy, which always has CFFI installed
-                        from cffi import FFI
-
-                        ffi = FFI()
-
-                        # PyPy is using an FFI CDATA element
-                        # (Pdb) self.tk.interp
-                        #  <cdata 'Tcl_Interp *' 0x3061b50>
-                        _imagingtk.tkinit(int(ffi.cast("uintptr_t", tk.interp)), 1)
-                    else:
-                        _imagingtk.tkinit(tk.interpaddr(), 1)
-                except AttributeError:
-                    _imagingtk.tkinit(id(tk), 0)
-                tk.call("PyImagingPhoto", self.__photo, block.id)
-            except (ImportError, AttributeError, tkinter.TclError):
-                raise  # configuration problem; cannot attach to Tkinter
+        _pyimagingtkcall("PyImagingPhoto", self.__photo, block.id)


 # --------------------------------------------------------------------
@@ -276,7 +277,7 @@
     im = Image.new("RGBA", (photo.width(), photo.height()))
     block = im.im

-    photo.tk.call("PyImagingPhotoGet", photo, block.id)
+    _pyimagingtkcall("PyImagingPhotoGet", photo, block.id)

     return im

('src/PIL', 'GbrImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -43,9 +43,9 @@

     def _open(self):
         header_size = i32(self.fp.read(4))
-        version = i32(self.fp.read(4))
         if header_size < 20:
             raise SyntaxError("not a GIMP brush")
+        version = i32(self.fp.read(4))
         if version not in (1, 2):
             raise SyntaxError(f"Unsupported GIMP brush version: {version}")

@@ -84,12 +84,10 @@
         self._data_size = width * height * color_depth

     def load(self):
-        if self.im:
-            # Already loaded
-            return
-
-        self.im = Image.core.new(self.mode, self.size)
-        self.frombytes(self.fp.read(self._data_size))
+        if not self.im:
+            self.im = Image.core.new(self.mode, self.size)
+            self.frombytes(self.fp.read(self._data_size))
+        return Image.Image.load(self)


 #
('src/PIL', 'ImageOps.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,6 +19,7 @@

 import functools
 import operator
+import re

 from . import Image

@@ -61,7 +62,7 @@
 # actions


-def autocontrast(image, cutoff=0, ignore=None, mask=None):
+def autocontrast(image, cutoff=0, ignore=None, mask=None, preserve_tone=False):
     """
     Maximize (normalize) image contrast. This function calculates a
     histogram of the input image (or mask region), removes ``cutoff`` percent of the
@@ -77,9 +78,17 @@
     :param mask: Histogram used in contrast operation is computed using pixels
                  within the mask. If no mask is given the entire image is used
                  for histogram computation.
-    :return: An image.
-    """
-    histogram = image.histogram(mask)
+    :param preserve_tone: Preserve image tone in Photoshop-like style autocontrast.
+
+                          .. versionadded:: 8.2.0
+
+    :return: An image.
+    """
+    if preserve_tone:
+        histogram = image.convert("L").histogram(mask)
+    else:
+        histogram = image.histogram(mask)
+
     lut = []
     for layer in range(0, len(histogram), 256):
         h = histogram[layer : layer + 256]
@@ -228,15 +237,43 @@
     return _lut(image, red + green + blue)


-def pad(image, size, method=Image.BICUBIC, color=None, centering=(0.5, 0.5)):
-    """
-    Returns a sized and padded version of the image, expanded to fill the
-    requested aspect ratio and size.
-
-    :param image: The image to size and crop.
+def contain(image, size, method=Image.Resampling.BICUBIC):
+    """
+    Returns a resized version of the image, set to the maximum width and height
+    within the requested size, while maintaining the original aspect ratio.
+
+    :param image: The image to resize and crop.
     :param size: The requested output size in pixels, given as a
                  (width, height) tuple.
-    :param method: What resampling method to use. Default is
+    :param method: Resampling method to use. Default is
+                   :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
+    :return: An image.
+    """
+
+    im_ratio = image.width / image.height
+    dest_ratio = size[0] / size[1]
+
+    if im_ratio != dest_ratio:
+        if im_ratio > dest_ratio:
+            new_height = int(image.height / image.width * size[0])
+            if new_height != size[1]:
+                size = (size[0], new_height)
+        else:
+            new_width = int(image.width / image.height * size[1])
+            if new_width != size[0]:
+                size = (new_width, size[1])
+    return image.resize(size, resample=method)
+
+
+def pad(image, size, method=Image.Resampling.BICUBIC, color=None, centering=(0.5, 0.5)):
+    """
+    Returns a resized and padded version of the image, expanded to fill the
+    requested aspect ratio and size.
+
+    :param image: The image to resize and crop.
+    :param size: The requested output size in pixels, given as a
+                 (width, height) tuple.
+    :param method: Resampling method to use. Default is
                    :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
     :param color: The background color of the padded image.
     :param centering: Control the position of the original image within the
@@ -249,27 +286,17 @@
     :return: An image.
     """

-    im_ratio = image.width / image.height
-    dest_ratio = size[0] / size[1]
-
-    if im_ratio == dest_ratio:
-        out = image.resize(size, resample=method)
+    resized = contain(image, size, method)
+    if resized.size == size:
+        out = resized
     else:
         out = Image.new(image.mode, size, color)
-        if im_ratio > dest_ratio:
-            new_height = int(image.height / image.width * size[0])
-            if new_height != size[1]:
-                image = image.resize((size[0], new_height), resample=method)
-
-            y = int((size[1] - new_height) * max(0, min(centering[1], 1)))
-            out.paste(image, (0, y))
+        if resized.width != size[0]:
+            x = int((size[0] - resized.width) * max(0, min(centering[0], 1)))
+            out.paste(resized, (x, 0))
         else:
-            new_width = int(image.width / image.height * size[1])
-            if new_width != size[0]:
-                image = image.resize((new_width, size[1]), resample=method)
-
-            x = int((size[0] - new_width) * max(0, min(centering[0], 1)))
-            out.paste(image, (x, 0))
+            y = int((size[1] - resized.height) * max(0, min(centering[1], 1)))
+            out.paste(resized, (0, y))
     return out


@@ -288,7 +315,7 @@
     return image.crop((left, top, image.size[0] - right, image.size[1] - bottom))


-def scale(image, factor, resample=Image.BICUBIC):
+def scale(image, factor, resample=Image.Resampling.BICUBIC):
     """
     Returns a rescaled image by a specific factor given in parameter.
     A factor greater than 1 expands the image, between 0 and 1 contracts the
@@ -296,7 +323,7 @@

     :param image: The image to rescale.
     :param factor: The expansion factor, as a float.
-    :param resample: What resampling method to use. Default is
+    :param resample: Resampling method to use. Default is
                      :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
     :returns: An :py:class:`~PIL.Image.Image` object.
     """
@@ -309,7 +336,7 @@
         return image.resize(size, resample)


-def deform(image, deformer, resample=Image.BILINEAR):
+def deform(image, deformer, resample=Image.Resampling.BILINEAR):
     """
     Deform the image.

@@ -320,7 +347,9 @@
        in the PIL.Image.transform function.
     :return: An image.
     """
-    return image.transform(image.size, Image.MESH, deformer.getmesh(image), resample)
+    return image.transform(
+        image.size, Image.Transform.MESH, deformer.getmesh(image), resample
+    )


 def equalize(image, mask=None):
@@ -366,22 +395,32 @@
     left, top, right, bottom = _border(border)
     width = left + image.size[0] + right
     height = top + image.size[1] + bottom
-    out = Image.new(image.mode, (width, height), _color(fill, image.mode))
+    color = _color(fill, image.mode)
+    if image.mode == "P" and image.palette:
+        image.load()
+        palette = image.palette.copy()
+        if isinstance(color, tuple):
+            color = palette.getcolor(color)
+    else:
+        palette = None
+    out = Image.new(image.mode, (width, height), color)
+    if palette:
+        out.putpalette(palette.palette)
     out.paste(image, (left, top))
     return out


-def fit(image, size, method=Image.BICUBIC, bleed=0.0, centering=(0.5, 0.5)):
-    """
-    Returns a sized and cropped version of the image, cropped to the
+def fit(image, size, method=Image.Resampling.BICUBIC, bleed=0.0, centering=(0.5, 0.5)):
+    """
+    Returns a resized and cropped version of the image, cropped to the
     requested aspect ratio and size.

     This function was contributed by Kevin Cazabon.

-    :param image: The image to size and crop.
+    :param image: The image to resize and crop.
     :param size: The requested output size in pixels, given as a
                  (width, height) tuple.
-    :param method: What resampling method to use. Default is
+    :param method: Resampling method to use. Default is
                    :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
     :param bleed: Remove a border around the outside of the image from all
                   four edges. The value is a decimal percentage (use 0.01 for
@@ -402,7 +441,7 @@

     # by Kevin Cazabon, Feb 17/2000
     # kevin@cazabon.com
-    # http://www.cazabon.com
+    # https://www.cazabon.com

     # ensure centering is mutable
     centering = list(centering)
@@ -463,7 +502,7 @@
     :param image: The image to flip.
     :return: An image.
     """
-    return image.transpose(Image.FLIP_TOP_BOTTOM)
+    return image.transpose(Image.Transpose.FLIP_TOP_BOTTOM)


 def grayscale(image):
@@ -486,7 +525,7 @@
     lut = []
     for i in range(256):
         lut.append(255 - i)
-    return _lut(image, lut)
+    return image.point(lut) if image.mode == "1" else _lut(image, lut)


 def mirror(image):
@@ -496,7 +535,7 @@
     :param image: The image to mirror.
     :return: An image.
     """
-    return image.transpose(Image.FLIP_LEFT_RIGHT)
+    return image.transpose(Image.Transpose.FLIP_LEFT_RIGHT)


 def posterize(image, bits):
@@ -542,17 +581,30 @@
     exif = image.getexif()
     orientation = exif.get(0x0112)
     method = {
-        2: Image.FLIP_LEFT_RIGHT,
-        3: Image.ROTATE_180,
-        4: Image.FLIP_TOP_BOTTOM,
-        5: Image.TRANSPOSE,
-        6: Image.ROTATE_270,
-        7: Image.TRANSVERSE,
-        8: Image.ROTATE_90,
+        2: Image.Transpose.FLIP_LEFT_RIGHT,
+        3: Image.Transpose.ROTATE_180,
+        4: Image.Transpose.FLIP_TOP_BOTTOM,
+        5: Image.Transpose.TRANSPOSE,
+        6: Image.Transpose.ROTATE_270,
+        7: Image.Transpose.TRANSVERSE,
+        8: Image.Transpose.ROTATE_90,
     }.get(orientation)
     if method is not None:
         transposed_image = image.transpose(method)
-        del exif[0x0112]
-        transposed_image.info["exif"] = exif.tobytes()
+        transposed_exif = transposed_image.getexif()
+        if 0x0112 in transposed_exif:
+            del transposed_exif[0x0112]
+            if "exif" in transposed_image.info:
+                transposed_image.info["exif"] = transposed_exif.tobytes()
+            elif "Raw profile type exif" in transposed_image.info:
+                transposed_image.info[
+                    "Raw profile type exif"
+                ] = transposed_exif.tobytes().hex()
+            elif "XML:com.adobe.xmp" in transposed_image.info:
+                transposed_image.info["XML:com.adobe.xmp"] = re.sub(
+                    r'tiff:Orientation="([0-9])"',
+                    "",
+                    transposed_image.info["XML:com.adobe.xmp"],
+                )
         return transposed_image
     return image.copy()
('src/PIL', 'PdfImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -124,10 +124,9 @@
             decode = None

             if im.mode == "1":
-                filter = "ASCIIHexDecode"
+                filter = "DCTDecode"
                 colorspace = PdfParser.PdfName("DeviceGray")
                 procset = "ImageB"  # grayscale
-                bits = 1
             elif im.mode == "L":
                 filter = "DCTDecode"
                 # params = f"<< /Predictor 15 /Columns {width-2} >>"
@@ -135,7 +134,7 @@
                 procset = "ImageB"  # grayscale
             elif im.mode == "P":
                 filter = "ASCIIHexDecode"
-                palette = im.im.getpalette("RGB")
+                palette = im.getpalette()
                 colorspace = [
                     PdfParser.PdfName("Indexed"),
                     PdfParser.PdfName("DeviceRGB"),
@@ -161,12 +160,6 @@
             op = io.BytesIO()

             if filter == "ASCIIHexDecode":
-                if bits == 1:
-                    # FIXME: the hex encoder doesn't support packed 1-bit
-                    # images; do things the hard way...
-                    data = im.tobytes("raw", "1")
-                    im = Image.new("L", im.size)
-                    im.putdata(data)
                 ImageFile._save(im, op, [("hex", (0, 0) + im.size, 0, im.mode)])
             elif filter == "DCTDecode":
                 Image.SAVE["JPEG"](im, op, filename)
@@ -208,8 +201,8 @@
                 MediaBox=[
                     0,
                     0,
-                    int(width * 72.0 / resolution),
-                    int(height * 72.0 / resolution),
+                    width * 72.0 / resolution,
+                    height * 72.0 / resolution,
                 ],
                 Contents=contents_refs[pageNumber],
             )
@@ -217,9 +210,9 @@
             #
             # page contents

-            page_contents = b"q %d 0 0 %d 0 0 cm /image Do Q\n" % (
-                int(width * 72.0 / resolution),
-                int(height * 72.0 / resolution),
+            page_contents = b"q %f 0 0 %f 0 0 cm /image Do Q\n" % (
+                width * 72.0 / resolution,
+                height * 72.0 / resolution,
             )

             existing_pdf.write_obj(contents_refs[pageNumber], stream=page_contents)
('src/PIL', 'ImageShow.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,7 +15,7 @@
 import shutil
 import subprocess
 import sys
-import tempfile
+import warnings
 from shlex import quote

 from PIL import Image
@@ -25,7 +25,12 @@

 def register(viewer, order=1):
     """
-    The :py:func:`register` function is used to register additional viewers.
+    The :py:func:`register` function is used to register additional viewers::
+
+        from PIL import ImageShow
+        ImageShow.register(MyViewer())  # MyViewer will be used as a last resort
+        ImageShow.register(MySecondViewer(), 0)  # MySecondViewer will be prioritised
+        ImageShow.register(ImageShow.XVViewer(), 0)  # XVViewer will be prioritised

     :param viewer: The viewer to be registered.
     :param order:
@@ -54,8 +59,8 @@
     """
     for viewer in _viewers:
         if viewer.show(image, title=title, **options):
-            return 1
-    return 0
+            return True
+    return False


 class Viewer:
@@ -69,7 +74,6 @@
         Converts the given image to the target format and displays it.
         """

-        # save temporary image to disk
         if not (
             image.mode in ("1", "RGBA")
             or (self.format == "PNG" and image.mode in ("I;16", "LA"))
@@ -106,9 +110,25 @@
         """Display the given image."""
         return self.show_file(self.save_image(image), **options)

-    def show_file(self, file, **options):
-        """Display the given file."""
-        os.system(self.get_command(file, **options))
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and will be removed in Pillow 10.0.0 (2023-07-01). ``path`` should be used
+        instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        os.system(self.get_command(path, **options))
         return 1


@@ -134,7 +154,7 @@


 class MacViewer(Viewer):
-    """The default viewer on MacOS using ``Preview.app``."""
+    """The default viewer on macOS using ``Preview.app``."""

     format = "PNG"
     options = {"compress_level": 1}
@@ -146,18 +166,33 @@
         command = f"({command} {quote(file)}; sleep 20; rm -f {quote(file)})&"
         return command

-    def show_file(self, file, **options):
-        """Display given file"""
-        fd, path = tempfile.mkstemp()
-        with os.fdopen(fd, "w") as f:
-            f.write(file)
-        with open(path) as f:
-            subprocess.Popen(
-                ["im=$(cat); open -a Preview.app $im; sleep 20; rm -f $im"],
-                shell=True,
-                stdin=f,
-            )
-        os.remove(path)
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and will be removed in Pillow 10.0.0 (2023-07-01). ``path`` should be used
+        instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        subprocess.call(["open", "-a", "Preview.app", path])
+        subprocess.Popen(
+            [
+                sys.executable,
+                "-c",
+                "import os, sys, time; time.sleep(20); os.remove(sys.argv[1])",
+                path,
+            ]
+        )
         return 1


@@ -171,36 +206,135 @@

     def get_command(self, file, **options):
         command = self.get_command_ex(file, **options)[0]
-        return f"({command} {quote(file)}; rm -f {quote(file)})&"
-
-    def show_file(self, file, **options):
-        """Display given file"""
-        fd, path = tempfile.mkstemp()
-        with os.fdopen(fd, "w") as f:
-            f.write(file)
-        with open(path) as f:
-            command = self.get_command_ex(file, **options)[0]
-            subprocess.Popen(
-                ["im=$(cat);" + command + " $im; rm -f $im"], shell=True, stdin=f
-            )
-        os.remove(path)
+        return f"({command} {quote(file)}"
+
+
+class XDGViewer(UnixViewer):
+    """
+    The freedesktop.org ``xdg-open`` command.
+    """
+
+    def get_command_ex(self, file, **options):
+        command = executable = "xdg-open"
+        return command, executable
+
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and will be removed in Pillow 10.0.0 (2023-07-01). ``path`` should be used
+        instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        subprocess.Popen(["xdg-open", path])
         return 1


 class DisplayViewer(UnixViewer):
-    """The ImageMagick ``display`` command."""
+    """
+    The ImageMagick ``display`` command.
+    This viewer supports the ``title`` parameter.
+    """
+
+    def get_command_ex(self, file, title=None, **options):
+        command = executable = "display"
+        if title:
+            command += f" -title {quote(title)}"
+        return command, executable
+
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and ``path`` should be used instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        args = ["display"]
+        title = options.get("title")
+        if title:
+            args += ["-title", title]
+        args.append(path)
+
+        subprocess.Popen(args)
+        return 1
+
+
+class GmDisplayViewer(UnixViewer):
+    """The GraphicsMagick ``gm display`` command."""

     def get_command_ex(self, file, **options):
-        command = executable = "display"
+        executable = "gm"
+        command = "gm display"
         return command, executable
+
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and ``path`` should be used instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        subprocess.Popen(["gm", "display", path])
+        return 1


 class EogViewer(UnixViewer):
     """The GNOME Image Viewer ``eog`` command."""

     def get_command_ex(self, file, **options):
-        command = executable = "eog"
+        executable = "eog"
+        command = "eog -n"
         return command, executable
+
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and ``path`` should be used instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        subprocess.Popen(["eog", "-n", path])
+        return 1


 class XVViewer(UnixViewer):
@@ -217,19 +351,66 @@
             command += f" -name {quote(title)}"
         return command, executable

+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and ``path`` should be used instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        args = ["xv"]
+        title = options.get("title")
+        if title:
+            args += ["-name", title]
+        args.append(path)
+
+        subprocess.Popen(args)
+        return 1
+

 if sys.platform not in ("win32", "darwin"):  # unixoids
+    if shutil.which("xdg-open"):
+        register(XDGViewer)
     if shutil.which("display"):
         register(DisplayViewer)
+    if shutil.which("gm"):
+        register(GmDisplayViewer)
     if shutil.which("eog"):
         register(EogViewer)
     if shutil.which("xv"):
         register(XVViewer)

+
+class IPythonViewer(Viewer):
+    """The viewer for IPython frontends."""
+
+    def show_image(self, image, **options):
+        ipython_display(image)
+        return 1
+
+
+try:
+    from IPython.display import display as ipython_display
+except ImportError:
+    pass
+else:
+    register(IPythonViewer)
+
+
 if __name__ == "__main__":

     if len(sys.argv) < 2:
-        print("Syntax: python ImageShow.py imagefile [title]")
+        print("Syntax: python3 ImageShow.py imagefile [title]")
         sys.exit()

     with Image.open(sys.argv[1]) as im:
('src/PIL', 'WmfImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,7 +21,6 @@

 from . import Image, ImageFile
 from ._binary import i16le as word
-from ._binary import i32le as dword
 from ._binary import si16le as short
 from ._binary import si32le as _long

@@ -112,7 +111,7 @@
             if s[22:26] != b"\x01\x00\t\x00":
                 raise SyntaxError("Unsupported WMF file format")

-        elif dword(s) == 1 and s[40:44] == b" EMF":
+        elif s[:4] == b"\x01\x00\x00\x00" and s[40:44] == b" EMF":
             # enhanced metafile

             # get bounding box
@@ -127,8 +126,8 @@
             size = x1 - x0, y1 - y0

             # calculate dots per inch from bbox and frame
-            xdpi = int(2540.0 * (x1 - y0) / (frame[2] - frame[0]) + 0.5)
-            ydpi = int(2540.0 * (y1 - y0) / (frame[3] - frame[1]) + 0.5)
+            xdpi = 2540.0 * (x1 - y0) / (frame[2] - frame[0])
+            ydpi = 2540.0 * (y1 - y0) / (frame[3] - frame[1])

             self.info["wmf_bbox"] = x0, y0, x1, y1

@@ -152,13 +151,13 @@

     def load(self, dpi=None):
         if dpi is not None and self._inch is not None:
-            self.info["dpi"] = int(dpi + 0.5)
+            self.info["dpi"] = dpi
             x0, y0, x1, y1 = self.info["wmf_bbox"]
             self._size = (
                 (x1 - x0) * self.info["dpi"] // self._inch,
                 (y1 - y0) * self.info["dpi"] // self._inch,
             )
-        super().load()
+        return super().load()


 def _save(im, fp, filename):
('src/PIL', 'ImageGrab.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -30,14 +30,18 @@
         if sys.platform == "darwin":
             fh, filepath = tempfile.mkstemp(".png")
             os.close(fh)
-            subprocess.call(["screencapture", "-x", filepath])
+            args = ["screencapture"]
+            if bbox:
+                left, top, right, bottom = bbox
+                args += ["-R", f"{left},{right},{right-left},{bottom-top}"]
+            subprocess.call(args + ["-x", filepath])
             im = Image.open(filepath)
             im.load()
             os.unlink(filepath)
             if bbox:
-                im_cropped = im.crop(bbox)
+                im_resized = im.resize((right - left, bottom - top))
                 im.close()
-                return im_cropped
+                return im_resized
             return im
         elif sys.platform == "win32":
             offset, size, data = Image.core.grabscreen_win32(
('src/PIL', 'WebPImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -96,7 +96,7 @@
     def _getexif(self):
         if "exif" not in self.info:
             return None
-        return dict(self.getexif())
+        return self.getexif()._get_merged_dict()

     def seek(self, frame):
         if not self._seek_check(frame):
@@ -190,9 +190,11 @@
             palette = im.getpalette()
             if palette:
                 r, g, b = palette[background * 3 : (background + 1) * 3]
-                background = (r, g, b, 0)
-
-    duration = im.encoderinfo.get("duration", 0)
+                background = (r, g, b, 255)
+            else:
+                background = (background, background, background, 255)
+
+    duration = im.encoderinfo.get("duration", im.info.get("duration", 0))
     loop = im.encoderinfo.get("loop", 0)
     minimize_size = im.encoderinfo.get("minimize_size", False)
     kmin = im.encoderinfo.get("kmin", None)
@@ -202,7 +204,7 @@
     lossless = im.encoderinfo.get("lossless", False)
     quality = im.encoderinfo.get("quality", 80)
     method = im.encoderinfo.get("method", 0)
-    icc_profile = im.encoderinfo.get("icc_profile", "")
+    icc_profile = im.encoderinfo.get("icc_profile") or ""
     exif = im.encoderinfo.get("exif", "")
     if isinstance(exif, Image.Exif):
         exif = exif.tobytes()
@@ -309,18 +311,18 @@
 def _save(im, fp, filename):
     lossless = im.encoderinfo.get("lossless", False)
     quality = im.encoderinfo.get("quality", 80)
-    icc_profile = im.encoderinfo.get("icc_profile", "")
+    icc_profile = im.encoderinfo.get("icc_profile") or ""
     exif = im.encoderinfo.get("exif", "")
     if isinstance(exif, Image.Exif):
         exif = exif.tobytes()
     xmp = im.encoderinfo.get("xmp", "")
-    method = im.encoderinfo.get("method", 0)
+    method = im.encoderinfo.get("method", 4)

     if im.mode not in _VALID_WEBP_LEGACY_MODES:
         alpha = (
             "A" in im.mode
             or "a" in im.mode
-            or (im.mode == "P" and "A" in im.im.getpalettemode())
+            or (im.mode == "P" and "transparency" in im.info)
         )
         im = im.convert("RGBA" if alpha else "RGB")

('src/PIL', 'FliImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -26,7 +26,11 @@


 def _accept(prefix):
-    return len(prefix) >= 6 and i16(prefix, 4) in [0xAF11, 0xAF12]
+    return (
+        len(prefix) >= 6
+        and i16(prefix, 4) in [0xAF11, 0xAF12]
+        and i16(prefix, 14) in [0, 3]  # flags
+    )


 ##
@@ -44,11 +48,7 @@

         # HEAD
         s = self.fp.read(128)
-        if not (
-            _accept(s)
-            and i16(s, 14) in [0, 3]  # flags
-            and s[20:22] == b"\x00\x00"  # reserved
-        ):
+        if not (_accept(s) and s[20:22] == b"\x00\x00"):
             raise SyntaxError("not an FLI/FLC file")

         # frames
('src/PIL', 'TiffTags.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -33,7 +33,7 @@
         return self.enum.get(value, value) if self.enum else value


-def lookup(tag):
+def lookup(tag, group=None):
     """
     :param tag: Integer tag number
     :returns: Taginfo namedtuple, From the TAGS_V2 info if possible,
@@ -42,7 +42,11 @@

     """

-    return TAGS_V2.get(tag, TagInfo(tag, TAGS.get(tag, "unknown")))
+    if group is not None:
+        info = TAGS_V2_GROUPS[group].get(tag) if group in TAGS_V2_GROUPS else None
+    else:
+        info = TAGS_V2.get(tag)
+    return info or TagInfo(tag, TAGS.get(tag, "unknown"))


 ##
@@ -70,6 +74,7 @@
 FLOAT = 11
 DOUBLE = 12
 IFD = 13
+LONG8 = 16

 TAGS_V2 = {
     254: ("NewSubfileType", LONG, 1),
@@ -178,12 +183,15 @@
     532: ("ReferenceBlackWhite", RATIONAL, 6),
     700: ("XMP", BYTE, 0),
     33432: ("Copyright", ASCII, 1),
-    33723: ("IptcNaaInfo", UNDEFINED, 0),
+    33723: ("IptcNaaInfo", UNDEFINED, 1),
     34377: ("PhotoshopInfo", BYTE, 0),
     # FIXME add more tags here
     34665: ("ExifIFD", LONG, 1),
     34675: ("ICCProfile", UNDEFINED, 1),
     34853: ("GPSInfoIFD", LONG, 1),
+    36864: ("ExifVersion", UNDEFINED, 1),
+    40965: ("InteroperabilityIFD", LONG, 1),
+    41730: ("CFAPattern", UNDEFINED, 1),
     # MPInfo
     45056: ("MPFVersion", UNDEFINED, 1),
     45057: ("NumberOfImages", LONG, 1),
@@ -204,10 +212,24 @@
     45579: ("YawAngle", SIGNED_RATIONAL, 1),
     45580: ("PitchAngle", SIGNED_RATIONAL, 1),
     45581: ("RollAngle", SIGNED_RATIONAL, 1),
+    40960: ("FlashPixVersion", UNDEFINED, 1),
     50741: ("MakerNoteSafety", SHORT, 1, {"Unsafe": 0, "Safe": 1}),
     50780: ("BestQualityScale", RATIONAL, 1),
     50838: ("ImageJMetaDataByteCounts", LONG, 0),  # Can be more than one
     50839: ("ImageJMetaData", UNDEFINED, 1),  # see Issue #2006
+}
+TAGS_V2_GROUPS = {
+    # ExifIFD
+    34665: {
+        36864: ("ExifVersion", UNDEFINED, 1),
+        40960: ("FlashPixVersion", UNDEFINED, 1),
+        40965: ("InteroperabilityIFD", LONG, 1),
+        41730: ("CFAPattern", UNDEFINED, 1),
+    },
+    # GPSInfoIFD
+    34853: {},
+    # InteroperabilityIFD
+    40965: {1: ("InteropIndex", ASCII, 1), 2: ("InteropVersion", UNDEFINED, 1)},
 }

 # Legacy Tags structure
@@ -367,6 +389,10 @@

         TAGS_V2[k] = TagInfo(k, *v)

+    for group, tags in TAGS_V2_GROUPS.items():
+        for k, v in tags.items():
+            tags[k] = TagInfo(k, *v)
+

 _populate()
 ##
@@ -484,9 +510,6 @@
     65537,
 }

-LIBTIFF_CORE.remove(301)  # Array of short, crashes
-LIBTIFF_CORE.remove(532)  # Array of long, crashes
-
 LIBTIFF_CORE.remove(255)  # We don't have support for subfiletypes
 LIBTIFF_CORE.remove(322)  # We don't have support for writing tiled images with libtiff
 LIBTIFF_CORE.remove(323)  # Tiled images
('src/PIL', 'TiffImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -41,6 +41,7 @@
 import io
 import itertools
 import logging
+import math
 import os
 import struct
 import warnings
@@ -48,7 +49,9 @@
 from fractions import Fraction
 from numbers import Number, Rational

-from . import Image, ImageFile, ImagePalette, TiffTags
+from . import Image, ImageFile, ImageOps, ImagePalette, TiffTags
+from ._binary import i16be as i16
+from ._binary import i32be as i32
 from ._binary import o8
 from .TiffTags import TYPES

@@ -58,6 +61,7 @@
 READ_LIBTIFF = False
 WRITE_LIBTIFF = False
 IFD_LEGACY_API = True
+STRIP_SIZE = 65536

 II = b"II"  # little-endian (Intel style)
 MM = b"MM"  # big-endian (Motorola style)
@@ -88,11 +92,15 @@
 ARTIST = 315
 PREDICTOR = 317
 COLORMAP = 320
+TILEWIDTH = 322
+TILELENGTH = 323
 TILEOFFSETS = 324
+TILEBYTECOUNTS = 325
 SUBIFD = 330
 EXTRASAMPLES = 338
 SAMPLEFORMAT = 339
 JPEGTABLES = 347
+YCBCRSUBSAMPLING = 530
 REFERENCEBLACKWHITE = 532
 COPYRIGHT = 33432
 IPTC_NAA_CHUNK = 33723  # newsphoto properties
@@ -167,6 +175,7 @@
     (II, 1, (1,), 1, (12,), ()): ("I;16", "I;12"),
     (II, 1, (1,), 1, (16,), ()): ("I;16", "I;16"),
     (MM, 1, (1,), 1, (16,), ()): ("I;16B", "I;16B"),
+    (II, 1, (1,), 2, (16,), ()): ("I;16", "I;16R"),
     (II, 1, (2,), 1, (16,), ()): ("I", "I;16S"),
     (MM, 1, (2,), 1, (16,), ()): ("I", "I;16BS"),
     (II, 0, (3,), 1, (32,), ()): ("F", "F;32F"),
@@ -252,6 +261,8 @@
     b"II\x2A\x00",  # Valid TIFF header with little-endian byte order
     b"MM\x2A\x00",  # Invalid TIFF header, assume big-endian
     b"II\x00\x2A",  # Invalid TIFF header, assume little-endian
+    b"MM\x00\x2B",  # BigTIFF with big-endian byte order
+    b"II\x2B\x00",  # BigTIFF with little-endian byte order
 ]


@@ -354,9 +365,22 @@
         return self._val.__hash__()

     def __eq__(self, other):
+        val = self._val
         if isinstance(other, IFDRational):
             other = other._val
-        return self._val == other
+        if isinstance(other, float):
+            val = float(val)
+        return val == other
+
+    def __getstate__(self):
+        return [self._val, self._numerator, self._denominator]
+
+    def __setstate__(self, state):
+        IFDRational.__init__(self, 0)
+        _val, _numerator, _denominator = state
+        self._val = _val
+        self._numerator = _numerator
+        self._denominator = _denominator

     def _delegate(op):
         def delegate(self, *args):
@@ -423,39 +447,45 @@

     Data Structures:

-        * self.tagtype = {}
-
-          * Key: numerical tiff tag number
+        * ``self.tagtype = {}``
+
+          * Key: numerical TIFF tag number
           * Value: integer corresponding to the data type from
-                   ~PIL.TiffTags.TYPES`
-
-    .. versionadded:: 3.0.0
+            :py:data:`.TiffTags.TYPES`
+
+          .. versionadded:: 3.0.0
+
+    'Internal' data structures:
+
+        * ``self._tags_v2 = {}``
+
+          * Key: numerical TIFF tag number
+          * Value: decoded data, as tuple for multiple values
+
+        * ``self._tagdata = {}``
+
+          * Key: numerical TIFF tag number
+          * Value: undecoded byte string from file
+
+        * ``self._tags_v1 = {}``
+
+          * Key: numerical TIFF tag number
+          * Value: decoded data in the v1 format
+
+    Tags will be found in the private attributes ``self._tagdata``, and in
+    ``self._tags_v2`` once decoded.
+
+    ``self.legacy_api`` is a value for internal use, and shouldn't be changed
+    from outside code. In cooperation with
+    :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`, if ``legacy_api``
+    is true, then decoded tags will be populated into both ``_tags_v1`` and
+    ``_tags_v2``. ``_tags_v2`` will be used if this IFD is used in the TIFF
+    save routine. Tags should be read from ``_tags_v1`` if
+    ``legacy_api == true``.
+
     """

-    """
-    Documentation:
-
-        'internal' data structures:
-        * self._tags_v2 = {} Key: numerical tiff tag number
-                             Value: decoded data, as tuple for multiple values
-        * self._tagdata = {} Key: numerical tiff tag number
-                             Value: undecoded byte string from file
-        * self._tags_v1 = {} Key: numerical tiff tag number
-                             Value: decoded data in the v1 format
-
-    Tags will be found in the private attributes self._tagdata, and in
-    self._tags_v2 once decoded.
-
-    Self.legacy_api is a value for internal use, and shouldn't be
-    changed from outside code. In cooperation with the
-    ImageFileDirectory_v1 class, if legacy_api is true, then decoded
-    tags will be populated into both _tags_v1 and _tags_v2. _Tags_v2
-    will be used if this IFD is used in the TIFF save routine. Tags
-    should be read from tags_v1 if legacy_api == true.
-
-    """
-
-    def __init__(self, ifh=b"II\052\0\0\0\0\0", prefix=None):
+    def __init__(self, ifh=b"II\052\0\0\0\0\0", prefix=None, group=None):
         """Initialize an ImageFileDirectory.

         To construct an ImageFileDirectory from a real file, pass the 8-byte
@@ -466,7 +496,7 @@
               endianness.
         :param prefix: Override the endianness of the file.
         """
-        if ifh[:4] not in PREFIXES:
+        if not _accept(ifh):
             raise SyntaxError(f"not a TIFF file (header {repr(ifh)} not valid)")
         self._prefix = prefix if prefix is not None else ifh[:2]
         if self._prefix == MM:
@@ -475,10 +505,14 @@
             self._endian = "<"
         else:
             raise SyntaxError("not a TIFF IFD")
+        self._bigtiff = ifh[2] == 43
+        self.group = group
         self.tagtype = {}
         """ Dictionary of tag types """
         self.reset()
-        (self.next,) = self._unpack("L", ifh[4:])
+        (self.next,) = (
+            self._unpack("Q", ifh[8:]) if self._bigtiff else self._unpack("L", ifh[4:])
+        )
         self._legacy_api = False

     prefix = property(lambda self: self._prefix)
@@ -506,7 +540,10 @@

         Returns the complete tag dictionary, with named tags where possible.
         """
-        return {TiffTags.lookup(code).name: value for code, value in self.items()}
+        return {
+            TiffTags.lookup(code, self.group).name: value
+            for code, value in self.items()
+        }

     def __len__(self):
         return len(set(self._tagdata) | set(self._tags_v2))
@@ -531,7 +568,7 @@
     def _setitem(self, tag, value, legacy_api):
         basetypes = (Number, bytes, str)

-        info = TiffTags.lookup(tag)
+        info = TiffTags.lookup(tag, self.group)
         values = [value] if isinstance(value, basetypes) else value

         if tag not in self.tagtype:
@@ -546,9 +583,9 @@
                         else TiffTags.SIGNED_RATIONAL
                     )
                 elif all(isinstance(v, int) for v in values):
-                    if all(0 <= v < 2 ** 16 for v in values):
+                    if all(0 <= v < 2**16 for v in values):
                         self.tagtype[tag] = TiffTags.SHORT
-                    elif all(-(2 ** 15) < v < 2 ** 15 for v in values):
+                    elif all(-(2**15) < v < 2**15 for v in values):
                         self.tagtype[tag] = TiffTags.SIGNED_SHORT
                     else:
                         self.tagtype[tag] = (
@@ -565,7 +602,8 @@

         if self.tagtype[tag] == TiffTags.UNDEFINED:
             values = [
-                value.encode("ascii", "replace") if isinstance(value, str) else value
+                v.encode("ascii", "replace") if isinstance(v, str) else v
+                for v in values
             ]
         elif self.tagtype[tag] == TiffTags.RATIONAL:
             values = [float(v) if isinstance(v, int) else v for v in values]
@@ -648,7 +686,7 @@
         _load_dispatch[idx] = (  # noqa: F821
             size,
             lambda self, data, legacy_api=True: (
-                self._unpack("{}{}".format(len(data) // size, fmt), data)
+                self._unpack(f"{len(data) // size}{fmt}", data)
             ),
         )
         _write_dispatch[idx] = lambda self, *values: (  # noqa: F821
@@ -667,6 +705,7 @@
                 (TiffTags.FLOAT, "f", "float"),
                 (TiffTags.DOUBLE, "d", "double"),
                 (TiffTags.IFD, "L", "long"),
+                (TiffTags.LONG8, "Q", "long8"),
             ],
         )
     )
@@ -692,7 +731,7 @@

     @_register_loader(5, 8)
     def load_rational(self, data, legacy_api=True):
-        vals = self._unpack("{}L".format(len(data) // 4), data)
+        vals = self._unpack(f"{len(data) // 4}L", data)

         def combine(a, b):
             return (a, b) if legacy_api else IFDRational(a, b)
@@ -702,7 +741,7 @@
     @_register_writer(5)
     def write_rational(self, *values):
         return b"".join(
-            self._pack("2L", *_limit_rational(frac, 2 ** 32 - 1)) for frac in values
+            self._pack("2L", *_limit_rational(frac, 2**32 - 1)) for frac in values
         )

     @_register_loader(7, 1)
@@ -715,7 +754,7 @@

     @_register_loader(10, 8)
     def load_signed_rational(self, data, legacy_api=True):
-        vals = self._unpack("{}l".format(len(data) // 4), data)
+        vals = self._unpack(f"{len(data) // 4}l", data)

         def combine(a, b):
             return (a, b) if legacy_api else IFDRational(a, b)
@@ -725,7 +764,7 @@
     @_register_writer(10)
     def write_signed_rational(self, *values):
         return b"".join(
-            self._pack("2l", *_limit_signed_rational(frac, 2 ** 31 - 1, -(2 ** 31)))
+            self._pack("2l", *_limit_signed_rational(frac, 2**31 - 1, -(2**31)))
             for frac in values
         )

@@ -744,10 +783,19 @@
         self._offset = fp.tell()

         try:
-            for i in range(self._unpack("H", self._ensure_read(fp, 2))[0]):
-                tag, typ, count, data = self._unpack("HHL4s", self._ensure_read(fp, 12))
-
-                tagname = TiffTags.lookup(tag).name
+            tag_count = (
+                self._unpack("Q", self._ensure_read(fp, 8))
+                if self._bigtiff
+                else self._unpack("H", self._ensure_read(fp, 2))
+            )[0]
+            for i in range(tag_count):
+                tag, typ, count, data = (
+                    self._unpack("HHQ8s", self._ensure_read(fp, 20))
+                    if self._bigtiff
+                    else self._unpack("HHL4s", self._ensure_read(fp, 12))
+                )
+
+                tagname = TiffTags.lookup(tag, self.group).name
                 typname = TYPES.get(typ, "unknown")
                 msg = f"tag: {tagname} ({tag}) - type: {typname} ({typ})"

@@ -757,9 +805,9 @@
                     logger.debug(msg + f" - unsupported type {typ}")
                     continue  # ignore unsupported type
                 size = count * unit_size
-                if size > 4:
+                if size > (8 if self._bigtiff else 4):
                     here = fp.tell()
-                    (offset,) = self._unpack("L", data)
+                    (offset,) = self._unpack("Q" if self._bigtiff else "L", data)
                     msg += f" Tag Location: {here} - Data Location: {offset}"
                     fp.seek(offset)
                     data = ImageFile._safe_read(fp, size)
@@ -788,7 +836,11 @@
                 )
                 logger.debug(msg)

-            (self.next,) = self._unpack("L", self._ensure_read(fp, 4))
+            (self.next,) = (
+                self._unpack("Q", self._ensure_read(fp, 8))
+                if self._bigtiff
+                else self._unpack("L", self._ensure_read(fp, 4))
+            )
         except OSError as msg:
             warnings.warn(str(msg))
             return
@@ -814,15 +866,16 @@
                     ifh = b"II\x2A\x00\x08\x00\x00\x00"
                 else:
                     ifh = b"MM\x00\x2A\x00\x00\x00\x08"
-                ifd = ImageFileDirectory_v2(ifh)
-                for ifd_tag, ifd_value in self._tags_v2[tag].items():
+                ifd = ImageFileDirectory_v2(ifh, group=tag)
+                values = self._tags_v2[tag]
+                for ifd_tag, ifd_value in values.items():
                     ifd[ifd_tag] = ifd_value
                 data = ifd.tobytes(offset)
             else:
                 values = value if isinstance(value, tuple) else (value,)
                 data = self._write_dispatch[typ](self, *values)

-            tagname = TiffTags.lookup(tag).name
+            tagname = TiffTags.lookup(tag, self.group).name
             typname = "ifd" if is_ifd else TYPES.get(typ, "unknown")
             msg = f"save: {tagname} ({tag}) - type: {typname} ({typ})"
             msg += " - value: " + (
@@ -1009,6 +1062,8 @@

         # Header
         ifh = self.fp.read(8)
+        if ifh[2] == 43:
+            ifh += self.fp.read(8)

         self.tag_v2 = ImageFileDirectory_v2(ifh)

@@ -1052,6 +1107,11 @@

     def _seek(self, frame):
         self.fp = self.__fp
+
+        # reset buffered io handle in case fp
+        # was passed to libtiff, invalidating the buffer
+        self.fp.tell()
+
         while len(self._frame_pos) <= frame:
             if not self.__next:
                 raise EOFError("no more images in TIFF file")
@@ -1059,14 +1119,16 @@
                 f"Seeking to frame {frame}, on frame {self.__frame}, "
                 f"__next {self.__next}, location: {self.fp.tell()}"
             )
-            # reset buffered io handle in case fp
-            # was passed to libtiff, invalidating the buffer
-            self.fp.tell()
             self.fp.seek(self.__next)
             self._frame_pos.append(self.__next)
             logger.debug("Loading tags, location: %s" % self.fp.tell())
             self.tag_v2.load(self.fp)
-            self.__next = self.tag_v2.next
+            if self.tag_v2.next in self._frame_pos:
+                # This IFD has already been processed
+                # Declare this to be the end of the image
+                self.__next = 0
+            else:
+                self.__next = self.tag_v2.next
             if self.__next == 0:
                 self._n_frames = frame + 1
             if len(self._frame_pos) == 1:
@@ -1083,6 +1145,36 @@
         """Return the current frame number"""
         return self.__frame

+    def getxmp(self):
+        """
+        Returns a dictionary containing the XMP tags.
+        Requires defusedxml to be installed.
+
+        :returns: XMP tags in a dictionary.
+        """
+        return self._getxmp(self.tag_v2[700]) if 700 in self.tag_v2 else {}
+
+    def get_photoshop_blocks(self):
+        """
+        Returns a dictionary of Photoshop "Image Resource Blocks".
+        The keys are the image resource ID. For more information, see
+        https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_pgfId-1037727
+
+        :returns: Photoshop "Image Resource Blocks" in a dictionary.
+        """
+        blocks = {}
+        val = self.tag_v2.get(0x8649)
+        if val:
+            while val[:4] == b"8BIM":
+                id = i16(val[4:6])
+                n = math.ceil((val[6] + 1) / 2) * 2
+                size = i32(val[6 + n : 10 + n])
+                data = val[10 + n : 10 + n + size]
+                blocks[id] = {"data": data}
+
+                val = val[math.ceil((10 + n + size) / 2) * 2 :]
+        return blocks
+
     def load(self):
         if self.tile and self.use_load_libtiff:
             return self._load_libtiff()
@@ -1091,13 +1183,13 @@
     def load_end(self):
         if self._tile_orientation:
             method = {
-                2: Image.FLIP_LEFT_RIGHT,
-                3: Image.ROTATE_180,
-                4: Image.FLIP_TOP_BOTTOM,
-                5: Image.TRANSPOSE,
-                6: Image.ROTATE_270,
-                7: Image.TRANSVERSE,
-                8: Image.ROTATE_90,
+                2: Image.Transpose.FLIP_LEFT_RIGHT,
+                3: Image.Transpose.ROTATE_180,
+                4: Image.Transpose.FLIP_TOP_BOTTOM,
+                5: Image.Transpose.TRANSPOSE,
+                6: Image.Transpose.ROTATE_270,
+                7: Image.Transpose.TRANSVERSE,
+                8: Image.Transpose.ROTATE_90,
             }.get(self._tile_orientation)
             if method is not None:
                 self.im = self.im.transpose(method)
@@ -1107,6 +1199,17 @@
         # This is the ImageFile.load path only, libtiff specific below.
         if not self.is_animated:
             self._close_exclusive_fp_after_loading = True
+
+            # reset buffered io handle in case fp
+            # was passed to libtiff, invalidating the buffer
+            self.fp.tell()
+
+            # load IFD data from fp before it is closed
+            exif = self.getexif()
+            for key in TiffTags.TAGS_V2_GROUPS.keys():
+                if key not in exif:
+                    continue
+                exif.get_ifd(key)

     def _load_libtiff(self):
         """Overload method triggered when we detect a compressed tiff
@@ -1178,6 +1281,12 @@
             # UNDONE -- so much for that buffer size thing.
             n, err = decoder.decode(self.fp.read())

+        if fp:
+            try:
+                os.close(fp)
+            except OSError:
+                pass
+
         self.tile = []
         self.readonly = 0

@@ -1245,10 +1354,22 @@
         else:
             bps_count = 1
         bps_count += len(extra_tuple)
-        # Some files have only one value in bps_tuple,
-        # while should have more. Fix it
-        if bps_count > len(bps_tuple) and len(bps_tuple) == 1:
+        bps_actual_count = len(bps_tuple)
+        if bps_count < bps_actual_count:
+            # If a file has more values in bps_tuple than expected,
+            # remove the excess.
+            bps_tuple = bps_tuple[:bps_count]
+        elif bps_count > bps_actual_count and bps_actual_count == 1:
+            # If a file has only one value in bps_tuple, when it should have more,
+            # presume it is the same number of bits for all of the samples.
             bps_tuple = bps_tuple * bps_count
+
+        samplesPerPixel = self.tag_v2.get(
+            SAMPLESPERPIXEL,
+            3 if self._compression == "tiff_jpeg" and photo in (2, 6) else 1,
+        )
+        if len(bps_tuple) != samplesPerPixel:
+            raise SyntaxError("unknown data organization")

         # mode: check photometric interpretation and bits per pixel
         key = (
@@ -1277,11 +1398,11 @@
         if xres and yres:
             resunit = self.tag_v2.get(RESOLUTION_UNIT)
             if resunit == 2:  # dots per inch
-                self.info["dpi"] = int(xres + 0.5), int(yres + 0.5)
+                self.info["dpi"] = (xres, yres)
             elif resunit == 3:  # dots per centimeter. convert to dpi
-                self.info["dpi"] = int(xres * 2.54 + 0.5), int(yres * 2.54 + 0.5)
+                self.info["dpi"] = (xres * 2.54, yres * 2.54)
             elif resunit is None:  # used to default to 1, but now 2)
-                self.info["dpi"] = int(xres + 0.5), int(yres + 0.5)
+                self.info["dpi"] = (xres, yres)
                 # For backward compatibility,
                 # we also preserve the old behavior
                 self.info["resolution"] = xres, yres
@@ -1323,6 +1444,15 @@
                 rawmode = rawmode.replace(";16B", ";16N")
             if ";16L" in rawmode:
                 rawmode = rawmode.replace(";16L", ";16N")
+
+            # YCbCr images with new jpeg compression with pixels in one plane
+            # unpacked straight into RGB values
+            if (
+                photo == 6
+                and self._compression == "jpeg"
+                and self._planar_configuration == 1
+            ):
+                rawmode = "RGB"

             # Offset in the tile tuple is 0, we go from 0,0 to
             # w,h, and we only do this once -- eds
@@ -1436,28 +1566,44 @@

     ifd = ImageFileDirectory_v2(prefix=prefix)

-    compression = im.encoderinfo.get("compression", im.info.get("compression"))
+    encoderinfo = im.encoderinfo
+    encoderconfig = im.encoderconfig
+    compression = encoderinfo.get("compression", im.info.get("compression"))
     if compression is None:
         compression = "raw"
     elif compression == "tiff_jpeg":
         # OJPEG is obsolete, so use new-style JPEG compression instead
         compression = "jpeg"
+    elif compression == "tiff_deflate":
+        compression = "tiff_adobe_deflate"

     libtiff = WRITE_LIBTIFF or compression != "raw"

     # required for color libtiff images
-    ifd[PLANAR_CONFIGURATION] = getattr(im, "_planar_configuration", 1)
+    ifd[PLANAR_CONFIGURATION] = 1

     ifd[IMAGEWIDTH] = im.size[0]
     ifd[IMAGELENGTH] = im.size[1]

     # write any arbitrary tags passed in as an ImageFileDirectory
-    info = im.encoderinfo.get("tiffinfo", {})
+    if "tiffinfo" in encoderinfo:
+        info = encoderinfo["tiffinfo"]
+    elif "exif" in encoderinfo:
+        info = encoderinfo["exif"]
+        if isinstance(info, bytes):
+            exif = Image.Exif()
+            exif.load(info)
+            info = exif
+    else:
+        info = {}
     logger.debug("Tiffinfo Keys: %s" % list(info))
     if isinstance(info, ImageFileDirectory_v1):
         info = info.to_v2()
     for key in info:
-        ifd[key] = info.get(key)
+        if isinstance(info, Image.Exif) and key in TiffTags.TAGS_V2_GROUPS.keys():
+            ifd[key] = info.get_ifd(key)
+        else:
+            ifd[key] = info.get(key)
         try:
             ifd.tagtype[key] = info.tagtype[key]
         except Exception:
@@ -1481,8 +1627,9 @@

     # preserve ICC profile (should also work when saving other formats
     # which support profiles as TIFF) -- 2008-06-06 Florian Hoech
-    if "icc_profile" in im.info:
-        ifd[ICCPROFILE] = im.info["icc_profile"]
+    icc = encoderinfo.get("icc_profile", im.info.get("icc_profile"))
+    if icc:
+        ifd[ICCPROFILE] = icc

     for key, name in [
         (IMAGEDESCRIPTION, "description"),
@@ -1496,14 +1643,14 @@
         (ARTIST, "artist"),
         (COPYRIGHT, "copyright"),
     ]:
-        if name in im.encoderinfo:
-            ifd[key] = im.encoderinfo[name]
-
-    dpi = im.encoderinfo.get("dpi")
+        if name in encoderinfo:
+            ifd[key] = encoderinfo[name]
+
+    dpi = encoderinfo.get("dpi")
     if dpi:
         ifd[RESOLUTION_UNIT] = 2
-        ifd[X_RESOLUTION] = int(dpi[0] + 0.5)
-        ifd[Y_RESOLUTION] = int(dpi[1] + 0.5)
+        ifd[X_RESOLUTION] = dpi[0]
+        ifd[Y_RESOLUTION] = dpi[1]

     if bits != (1,):
         ifd[BITSPERSAMPLE] = bits
@@ -1514,25 +1661,59 @@
     if format != 1:
         ifd[SAMPLEFORMAT] = format

-    ifd[PHOTOMETRIC_INTERPRETATION] = photo
+    if PHOTOMETRIC_INTERPRETATION not in ifd:
+        ifd[PHOTOMETRIC_INTERPRETATION] = photo
+    elif im.mode in ("1", "L") and ifd[PHOTOMETRIC_INTERPRETATION] == 0:
+        if im.mode == "1":
+            inverted_im = im.copy()
+            px = inverted_im.load()
+            for y in range(inverted_im.height):
+                for x in range(inverted_im.width):
+                    px[x, y] = 0 if px[x, y] == 255 else 255
+            im = inverted_im
+        else:
+            im = ImageOps.invert(im)

     if im.mode in ["P", "PA"]:
         lut = im.im.getpalette("RGB", "RGB;L")
         ifd[COLORMAP] = tuple(v * 256 for v in lut)
     # data orientation
     stride = len(bits) * ((im.size[0] * bits[0] + 7) // 8)
-    ifd[ROWSPERSTRIP] = im.size[1]
-    strip_byte_counts = stride * im.size[1]
-    if strip_byte_counts >= 2 ** 16:
+    # aim for given strip size (64 KB by default) when using libtiff writer
+    if libtiff:
+        rows_per_strip = 1 if stride == 0 else min(STRIP_SIZE // stride, im.size[1])
+        # JPEG encoder expects multiple of 8 rows
+        if compression == "jpeg":
+            rows_per_strip = min(((rows_per_strip + 7) // 8) * 8, im.size[1])
+    else:
+        rows_per_strip = im.size[1]
+    if rows_per_strip == 0:
+        rows_per_strip = 1
+    strip_byte_counts = 1 if stride == 0 else stride * rows_per_strip
+    strips_per_image = (im.size[1] + rows_per_strip - 1) // rows_per_strip
+    ifd[ROWSPERSTRIP] = rows_per_strip
+    if strip_byte_counts >= 2**16:
         ifd.tagtype[STRIPBYTECOUNTS] = TiffTags.LONG
-    ifd[STRIPBYTECOUNTS] = strip_byte_counts
-    ifd[STRIPOFFSETS] = 0  # this is adjusted by IFD writer
+    ifd[STRIPBYTECOUNTS] = (strip_byte_counts,) * (strips_per_image - 1) + (
+        stride * im.size[1] - strip_byte_counts * (strips_per_image - 1),
+    )
+    ifd[STRIPOFFSETS] = tuple(
+        range(0, strip_byte_counts * strips_per_image, strip_byte_counts)
+    )  # this is adjusted by IFD writer
     # no compression by default:
     ifd[COMPRESSION] = COMPRESSION_INFO_REV.get(compression, 1)

+    if im.mode == "YCbCr":
+        for tag, value in {
+            YCBCRSUBSAMPLING: (1, 1),
+            REFERENCEBLACKWHITE: (0, 255, 128, 255, 128, 255),
+        }.items():
+            ifd.setdefault(tag, value)
+
+    blocklist = [TILEWIDTH, TILELENGTH, TILEOFFSETS, TILEBYTECOUNTS]
     if libtiff:
-        if "quality" in im.encoderinfo:
-            quality = im.encoderinfo["quality"]
+        if "quality" in encoderinfo:
+            quality = encoderinfo["quality"]
             if not isinstance(quality, int) or quality < 0 or quality > 100:
                 raise ValueError("Invalid quality setting")
             if compression != "jpeg":
@@ -1553,17 +1734,14 @@

         # optional types for non core tags
         types = {}
-        # SAMPLEFORMAT is determined by the image format and should not be copied
-        # from legacy_ifd.
         # STRIPOFFSETS and STRIPBYTECOUNTS are added by the library
         # based on the data in the strip.
         # The other tags expect arrays with a certain length (fixed or depending on
         # BITSPERSAMPLE, etc), passing arrays with a different length will result in
         # segfaults. Block these tags until we add extra validation.
         # SUBIFD may also cause a segfault.
-        blocklist = [
+        blocklist += [
             REFERENCEBLACKWHITE,
-            SAMPLEFORMAT,
             STRIPBYTECOUNTS,
             STRIPOFFSETS,
             TRANSFERFUNCTION,
@@ -1579,9 +1757,14 @@
         legacy_ifd = {}
         if hasattr(im, "tag"):
             legacy_ifd = im.tag.to_v2()
-        for tag, value in itertools.chain(
-            ifd.items(), getattr(im, "tag_v2", {}).items(), legacy_ifd.items()
-        ):
+
+        # SAMPLEFORMAT is determined by the image format and should not be copied
+        # from legacy_ifd.
+        supplied_tags = {**getattr(im, "tag_v2", {}), **legacy_ifd}
+        if SAMPLEFORMAT in supplied_tags:
+            del supplied_tags[SAMPLEFORMAT]
+
+        for tag, value in itertools.chain(ifd.items(), supplied_tags.items()):
             # Libtiff can only process certain core items without adding
             # them to the custom dictionary.
             # Custom items are supported for int, float, unicode, string and byte
@@ -1606,6 +1789,9 @@
                 else:
                     atts[tag] = value

+        if SAMPLEFORMAT in atts and len(atts[SAMPLEFORMAT]) == 1:
+            atts[SAMPLEFORMAT] = atts[SAMPLEFORMAT][0]
+
         logger.debug("Converted items: %s" % sorted(atts.items()))

         # libtiff always expects the bytes in native order.
@@ -1621,7 +1807,7 @@
         tags = list(atts.items())
         tags.sort()
         a = (rawmode, compression, _fp, filename, tags, types)
-        e = Image._getencoder(im.mode, "libtiff", a, im.encoderconfig)
+        e = Image._getencoder(im.mode, "libtiff", a, encoderconfig)
         e.setimage(im.im, (0, 0) + im.size)
         while True:
             # undone, change to self.decodermaxblock:
@@ -1634,6 +1820,8 @@
             raise OSError(f"encoder error {s} when writing image file")

     else:
+        for tag in blocklist:
+            del ifd[tag]
         offset = ifd.save(fp)

         ImageFile._save(
@@ -1641,7 +1829,7 @@
         )

     # -- helper for multi-page save --
-    if "_debug_multipage" in im.encoderinfo:
+    if "_debug_multipage" in encoderinfo:
         # just to access o32 and o16 (using correct byte order)
         im._debug_multipage = ifd

('src/PIL', 'ImagePalette.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -17,6 +17,7 @@
 #

 import array
+import warnings

 from . import GimpGradientFile, GimpPaletteFile, ImageColor, PaletteFile

@@ -25,27 +26,45 @@
     """
     Color palette for palette mapped images

-    :param mode: The mode to use for the Palette. See:
+    :param mode: The mode to use for the palette. See:
         :ref:`concept-modes`. Defaults to "RGB"
     :param palette: An optional palette. If given, it must be a bytearray,
-        an array or a list of ints between 0-255 and of length ``size``
-        times the number of colors in ``mode``. The list must be aligned
-        by channel (All R values must be contiguous in the list before G
-        and B values.) Defaults to 0 through 255 per channel.
-    :param size: An optional palette size. If given, it cannot be equal to
-        or greater than 256. Defaults to 0.
+        an array or a list of ints between 0-255. The list must consist of
+        all channels for one color followed by the next color (e.g. RGBRGBRGB).
+        Defaults to an empty palette.
+    :param size: An optional palette size. If given, an error is raised
+        if ``palette`` is not of equal length.
     """

     def __init__(self, mode="RGB", palette=None, size=0):
         self.mode = mode
         self.rawmode = None  # if set, palette contains raw data
-        self.palette = palette or bytearray(range(256)) * len(self.mode)
+        self.palette = palette or bytearray()
+        self.dirty = None
+        if size != 0:
+            warnings.warn(
+                "The size parameter is deprecated and will be removed in Pillow 10 "
+                "(2023-07-01).",
+                DeprecationWarning,
+            )
+            if size != len(self.palette):
+                raise ValueError("wrong palette size")
+
+    @property
+    def palette(self):
+        return self._palette
+
+    @palette.setter
+    def palette(self, palette):
+        self._palette = palette
+
+        mode_len = len(self.mode)
         self.colors = {}
-        self.dirty = None
-        if (size == 0 and len(self.mode) * 256 != len(self.palette)) or (
-            size != 0 and size != len(self.palette)
-        ):
-            raise ValueError("wrong palette size")
+        for i in range(0, len(self.palette), mode_len):
+            color = tuple(self.palette[i : i + mode_len])
+            if color in self.colors:
+                continue
+            self.colors[color] = i // mode_len

     def copy(self):
         new = ImagePalette()
@@ -54,7 +73,6 @@
         new.rawmode = self.rawmode
         if self.palette is not None:
             new.palette = self.palette[:]
-        new.colors = self.colors.copy()
         new.dirty = self.dirty

         return new
@@ -68,7 +86,7 @@
         """
         if self.rawmode:
             return self.rawmode, self.palette
-        return self.mode + ";L", self.tobytes()
+        return self.mode, self.tobytes()

     def tobytes(self):
         """Convert palette to bytes.
@@ -80,14 +98,12 @@
         if isinstance(self.palette, bytes):
             return self.palette
         arr = array.array("B", self.palette)
-        if hasattr(arr, "tobytes"):
-            return arr.tobytes()
-        return arr.tostring()
+        return arr.tobytes()

     # Declare tostring as an alias for tobytes
     tostring = tobytes

-    def getcolor(self, color):
+    def getcolor(self, color, image=None):
         """Given an rgb tuple, allocate palette entry.

         .. warning:: This method is experimental.
@@ -95,19 +111,45 @@
         if self.rawmode:
             raise ValueError("palette contains raw palette data")
         if isinstance(color, tuple):
+            if self.mode == "RGB":
+                if len(color) == 4 and color[3] == 255:
+                    color = color[:3]
+            elif self.mode == "RGBA":
+                if len(color) == 3:
+                    color += (255,)
             try:
                 return self.colors[color]
             except KeyError as e:
                 # allocate new color slot
-                if isinstance(self.palette, bytes):
-                    self.palette = bytearray(self.palette)
-                index = len(self.colors)
+                if not isinstance(self.palette, bytearray):
+                    self._palette = bytearray(self.palette)
+                index = len(self.palette) // 3
+                special_colors = ()
+                if image:
+                    special_colors = (
+                        image.info.get("background"),
+                        image.info.get("transparency"),
+                    )
+                while index in special_colors:
+                    index += 1
                 if index >= 256:
-                    raise ValueError("cannot allocate more than 256 colors") from e
+                    if image:
+                        # Search for an unused index
+                        for i, count in reversed(list(enumerate(image.histogram()))):
+                            if count == 0 and i not in special_colors:
+                                index = i
+                                break
+                    if index >= 256:
+                        raise ValueError("cannot allocate more than 256 colors") from e
                 self.colors[color] = index
-                self.palette[index] = color[0]
-                self.palette[index + 256] = color[1]
-                self.palette[index + 512] = color[2]
+                if index * 3 < len(self.palette):
+                    self._palette = (
+                        self.palette[: index * 3]
+                        + bytes(color)
+                        + self.palette[index * 3 + 3 :]
+                    )
+                else:
+                    self._palette += bytes(color)
                 self.dirty = 1
                 return index
         else:
@@ -169,9 +211,9 @@


 def negative(mode="RGB"):
-    palette = list(range(256))
+    palette = list(range(256 * len(mode)))
     palette.reverse()
-    return ImagePalette(mode, palette * len(mode))
+    return ImagePalette(mode, [i // len(mode) for i in palette])


 def random(mode="RGB"):
@@ -184,15 +226,13 @@


 def sepia(white="#fff0c0"):
-    r, g, b = ImageColor.getrgb(white)
-    r = make_linear_lut(0, r)
-    g = make_linear_lut(0, g)
-    b = make_linear_lut(0, b)
-    return ImagePalette("RGB", r + g + b)
+    bands = [make_linear_lut(0, band) for band in ImageColor.getrgb(white)]
+    return ImagePalette("RGB", [bands[i % 3][i // 3] for i in range(256 * 3)])


 def wedge(mode="RGB"):
-    return ImagePalette(mode, list(range(256)) * len(mode))
+    palette = list(range(256 * len(mode)))
+    return ImagePalette(mode, [i // len(mode) for i in palette])


 def load(filename):
('src/PIL', 'BmpImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,6 +24,8 @@
 #


+import os
+
 from . import Image, ImageFile, ImagePalette
 from ._binary import i16le as i16
 from ._binary import i32le as i32
@@ -58,7 +60,7 @@
 # Image plugin for the Windows BMP format.
 # =============================================================================
 class BmpImageFile(ImageFile.ImageFile):
-    """ Image plugin for the Windows Bitmap format (BMP) """
+    """Image plugin for the Windows Bitmap format (BMP)"""

     # ------------------------------------------------------------- Description
     format_description = "Windows Bitmap"
@@ -70,7 +72,7 @@
         vars()[k] = v

     def _bitmap(self, header=0, offset=0):
-        """ Read relevant info about the BMP """
+        """Read relevant info about the BMP"""
         read, seek = self.fp.read, self.fp.seek
         if header:
             seek(header)
@@ -102,7 +104,7 @@
             file_info["height"] = (
                 i32(header_data, 4)
                 if not file_info["y_flip"]
-                else 2 ** 32 - i32(header_data, 4)
+                else 2**32 - i32(header_data, 4)
             )
             file_info["planes"] = i16(header_data, 8)
             file_info["bits"] = i16(header_data, 10)
@@ -115,9 +117,7 @@
             )
             file_info["colors"] = i32(header_data, 28)
             file_info["palette_padding"] = 4
-            self.info["dpi"] = tuple(
-                int(x / 39.3701 + 0.5) for x in file_info["pixels_per_meter"]
-            )
+            self.info["dpi"] = tuple(x / 39.3701 for x in file_info["pixels_per_meter"])
             if file_info["compression"] == self.BITFIELDS:
                 if len(header_data) >= 52:
                     for idx, mask in enumerate(
@@ -160,6 +160,8 @@
             if file_info.get("colors", 0)
             else (1 << file_info["bits"])
         )
+        if offset == 14 + file_info["header_size"] and file_info["bits"] <= 8:
+            offset += 4 * file_info["colors"]

         # ---------------------- Check bit depth for unusual unsupported values
         self.mode, raw_mode = BIT2MODE.get(file_info["bits"], (None, None))
@@ -167,6 +169,7 @@
             raise OSError(f"Unsupported BMP pixel depth ({file_info['bits']})")

         # ---------------- Process BMP with Bitfields compression (not palette)
+        decoder_name = "raw"
         if file_info["compression"] == self.BITFIELDS:
             SUPPORTED = {
                 32: [
@@ -208,6 +211,8 @@
         elif file_info["compression"] == self.RAW:
             if file_info["bits"] == 32 and header == 22:  # 32-bit .cur offset
                 raw_mode, self.mode = "BGRA", "RGBA"
+        elif file_info["compression"] == self.RLE8:
+            decoder_name = "bmp_rle"
         else:
             raise OSError(f"Unsupported BMP compression ({file_info['compression']})")

@@ -247,7 +252,7 @@
         self.info["compression"] = file_info["compression"]
         self.tile = [
             (
-                "raw",
+                decoder_name,
                 (0, 0, file_info["width"], file_info["height"]),
                 offset or self.fp.tell(),
                 (
@@ -259,7 +264,7 @@
         ]

     def _open(self):
-        """ Open file, check magic number and read header """
+        """Open file, check magic number and read header"""
         # read 14 bytes: magic number, filesize, reserved, header final offset
         head_data = self.fp.read(14)
         # choke if the file does not have the required magic bytes
@@ -271,6 +276,57 @@
         self._bitmap(offset=offset)


+class BmpRleDecoder(ImageFile.PyDecoder):
+    _pulls_fd = True
+
+    def decode(self, buffer):
+        data = bytearray()
+        x = 0
+        while len(data) < self.state.xsize * self.state.ysize:
+            pixels = self.fd.read(1)
+            byte = self.fd.read(1)
+            if not pixels or not byte:
+                break
+            num_pixels = pixels[0]
+            if num_pixels:
+                # encoded mode
+                if x + num_pixels > self.state.xsize:
+                    # Too much data for row
+                    num_pixels = max(0, self.state.xsize - x)
+                data += byte * num_pixels
+                x += num_pixels
+            else:
+                if byte[0] == 0:
+                    # end of line
+                    while len(data) % self.state.xsize != 0:
+                        data += b"\x00"
+                    x = 0
+                elif byte[0] == 1:
+                    # end of bitmap
+                    break
+                elif byte[0] == 2:
+                    # delta
+                    bytes_read = self.fd.read(2)
+                    if len(bytes_read) < 2:
+                        break
+                    right, up = self.fd.read(2)
+                    data += b"\x00" * (right + up * self.state.xsize)
+                    x = len(data) % self.state.xsize
+                else:
+                    # absolute mode
+                    bytes_read = self.fd.read(byte[0])
+                    data += bytes_read
+                    if len(bytes_read) < byte[0]:
+                        break
+                    x += byte[0]
+
+                    # align to 16-bit word boundary
+                    if self.fd.tell() % 2 != 0:
+                        self.fd.seek(1, os.SEEK_CUR)
+        self.set_as_raw(bytes(data), ("P", 0, self.args[-1]))
+        return -1, 0
+
+
 # =============================================================================
 # Image plugin for the DIB format (BMP alias)
 # =============================================================================
@@ -322,7 +378,7 @@
     if bitmap_header:
         offset = 14 + header + colors * 4
         file_size = offset + image
-        if file_size > 2 ** 32 - 1:
+        if file_size > 2**32 - 1:
             raise ValueError("File size is too large for the BMP format")
         fp.write(
             b"BM"  # file type (magic)
@@ -372,6 +428,8 @@

 Image.register_mime(BmpImageFile.format, "image/bmp")

+Image.register_decoder("bmp_rle", BmpRleDecoder)
+
 Image.register_open(DibImageFile.format, DibImageFile, _dib_accept)
 Image.register_save(DibImageFile.format, _dib_save)

('src/PIL', 'ImageTransform.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -47,7 +47,7 @@
         from an affine transform matrix.
     """

-    method = Image.AFFINE
+    method = Image.Transform.AFFINE


 class ExtentTransform(Transform):
@@ -69,7 +69,7 @@
         input image's coordinate system. See :ref:`coordinate-system`.
     """

-    method = Image.EXTENT
+    method = Image.Transform.EXTENT


 class QuadTransform(Transform):
@@ -86,7 +86,7 @@
         source quadrilateral.
     """

-    method = Image.QUAD
+    method = Image.Transform.QUAD


 class MeshTransform(Transform):
@@ -99,4 +99,4 @@
     :param data: A list of (bbox, quad) tuples.
     """

-    method = Image.MESH
+    method = Image.Transform.MESH
('src/PIL', 'IcnsImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,22 +6,21 @@
 #
 # history:
 # 2004-10-09 fl   Turned into a PIL plugin; removed 2.3 dependencies.
+# 2020-04-04      Allow saving on all operating systems.
 #
 # Copyright (c) 2004 by Bob Ippolito.
 # Copyright (c) 2004 by Secret Labs.
 # Copyright (c) 2004 by Fredrik Lundh.
 # Copyright (c) 2014 by Alastair Houghton.
+# Copyright (c) 2020 by Pan Jing.
 #
 # See the README file for information on usage and redistribution.
 #

 import io
 import os
-import shutil
 import struct
-import subprocess
 import sys
-import tempfile

 from PIL import Image, ImageFile, PngImagePlugin, features

@@ -29,6 +28,7 @@
 if enable_jpeg2k:
     from PIL import Jpeg2KImagePlugin

+MAGIC = b"icns"
 HEADERSIZE = 8


@@ -105,6 +105,7 @@
     if sig[:8] == b"\x89PNG\x0d\x0a\x1a\x0a":
         fobj.seek(start)
         im = PngImagePlugin.PngImageFile(fobj)
+        Image._decompression_bomb_check(im.size)
         return {"RGBA": im}
     elif (
         sig[:4] == b"\xff\x4f\xff\x51"
@@ -121,6 +122,7 @@
         jp2kstream = fobj.read(length)
         f = io.BytesIO(jp2kstream)
         im = Jpeg2KImagePlugin.Jpeg2KImageFile(f)
+        Image._decompression_bomb_check(im.size)
         if im.mode != "RGBA":
             im = im.convert("RGBA")
         return {"RGBA": im}
@@ -165,7 +167,7 @@
         self.dct = dct = {}
         self.fobj = fobj
         sig, filesize = nextheader(fobj)
-        if sig != b"icns":
+        if not _accept(sig):
             raise SyntaxError("not an icns file")
         i = HEADERSIZE
         while i < filesize:
@@ -284,92 +286,99 @@
                 self.best_size[1] * self.best_size[2],
             )

-        Image.Image.load(self)
-        if self.im and self.im.size == self.size:
+        px = Image.Image.load(self)
+        if self.im is not None and self.im.size == self.size:
             # Already loaded
-            return
+            return px
         self.load_prepare()
         # This is likely NOT the best way to do it, but whatever.
         im = self.icns.getimage(self.best_size)

         # If this is a PNG or JPEG 2000, it won't be loaded yet
-        im.load()
+        px = im.load()

         self.im = im.im
         self.mode = im.mode
         self.size = im.size
-        self.load_end()
+
+        return px


 def _save(im, fp, filename):
     """
     Saves the image as a series of PNG files,
-    that are then converted to a .icns file
-    using the macOS command line utility 'iconutil'.
-
-    macOS only.
+    that are then combined into a .icns file.
     """
     if hasattr(fp, "flush"):
         fp.flush()

-    # create the temporary set of pngs
-    with tempfile.TemporaryDirectory(".iconset") as iconset:
-        provided_images = {
-            im.width: im for im in im.encoderinfo.get("append_images", [])
-        }
-        last_w = None
-        second_path = None
-        for w in [16, 32, 128, 256, 512]:
-            prefix = f"icon_{w}x{w}"
-
-            first_path = os.path.join(iconset, prefix + ".png")
-            if last_w == w:
-                shutil.copyfile(second_path, first_path)
-            else:
-                im_w = provided_images.get(w, im.resize((w, w), Image.LANCZOS))
-                im_w.save(first_path)
-
-            second_path = os.path.join(iconset, prefix + "@2x.png")
-            im_w2 = provided_images.get(w * 2, im.resize((w * 2, w * 2), Image.LANCZOS))
-            im_w2.save(second_path)
-            last_w = w * 2
-
-        # iconutil -c icns -o {} {}
-
-        fp_only = not filename
-        if fp_only:
-            f, filename = tempfile.mkstemp(".icns")
-            os.close(f)
-        convert_cmd = ["iconutil", "-c", "icns", "-o", filename, iconset]
-        convert_proc = subprocess.Popen(
-            convert_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL
+    sizes = {
+        b"ic07": 128,
+        b"ic08": 256,
+        b"ic09": 512,
+        b"ic10": 1024,
+        b"ic11": 32,
+        b"ic12": 64,
+        b"ic13": 256,
+        b"ic14": 512,
+    }
+    provided_images = {im.width: im for im in im.encoderinfo.get("append_images", [])}
+    size_streams = {}
+    for size in set(sizes.values()):
+        image = (
+            provided_images[size]
+            if size in provided_images
+            else im.resize((size, size))
         )

-        convert_proc.stdout.close()
-
-        retcode = convert_proc.wait()
-
-        if retcode:
-            raise subprocess.CalledProcessError(retcode, convert_cmd)
-
-        if fp_only:
-            with open(filename, "rb") as f:
-                fp.write(f.read())
-
-
-Image.register_open(IcnsImageFile.format, IcnsImageFile, lambda x: x[:4] == b"icns")
+        temp = io.BytesIO()
+        image.save(temp, "png")
+        size_streams[size] = temp.getvalue()
+
+    entries = []
+    for type, size in sizes.items():
+        stream = size_streams[size]
+        entries.append(
+            {"type": type, "size": HEADERSIZE + len(stream), "stream": stream}
+        )
+
+    # Header
+    fp.write(MAGIC)
+    file_length = HEADERSIZE  # Header
+    file_length += HEADERSIZE + 8 * len(entries)  # TOC
+    file_length += sum(entry["size"] for entry in entries)
+    fp.write(struct.pack(">i", file_length))
+
+    # TOC
+    fp.write(b"TOC ")
+    fp.write(struct.pack(">i", HEADERSIZE + len(entries) * HEADERSIZE))
+    for entry in entries:
+        fp.write(entry["type"])
+        fp.write(struct.pack(">i", entry["size"]))
+
+    # Data
+    for entry in entries:
+        fp.write(entry["type"])
+        fp.write(struct.pack(">i", entry["size"]))
+        fp.write(entry["stream"])
+
+    if hasattr(fp, "flush"):
+        fp.flush()
+
+
+def _accept(prefix):
+    return prefix[:4] == MAGIC
+
+
+Image.register_open(IcnsImageFile.format, IcnsImageFile, _accept)
 Image.register_extension(IcnsImageFile.format, ".icns")

-if sys.platform == "darwin":
-    Image.register_save(IcnsImageFile.format, _save)
-
-    Image.register_mime(IcnsImageFile.format, "image/icns")
-
+Image.register_save(IcnsImageFile.format, _save)
+Image.register_mime(IcnsImageFile.format, "image/icns")

 if __name__ == "__main__":
-
     if len(sys.argv) < 2:
-        print("Syntax: python IcnsImagePlugin.py [file]")
+        print("Syntax: python3 IcnsImagePlugin.py [file]")
         sys.exit()

     with open(sys.argv[1], "rb") as fp:
('src/PIL', 'DdsImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,6 +14,7 @@
 from io import BytesIO

 from . import Image, ImageFile
+from ._binary import o32le as o32

 # Magic ("DDS ")
 DDS_MAGIC = 0x20534444
@@ -97,6 +98,9 @@
 DXGI_FORMAT_R8G8B8A8_TYPELESS = 27
 DXGI_FORMAT_R8G8B8A8_UNORM = 28
 DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29
+DXGI_FORMAT_BC5_TYPELESS = 82
+DXGI_FORMAT_BC5_UNORM = 83
+DXGI_FORMAT_BC5_SNORM = 84
 DXGI_FORMAT_BC7_TYPELESS = 97
 DXGI_FORMAT_BC7_UNORM = 98
 DXGI_FORMAT_BC7_UNORM_SRGB = 99
@@ -107,7 +111,9 @@
     format_description = "DirectDraw Surface"

     def _open(self):
-        magic, header_size = struct.unpack("<II", self.fp.read(8))
+        if not _accept(self.fp.read(4)):
+            raise SyntaxError("not a DDS file")
+        (header_size,) = struct.unpack("<I", self.fp.read(4))
         if header_size != 124:
             raise OSError(f"Unsupported header size {repr(header_size)}")
         header_bytes = self.fp.read(header_size - 4)
@@ -127,15 +133,17 @@
         fourcc = header.read(4)
         (bitcount,) = struct.unpack("<I", header.read(4))
         masks = struct.unpack("<4I", header.read(16))
-        if pfflags & 0x40:
-            # DDPF_RGB - Texture contains uncompressed RGB data
+        if pfflags & DDPF_RGB:
+            # Texture contains uncompressed RGB data
             masks = {mask: ["R", "G", "B", "A"][i] for i, mask in enumerate(masks)}
             rawmode = ""
             if bitcount == 32:
                 rawmode += masks[0xFF000000]
+            else:
+                self.mode = "RGB"
             rawmode += masks[0xFF0000] + masks[0xFF00] + masks[0xFF]

-            self.tile = [("raw", (0, 0) + self.size, 0, (rawmode, 0, 1))]
+            self.tile = [("raw", (0, 0) + self.size, 0, (rawmode[::-1], 0, 1))]
         else:
             data_start = header_size + 4
             n = 0
@@ -148,12 +156,24 @@
             elif fourcc == b"DXT5":
                 self.pixel_format = "DXT5"
                 n = 3
+            elif fourcc == b"BC5S":
+                self.pixel_format = "BC5S"
+                n = 5
+                self.mode = "RGB"
             elif fourcc == b"DX10":
                 data_start += 20
                 # ignoring flags which pertain to volume textures and cubemaps
-                dxt10 = BytesIO(self.fp.read(20))
-                dxgi_format, dimension = struct.unpack("<II", dxt10.read(8))
-                if dxgi_format in (DXGI_FORMAT_BC7_TYPELESS, DXGI_FORMAT_BC7_UNORM):
+                (dxgi_format,) = struct.unpack("<I", self.fp.read(4))
+                self.fp.read(16)
+                if dxgi_format in (DXGI_FORMAT_BC5_TYPELESS, DXGI_FORMAT_BC5_UNORM):
+                    self.pixel_format = "BC5"
+                    n = 5
+                    self.mode = "RGB"
+                elif dxgi_format == DXGI_FORMAT_BC5_SNORM:
+                    self.pixel_format = "BC5S"
+                    n = 5
+                    self.mode = "RGB"
+                elif dxgi_format in (DXGI_FORMAT_BC7_TYPELESS, DXGI_FORMAT_BC7_UNORM):
                     self.pixel_format = "BC7"
                     n = 7
                 elif dxgi_format == DXGI_FORMAT_BC7_UNORM_SRGB:
@@ -176,15 +196,54 @@
             else:
                 raise NotImplementedError(f"Unimplemented pixel format {repr(fourcc)}")

-            self.tile = [("bcn", (0, 0) + self.size, data_start, (n))]
+            self.tile = [
+                ("bcn", (0, 0) + self.size, data_start, (n, self.pixel_format))
+            ]

     def load_seek(self, pos):
         pass


-def _validate(prefix):
+def _save(im, fp, filename):
+    if im.mode not in ("RGB", "RGBA"):
+        raise OSError(f"cannot write mode {im.mode} as DDS")
+
+    fp.write(
+        o32(DDS_MAGIC)
+        + o32(124)  # header size
+        + o32(
+            DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | DDSD_PIXELFORMAT
+        )  # flags
+        + o32(im.height)
+        + o32(im.width)
+        + o32((im.width * (32 if im.mode == "RGBA" else 24) + 7) // 8)  # pitch
+        + o32(0)  # depth
+        + o32(0)  # mipmaps
+        + o32(0) * 11  # reserved
+        + o32(32)  # pfsize
+        + o32(DDS_RGBA if im.mode == "RGBA" else DDPF_RGB)  # pfflags
+        + o32(0)  # fourcc
+        + o32(32 if im.mode == "RGBA" else 24)  # bitcount
+        + o32(0xFF0000)  # rbitmask
+        + o32(0xFF00)  # gbitmask
+        + o32(0xFF)  # bbitmask
+        + o32(0xFF000000 if im.mode == "RGBA" else 0)  # abitmask
+        + o32(DDSCAPS_TEXTURE)  # dwCaps
+        + o32(0)  # dwCaps2
+        + o32(0)  # dwCaps3
+        + o32(0)  # dwCaps4
+        + o32(0)  # dwReserved2
+    )
+    if im.mode == "RGBA":
+        r, g, b, a = im.split()
+        im = Image.merge("RGBA", (a, r, g, b))
+    ImageFile._save(im, fp, [("raw", (0, 0) + im.size, 0, (im.mode[::-1], 0, 1))])
+
+
+def _accept(prefix):
     return prefix[:4] == b"DDS "


-Image.register_open(DdsImageFile.format, DdsImageFile, _validate)
+Image.register_open(DdsImageFile.format, DdsImageFile, _accept)
+Image.register_save(DdsImageFile.format, _save)
 Image.register_extension(DdsImageFile.format, ".dds")
('src/PIL', 'PyAccess.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -54,6 +54,7 @@
         self.image32 = ffi.cast("int **", vals["image32"])
         self.image = ffi.cast("unsigned char **", vals["image"])
         self.xsize, self.ysize = img.im.size
+        self._img = img

         # Keep pointer to im object to prevent dereferencing.
         self._im = img.im
@@ -93,7 +94,7 @@
             and len(color) in [3, 4]
         ):
             # RGB or RGBA value for a P image
-            color = self._palette.getcolor(color)
+            color = self._palette.getcolor(color, self._img)

         return self.set_pixel(x, y, color)

@@ -127,7 +128,7 @@


 class _PyAccess32_2(PyAccess):
-    """ PA, LA, stored in first and last bytes of a 32 bit word """
+    """PA, LA, stored in first and last bytes of a 32 bit word"""

     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)
@@ -144,7 +145,7 @@


 class _PyAccess32_3(PyAccess):
-    """ RGB and friends, stored in the first three bytes of a 32 bit word """
+    """RGB and friends, stored in the first three bytes of a 32 bit word"""

     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)
@@ -163,7 +164,7 @@


 class _PyAccess32_4(PyAccess):
-    """ RGBA etc, all 4 bytes of a 32 bit word """
+    """RGBA etc, all 4 bytes of a 32 bit word"""

     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)
@@ -182,7 +183,7 @@


 class _PyAccess8(PyAccess):
-    """ 1, L, P, 8 bit images stored as uint8 """
+    """1, L, P, 8 bit images stored as uint8"""

     def _post_init(self, *args, **kwargs):
         self.pixels = self.image8
@@ -200,7 +201,7 @@


 class _PyAccessI16_N(PyAccess):
-    """ I;16 access, native bitendian without conversion """
+    """I;16 access, native bitendian without conversion"""

     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("unsigned short **", self.image)
@@ -218,7 +219,7 @@


 class _PyAccessI16_L(PyAccess):
-    """ I;16L access, with conversion """
+    """I;16L access, with conversion"""

     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_I16 **", self.image)
@@ -239,7 +240,7 @@


 class _PyAccessI16_B(PyAccess):
-    """ I;16B access, with conversion """
+    """I;16B access, with conversion"""

     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_I16 **", self.image)
@@ -260,7 +261,7 @@


 class _PyAccessI32_N(PyAccess):
-    """ Signed Int32 access, native endian """
+    """Signed Int32 access, native endian"""

     def _post_init(self, *args, **kwargs):
         self.pixels = self.image32
@@ -273,7 +274,7 @@


 class _PyAccessI32_Swap(PyAccess):
-    """ I;32L/B access, with byteswapping conversion """
+    """I;32L/B access, with byteswapping conversion"""

     def _post_init(self, *args, **kwargs):
         self.pixels = self.image32
@@ -292,7 +293,7 @@


 class _PyAccessF(PyAccess):
-    """ 32 bit float access """
+    """32 bit float access"""

     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("float **", self.image32)
('src/PIL', '_binary.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -47,6 +47,16 @@
     return unpack_from("<h", c, o)[0]


+def si16be(c, o=0):
+    """
+    Converts a 2-bytes (16 bits) string to a signed integer, big endian.
+
+    :param c: string containing bytes to convert
+    :param o: offset of bytes to convert in string
+    """
+    return unpack_from(">h", c, o)[0]
+
+
 def i32le(c, o=0):
     """
     Converts a 4-bytes (32 bits) string to an unsigned integer.
('src/PIL', 'Image.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -31,43 +31,81 @@
 import math
 import numbers
 import os
+import re
 import struct
 import sys
 import tempfile
 import warnings
-import xml.etree.ElementTree
 from collections.abc import Callable, MutableMapping
+from enum import IntEnum
 from pathlib import Path

+try:
+    import defusedxml.ElementTree as ElementTree
+except ImportError:
+    ElementTree = None
+
 # VERSION was removed in Pillow 6.0.0.
-# PILLOW_VERSION is deprecated and will be removed in a future release.
+# PILLOW_VERSION was removed in Pillow 9.0.0.
 # Use __version__ instead.
-from . import (
-    ImageMode,
-    TiffTags,
-    UnidentifiedImageError,
-    __version__,
-    _plugins,
-    _raise_version_warning,
-)
-from ._binary import i32le
+from . import ImageMode, TiffTags, UnidentifiedImageError, __version__, _plugins
+from ._binary import i32le, o32be, o32le
 from ._util import deferred_error, isPath

-if sys.version_info >= (3, 7):
-
-    def __getattr__(name):
-        if name == "PILLOW_VERSION":
-            _raise_version_warning()
-            return __version__
-        raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
-
-
-else:
-
-    from . import PILLOW_VERSION
-
-    # Silence warning
-    assert PILLOW_VERSION
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    categories = {"NORMAL": 0, "SEQUENCE": 1, "CONTAINER": 2}
+    if name in categories:
+        warnings.warn(
+            "Image categories are " + deprecated + "Use is_animated instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return categories[name]
+    elif name in ("NEAREST", "NONE"):
+        warnings.warn(
+            name
+            + " is "
+            + deprecated
+            + "Use Resampling.NEAREST or Dither.NONE instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return 0
+    old_resampling = {
+        "LINEAR": "BILINEAR",
+        "CUBIC": "BICUBIC",
+        "ANTIALIAS": "LANCZOS",
+    }
+    if name in old_resampling:
+        warnings.warn(
+            name
+            + " is "
+            + deprecated
+            + "Use Resampling."
+            + old_resampling[name]
+            + " instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return Resampling[old_resampling[name]]
+    for enum in (Transpose, Transform, Resampling, Dither, Palette, Quantize):
+        if name in enum.__members__:
+            warnings.warn(
+                name
+                + " is "
+                + deprecated
+                + "Use "
+                + enum.__name__
+                + "."
+                + name
+                + " instead.",
+                DeprecationWarning,
+                stacklevel=2,
+            )
+            return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")


 logger = logging.getLogger(__name__)
@@ -143,54 +181,65 @@
 #
 # Constants

-NONE = 0
-
 # transpose
-FLIP_LEFT_RIGHT = 0
-FLIP_TOP_BOTTOM = 1
-ROTATE_90 = 2
-ROTATE_180 = 3
-ROTATE_270 = 4
-TRANSPOSE = 5
-TRANSVERSE = 6
+class Transpose(IntEnum):
+    FLIP_LEFT_RIGHT = 0
+    FLIP_TOP_BOTTOM = 1
+    ROTATE_90 = 2
+    ROTATE_180 = 3
+    ROTATE_270 = 4
+    TRANSPOSE = 5
+    TRANSVERSE = 6
+

 # transforms (also defined in Imaging.h)
-AFFINE = 0
-EXTENT = 1
-PERSPECTIVE = 2
-QUAD = 3
-MESH = 4
+class Transform(IntEnum):
+    AFFINE = 0
+    EXTENT = 1
+    PERSPECTIVE = 2
+    QUAD = 3
+    MESH = 4
+

 # resampling filters (also defined in Imaging.h)
-NEAREST = NONE = 0
-BOX = 4
-BILINEAR = LINEAR = 2
-HAMMING = 5
-BICUBIC = CUBIC = 3
-LANCZOS = ANTIALIAS = 1
-
-_filters_support = {BOX: 0.5, BILINEAR: 1.0, HAMMING: 1.0, BICUBIC: 2.0, LANCZOS: 3.0}
+class Resampling(IntEnum):
+    NEAREST = 0
+    BOX = 4
+    BILINEAR = 2
+    HAMMING = 5
+    BICUBIC = 3
+    LANCZOS = 1
+
+
+_filters_support = {
+    Resampling.BOX: 0.5,
+    Resampling.BILINEAR: 1.0,
+    Resampling.HAMMING: 1.0,
+    Resampling.BICUBIC: 2.0,
+    Resampling.LANCZOS: 3.0,
+}


 # dithers
-NEAREST = NONE = 0
-ORDERED = 1  # Not yet implemented
-RASTERIZE = 2  # Not yet implemented
-FLOYDSTEINBERG = 3  # default
+class Dither(IntEnum):
+    NONE = 0
+    ORDERED = 1  # Not yet implemented
+    RASTERIZE = 2  # Not yet implemented
+    FLOYDSTEINBERG = 3  # default
+

 # palettes/quantizers
-WEB = 0
-ADAPTIVE = 1
-
-MEDIANCUT = 0
-MAXCOVERAGE = 1
-FASTOCTREE = 2
-LIBIMAGEQUANT = 3
-
-# categories
-NORMAL = 0
-SEQUENCE = 1
-CONTAINER = 2
+class Palette(IntEnum):
+    WEB = 0
+    ADAPTIVE = 1
+
+
+class Quantize(IntEnum):
+    MEDIANCUT = 0
+    MAXCOVERAGE = 1
+    FASTOCTREE = 2
+    LIBIMAGEQUANT = 3
+

 if hasattr(core, "DEFAULT_STRATEGY"):
     DEFAULT_STRATEGY = core.DEFAULT_STRATEGY
@@ -213,74 +262,21 @@
 ENCODERS = {}

 # --------------------------------------------------------------------
-# Modes supported by this version
-
-_MODEINFO = {
-    # NOTE: this table will be removed in future versions.  use
-    # getmode* functions or ImageMode descriptors instead.
-    # official modes
-    "1": ("L", "L", ("1",)),
-    "L": ("L", "L", ("L",)),
-    "I": ("L", "I", ("I",)),
-    "F": ("L", "F", ("F",)),
-    "P": ("P", "L", ("P",)),
-    "RGB": ("RGB", "L", ("R", "G", "B")),
-    "RGBX": ("RGB", "L", ("R", "G", "B", "X")),
-    "RGBA": ("RGB", "L", ("R", "G", "B", "A")),
-    "CMYK": ("RGB", "L", ("C", "M", "Y", "K")),
-    "YCbCr": ("RGB", "L", ("Y", "Cb", "Cr")),
-    "LAB": ("RGB", "L", ("L", "A", "B")),
-    "HSV": ("RGB", "L", ("H", "S", "V")),
-    # Experimental modes include I;16, I;16L, I;16B, RGBa, BGR;15, and
-    # BGR;24.  Use these modes only if you know exactly what you're
-    # doing...
-}
-
-if sys.byteorder == "little":
-    _ENDIAN = "<"
-else:
-    _ENDIAN = ">"
-
-_MODE_CONV = {
-    # official modes
-    "1": ("|b1", None),  # Bits need to be extended to bytes
-    "L": ("|u1", None),
-    "LA": ("|u1", 2),
-    "I": (_ENDIAN + "i4", None),
-    "F": (_ENDIAN + "f4", None),
-    "P": ("|u1", None),
-    "RGB": ("|u1", 3),
-    "RGBX": ("|u1", 4),
-    "RGBA": ("|u1", 4),
-    "CMYK": ("|u1", 4),
-    "YCbCr": ("|u1", 3),
-    "LAB": ("|u1", 3),  # UNDONE - unsigned |u1i1i1
-    "HSV": ("|u1", 3),
-    # I;16 == I;16L, and I;32 == I;32L
-    "I;16": ("<u2", None),
-    "I;16B": (">u2", None),
-    "I;16L": ("<u2", None),
-    "I;16S": ("<i2", None),
-    "I;16BS": (">i2", None),
-    "I;16LS": ("<i2", None),
-    "I;32": ("<u4", None),
-    "I;32B": (">u4", None),
-    "I;32L": ("<u4", None),
-    "I;32S": ("<i4", None),
-    "I;32BS": (">i4", None),
-    "I;32LS": ("<i4", None),
-}
+# Modes
+
+_ENDIAN = "<" if sys.byteorder == "little" else ">"


 def _conv_type_shape(im):
-    typ, extra = _MODE_CONV[im.mode]
-    if extra is None:
-        return (im.size[1], im.size[0]), typ
-    else:
-        return (im.size[1], im.size[0], extra), typ
-
-
-MODES = sorted(_MODEINFO)
+    m = ImageMode.getmode(im.mode)
+    shape = (im.height, im.width)
+    extra = len(m.bands)
+    if extra != 1:
+        shape += (extra,)
+    return shape, m.typestr
+
+
+MODES = ["1", "CMYK", "F", "HSV", "I", "L", "LAB", "P", "RGB", "RGBA", "RGBX", "YCbCr"]

 # raw modes that may be memory mapped.  NOTE: if you change this, you
 # may have to modify the stride calculation in map.c too!
@@ -535,10 +531,21 @@
         self._size = (0, 0)
         self.palette = None
         self.info = {}
-        self.category = NORMAL
+        self._category = 0
         self.readonly = 0
         self.pyaccess = None
         self._exif = None
+
+    def __getattr__(self, name):
+        if name == "category":
+            warnings.warn(
+                "Image categories are deprecated and will be removed in Pillow 10 "
+                "(2023-07-01). Use is_animated instead.",
+                DeprecationWarning,
+                stacklevel=2,
+            )
+            return self._category
+        raise AttributeError(name)

     @property
     def width(self):
@@ -586,10 +593,10 @@
         This operation will destroy the image core and release its memory.
         The image data will be unusable afterward.

-        This function is only required to close images that have not
-        had their file read and closed by the
-        :py:meth:`~PIL.Image.Image.load` method. See
-        :ref:`file-handling` for more information.
+        This function is required to close images that have multiple frames or
+        have not had their file read and closed by the
+        :py:meth:`~PIL.Image.Image.load` method. See :ref:`file-handling` for
+        more information.
         """
         try:
             if hasattr(self, "_close__fp"):
@@ -648,8 +655,7 @@
             and self.mode == other.mode
             and self.size == other.size
             and self.info == other.info
-            and self.category == other.category
-            and self.readonly == other.readonly
+            and self._category == other._category
             and self.getpalette() == other.getpalette()
             and self.tobytes() == other.tobytes()
         )
@@ -664,6 +670,22 @@
             id(self),
         )

+    def _repr_pretty_(self, p, cycle):
+        """IPython plain text display support"""
+
+        # Same as __repr__ but without unpredicatable id(self),
+        # to keep Jupyter notebook `text/plain` output stable.
+        p.text(
+            "<%s.%s image mode=%s size=%dx%d>"
+            % (
+                self.__class__.__module__,
+                self.__class__.__name__,
+                self.mode,
+                self.size[0],
+                self.size[1],
+            )
+        )
+
     def _repr_png_(self):
         """iPython display hook support

@@ -676,9 +698,14 @@
             raise ValueError("Could not save to PNG for display") from e
         return b.getvalue()

-    @property
-    def __array_interface__(self):
+    class _ArrayData:
+        def __init__(self, new):
+            self.__array_interface__ = new
+
+    def __array__(self, dtype=None):
         # numpy array interface support
+        import numpy as np
+
         new = {}
         shape, typestr = _conv_type_shape(self)
         new["shape"] = shape
@@ -690,7 +717,8 @@
             new["data"] = self.tobytes("raw", "L")
         else:
             new["data"] = self.tobytes()
-        return new
+
+        return np.array(self._ArrayData(new), dtype)

     def __getstate__(self):
         return [self.info, self.mode, self.size, self.getpalette(), self.tobytes()]
@@ -732,6 +760,9 @@
             args = self.mode

         self.load()
+
+        if self.width == 0 or self.height == 0:
+            return b""

         # unpack data
         e = _getencoder(self.mode, encoder_name, args)
@@ -816,28 +847,24 @@
         :returns: An image access object.
         :rtype: :ref:`PixelAccess` or :py:class:`PIL.PyAccess`
         """
-        if self.im and self.palette and self.palette.dirty:
+        if self.im is not None and self.palette and self.palette.dirty:
             # realize palette
             mode, arr = self.palette.getdata()
-            if mode == "RGBA":
-                mode = "RGB"
-                self.info["transparency"] = arr[3::4]
-                arr = bytes(
-                    value for (index, value) in enumerate(arr) if index % 4 != 3
-                )
             self.im.putpalette(mode, arr)
             self.palette.dirty = 0
             self.palette.rawmode = None
-            if "transparency" in self.info:
+            if "transparency" in self.info and mode in ("LA", "PA"):
                 if isinstance(self.info["transparency"], int):
                     self.im.putpalettealpha(self.info["transparency"], 0)
                 else:
                     self.im.putpalettealphas(self.info["transparency"])
                 self.palette.mode = "RGBA"
             else:
-                self.palette.mode = "RGB"
-
-        if self.im:
+                palette_mode = "RGBA" if mode.startswith("RGBA") else "RGB"
+                self.palette.mode = palette_mode
+                self.palette.palette = self.im.getpalette(palette_mode, palette_mode)
+
+        if self.im is not None:
             if cffi and USE_CFFI_ACCESS:
                 if self.pyaccess:
                     return self.pyaccess
@@ -859,7 +886,9 @@
         """
         pass

-    def convert(self, mode=None, matrix=None, dither=None, palette=WEB, colors=256):
+    def convert(
+        self, mode=None, matrix=None, dither=None, palette=Palette.WEB, colors=256
+    ):
         """
         Returns a converted copy of this image. For the "P" mode, this
         method translates pixels through the palette.  If mode is
@@ -878,7 +907,7 @@
         The default method of converting a greyscale ("L") or "RGB"
         image into a bilevel (mode "1") image uses Floyd-Steinberg
         dither to approximate the original image luminosity levels. If
-        dither is :data:`NONE`, all values larger than 128 are set to 255 (white),
+        dither is ``None``, all values larger than 127 are set to 255 (white),
         all other values to 0 (black). To use other thresholds, use the
         :py:meth:`~PIL.Image.Image.point` method.

@@ -891,28 +920,31 @@
            should be 4- or 12-tuple containing floating point values.
         :param dither: Dithering method, used when converting from
            mode "RGB" to "P" or from "RGB" or "L" to "1".
-           Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
-           Note that this is not used when ``matrix`` is supplied.
+           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`
+           (default). Note that this is not used when ``matrix`` is supplied.
         :param palette: Palette to use when converting from mode "RGB"
-           to "P".  Available palettes are :data:`WEB` or :data:`ADAPTIVE`.
-        :param colors: Number of colors to use for the :data:`ADAPTIVE` palette.
-           Defaults to 256.
+           to "P".  Available palettes are :data:`Palette.WEB` or
+           :data:`Palette.ADAPTIVE`.
+        :param colors: Number of colors to use for the :data:`Palette.ADAPTIVE`
+           palette. Defaults to 256.
         :rtype: :py:class:`~PIL.Image.Image`
         :returns: An :py:class:`~PIL.Image.Image` object.
         """

         self.load()

+        has_transparency = self.info.get("transparency") is not None
         if not mode and self.mode == "P":
             # determine default mode
             if self.palette:
                 mode = self.palette.mode
             else:
                 mode = "RGB"
+            if mode == "RGB" and has_transparency:
+                mode = "RGBA"
         if not mode or (mode == self.mode and not matrix):
             return self.copy()

-        has_transparency = self.info.get("transparency") is not None
         if matrix:
             # matrix conversion
             if mode not in ("L", "RGB"):
@@ -930,12 +962,8 @@
                     transparency = convert_transparency(matrix, transparency)
                 elif len(mode) == 3:
                     transparency = tuple(
-                        [
-                            convert_transparency(
-                                matrix[i * 4 : i * 4 + 4], transparency
-                            )
-                            for i in range(0, len(transparency))
-                        ]
+                        convert_transparency(matrix[i * 4 : i * 4 + 4], transparency)
+                        for i in range(0, len(transparency))
                     )
                 new.info["transparency"] = transparency
             return new
@@ -947,7 +975,9 @@
         delete_trns = False
         # transparency handling
         if has_transparency:
-            if self.mode in ("1", "L", "I", "RGB") and mode == "RGBA":
+            if (self.mode in ("1", "L", "I") and mode in ("LA", "RGBA")) or (
+                self.mode == "RGB" and mode == "RGBA"
+            ):
                 # Use transparent conversion to promote from transparent
                 # color to an alpha channel.
                 new_im = self._new(
@@ -971,23 +1001,30 @@
                     if self.mode == "P":
                         trns_im.putpalette(self.palette)
                         if isinstance(t, tuple):
+                            err = "Couldn't allocate a palette color for transparency"
                             try:
-                                t = trns_im.palette.getcolor(t)
-                            except Exception as e:
-                                raise ValueError(
-                                    "Couldn't allocate a palette color for transparency"
-                                ) from e
-                    trns_im.putpixel((0, 0), t)
-
-                    if mode in ("L", "RGB"):
-                        trns_im = trns_im.convert(mode)
+                                t = trns_im.palette.getcolor(t, self)
+                            except ValueError as e:
+                                if str(e) == "cannot allocate more than 256 colors":
+                                    # If all 256 colors are in use,
+                                    # then there is no need for transparency
+                                    t = None
+                                else:
+                                    raise ValueError(err) from e
+                    if t is None:
+                        trns = None
                     else:
-                        # can't just retrieve the palette number, got to do it
-                        # after quantization.
-                        trns_im = trns_im.convert("RGB")
-                    trns = trns_im.getpixel((0, 0))
-
-            elif self.mode == "P" and mode == "RGBA":
+                        trns_im.putpixel((0, 0), t)
+
+                        if mode in ("L", "RGB"):
+                            trns_im = trns_im.convert(mode)
+                        else:
+                            # can't just retrieve the palette number, got to do it
+                            # after quantization.
+                            trns_im = trns_im.convert("RGB")
+                        trns = trns_im.getpixel((0, 0))
+
+            elif self.mode == "P" and mode in ("LA", "PA", "RGBA"):
                 t = self.info["transparency"]
                 delete_trns = True

@@ -998,19 +1035,19 @@
                 else:
                     raise ValueError("Transparency for P mode should be bytes or int")

-        if mode == "P" and palette == ADAPTIVE:
+        if mode == "P" and palette == Palette.ADAPTIVE:
             im = self.im.quantize(colors)
             new = self._new(im)
             from . import ImagePalette

-            new.palette = ImagePalette.raw("RGB", new.im.getpalette("RGB"))
+            new.palette = ImagePalette.ImagePalette("RGB", new.im.getpalette("RGB"))
             if delete_trns:
                 # This could possibly happen if we requantize to fewer colors.
                 # The transparency would be totally off in that case.
                 del new.info["transparency"]
             if trns is not None:
                 try:
-                    new.info["transparency"] = new.palette.getcolor(trns)
+                    new.info["transparency"] = new.palette.getcolor(trns, new)
                 except Exception:
                     # if we can't make a transparent color, don't leave the old
                     # transparency hanging around to mess us up.
@@ -1020,7 +1057,7 @@

         # colorspace conversion
         if dither is None:
-            dither = FLOYDSTEINBERG
+            dither = Dither.FLOYDSTEINBERG

         try:
             im = self.im.convert(mode, dither)
@@ -1033,39 +1070,61 @@
                 raise ValueError("illegal conversion") from e

         new_im = self._new(im)
+        if mode == "P" and palette != Palette.ADAPTIVE:
+            from . import ImagePalette
+
+            new_im.palette = ImagePalette.ImagePalette("RGB", list(range(256)) * 3)
         if delete_trns:
             # crash fail if we leave a bytes transparency in an rgb/l mode.
             del new_im.info["transparency"]
         if trns is not None:
             if new_im.mode == "P":
                 try:
-                    new_im.info["transparency"] = new_im.palette.getcolor(trns)
-                except Exception:
+                    new_im.info["transparency"] = new_im.palette.getcolor(trns, new_im)
+                except ValueError as e:
                     del new_im.info["transparency"]
-                    warnings.warn("Couldn't allocate palette entry for transparency")
+                    if str(e) != "cannot allocate more than 256 colors":
+                        # If all 256 colors are in use,
+                        # then there is no need for transparency
+                        warnings.warn(
+                            "Couldn't allocate palette entry for transparency"
+                        )
             else:
                 new_im.info["transparency"] = trns
         return new_im

-    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1):
+    def quantize(
+        self,
+        colors=256,
+        method=None,
+        kmeans=0,
+        palette=None,
+        dither=Dither.FLOYDSTEINBERG,
+    ):
         """
         Convert the image to 'P' mode with the specified number
         of colors.

         :param colors: The desired number of colors, <= 256
-        :param method: :data:`MEDIANCUT` (median cut),
-                       :data:`MAXCOVERAGE` (maximum coverage),
-                       :data:`FASTOCTREE` (fast octree),
-                       :data:`LIBIMAGEQUANT` (libimagequant; check support using
-                       :py:func:`PIL.features.check_feature`
-                       with ``feature="libimagequant"``).
+        :param method: :data:`Quantize.MEDIANCUT` (median cut),
+                       :data:`Quantize.MAXCOVERAGE` (maximum coverage),
+                       :data:`Quantize.FASTOCTREE` (fast octree),
+                       :data:`Quantize.LIBIMAGEQUANT` (libimagequant; check support
+                       using :py:func:`PIL.features.check_feature` with
+                       ``feature="libimagequant"``).
+
+                       By default, :data:`Quantize.MEDIANCUT` will be used.
+
+                       The exception to this is RGBA images. :data:`Quantize.MEDIANCUT`
+                       and :data:`Quantize.MAXCOVERAGE` do not support RGBA images, so
+                       :data:`Quantize.FASTOCTREE` is used by default instead.
         :param kmeans: Integer
         :param palette: Quantize to the palette of given
                         :py:class:`PIL.Image.Image`.
         :param dither: Dithering method, used when converting from
            mode "RGB" to "P" or from "RGB" or "L" to "1".
-           Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
-           Default: 1 (legacy setting)
+           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`
+           (default).
         :returns: A new image

         """
@@ -1074,11 +1133,14 @@

         if method is None:
             # defaults:
-            method = 0
+            method = Quantize.MEDIANCUT
             if self.mode == "RGBA":
-                method = 2
-
-        if self.mode == "RGBA" and method not in (2, 3):
+                method = Quantize.FASTOCTREE
+
+        if self.mode == "RGBA" and method not in (
+            Quantize.FASTOCTREE,
+            Quantize.LIBIMAGEQUANT,
+        ):
             # Caller specified an invalid mode.
             raise ValueError(
                 "Fast Octree (method == 2) and libimagequant (method == 3) "
@@ -1095,14 +1157,17 @@
                     "only RGB or L mode images can be quantized to a palette"
                 )
             im = self.im.convert("P", dither, palette.im)
-            return self._new(im)
+            new_im = self._new(im)
+            new_im.palette = palette.palette.copy()
+            return new_im

         im = self._new(self.im.quantize(colors, method, kmeans))

         from . import ImagePalette

         mode = im.im.getpalettemode()
-        im.palette = ImagePalette.ImagePalette(mode, im.im.getpalette(mode, mode))
+        palette = im.im.getpalette(mode, mode)[: colors * len(mode)]
+        im.palette = ImagePalette.ImagePalette(mode, palette)

         return im

@@ -1134,6 +1199,11 @@

         if box is None:
             return self.copy()
+
+        if box[2] < box[0]:
+            raise ValueError("Coordinate 'right' is less than 'left'")
+        elif box[3] < box[1]:
+            raise ValueError("Coordinate 'lower' is less than 'upper'")

         self.load()
         return self._new(self._crop(self.im, box))
@@ -1242,6 +1312,10 @@
     def getcolors(self, maxcolors=256):
         """
         Returns a list of colors used in this image.
+
+        The colors will be in the image's mode. For example, an RGB image will
+        return a tuple of (red, green, blue) color values, and a P image will
+        return the index of the color in the palette.

         :param maxcolors: Maximum number of colors.  If this number is
            exceeded, this method returns None.  The default limit is
@@ -1302,30 +1376,61 @@
             return tuple(extrema)
         return self.im.getextrema()

+    def _getxmp(self, xmp_tags):
+        def get_name(tag):
+            return tag.split("}")[1]
+
+        def get_value(element):
+            value = {get_name(k): v for k, v in element.attrib.items()}
+            children = list(element)
+            if children:
+                for child in children:
+                    name = get_name(child.tag)
+                    child_value = get_value(child)
+                    if name in value:
+                        if not isinstance(value[name], list):
+                            value[name] = [value[name]]
+                        value[name].append(child_value)
+                    else:
+                        value[name] = child_value
+            elif value:
+                if element.text:
+                    value["text"] = element.text
+            else:
+                return element.text
+            return value
+
+        if ElementTree is None:
+            warnings.warn("XMP data cannot be read without defusedxml dependency")
+            return {}
+        else:
+            root = ElementTree.fromstring(xmp_tags)
+            return {get_name(root.tag): get_value(root)}
+
     def getexif(self):
         if self._exif is None:
             self._exif = Exif()

         exif_info = self.info.get("exif")
-        if exif_info is None and "Raw profile type exif" in self.info:
-            exif_info = bytes.fromhex(
-                "".join(self.info["Raw profile type exif"].split("\n")[3:])
-            )
-        self._exif.load(exif_info)
+        if exif_info is None:
+            if "Raw profile type exif" in self.info:
+                exif_info = bytes.fromhex(
+                    "".join(self.info["Raw profile type exif"].split("\n")[3:])
+                )
+            elif hasattr(self, "tag_v2"):
+                self._exif.bigtiff = self.tag_v2._bigtiff
+                self._exif.endian = self.tag_v2._endian
+                self._exif.load_from_fp(self.fp, self.tag_v2._offset)
+        if exif_info is not None:
+            self._exif.load(exif_info)

         # XMP tags
         if 0x0112 not in self._exif:
             xmp_tags = self.info.get("XML:com.adobe.xmp")
             if xmp_tags:
-                root = xml.etree.ElementTree.fromstring(xmp_tags)
-                for elem in root.iter():
-                    if elem.tag.endswith("}Description"):
-                        orientation = elem.attrib.get(
-                            "{http://ns.adobe.com/tiff/1.0/}Orientation"
-                        )
-                        if orientation:
-                            self._exif[0x0112] = int(orientation)
-                        break
+                match = re.search(r'tiff:Orientation="([0-9])"', xmp_tags)
+                if match:
+                    self._exif[0x0112] = int(match[1])

         return self._exif

@@ -1339,9 +1444,14 @@
         self.load()
         return self.im.ptr

-    def getpalette(self):
+    def getpalette(self, rawmode="RGB"):
         """
         Returns the image palette as a list.
+
+        :param rawmode: The mode in which to return the palette. ``None`` will
+           return the palette in its current mode.
+
+           .. versionadded:: 9.1.0

         :returns: A list of color values [r, g, b, ...], or None if the
            image has no palette.
@@ -1349,9 +1459,12 @@

         self.load()
         try:
-            return list(self.im.getpalette())
+            mode = self.im.getpalettemode()
         except ValueError:
             return None  # no palette
+        if rawmode is None:
+            rawmode = mode
+        return list(self.im.getpalette(mode, rawmode))

     def getpixel(self, xy):
         """
@@ -1382,11 +1495,12 @@

     def histogram(self, mask=None, extrema=None):
         """
-        Returns a histogram for the image. The histogram is returned as
-        a list of pixel counts, one for each pixel value in the source
-        image. If the image has more than one band, the histograms for
-        all bands are concatenated (for example, the histogram for an
-        "RGB" image contains 768 values).
+        Returns a histogram for the image. The histogram is returned as a
+        list of pixel counts, one for each pixel value in the source
+        image. Counts are grouped into 256 bins for each band, even if
+        the image has more than 8 bits per band. If the image has more
+        than one band, the histograms for all bands are concatenated (for
+        example, the histogram for an "RGB" image contains 768 values).

         A bilevel image (mode "1") is treated as a greyscale ("L") image
         by this method.
@@ -1454,8 +1568,8 @@
         also use color strings as supported by the ImageColor module.

         If a mask is given, this method updates only the regions
-        indicated by the mask.  You can use either "1", "L" or "RGBA"
-        images (in the latter case, the alpha band is used as mask).
+        indicated by the mask. You can use either "1", "L", "LA", "RGBA"
+        or "RGBa" images (if present, the alpha band is used as mask).
         Where the mask is 255, the given image is copied as is.  Where
         the mask is 0, the current value is preserved.  Intermediate
         values will mix the two images together, including their alpha
@@ -1503,7 +1617,7 @@
         elif isImageType(im):
             im.load()
             if self.mode != im.mode:
-                if self.mode != "RGB" or im.mode not in ("RGBA", "RGBa"):
+                if self.mode != "RGB" or im.mode not in ("LA", "RGBA", "RGBa"):
                     # should use an adapter for this!
                     im = im.convert(self.mode)
             im = im.im
@@ -1540,8 +1654,6 @@
             raise ValueError("Destination must be a 2-tuple")
         if min(source) < 0:
             raise ValueError("Source must be non-negative")
-        if min(dest) < 0:
-            raise ValueError("Destination must be non-negative")

         if len(source) == 2:
             source = source + im.size
@@ -1666,13 +1778,14 @@

     def putdata(self, data, scale=1.0, offset=0.0):
         """
-        Copies pixel data to this image.  This method copies data from a
-        sequence object into the image, starting at the upper left
-        corner (0, 0), and continuing until either the image or the
-        sequence ends.  The scale and offset values are used to adjust
-        the sequence values: **pixel = value*scale + offset**.
-
-        :param data: A sequence object.
+        Copies pixel data from a flattened sequence object into the image. The
+        values should start at the upper left corner (0, 0), continue to the
+        end of the line, followed directly by the first value of the second
+        line, and so on. Data will be read until either the image or the
+        sequence ends. The scale and offset values are used to adjust the
+        sequence values: **pixel = value*scale + offset**.
+
+        :param data: A flattened sequence object.
         :param scale: An optional scale value.  The default is 1.0.
         :param offset: An optional offset value.  The default is 0.0.
         """
@@ -1686,20 +1799,24 @@
         Attaches a palette to this image.  The image must be a "P", "PA", "L"
         or "LA" image.

-        The palette sequence must contain either 768 integer values, or 1024
-        integer values if alpha is included. Each group of values represents
-        the red, green, blue (and alpha if included) values for the
-        corresponding pixel index. Instead of an integer sequence, you can use
-        an 8-bit string.
+        The palette sequence must contain at most 256 colors, made up of one
+        integer value for each channel in the raw mode.
+        For example, if the raw mode is "RGB", then it can contain at most 768
+        values, made up of red, green and blue values for the corresponding pixel
+        index in the 256 colors.
+        If the raw mode is "RGBA", then it can contain at most 1024 values,
+        containing red, green, blue and alpha values.
+
+        Alternatively, an 8-bit string may be used instead of an integer sequence.

         :param data: A palette sequence (either a list or a string).
-        :param rawmode: The raw mode of the palette.
+        :param rawmode: The raw mode of the palette. Either "RGB", "RGBA", or a mode
+           that can be transformed to "RGB" or "RGBA" (e.g. "R", "BGR;15", "RGBA;L").
         """
         from . import ImagePalette

         if self.mode not in ("L", "LA", "P", "PA"):
             raise ValueError("illegal image mode")
-        self.load()
         if isinstance(data, ImagePalette.ImagePalette):
             palette = ImagePalette.raw(data.rawmode, data.palette)
         else:
@@ -1746,7 +1863,7 @@
             and len(value) in [3, 4]
         ):
             # RGB or RGBA value for a P image
-            value = self.palette.getcolor(value)
+            value = self.palette.getcolor(value, self)
         return self.im.putpixel(xy, value)

     def remap_palette(self, dest_map, source_palette=None):
@@ -1767,18 +1884,17 @@

         if source_palette is None:
             if self.mode == "P":
-                real_source_palette = self.im.getpalette("RGB")[:768]
+                self.load()
+                source_palette = self.im.getpalette("RGB")[:768]
             else:  # L-mode
-                real_source_palette = bytearray(i // 3 for i in range(768))
-        else:
-            real_source_palette = source_palette
+                source_palette = bytearray(i // 3 for i in range(768))

         palette_bytes = b""
         new_positions = [0] * 256

         # pick only the used colors from the palette
         for i, oldPosition in enumerate(dest_map):
-            palette_bytes += real_source_palette[oldPosition * 3 : oldPosition * 3 + 3]
+            palette_bytes += source_palette[oldPosition * 3 : oldPosition * 3 + 3]
             new_positions[oldPosition] = i

         # replace the palette color id of all pixel with the new id
@@ -1804,23 +1920,19 @@
         m_im = self.copy()
         m_im.mode = "P"

-        m_im.palette = ImagePalette.ImagePalette(
-            "RGB", palette=mapping_palette * 3, size=768
-        )
+        m_im.palette = ImagePalette.ImagePalette("RGB", palette=mapping_palette * 3)
         # possibly set palette dirty, then
         # m_im.putpalette(mapping_palette, 'L')  # converts to 'P'
         # or just force it.
         # UNDONE -- this is part of the general issue with palettes
-        m_im.im.putpalette(*m_im.palette.getdata())
+        m_im.im.putpalette("RGB;L", m_im.palette.tobytes())

         m_im = m_im.convert("L")

         # Internally, we require 768 bytes for a palette.
         new_palette_bytes = palette_bytes + (768 - len(palette_bytes)) * b"\x00"
         m_im.putpalette(new_palette_bytes)
-        m_im.palette = ImagePalette.ImagePalette(
-            "RGB", palette=palette_bytes, size=len(palette_bytes)
-        )
+        m_im.palette = ImagePalette.ImagePalette("RGB", palette=palette_bytes)

         return m_im

@@ -1841,20 +1953,25 @@
             min(self.size[1], math.ceil(box[3] + support_y)),
         )

-    def resize(self, size, resample=BICUBIC, box=None, reducing_gap=None):
+    def resize(self, size, resample=None, box=None, reducing_gap=None):
         """
         Returns a resized copy of this image.

         :param size: The requested size in pixels, as a 2-tuple:
            (width, height).
         :param resample: An optional resampling filter.  This can be
-           one of :py:data:`PIL.Image.NEAREST`, :py:data:`PIL.Image.BOX`,
-           :py:data:`PIL.Image.BILINEAR`, :py:data:`PIL.Image.HAMMING`,
-           :py:data:`PIL.Image.BICUBIC` or :py:data:`PIL.Image.LANCZOS`.
-           Default filter is :py:data:`PIL.Image.BICUBIC`.
-           If the image has mode "1" or "P", it is
-           always set to :py:data:`PIL.Image.NEAREST`.
-           See: :ref:`concept-filters`.
+           one of :py:data:`PIL.Image.Resampling.NEAREST`,
+           :py:data:`PIL.Image.Resampling.BOX`,
+           :py:data:`PIL.Image.Resampling.BILINEAR`,
+           :py:data:`PIL.Image.Resampling.HAMMING`,
+           :py:data:`PIL.Image.Resampling.BICUBIC` or
+           :py:data:`PIL.Image.Resampling.LANCZOS`.
+           If the image has mode "1" or "P", it is always set to
+           :py:data:`PIL.Image.Resampling.NEAREST`.
+           If the image mode specifies a number of bits, such as "I;16", then the
+           default filter is :py:data:`PIL.Image.Resampling.NEAREST`.
+           Otherwise, the default filter is
+           :py:data:`PIL.Image.Resampling.BICUBIC`. See: :ref:`concept-filters`.
         :param box: An optional 4-tuple of floats providing
            the source image region to be scaled.
            The values must be within (0, 0, width, height) rectangle.
@@ -1874,18 +1991,28 @@
         :returns: An :py:class:`~PIL.Image.Image` object.
         """

-        if resample not in (NEAREST, BILINEAR, BICUBIC, LANCZOS, BOX, HAMMING):
+        if resample is None:
+            type_special = ";" in self.mode
+            resample = Resampling.NEAREST if type_special else Resampling.BICUBIC
+        elif resample not in (
+            Resampling.NEAREST,
+            Resampling.BILINEAR,
+            Resampling.BICUBIC,
+            Resampling.LANCZOS,
+            Resampling.BOX,
+            Resampling.HAMMING,
+        ):
             message = f"Unknown resampling filter ({resample})."

             filters = [
-                "{} ({})".format(filter[1], filter[0])
+                f"{filter[1]} ({filter[0]})"
                 for filter in (
-                    (NEAREST, "Image.NEAREST"),
-                    (LANCZOS, "Image.LANCZOS"),
-                    (BILINEAR, "Image.BILINEAR"),
-                    (BICUBIC, "Image.BICUBIC"),
-                    (BOX, "Image.BOX"),
-                    (HAMMING, "Image.HAMMING"),
+                    (Resampling.NEAREST, "Image.Resampling.NEAREST"),
+                    (Resampling.LANCZOS, "Image.Resampling.LANCZOS"),
+                    (Resampling.BILINEAR, "Image.Resampling.BILINEAR"),
+                    (Resampling.BICUBIC, "Image.Resampling.BICUBIC"),
+                    (Resampling.BOX, "Image.Resampling.BOX"),
+                    (Resampling.HAMMING, "Image.Resampling.HAMMING"),
                 )
             ]
             raise ValueError(
@@ -1906,16 +2033,16 @@
             return self.copy()

         if self.mode in ("1", "P"):
-            resample = NEAREST
-
-        if self.mode in ["LA", "RGBA"]:
-            im = self.convert(self.mode[:-1] + "a")
+            resample = Resampling.NEAREST
+
+        if self.mode in ["LA", "RGBA"] and resample != Resampling.NEAREST:
+            im = self.convert({"LA": "La", "RGBA": "RGBa"}[self.mode])
             im = im.resize(size, resample, box)
             return im.convert(self.mode)

         self.load()

-        if reducing_gap is not None and resample != NEAREST:
+        if reducing_gap is not None and resample != Resampling.NEAREST:
             factor_x = int((box[2] - box[0]) / size[0] / reducing_gap) or 1
             factor_y = int((box[3] - box[1]) / size[1] / reducing_gap) or 1
             if factor_x > 1 or factor_y > 1:
@@ -1959,7 +2086,7 @@
             return self.copy()

         if self.mode in ["LA", "RGBA"]:
-            im = self.convert(self.mode[:-1] + "a")
+            im = self.convert({"LA": "La", "RGBA": "RGBa"}[self.mode])
             im = im.reduce(factor, box)
             return im.convert(self.mode)

@@ -1970,7 +2097,7 @@
     def rotate(
         self,
         angle,
-        resample=NEAREST,
+        resample=Resampling.NEAREST,
         expand=0,
         center=None,
         translate=None,
@@ -1983,12 +2110,12 @@

         :param angle: In degrees counter clockwise.
         :param resample: An optional resampling filter.  This can be
-           one of :py:data:`PIL.Image.NEAREST` (use nearest neighbour),
+           one of :py:data:`PIL.Image.Resampling.NEAREST` (use nearest neighbour),
            :py:data:`PIL.Image.BILINEAR` (linear interpolation in a 2x2
-           environment), or :py:data:`PIL.Image.BICUBIC`
+           environment), or :py:data:`PIL.Image.Resampling.BICUBIC`
            (cubic spline interpolation in a 4x4 environment).
            If omitted, or if the image has mode "1" or "P", it is
-           set to :py:data:`PIL.Image.NEAREST`. See :ref:`concept-filters`.
+           set to :py:data:`PIL.Image.Resampling.NEAREST`. See :ref:`concept-filters`.
         :param expand: Optional expansion flag.  If true, expands the output
            image to make it large enough to hold the entire rotated image.
            If false or omitted, make the output image the same size as the
@@ -2009,11 +2136,11 @@
             if angle == 0:
                 return self.copy()
             if angle == 180:
-                return self.transpose(ROTATE_180)
-            if angle == 90 and expand:
-                return self.transpose(ROTATE_90)
-            if angle == 270 and expand:
-                return self.transpose(ROTATE_270)
+                return self.transpose(Transpose.ROTATE_180)
+            if angle in (90, 270) and (expand or self.width == self.height):
+                return self.transpose(
+                    Transpose.ROTATE_90 if angle == 90 else Transpose.ROTATE_270
+                )

         # Calculate the affine matrix.  Note that this is the reverse
         # transformation (from destination image to source) because we
@@ -2082,7 +2209,9 @@
             matrix[2], matrix[5] = transform(-(nw - w) / 2.0, -(nh - h) / 2.0, matrix)
             w, h = nw, nh

-        return self.transform((w, h), AFFINE, matrix, resample, fillcolor=fillcolor)
+        return self.transform(
+            (w, h), Transform.AFFINE, matrix, resample, fillcolor=fillcolor
+        )

     def save(self, fp, format=None, **params):
         """
@@ -2116,12 +2245,17 @@

         filename = ""
         open_fp = False
-        if isPath(fp):
+        if isinstance(fp, Path):
+            filename = str(fp)
+            open_fp = True
+        elif isPath(fp):
             filename = fp
             open_fp = True
-        elif isinstance(fp, Path):
-            filename = str(fp)
-            open_fp = True
+        elif fp == sys.stdout:
+            try:
+                fp = sys.stdout.buffer
+            except AttributeError:
+                pass
         if not filename and hasattr(fp, "name") and isPath(fp.name):
             # only set the name for metadata purposes
             filename = fp.name
@@ -2152,7 +2286,9 @@
         else:
             save_handler = SAVE[format.upper()]

+        created = False
         if open_fp:
+            created = not os.path.exists(filename)
             if params.get("append", False):
                 # Open also for reading ("+"), because TIFF save_all
                 # writer needs to go back and edit the written data.
@@ -2162,10 +2298,17 @@

         try:
             save_handler(self, fp, filename)
-        finally:
-            # do what we can to clean up
+        except Exception:
             if open_fp:
                 fp.close()
+            if created:
+                try:
+                    os.remove(filename)
+                except PermissionError:
+                    pass
+            raise
+        if open_fp:
+            fp.close()

     def seek(self, frame):
         """
@@ -2188,7 +2331,7 @@
         if frame != 0:
             raise EOFError

-    def show(self, title=None, command=None):
+    def show(self, title=None):
         """
         Displays this image. This method is mainly intended for debugging purposes.

@@ -2208,14 +2351,7 @@
         :param title: Optional title to use for the image window, where possible.
         """

-        if command is not None:
-            warnings.warn(
-                "The command parameter is deprecated and will be removed in Pillow 9 "
-                "(2022-01-02). Use a subclass of ImageShow.Viewer instead.",
-                DeprecationWarning,
-            )
-
-        _show(self, title=title, command=command)
+        _show(self, title=title)

     def split(self):
         """
@@ -2270,7 +2406,7 @@
         """
         return 0

-    def thumbnail(self, size, resample=BICUBIC, reducing_gap=2.0):
+    def thumbnail(self, size, resample=Resampling.BICUBIC, reducing_gap=2.0):
         """
         Make this image into a thumbnail.  This method modifies the
         image to contain a thumbnail version of itself, no larger than
@@ -2286,11 +2422,14 @@

         :param size: Requested size.
         :param resample: Optional resampling filter.  This can be one
-           of :py:data:`PIL.Image.NEAREST`, :py:data:`PIL.Image.BOX`,
-           :py:data:`PIL.Image.BILINEAR`, :py:data:`PIL.Image.HAMMING`,
-           :py:data:`PIL.Image.BICUBIC` or :py:data:`PIL.Image.LANCZOS`.
-           If omitted, it defaults to :py:data:`PIL.Image.BICUBIC`.
-           (was :py:data:`PIL.Image.NEAREST` prior to version 2.5.0).
+           of :py:data:`PIL.Image.Resampling.NEAREST`,
+           :py:data:`PIL.Image.Resampling.BOX`,
+           :py:data:`PIL.Image.Resampling.BILINEAR`,
+           :py:data:`PIL.Image.Resampling.HAMMING`,
+           :py:data:`PIL.Image.Resampling.BICUBIC` or
+           :py:data:`PIL.Image.Resampling.LANCZOS`.
+           If omitted, it defaults to :py:data:`PIL.Image.Resampling.BICUBIC`.
+           (was :py:data:`PIL.Image.Resampling.NEAREST` prior to version 2.5.0).
            See: :ref:`concept-filters`.
         :param reducing_gap: Apply optimization by resizing the image
            in two steps. First, reducing the image by integer times
@@ -2345,7 +2484,13 @@
     # FIXME: the different transform methods need further explanation
     # instead of bloating the method docs, add a separate chapter.
     def transform(
-        self, size, method, data=None, resample=NEAREST, fill=1, fillcolor=None
+        self,
+        size,
+        method,
+        data=None,
+        resample=Resampling.NEAREST,
+        fill=1,
+        fillcolor=None,
     ):
         """
         Transforms this image.  This method creates a new image with the
@@ -2354,11 +2499,11 @@

         :param size: The output size.
         :param method: The transformation method.  This is one of
-          :py:data:`PIL.Image.EXTENT` (cut out a rectangular subregion),
-          :py:data:`PIL.Image.AFFINE` (affine transform),
-          :py:data:`PIL.Image.PERSPECTIVE` (perspective transform),
-          :py:data:`PIL.Image.QUAD` (map a quadrilateral to a rectangle), or
-          :py:data:`PIL.Image.MESH` (map a number of source quadrilaterals
+          :py:data:`PIL.Image.Transform.EXTENT` (cut out a rectangular subregion),
+          :py:data:`PIL.Image.Transform.AFFINE` (affine transform),
+          :py:data:`PIL.Image.Transform.PERSPECTIVE` (perspective transform),
+          :py:data:`PIL.Image.Transform.QUAD` (map a quadrilateral to a rectangle), or
+          :py:data:`PIL.Image.Transform.MESH` (map a number of source quadrilaterals
           in one operation).

           It may also be an :py:class:`~PIL.Image.ImageTransformHandler`
@@ -2373,16 +2518,16 @@

             class Example:
                 def getdata(self):
-                    method = Image.EXTENT
+                    method = Image.Transform.EXTENT
                     data = (0, 0, 100, 100)
                     return method, data
         :param data: Extra data to the transformation method.
         :param resample: Optional resampling filter.  It can be one of
-           :py:data:`PIL.Image.NEAREST` (use nearest neighbour),
-           :py:data:`PIL.Image.BILINEAR` (linear interpolation in a 2x2
+           :py:data:`PIL.Image.Resampling.NEAREST` (use nearest neighbour),
+           :py:data:`PIL.Image.Resampling.BILINEAR` (linear interpolation in a 2x2
            environment), or :py:data:`PIL.Image.BICUBIC` (cubic spline
            interpolation in a 4x4 environment). If omitted, or if the image
-           has mode "1" or "P", it is set to :py:data:`PIL.Image.NEAREST`.
+           has mode "1" or "P", it is set to :py:data:`PIL.Image.Resampling.NEAREST`.
            See: :ref:`concept-filters`.
         :param fill: If ``method`` is an
           :py:class:`~PIL.Image.ImageTransformHandler` object, this is one of
@@ -2392,18 +2537,11 @@
         :returns: An :py:class:`~PIL.Image.Image` object.
         """

-        if self.mode == "LA":
+        if self.mode in ("LA", "RGBA") and resample != Resampling.NEAREST:
             return (
-                self.convert("La")
+                self.convert({"LA": "La", "RGBA": "RGBa"}[self.mode])
                 .transform(size, method, data, resample, fill, fillcolor)
-                .convert("LA")
-            )
-
-        if self.mode == "RGBA":
-            return (
-                self.convert("RGBa")
-                .transform(size, method, data, resample, fill, fillcolor)
-                .convert("RGBA")
+                .convert(self.mode)
             )

         if isinstance(method, ImageTransformHandler):
@@ -2417,11 +2555,15 @@
             raise ValueError("missing method data")

         im = new(self.mode, size, fillcolor)
+        if self.mode == "P" and self.palette:
+            im.palette = self.palette.copy()
         im.info = self.info.copy()
-        if method == MESH:
+        if method == Transform.MESH:
             # list of quads
             for box, quad in data:
-                im.__transformer(box, self, QUAD, quad, resample, fillcolor is None)
+                im.__transformer(
+                    box, self, Transform.QUAD, quad, resample, fillcolor is None
+                )
         else:
             im.__transformer(
                 (0, 0) + size, self, method, data, resample, fillcolor is None
@@ -2429,25 +2571,27 @@

         return im

-    def __transformer(self, box, image, method, data, resample=NEAREST, fill=1):
+    def __transformer(
+        self, box, image, method, data, resample=Resampling.NEAREST, fill=1
+    ):
         w = box[2] - box[0]
         h = box[3] - box[1]

-        if method == AFFINE:
+        if method == Transform.AFFINE:
             data = data[0:6]

-        elif method == EXTENT:
+        elif method == Transform.EXTENT:
             # convert extent to an affine transform
             x0, y0, x1, y1 = data
             xs = (x1 - x0) / w
             ys = (y1 - y0) / h
-            method = AFFINE
+            method = Transform.AFFINE
             data = (xs, 0, x0, 0, ys, y0)

-        elif method == PERSPECTIVE:
+        elif method == Transform.PERSPECTIVE:
             data = data[0:8]

-        elif method == QUAD:
+        elif method == Transform.QUAD:
             # quadrilateral warp.  data specifies the four corners
             # given as NW, SW, SE, and NE.
             nw = data[0:2]
@@ -2471,22 +2615,26 @@
         else:
             raise ValueError("unknown transformation method")

-        if resample not in (NEAREST, BILINEAR, BICUBIC):
-            if resample in (BOX, HAMMING, LANCZOS):
+        if resample not in (
+            Resampling.NEAREST,
+            Resampling.BILINEAR,
+            Resampling.BICUBIC,
+        ):
+            if resample in (Resampling.BOX, Resampling.HAMMING, Resampling.LANCZOS):
                 message = {
-                    BOX: "Image.BOX",
-                    HAMMING: "Image.HAMMING",
-                    LANCZOS: "Image.LANCZOS/Image.ANTIALIAS",
+                    Resampling.BOX: "Image.Resampling.BOX",
+                    Resampling.HAMMING: "Image.Resampling.HAMMING",
+                    Resampling.LANCZOS: "Image.Resampling.LANCZOS",
                 }[resample] + f" ({resample}) cannot be used."
             else:
                 message = f"Unknown resampling filter ({resample})."

             filters = [
-                "{} ({})".format(filter[1], filter[0])
+                f"{filter[1]} ({filter[0]})"
                 for filter in (
-                    (NEAREST, "Image.NEAREST"),
-                    (BILINEAR, "Image.BILINEAR"),
-                    (BICUBIC, "Image.BICUBIC"),
+                    (Resampling.NEAREST, "Image.Resampling.NEAREST"),
+                    (Resampling.BILINEAR, "Image.Resampling.BILINEAR"),
+                    (Resampling.BICUBIC, "Image.Resampling.BICUBIC"),
                 )
             ]
             raise ValueError(
@@ -2498,7 +2646,7 @@
         self.load()

         if image.mode in ("1", "P"):
-            resample = NEAREST
+            resample = Resampling.NEAREST

         self.im.transform2(box, image.im, method, data, resample, fill)

@@ -2506,10 +2654,13 @@
         """
         Transpose image (flip or rotate in 90 degree steps)

-        :param method: One of :py:data:`PIL.Image.FLIP_LEFT_RIGHT`,
-          :py:data:`PIL.Image.FLIP_TOP_BOTTOM`, :py:data:`PIL.Image.ROTATE_90`,
-          :py:data:`PIL.Image.ROTATE_180`, :py:data:`PIL.Image.ROTATE_270`,
-          :py:data:`PIL.Image.TRANSPOSE` or :py:data:`PIL.Image.TRANSVERSE`.
+        :param method: One of :py:data:`PIL.Image.Transpose.FLIP_LEFT_RIGHT`,
+          :py:data:`PIL.Image.Transpose.FLIP_TOP_BOTTOM`,
+          :py:data:`PIL.Image.Transpose.ROTATE_90`,
+          :py:data:`PIL.Image.Transpose.ROTATE_180`,
+          :py:data:`PIL.Image.Transpose.ROTATE_270`,
+          :py:data:`PIL.Image.Transpose.TRANSPOSE` or
+          :py:data:`PIL.Image.Transpose.TRANSVERSE`.
         :returns: Returns a flipped or rotated copy of this image.
         """

@@ -2641,9 +2792,9 @@
     In its simplest form, this function takes three arguments
     (mode, size, and unpacked pixel data).

-    You can also use any pixel decoder supported by PIL.  For more
+    You can also use any pixel decoder supported by PIL. For more
     information on available decoders, see the section
-    :ref:`Writing Your Own File Decoder <file-decoders>`.
+    :ref:`Writing Your Own File Codec <file-codecs>`.

     Note that this function decodes pixel data only, not entire images.
     If you have an entire image in a string, wrap it in a
@@ -2737,7 +2888,7 @@

       from PIL import Image
       import numpy as np
-      im = Image.open('hopper.jpg')
+      im = Image.open("hopper.jpg")
       a = np.asarray(im)

     Then this can be used to convert it to a Pillow image::
@@ -2745,8 +2896,21 @@
       im = Image.fromarray(a)

     :param obj: Object with array interface
-    :param mode: Mode to use (will be determined from type if None)
-      See: :ref:`concept-modes`.
+    :param mode: Optional mode to use when reading ``obj``. Will be determined from
+      type if ``None``.
+
+      This will not be used to convert the data after reading, but will be used to
+      change how the data is read::
+
+        from PIL import Image
+        import numpy as np
+        a = np.full((1, 1), 300)
+        im = Image.fromarray(a, mode="L")
+        im.getpixel((0, 0))  # 44
+        im = Image.fromarray(a, mode="RGB")
+        im.getpixel((0, 0))  # (44, 1, 0)
+
+      See: :ref:`concept-modes` for general information about modes.
     :returns: An image object.

     .. versionadded:: 1.1.6
@@ -2869,7 +3033,7 @@
     :param formats: A list or tuple of formats to attempt to load the file in.
        This can be used to restrict the set of formats checked.
        Pass ``None`` to try all supported formats. You can print the set of
-       available formats by running ``python -m PIL`` or using
+       available formats by running ``python3 -m PIL`` or using
        the :py:func:`PIL.features.pilinfo` function.
     :returns: An :py:class:`~PIL.Image.Image` object.
     :exception FileNotFoundError: If the file cannot be found.
@@ -2918,6 +3082,7 @@

     def _open_core(fp, filename, prefix, formats):
         for i in formats:
+            i = i.upper()
             if i not in OPEN:
                 init()
             try:
@@ -2982,7 +3147,7 @@
 def blend(im1, im2, alpha):
     """
     Creates a new image by interpolating between two input images, using
-    a constant alpha.::
+    a constant alpha::

         out = image1 * (1.0 - alpha) + image2 * alpha

@@ -3178,22 +3343,9 @@


 def _show(image, **options):
-    options["_internal_pillow"] = True
-    _showxv(image, **options)
-
-
-def _showxv(image, title=None, **options):
     from . import ImageShow

-    if "_internal_pillow" in options:
-        del options["_internal_pillow"]
-    else:
-        warnings.warn(
-            "_showxv is deprecated and will be removed in Pillow 9 (2022-01-02). "
-            "Use Image.show instead.",
-            DeprecationWarning,
-        )
-    ImageShow.show(image, title, **options)
+    ImageShow.show(image, **options)


 # --------------------------------------------------------------------
@@ -3283,7 +3435,8 @@


 class Exif(MutableMapping):
-    endian = "<"
+    endian = None
+    bigtiff = False

     def __init__(self):
         self._data = {}
@@ -3304,11 +3457,11 @@
         # returns a dict with any single item tuples/lists as individual values
         return {k: self._fixup(v) for k, v in src_dict.items()}

-    def _get_ifd_dict(self, tag):
+    def _get_ifd_dict(self, offset):
         try:
             # an offset pointer to the location of the nested embedded IFD.
             # It should be a long, but may be corrupted.
-            self.fp.seek(self[tag])
+            self.fp.seek(offset)
         except (KeyError, TypeError):
             pass
         else:
@@ -3317,6 +3470,17 @@
             info = TiffImagePlugin.ImageFileDirectory_v2(self.head)
             info.load(self.fp)
             return self._fixup_dict(info)
+
+    def _get_head(self):
+        version = b"\x2B" if self.bigtiff else b"\x2A"
+        if self.endian == "<":
+            head = b"II" + version + b"\x00" + o32le(8)
+        else:
+            head = b"MM\x00" + version + o32be(8)
+        if self.bigtiff:
+            head += o32le(8) if self.endian == "<" else o32be(8)
+            head += b"\x00\x00\x00\x00"
+        return head

     def load(self, data):
         # Extract EXIF information.  This is highly experimental,
@@ -3330,12 +3494,12 @@
         self._loaded_exif = data
         self._data.clear()
         self._ifds.clear()
-        self._info = None
+        if data and data.startswith(b"Exif\x00\x00"):
+            data = data[6:]
         if not data:
+            self._info = None
             return

-        if data.startswith(b"Exif\x00\x00"):
-            data = data[6:]
         self.fp = io.BytesIO(data)
         self.head = self.fp.read(8)
         # process dictionary
@@ -3346,106 +3510,150 @@
         self.fp.seek(self._info.next)
         self._info.load(self.fp)

+    def load_from_fp(self, fp, offset=None):
+        self._loaded_exif = None
+        self._data.clear()
+        self._ifds.clear()
+
+        # process dictionary
+        from . import TiffImagePlugin
+
+        self.fp = fp
+        if offset is not None:
+            self.head = self._get_head()
+        else:
+            self.head = self.fp.read(8)
+        self._info = TiffImagePlugin.ImageFileDirectory_v2(self.head)
+        if self.endian is None:
+            self.endian = self._info._endian
+        if offset is None:
+            offset = self._info.next
+        self.fp.seek(offset)
+        self._info.load(self.fp)
+
+    def _get_merged_dict(self):
+        merged_dict = dict(self)
+
         # get EXIF extension
-        ifd = self._get_ifd_dict(0x8769)
-        if ifd:
-            self._data.update(ifd)
-            self._ifds[0x8769] = ifd
+        if 0x8769 in self:
+            ifd = self._get_ifd_dict(self[0x8769])
+            if ifd:
+                merged_dict.update(ifd)
+
+        # GPS
+        if 0x8825 in self:
+            merged_dict[0x8825] = self._get_ifd_dict(self[0x8825])
+
+        return merged_dict

     def tobytes(self, offset=8):
         from . import TiffImagePlugin

-        if self.endian == "<":
-            head = b"II\x2A\x00\x08\x00\x00\x00"
-        else:
-            head = b"MM\x00\x2A\x00\x00\x00\x08"
+        head = self._get_head()
         ifd = TiffImagePlugin.ImageFileDirectory_v2(ifh=head)
         for tag, value in self.items():
+            if tag in [0x8769, 0x8225, 0x8825] and not isinstance(value, dict):
+                value = self.get_ifd(tag)
+                if (
+                    tag == 0x8769
+                    and 0xA005 in value
+                    and not isinstance(value[0xA005], dict)
+                ):
+                    value = value.copy()
+                    value[0xA005] = self.get_ifd(0xA005)
             ifd[tag] = value
         return b"Exif\x00\x00" + head + ifd.tobytes(offset)

     def get_ifd(self, tag):
-        if tag not in self._ifds and tag in self:
-            if tag in [0x8825, 0xA005]:
-                # gpsinfo, interop
-                self._ifds[tag] = self._get_ifd_dict(tag)
-            elif tag == 0x927C:  # makernote
-                from .TiffImagePlugin import ImageFileDirectory_v2
-
-                if self[0x927C][:8] == b"FUJIFILM":
-                    exif_data = self[0x927C]
-                    ifd_offset = i32le(exif_data, 8)
-                    ifd_data = exif_data[ifd_offset:]
-
-                    makernote = {}
-                    for i in range(0, struct.unpack("<H", ifd_data[:2])[0]):
-                        ifd_tag, typ, count, data = struct.unpack(
-                            "<HHL4s", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]
-                        )
-                        try:
-                            unit_size, handler = ImageFileDirectory_v2._load_dispatch[
-                                typ
-                            ]
-                        except KeyError:
-                            continue
-                        size = count * unit_size
-                        if size > 4:
-                            (offset,) = struct.unpack("<L", data)
-                            data = ifd_data[offset - 12 : offset + size - 12]
-                        else:
-                            data = data[:size]
-
-                        if len(data) != size:
-                            warnings.warn(
-                                "Possibly corrupt EXIF MakerNote data.  "
-                                f"Expecting to read {size} bytes but only got "
-                                f"{len(data)}. Skipping tag {ifd_tag}"
+        if tag not in self._ifds:
+            if tag in [0x8769, 0x8825]:
+                # exif, gpsinfo
+                if tag in self:
+                    self._ifds[tag] = self._get_ifd_dict(self[tag])
+            elif tag in [0xA005, 0x927C]:
+                # interop, makernote
+                if 0x8769 not in self._ifds:
+                    self.get_ifd(0x8769)
+                tag_data = self._ifds[0x8769][tag]
+                if tag == 0x927C:
+                    # makernote
+                    from .TiffImagePlugin import ImageFileDirectory_v2
+
+                    if tag_data[:8] == b"FUJIFILM":
+                        ifd_offset = i32le(tag_data, 8)
+                        ifd_data = tag_data[ifd_offset:]
+
+                        makernote = {}
+                        for i in range(0, struct.unpack("<H", ifd_data[:2])[0]):
+                            ifd_tag, typ, count, data = struct.unpack(
+                                "<HHL4s", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]
                             )
-                            continue
-
-                        if not data:
-                            continue
-
-                        makernote[ifd_tag] = handler(
-                            ImageFileDirectory_v2(), data, False
-                        )
-                    self._ifds[0x927C] = dict(self._fixup_dict(makernote))
-                elif self.get(0x010F) == "Nintendo":
-                    ifd_data = self[0x927C]
-
-                    makernote = {}
-                    for i in range(0, struct.unpack(">H", ifd_data[:2])[0]):
-                        ifd_tag, typ, count, data = struct.unpack(
-                            ">HHL4s", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]
-                        )
-                        if ifd_tag == 0x1101:
-                            # CameraInfo
-                            (offset,) = struct.unpack(">L", data)
-                            self.fp.seek(offset)
-
-                            camerainfo = {"ModelID": self.fp.read(4)}
-
-                            self.fp.read(4)
-                            # Seconds since 2000
-                            camerainfo["TimeStamp"] = i32le(self.fp.read(12))
-
-                            self.fp.read(4)
-                            camerainfo["InternalSerialNumber"] = self.fp.read(4)
-
-                            self.fp.read(12)
-                            parallax = self.fp.read(4)
-                            handler = ImageFileDirectory_v2._load_dispatch[
-                                TiffTags.FLOAT
-                            ][1]
-                            camerainfo["Parallax"] = handler(
-                                ImageFileDirectory_v2(), parallax, False
+                            try:
+                                (
+                                    unit_size,
+                                    handler,
+                                ) = ImageFileDirectory_v2._load_dispatch[typ]
+                            except KeyError:
+                                continue
+                            size = count * unit_size
+                            if size > 4:
+                                (offset,) = struct.unpack("<L", data)
+                                data = ifd_data[offset - 12 : offset + size - 12]
+                            else:
+                                data = data[:size]
+
+                            if len(data) != size:
+                                warnings.warn(
+                                    "Possibly corrupt EXIF MakerNote data.  "
+                                    f"Expecting to read {size} bytes but only got "
+                                    f"{len(data)}. Skipping tag {ifd_tag}"
+                                )
+                                continue
+
+                            if not data:
+                                continue
+
+                            makernote[ifd_tag] = handler(
+                                ImageFileDirectory_v2(), data, False
                             )
-
-                            self.fp.read(4)
-                            camerainfo["Category"] = self.fp.read(2)
-
-                            makernote = {0x1101: dict(self._fixup_dict(camerainfo))}
-                    self._ifds[0x927C] = makernote
+                        self._ifds[tag] = dict(self._fixup_dict(makernote))
+                    elif self.get(0x010F) == "Nintendo":
+                        makernote = {}
+                        for i in range(0, struct.unpack(">H", tag_data[:2])[0]):
+                            ifd_tag, typ, count, data = struct.unpack(
+                                ">HHL4s", tag_data[i * 12 + 2 : (i + 1) * 12 + 2]
+                            )
+                            if ifd_tag == 0x1101:
+                                # CameraInfo
+                                (offset,) = struct.unpack(">L", data)
+                                self.fp.seek(offset)
+
+                                camerainfo = {"ModelID": self.fp.read(4)}
+
+                                self.fp.read(4)
+                                # Seconds since 2000
+                                camerainfo["TimeStamp"] = i32le(self.fp.read(12))
+
+                                self.fp.read(4)
+                                camerainfo["InternalSerialNumber"] = self.fp.read(4)
+
+                                self.fp.read(12)
+                                parallax = self.fp.read(4)
+                                handler = ImageFileDirectory_v2._load_dispatch[
+                                    TiffTags.FLOAT
+                                ][1]
+                                camerainfo["Parallax"] = handler(
+                                    ImageFileDirectory_v2(), parallax, False
+                                )
+
+                                self.fp.read(4)
+                                camerainfo["Category"] = self.fp.read(2)
+
+                                makernote = {0x1101: dict(self._fixup_dict(camerainfo))}
+                        self._ifds[tag] = makernote
+                else:
+                    # interop
+                    self._ifds[tag] = self._get_ifd_dict(tag_data)
         return self._ifds.get(tag, {})

     def __str__(self):
@@ -3465,8 +3673,6 @@
     def __getitem__(self, tag):
         if self._info is not None and tag not in self._data and tag in self._info:
             self._data[tag] = self._fixup(self._info[tag])
-            if tag == 0x8825:
-                self._data[tag] = self.get_ifd(tag)
             del self._info[tag]
         return self._data[tag]

('src/PIL', 'SgiImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -193,7 +193,8 @@
     for channel in im.split():
         fp.write(channel.tobytes("raw", rawmode, 0, orientation))

-    fp.close()
+    if hasattr(fp, "flush"):
+        fp.flush()


 class SGI16Decoder(ImageFile.PyDecoder):
('src/PIL', 'ImImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -100,7 +100,7 @@
 # --------------------------------------------------------------------
 # Read IM directory

-split = re.compile(br"^([A-Za-z][^:]*):[ \t]*(.*)[ \t]*$")
+split = re.compile(rb"^([A-Za-z][^:]*):[ \t]*(.*)[ \t]*$")


 def number(s):
('src/PIL', 'PsdImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -22,6 +22,7 @@
 from ._binary import i8
 from ._binary import i16be as i16
 from ._binary import i32be as i32
+from ._binary import si16be as si16

 MODES = {
     # (photoshop mode, bits) -> (pil mode, required channels)
@@ -119,7 +120,8 @@
             end = self.fp.tell() + size
             size = i32(read(4))
             if size:
-                self.layers = _layerinfo(self.fp)
+                _layer_data = io.BytesIO(ImageFile._safe_read(self.fp, size))
+                self.layers = _layerinfo(_layer_data, size)
             self.fp.seek(end)
         self.n_frames = len(self.layers)
         self.is_animated = self.n_frames > 1
@@ -153,14 +155,6 @@
         # return layer number (0=image, 1..max=layers)
         return self.frame

-    def load_prepare(self):
-        # create image memory if necessary
-        if not self.im or self.im.mode != self.mode or self.im.size != self.size:
-            self.im = Image.core.fill(self.mode, self.size, 0)
-        # create palette (optional)
-        if self.mode == "P":
-            Image.Image.load(self)
-
     def _close__fp(self):
         try:
             if self.__fp != self.fp:
@@ -171,11 +165,20 @@
             self.__fp = None


-def _layerinfo(file):
+def _layerinfo(fp, ct_bytes):
     # read layerinfo block
     layers = []
-    read = file.read
-    for i in range(abs(i16(read(2)))):
+
+    def read(size):
+        return ImageFile._safe_read(fp, size)
+
+    ct = si16(read(2))
+
+    # sanity check
+    if ct_bytes < (abs(ct) * 20):
+        raise SyntaxError("Layer block too short for number of layers requested")
+
+    for i in range(abs(ct)):

         # bounding box
         y0 = i32(read(4))
@@ -184,9 +187,9 @@
         x1 = i32(read(4))

         # image info
-        info = []
         mode = []
-        types = list(range(i16(read(2))))
+        ct_types = i16(read(2))
+        types = list(range(ct_types))
         if len(types) > 4:
             continue

@@ -199,8 +202,7 @@
                 m = "RGBA"[type]

             mode.append(m)
-            size = i32(read(4))
-            info.append((m, size))
+            read(4)  # size

         # figure out the image mode
         mode.sort()
@@ -217,28 +219,24 @@
         read(12)  # filler
         name = ""
         size = i32(read(4))  # length of the extra data field
-        combined = 0
         if size:
-            data_end = file.tell() + size
+            data_end = fp.tell() + size

             length = i32(read(4))
             if length:
-                file.seek(length - 16, io.SEEK_CUR)
-            combined += length + 4
+                fp.seek(length - 16, io.SEEK_CUR)

             length = i32(read(4))
             if length:
-                file.seek(length, io.SEEK_CUR)
-            combined += length + 4
+                fp.seek(length, io.SEEK_CUR)

             length = i8(read(1))
             if length:
                 # Don't know the proper encoding,
                 # Latin-1 should be a good guess
                 name = read(length).decode("latin-1", "replace")
-            combined += length + 1
-
-            file.seek(data_end)
+
+            fp.seek(data_end)
         layers.append((name, mode, (x0, y0, x1, y1)))

     # get tiles
@@ -246,7 +244,7 @@
     for name, mode, bbox in layers:
         tile = []
         for m in mode:
-            t = _maketile(file, m, bbox, 1)
+            t = _maketile(fp, m, bbox, 1)
             if t:
                 tile.extend(t)
         layers[i] = name, mode, bbox, tile
('src/PIL', 'JpegImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -33,6 +33,7 @@
 #
 import array
 import io
+import math
 import os
 import struct
 import subprocess
@@ -139,8 +140,8 @@
         self.info["adobe"] = i16(s, 5)
         # extract Adobe custom properties
         try:
-            adobe_transform = s[1]
-        except Exception:
+            adobe_transform = s[11]
+        except IndexError:
             pass
         else:
             self.info["adobe_transform"] = adobe_transform
@@ -161,15 +162,17 @@
                 dpi = float(x_resolution[0]) / x_resolution[1]
             except TypeError:
                 dpi = x_resolution
+            if math.isnan(dpi):
+                raise ValueError
             if resolution_unit == 3:  # cm
                 # 1 dpcm = 2.54 dpi
                 dpi *= 2.54
-            self.info["dpi"] = int(dpi + 0.5), int(dpi + 0.5)
-        except (KeyError, SyntaxError, ValueError, ZeroDivisionError):
+            self.info["dpi"] = dpi, dpi
+        except (TypeError, KeyError, SyntaxError, ValueError, ZeroDivisionError):
             # SyntaxError for invalid/unreadable EXIF
             # KeyError for dpi not included
             # ZeroDivisionError for invalid dpi rational value
-            # ValueError for x_resolution[0] being an invalid float
+            # ValueError or TypeError for dpi being an invalid float
             self.info["dpi"] = 72, 72


@@ -251,7 +254,7 @@
         data = array.array("B" if precision == 1 else "H", s[1:qt_length])
         if sys.byteorder == "little" and precision > 1:
             data.byteswap()  # the values are always big-endian
-        self.quantization[v & 15] = data
+        self.quantization[v & 15] = [data[i] for i in zigzag_index]
         s = s[qt_length:]


@@ -398,9 +401,10 @@
         """
         s = self.fp.read(read_bytes)

-        if not s and ImageFile.LOAD_TRUNCATED_IMAGES:
+        if not s and ImageFile.LOAD_TRUNCATED_IMAGES and not hasattr(self, "_ended"):
             # Premature EOF.
             # Pretend file is finished adding EOI marker
+            self._ended = True
             return b"\xFF\xD9"

         return s
@@ -474,11 +478,26 @@
     def _getmp(self):
         return _getmp(self)

+    def getxmp(self):
+        """
+        Returns a dictionary containing the XMP tags.
+        Requires defusedxml to be installed.
+
+        :returns: XMP tags in a dictionary.
+        """
+
+        for segment, content in self.applist:
+            if segment == "APP1":
+                marker, xmp_tags = content.rsplit(b"\x00", 1)
+                if marker == b"http://ns.adobe.com/xap/1.0/":
+                    return self._getxmp(xmp_tags)
+        return {}
+

 def _getexif(self):
     if "exif" not in self.info:
         return None
-    return dict(self.getexif())
+    return self.getexif()._get_merged_dict()


 def _getmp(self):
@@ -584,9 +603,11 @@


 def convert_dict_qtables(qtables):
-    qtables = [qtables[key] for key in range(len(qtables)) if key in qtables]
-    for idx, table in enumerate(qtables):
-        qtables[idx] = [table[i] for i in zigzag_index]
+    warnings.warn(
+        "convert_dict_qtables is deprecated and will be removed in Pillow 10"
+        "(2023-07-01). Conversion is no longer needed.",
+        DeprecationWarning,
+    )
     return qtables


@@ -605,6 +626,8 @@


 def _save(im, fp, filename):
+    if im.width == 0 or im.height == 0:
+        raise ValueError("cannot write empty image as JPEG")

     try:
         rawmode = RAWMODE[im.mode]
@@ -667,7 +690,9 @@
                 qtables = [lines[s : s + 64] for s in range(0, len(lines), 64)]
         if isinstance(qtables, (tuple, list, dict)):
             if isinstance(qtables, dict):
-                qtables = convert_dict_qtables(qtables)
+                qtables = [
+                    qtables[key] for key in range(len(qtables)) if key in qtables
+                ]
             elif isinstance(qtables, tuple):
                 qtables = list(qtables)
             if not (0 < len(qtables) < 5):
('src/PIL', 'ImageFont.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -29,13 +29,39 @@
 import os
 import sys
 import warnings
+from enum import IntEnum
 from io import BytesIO

-from . import Image, features
+from . import Image
 from ._util import isDirectory, isPath

-LAYOUT_BASIC = 0
-LAYOUT_RAQM = 1
+
+class Layout(IntEnum):
+    BASIC = 0
+    RAQM = 1
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {Layout: "LAYOUT_"}.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")


 class _imagingft_not_installed:
@@ -165,27 +191,18 @@
         self.index = index
         self.encoding = encoding

-        try:
-            from packaging.version import parse as parse_version
-        except ImportError:
-            pass
-        else:
-            freetype_version = parse_version(features.version_module("freetype2"))
-            if freetype_version < parse_version("2.8"):
-                warnings.warn(
-                    "Support for FreeType 2.7 is deprecated and will be removed"
-                    " in Pillow 9 (2022-01-02). Please upgrade to FreeType 2.8 "
-                    "or newer, preferably FreeType 2.10.4 which fixes "
-                    "CVE-2020-15999.",
-                    DeprecationWarning,
-                )
-
-        if layout_engine not in (LAYOUT_BASIC, LAYOUT_RAQM):
-            layout_engine = LAYOUT_BASIC
+        if layout_engine not in (Layout.BASIC, Layout.RAQM):
+            layout_engine = Layout.BASIC
             if core.HAVE_RAQM:
-                layout_engine = LAYOUT_RAQM
-        elif layout_engine == LAYOUT_RAQM and not core.HAVE_RAQM:
-            layout_engine = LAYOUT_BASIC
+                layout_engine = Layout.RAQM
+        elif layout_engine == Layout.RAQM and not core.HAVE_RAQM:
+            import warnings
+
+            warnings.warn(
+                "Raqm layout was requested, but Raqm is not available. "
+                "Falling back to basic layout."
+            )
+            layout_engine = Layout.BASIC

         self.layout_engine = layout_engine

@@ -212,6 +229,13 @@
         else:
             load_from_bytes(font)

+    def __getstate__(self):
+        return [self.path, self.size, self.index, self.encoding, self.layout_engine]
+
+    def __setstate__(self, state):
+        path, size, index, encoding, layout_engine = state
+        self.__init__(path, size, index, encoding, layout_engine)
+
     def _multiline_split(self, text):
         split_character = "\n" if isinstance(text, str) else b"\n"
         return text.split(split_character)
@@ -669,6 +693,7 @@
         )
         size = size[0] + stroke_width * 2, size[1] + stroke_width * 2
         offset = offset[0] - stroke_width, offset[1] - stroke_width
+        Image._decompression_bomb_check(size)
         im = fill("RGBA" if mode == "RGBA" else "L", size, 0)
         self.font.render(
             text, im.id, mode, direction, features, language, stroke_width, ink
@@ -759,15 +784,16 @@

         :param font: A font object.
         :param orientation: An optional orientation.  If given, this should
-            be one of Image.FLIP_LEFT_RIGHT, Image.FLIP_TOP_BOTTOM,
-            Image.ROTATE_90, Image.ROTATE_180, or Image.ROTATE_270.
+            be one of Image.Transpose.FLIP_LEFT_RIGHT, Image.Transpose.FLIP_TOP_BOTTOM,
+            Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_180, or
+            Image.Transpose.ROTATE_270.
         """
         self.font = font
         self.orientation = orientation  # any 'transpose' argument, or None

     def getsize(self, text, *args, **kwargs):
         w, h = self.font.getsize(text)
-        if self.orientation in (Image.ROTATE_90, Image.ROTATE_270):
+        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):
             return h, w
         return w, h

@@ -813,7 +839,7 @@
                  :file:`/System/Library/Fonts/` and :file:`~/Library/Fonts/` on
                  macOS.

-    :param size: The requested size, in points.
+    :param size: The requested size, in pixels.
     :param index: Which font face to load (default is first available face).
     :param encoding: Which font encoding to use (default is Unicode). Possible
                      encodings include (see the FreeType documentation for more
@@ -835,7 +861,7 @@
                      This specifies the character set to use. It does not alter the
                      encoding of any text provided in subsequent operations.
     :param layout_engine: Which layout engine to use, if available:
-                     :data:`.ImageFont.LAYOUT_BASIC` or :data:`.ImageFont.LAYOUT_RAQM`.
+                     :data:`.ImageFont.Layout.BASIC` or :data:`.ImageFont.Layout.RAQM`.

                      You can check support for Raqm layout using
                      :py:func:`PIL.features.check_feature` with ``feature="raqm"``.
('src/PIL', 'PpmImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,6 +16,9 @@


 from . import Image, ImageFile
+from ._binary import i16be as i16
+from ._binary import o8
+from ._binary import o32le as o32

 #
 # --------------------------------------------------------------------
@@ -49,26 +52,46 @@
     format = "PPM"
     format_description = "Pbmplus image"

-    def _token(self, s=b""):
-        while True:  # read until next whitespace
+    def _read_magic(self):
+        magic = b""
+        # read until whitespace or longest available magic number
+        for _ in range(6):
             c = self.fp.read(1)
             if not c or c in b_whitespace:
                 break
-            if c > b"\x79":
-                raise ValueError("Expected ASCII value, found binary")
-            s = s + c
-            if len(s) > 9:
-                raise ValueError("Expected int, got > 9 digits")
-        return s
+            magic += c
+        return magic
+
+    def _read_token(self):
+        token = b""
+        while len(token) <= 10:  # read until next whitespace or limit of 10 characters
+            c = self.fp.read(1)
+            if not c:
+                break
+            elif c in b_whitespace:  # token ended
+                if not token:
+                    # skip whitespace at start
+                    continue
+                break
+            elif c == b"#":
+                # ignores rest of the line; stops at CR, LF or EOF
+                while self.fp.read(1) not in b"\r\n":
+                    pass
+                continue
+            token += c
+        if not token:
+            # Token was not even 1 byte
+            raise ValueError("Reached EOF while reading header")
+        elif len(token) > 10:
+            raise ValueError(f"Token too long in file header: {token}")
+        return token

     def _open(self):
-
-        # check magic
-        s = self.fp.read(1)
-        if s != b"P":
+        magic_number = self._read_magic()
+        try:
+            mode = MODES[magic_number]
+        except KeyError:
             raise SyntaxError("not a PPM file")
-        magic_number = self._token(s)
-        mode = MODES[magic_number]

         self.custom_mimetype = {
             b"P4": "image/x-portable-bitmap",
@@ -82,38 +105,55 @@
         else:
             self.mode = rawmode = mode

+        decoder_name = "raw"
         for ix in range(3):
-            while True:
-                while True:
-                    s = self.fp.read(1)
-                    if s not in b_whitespace:
-                        break
-                    if s == b"":
-                        raise ValueError("File does not extend beyond magic number")
-                if s != b"#":
-                    break
-                s = self.fp.readline()
-            s = int(self._token(s))
-            if ix == 0:
-                xsize = s
-            elif ix == 1:
-                ysize = s
+            token = int(self._read_token())
+            if ix == 0:  # token is the x size
+                xsize = token
+            elif ix == 1:  # token is the y size
+                ysize = token
                 if mode == "1":
                     break
-            elif ix == 2:
-                # maxgrey
-                if s > 255:
-                    if not mode == "L":
-                        raise ValueError(f"Too many colors for band: {s}")
-                    if s < 2 ** 16:
-                        self.mode = "I"
-                        rawmode = "I;16B"
-                    else:
-                        self.mode = "I"
-                        rawmode = "I;32B"
+            elif ix == 2:  # token is maxval
+                maxval = token
+                if maxval > 255 and mode == "L":
+                    self.mode = "I"
+
+                # If maxval matches a bit depth, use the raw decoder directly
+                if maxval == 65535 and mode == "L":
+                    rawmode = "I;16B"
+                elif maxval != 255:
+                    decoder_name = "ppm"
+        args = (rawmode, 0, 1) if decoder_name == "raw" else (rawmode, maxval)

         self._size = xsize, ysize
-        self.tile = [("raw", (0, 0, xsize, ysize), self.fp.tell(), (rawmode, 0, 1))]
+        self.tile = [(decoder_name, (0, 0, xsize, ysize), self.fp.tell(), args)]
+
+
+class PpmDecoder(ImageFile.PyDecoder):
+    _pulls_fd = True
+
+    def decode(self, buffer):
+        data = bytearray()
+        maxval = min(self.args[-1], 65535)
+        in_byte_count = 1 if maxval < 256 else 2
+        out_byte_count = 4 if self.mode == "I" else 1
+        out_max = 65535 if self.mode == "I" else 255
+        bands = Image.getmodebands(self.mode)
+        while len(data) < self.state.xsize * self.state.ysize * bands * out_byte_count:
+            pixels = self.fd.read(in_byte_count * bands)
+            if len(pixels) < in_byte_count * bands:
+                # eof
+                break
+            for b in range(bands):
+                value = (
+                    pixels[b] if in_byte_count == 1 else i16(pixels, b * in_byte_count)
+                )
+                value = min(out_max, round(value / maxval * out_max))
+                data += o32(value) if self.mode == "I" else o8(value)
+        rawmode = "I;32" if self.mode == "I" else self.mode
+        self.set_as_raw(bytes(data), (rawmode, 0, 1))
+        return -1, 0


 #
@@ -126,26 +166,19 @@
     elif im.mode == "L":
         rawmode, head = "L", b"P5"
     elif im.mode == "I":
-        if im.getextrema()[1] < 2 ** 16:
-            rawmode, head = "I;16B", b"P5"
-        else:
-            rawmode, head = "I;32B", b"P5"
-    elif im.mode == "RGB":
-        rawmode, head = "RGB", b"P6"
-    elif im.mode == "RGBA":
+        rawmode, head = "I;16B", b"P5"
+    elif im.mode in ("RGB", "RGBA"):
         rawmode, head = "RGB", b"P6"
     else:
         raise OSError(f"cannot write mode {im.mode} as PPM")
-    fp.write(head + ("\n%d %d\n" % im.size).encode("ascii"))
+    fp.write(head + b"\n%d %d\n" % im.size)
     if head == b"P6":
         fp.write(b"255\n")
-    if head == b"P5":
+    elif head == b"P5":
         if rawmode == "L":
             fp.write(b"255\n")
-        elif rawmode == "I;16B":
+        else:
             fp.write(b"65535\n")
-        elif rawmode == "I;32B":
-            fp.write(b"2147483648\n")
     ImageFile._save(im, fp, [("raw", (0, 0) + im.size, 0, (rawmode, 0, 1))])

     # ALTERNATIVE: save via builtin debug function
@@ -159,6 +192,8 @@
 Image.register_open(PpmImageFile.format, PpmImageFile, _accept)
 Image.register_save(PpmImageFile.format, _save)

+Image.register_decoder("ppm", PpmDecoder)
+
 Image.register_extensions(PpmImageFile.format, [".pbm", ".pgm", ".ppm", ".pnm"])

 Image.register_mime(PpmImageFile.format, "image/x-portable-anymap")
('src/PIL', 'FtexImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -52,13 +52,41 @@
 """

 import struct
+import warnings
+from enum import IntEnum
 from io import BytesIO

 from . import Image, ImageFile

 MAGIC = b"FTEX"
-FORMAT_DXT1 = 0
-FORMAT_UNCOMPRESSED = 1
+
+
+class Format(IntEnum):
+    DXT1 = 0
+    UNCOMPRESSED = 1
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {Format: "FORMAT_"}.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")


 class FtexImageFile(ImageFile.ImageFile):
@@ -66,7 +94,8 @@
     format_description = "Texture File Format (IW2:EOC)"

     def _open(self):
-        struct.unpack("<I", self.fp.read(4))  # magic
+        if not _accept(self.fp.read(4)):
+            raise SyntaxError("not an FTEX file")
         struct.unpack("<i", self.fp.read(4))  # version
         self._size = struct.unpack("<2i", self.fp.read(8))
         mipmap_count, format_count = struct.unpack("<2i", self.fp.read(8))
@@ -83,10 +112,10 @@

         data = self.fp.read(mipmap_size)

-        if format == FORMAT_DXT1:
+        if format == Format.DXT1:
             self.mode = "RGBA"
             self.tile = [("bcn", (0, 0) + self.size, 0, (1))]
-        elif format == FORMAT_UNCOMPRESSED:
+        elif format == Format.UNCOMPRESSED:
             self.tile = [("raw", (0, 0) + self.size, 0, ("RGB", 0, 1))]
         else:
             raise ValueError(f"Invalid texture compression format: {repr(format)}")
@@ -98,9 +127,9 @@
         pass


-def _validate(prefix):
+def _accept(prefix):
     return prefix[:4] == MAGIC


-Image.register_open(FtexImageFile.format, FtexImageFile, _validate)
+Image.register_open(FtexImageFile.format, FtexImageFile, _accept)
 Image.register_extensions(FtexImageFile.format, [".ftc", ".ftu"])
