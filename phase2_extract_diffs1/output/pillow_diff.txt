('', 'selftest.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 # minimal sanity check
 
 import sys
@@ -14,17 +14,13 @@
     pass
 
 
-def _info(im):
-    im.load()
-    return im.format, im.mode, im.size
-
-
 def testimage():
     """
     PIL lets you create in-memory images with various pixel types:
 
     >>> from PIL import Image, ImageDraw, ImageFilter, ImageMath
     >>> im = Image.new("1", (128, 128)) # monochrome
+    >>> def _info(im): return (im.format, im.mode, im.size)
     >>> _info(im)
     (None, '1', (128, 128))
     >>> _info(Image.new("L", (128, 128))) # grayscale (luminance)
@@ -101,9 +97,9 @@
     10456
     >>> len(im.tobytes())
     49152
-    >>> _info(im.transform((512, 512), Image.AFFINE, (1,0,0,0,1,0)))
+    >>> _info(im.transform((512, 512), Image.Transform.AFFINE, (1,0,0,0,1,0)))
     (None, 'RGB', (512, 512))
-    >>> _info(im.transform((512, 512), Image.EXTENT, (32,32,96,96)))
+    >>> _info(im.transform((512, 512), Image.Transform.EXTENT, (32,32,96,96)))
     (None, 'RGB', (512, 512))
 
     The ImageDraw module lets you draw stuff in raster images:
@@ -147,9 +143,7 @@
     ('F', (128, 128))
 
     PIL can do many other things, but I'll leave that for another
-    day.  If you're curious, check the handbook, available from:
-
-        http://www.pythonware.com
+    day.
 
     Cheers /F
     """
('', 'setup.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 # > pyroma .
 # ------------------------------
 # Checking .
@@ -26,18 +26,19 @@
     return locals()["__version__"]
 
 
-NAME = "Pillow"
 PILLOW_VERSION = get_version()
 FREETYPE_ROOT = None
+HARFBUZZ_ROOT = None
+FRIBIDI_ROOT = None
 IMAGEQUANT_ROOT = None
 JPEG2K_ROOT = None
 JPEG_ROOT = None
 LCMS_ROOT = None
 TIFF_ROOT = None
 ZLIB_ROOT = None
-
-
-if sys.platform == "win32" and sys.version_info >= (3, 10):
+FUZZING_BUILD = "LIB_FUZZING_ENGINE" in os.environ
+
+if sys.platform == "win32" and sys.version_info >= (3, 11):
     import atexit
 
     atexit.register(
@@ -166,7 +167,7 @@
         # Assuming GLIBC's ldconfig (with option -p)
         # Alpine Linux uses musl that can't print cache
         args = ["/sbin/ldconfig", "-p"]
-        expr = fr".*\({abi_type}.*\) => (.*)"
+        expr = rf".*\({abi_type}.*\) => (.*)"
         env = dict(os.environ)
         env["LC_ALL"] = "C"
         env["LANG"] = "C"
@@ -184,7 +185,7 @@
         return []
     [data, _] = p.communicate()
     if isinstance(data, bytes):
-        data = data.decode()
+        data = data.decode("latin1")
 
     dirs = []
     for dll in re.findall(expr, data):
@@ -226,6 +227,19 @@
     else:
         _dbg("Couldn't find library %s in %s", (library, self.compiler.library_dirs))
     return ret
+
+
+def _find_include_dir(self, dirname, include):
+    for directory in self.compiler.include_dirs:
+        _dbg("Checking for include file %s in %s", (include, directory))
+        if os.path.isfile(os.path.join(directory, include)):
+            _dbg("Found %s in %s", (include, directory))
+            return True
+        subdir = os.path.join(directory, dirname)
+        _dbg("Checking for include file %s in %s", (include, subdir))
+        if os.path.isfile(os.path.join(subdir, include)):
+            _dbg("Found %s in %s", (include, subdir))
+            return subdir
 
 
 def _cmd_exists(cmd):
@@ -267,6 +281,7 @@
             "jpeg",
             "tiff",
             "freetype",
+            "raqm",
             "lcms",
             "webp",
             "webpmux",
@@ -276,6 +291,7 @@
         ]
 
         required = {"jpeg", "zlib"}
+        vendor = set()
 
         def __init__(self):
             for f in self.features:
@@ -286,6 +302,9 @@
 
         def want(self, feat):
             return getattr(self, feat) is None
+
+        def want_vendor(self, feat):
+            return feat in self.vendor
 
         def __iter__(self):
             yield from self.features
@@ -296,6 +315,10 @@
         build_ext.user_options
         + [(f"disable-{x}", None, f"Disable support for {x}") for x in feature]
         + [(f"enable-{x}", None, f"Enable support for {x}") for x in feature]
+        + [
+            (f"vendor-{x}", None, f"Use vendored version of {x}")
+            for x in ("raqm", "fribidi")
+        ]
         + [
             ("disable-platform-guessing", None, "Disable platform guessing on Linux"),
             ("debug", None, "Debug logging"),
@@ -310,6 +333,8 @@
         for x in self.feature:
             setattr(self, f"disable_{x}", None)
             setattr(self, f"enable_{x}", None)
+        for x in ("raqm", "fribidi"):
+            setattr(self, f"vendor_{x}", None)
 
     def finalize_options(self):
         build_ext.finalize_options(self)
@@ -334,18 +359,43 @@
                     raise ValueError(
                         f"Conflicting options: --enable-{x} and --disable-{x}"
                     )
+                if x == "freetype":
+                    _dbg("--disable-freetype implies --disable-raqm")
+                    if getattr(self, "enable_raqm"):
+                        raise ValueError(
+                            "Conflicting options: --enable-raqm and --disable-freetype"
+                        )
+                    setattr(self, "disable_raqm", True)
             if getattr(self, f"enable_{x}"):
                 _dbg("Requiring %s", x)
                 self.feature.required.add(x)
-
-    def _update_extension(self, name, libraries, define_macros=None, include_dirs=None):
+                if x == "raqm":
+                    _dbg("--enable-raqm implies --enable-freetype")
+                    self.feature.required.add("freetype")
+        for x in ("raqm", "fribidi"):
+            if getattr(self, f"vendor_{x}"):
+                if getattr(self, "disable_raqm"):
+                    raise ValueError(
+                        f"Conflicting options: --vendor-{x} and --disable-raqm"
+                    )
+                if x == "fribidi" and not getattr(self, "vendor_raqm"):
+                    raise ValueError(
+                        f"Conflicting options: --vendor-{x} and not --vendor-raqm"
+                    )
+                _dbg("Using vendored version of %s", x)
+                self.feature.vendor.add(x)
+
+    def _update_extension(self, name, libraries, define_macros=None, sources=None):
         for extension in self.extensions:
             if extension.name == name:
                 extension.libraries += libraries
                 if define_macros is not None:
                     extension.define_macros += define_macros
-                if include_dirs is not None:
-                    extension.include_dirs += include_dirs
+                if sources is not None:
+                    extension.sources += sources
+                if FUZZING_BUILD:
+                    extension.language = "c++"
+                    extension.extra_link_args = ["--stdlib=libc++"]
                 break
 
     def _remove_extension(self, name):
@@ -353,6 +403,27 @@
             if extension.name == name:
                 self.extensions.remove(extension)
                 break
+
+    def get_macos_sdk_path(self):
+        try:
+            sdk_path = (
+                subprocess.check_output(["xcrun", "--show-sdk-path"])
+                .strip()
+                .decode("latin1")
+            )
+        except Exception:
+            sdk_path = None
+        if (
+            not sdk_path
+            or sdk_path == "/Applications/Xcode.app/Contents/Developer"
+            "/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
+        ):
+            commandlinetools_sdk_path = (
+                "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
+            )
+            if os.path.exists(commandlinetools_sdk_path):
+                sdk_path = commandlinetools_sdk_path
+        return sdk_path
 
     def build_extensions(self):
 
@@ -371,6 +442,8 @@
             TIFF_ROOT=("libtiff-5", "libtiff-4"),
             ZLIB_ROOT="zlib",
             FREETYPE_ROOT="freetype2",
+            HARFBUZZ_ROOT="harfbuzz",
+            FRIBIDI_ROOT="fribidi",
             LCMS_ROOT="lcms2",
             IMAGEQUANT_ROOT="libimagequant",
         ).items():
@@ -479,15 +552,7 @@
                 _add_directory(library_dirs, "/usr/X11/lib")
                 _add_directory(include_dirs, "/usr/X11/include")
 
-            # SDK install path
-            try:
-                sdk_path = (
-                    subprocess.check_output(["xcrun", "--show-sdk-path"])
-                    .strip()
-                    .decode("latin1")
-                )
-            except Exception:
-                sdk_path = None
+            sdk_path = self.get_macos_sdk_path()
             if sdk_path:
                 _add_directory(library_dirs, os.path.join(sdk_path, "usr", "lib"))
                 _add_directory(include_dirs, os.path.join(sdk_path, "usr", "include"))
@@ -506,7 +571,11 @@
                 # headers are at $PREFIX/include
                 # user libs are at $PREFIX/lib
                 _add_directory(
-                    library_dirs, os.path.join(os.environ["ANDROID_ROOT"], "lib")
+                    library_dirs,
+                    os.path.join(
+                        os.environ["ANDROID_ROOT"],
+                        "lib" if struct.calcsize("l") == 4 else "lib64",
+                    ),
                 )
 
         elif sys.platform.startswith("netbsd"):
@@ -656,6 +725,39 @@
                     if subdir:
                         _add_directory(self.compiler.include_dirs, subdir, 0)
 
+        if feature.freetype and feature.want("raqm"):
+            if not feature.want_vendor("raqm"):  # want system Raqm
+                _dbg("Looking for Raqm")
+                if _find_include_file(self, "raqm.h"):
+                    if _find_library_file(self, "raqm"):
+                        feature.raqm = "raqm"
+                    elif _find_library_file(self, "libraqm"):
+                        feature.raqm = "libraqm"
+            else:  # want to build Raqm from src/thirdparty
+                _dbg("Looking for HarfBuzz")
+                feature.harfbuzz = None
+                hb_dir = _find_include_dir(self, "harfbuzz", "hb.h")
+                if hb_dir:
+                    if isinstance(hb_dir, str):
+                        _add_directory(self.compiler.include_dirs, hb_dir, 0)
+                    if _find_library_file(self, "harfbuzz"):
+                        feature.harfbuzz = "harfbuzz"
+                if feature.harfbuzz:
+                    if not feature.want_vendor("fribidi"):  # want system FriBiDi
+                        _dbg("Looking for FriBiDi")
+                        feature.fribidi = None
+                        fribidi_dir = _find_include_dir(self, "fribidi", "fribidi.h")
+                        if fribidi_dir:
+                            if isinstance(fribidi_dir, str):
+                                _add_directory(
+                                    self.compiler.include_dirs, fribidi_dir, 0
+                                )
+                            if _find_library_file(self, "fribidi"):
+                                feature.fribidi = "fribidi"
+                                feature.raqm = True
+                    else:  # want to build FriBiDi shim from src/thirdparty
+                        feature.raqm = True
+
         if feature.want("lcms"):
             _dbg("Looking for lcms")
             if _find_include_file(self, "lcms2.h"):
@@ -724,9 +826,11 @@
         if feature.tiff:
             libs.append(feature.tiff)
             defs.append(("HAVE_LIBTIFF", None))
-            # FIXME the following define should be detected automatically
-            #       based on system libtiff, see #4237
-            if PLATFORM_MINGW:
+            if sys.platform == "win32":
+                # This define needs to be defined if-and-only-if it was defined
+                # when compiling LibTIFF. LibTIFF doesn't expose it in `tiffconf.h`,
+                # so we have to guess; by default it is defined in all Windows builds.
+                # See #4237, #5243, #5359 for more information.
                 defs.append(("USE_WIN32_FILEIO", None))
         if feature.xcb:
             libs.append(feature.xcb)
@@ -751,9 +855,25 @@
         # additional libraries
 
         if feature.freetype:
+            srcs = []
             libs = ["freetype"]
             defs = []
-            self._update_extension("PIL._imagingft", libs, defs)
+            if feature.raqm:
+                if not feature.want_vendor("raqm"):  # using system Raqm
+                    defs.append(("HAVE_RAQM", None))
+                    defs.append(("HAVE_RAQM_SYSTEM", None))
+                    libs.append(feature.raqm)
+                else:  # building Raqm from src/thirdparty
+                    defs.append(("HAVE_RAQM", None))
+                    srcs.append("src/thirdparty/raqm/raqm.c")
+                    libs.append(feature.harfbuzz)
+                    if not feature.want_vendor("fribidi"):  # using system FriBiDi
+                        defs.append(("HAVE_FRIBIDI_SYSTEM", None))
+                        libs.append(feature.fribidi)
+                    else:  # building FriBiDi shim from src/thirdparty
+                        srcs.append("src/thirdparty/fribidi-shim/fribidi.c")
+            self._update_extension("PIL._imagingft", libs, defs, srcs)
+
         else:
             self._remove_extension("PIL._imagingft")
 
@@ -778,7 +898,7 @@
         else:
             self._remove_extension("PIL._webp")
 
-        tk_libs = ["psapi"] if sys.platform == "win32" else []
+        tk_libs = ["psapi"] if sys.platform in ("win32", "cygwin") else []
         self._update_extension("PIL._imagingtk", tk_libs)
 
         build_ext.build_extensions(self)
@@ -800,6 +920,12 @@
             print(f"             [{v.strip()}")
         print("-" * 68)
 
+        raqm_extra_info = ""
+        if feature.want_vendor("raqm"):
+            raqm_extra_info += "bundled"
+            if feature.want_vendor("fribidi"):
+                raqm_extra_info += ", FriBiDi shim"
+
         options = [
             (feature.jpeg, "JPEG"),
             (feature.jpeg2000, "OPENJPEG (JPEG2000)", feature.openjpeg_version),
@@ -807,6 +933,7 @@
             (feature.imagequant, "LIBIMAGEQUANT"),
             (feature.tiff, "LIBTIFF"),
             (feature.freetype, "FREETYPE2"),
+            (feature.raqm, "RAQM (Text shaping)", raqm_extra_info),
             (feature.lcms, "LITTLECMS2"),
             (feature.webp, "WEBP"),
             (feature.webpmux, "WEBPMUX"),
@@ -816,10 +943,10 @@
         all = 1
         for option in options:
             if option[0]:
-                version = ""
+                extra_info = ""
                 if len(option) >= 3 and option[2]:
-                    version = f" ({option[2]})"
-                print(f"--- {option[1]} support available{version}")
+                    extra_info = f" ({option[2]})"
+                print(f"--- {option[1]} support available{extra_info}")
             else:
                 print(f"*** {option[1]} support not available")
                 all = 0
@@ -840,7 +967,7 @@
 
 
 def debug_build():
-    return hasattr(sys, "gettotalrefcount")
+    return hasattr(sys, "gettotalrefcount") or FUZZING_BUILD
 
 
 files = ["src/_imaging.c"]
@@ -858,54 +985,14 @@
     Extension("PIL._imagingmorph", ["src/_imagingmorph.c"]),
 ]
 
-with open("README.md") as f:
-    long_description = f.read()
-
 try:
     setup(
-        name=NAME,
         version=PILLOW_VERSION,
-        description="Python Imaging Library (Fork)",
-        long_description=long_description,
-        long_description_content_type="text/markdown",
-        license="HPND",
-        author="Alex Clark (PIL Fork Author)",
-        author_email="aclark@python-pillow.org",
-        url="https://python-pillow.org",
-        project_urls={
-            "Documentation": "https://pillow.readthedocs.io",
-            "Source": "https://github.com/python-pillow/Pillow",
-            "Funding": "https://tidelift.com/subscription/pkg/pypi-pillow?"
-            "utm_source=pypi-pillow&utm_medium=pypi",
-            "Release notes": "https://pillow.readthedocs.io/en/stable/releasenotes/"
-            "index.html",
-            "Changelog": "https://github.com/python-pillow/Pillow/blob/master/"
-            "CHANGES.rst",
-        },
-        classifiers=[
-            "Development Status :: 6 - Mature",
-            "License :: OSI Approved :: Historical Permission Notice and Disclaimer (HPND)",  # noqa: E501
-            "Programming Language :: Python :: 3",
-            "Programming Language :: Python :: 3.6",
-            "Programming Language :: Python :: 3.7",
-            "Programming Language :: Python :: 3.8",
-            "Programming Language :: Python :: 3.9",
-            "Programming Language :: Python :: 3 :: Only",
-            "Programming Language :: Python :: Implementation :: CPython",
-            "Programming Language :: Python :: Implementation :: PyPy",
-            "Topic :: Multimedia :: Graphics",
-            "Topic :: Multimedia :: Graphics :: Capture :: Digital Camera",
-            "Topic :: Multimedia :: Graphics :: Capture :: Screen Capture",
-            "Topic :: Multimedia :: Graphics :: Graphics Conversion",
-            "Topic :: Multimedia :: Graphics :: Viewers",
-        ],
-        python_requires=">=3.6",
         cmdclass={"build_ext": pil_build_ext},
         ext_modules=ext_modules,
         include_package_data=True,
         packages=["PIL"],
         package_dir={"": "src"},
-        keywords=["Imaging"],
         zip_safe=not (debug_build() or PLATFORM_MINGW),
     )
 except RequiredDependencyException as err:
('winbuild', 'build_prepare.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,5 @@
 import os
+import platform
 import shutil
 import struct
 import subprocess
@@ -88,11 +89,12 @@
     )
 
 
-SF_MIRROR = "http://iweb.dl.sourceforge.net"
+SF_MIRROR = "https://iweb.dl.sourceforge.net"
 
 architectures = {
     "x86": {"vcvars_arch": "x86", "msbuild_arch": "Win32"},
     "x64": {"vcvars_arch": "x86_amd64", "msbuild_arch": "x64"},
+    "ARM64": {"vcvars_arch": "x86_arm64", "msbuild_arch": "ARM64"},
 }
 
 header = [
@@ -105,9 +107,9 @@
 # dependencies, listed in order of compilation
 deps = {
     "libjpeg": {
-        "url": SF_MIRROR + "/project/libjpeg-turbo/2.0.6/libjpeg-turbo-2.0.6.tar.gz",
-        "filename": "libjpeg-turbo-2.0.6.tar.gz",
-        "dir": "libjpeg-turbo-2.0.6",
+        "url": SF_MIRROR + "/project/libjpeg-turbo/2.1.3/libjpeg-turbo-2.1.3.tar.gz",
+        "filename": "libjpeg-turbo-2.1.3.tar.gz",
+        "dir": "libjpeg-turbo-2.1.3",
         "build": [
             cmd_cmake(
                 [
@@ -129,9 +131,9 @@
         "bins": ["cjpeg.exe", "djpeg.exe"],
     },
     "zlib": {
-        "url": "http://zlib.net/zlib1211.zip",
-        "filename": "zlib1211.zip",
-        "dir": "zlib-1.2.11",
+        "url": "https://zlib.net/zlib1212.zip",
+        "filename": "zlib1212.zip",
+        "dir": "zlib-1.2.12",
         "build": [
             cmd_nmake(r"win32\Makefile.msc", "clean"),
             cmd_nmake(r"win32\Makefile.msc", "zlib.lib"),
@@ -141,22 +143,22 @@
         "libs": [r"*.lib"],
     },
     "libtiff": {
-        "url": "https://download.osgeo.org/libtiff/tiff-4.2.0.tar.gz",
-        "filename": "tiff-4.2.0.tar.gz",
-        "dir": "tiff-4.2.0",
-        "build": [
-            cmd_copy(r"{winbuild_dir}\tiff.opt", "nmake.opt"),
-            cmd_nmake("makefile.vc", "clean"),
-            cmd_nmake("makefile.vc", "lib"),
+        "url": "https://download.osgeo.org/libtiff/tiff-4.3.0.tar.gz",
+        "filename": "tiff-4.3.0.tar.gz",
+        "dir": "tiff-4.3.0",
+        "build": [
+            cmd_cmake("-DBUILD_SHARED_LIBS:BOOL=OFF"),
+            cmd_nmake(target="clean"),
+            cmd_nmake(target="tiff"),
         ],
         "headers": [r"libtiff\tiff*.h"],
         "libs": [r"libtiff\*.lib"],
         # "bins": [r"libtiff\*.dll"],
     },
     "libwebp": {
-        "url": "http://downloads.webmproject.org/releases/webp/libwebp-1.1.0.tar.gz",
-        "filename": "libwebp-1.1.0.tar.gz",
-        "dir": "libwebp-1.1.0",
+        "url": "http://downloads.webmproject.org/releases/webp/libwebp-1.2.2.tar.gz",
+        "filename": "libwebp-1.2.2.tar.gz",
+        "dir": "libwebp-1.2.2",
         "build": [
             cmd_rmdir(r"output\release-static"),  # clean
             cmd_nmake(
@@ -184,9 +186,9 @@
         "libs": [r"libpng16.lib"],
     },
     "freetype": {
-        "url": "https://download.savannah.gnu.org/releases/freetype/freetype-2.10.4.tar.gz",  # noqa: E501
-        "filename": "freetype-2.10.4.tar.gz",
-        "dir": "freetype-2.10.4",
+        "url": "https://download.savannah.gnu.org/releases/freetype/freetype-2.12.0.tar.gz",  # noqa: E501
+        "filename": "freetype-2.12.0.tar.gz",
+        "dir": "freetype-2.12.0",
         "patch": {
             r"builds\windows\vc2010\freetype.vcxproj": {
                 # freetype setting is /MD for .dll and /MT for .lib, we need /MD
@@ -219,24 +221,26 @@
         # "bins": [r"objs\{msbuild_arch}\Release\freetype.dll"],
     },
     "lcms2": {
-        "url": SF_MIRROR + "/project/lcms/lcms/2.11/lcms2-2.11.tar.gz",
-        "filename": "lcms2-2.11.tar.gz",
-        "dir": "lcms2-2.11",
+        "url": SF_MIRROR + "/project/lcms/lcms/2.13/lcms2-2.13.1.tar.gz",
+        "filename": "lcms2-2.13.1.tar.gz",
+        "dir": "lcms2-2.13.1",
         "patch": {
-            r"Projects\VC2017\lcms2_static\lcms2_static.vcxproj": {
+            r"Projects\VC2019\lcms2_static\lcms2_static.vcxproj": {
                 # default is /MD for x86 and /MT for x64, we need /MD always
                 "<RuntimeLibrary>MultiThreaded</RuntimeLibrary>": "<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>",  # noqa: E501
                 # retarget to default toolset (selected by vcvarsall.bat)
-                "<PlatformToolset>v141</PlatformToolset>": "<PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>",  # noqa: E501
+                "<PlatformToolset>v142</PlatformToolset>": "<PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>",  # noqa: E501
                 # retarget to latest (selected by vcvarsall.bat)
-                "<WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>": "<WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>",  # noqa: E501
+                "<WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>": "<WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>",  # noqa: E501
             }
         },
         "build": [
             cmd_rmdir("Lib"),
-            cmd_rmdir(r"Projects\VC2017\Release"),
-            cmd_msbuild(r"Projects\VC2017\lcms2.sln", "Release", "Clean"),
-            cmd_msbuild(r"Projects\VC2017\lcms2.sln", "Release", "lcms2_static"),
+            cmd_rmdir(r"Projects\VC2019\Release"),
+            cmd_msbuild(r"Projects\VC2019\lcms2.sln", "Release", "Clean"),
+            cmd_msbuild(
+                r"Projects\VC2019\lcms2.sln", "Release", "lcms2_static:Rebuild"
+            ),
             cmd_xcopy("include", "{inc_dir}"),
         ],
         "libs": [r"Lib\MS\*.lib"],
@@ -255,29 +259,30 @@
         "libs": [r"bin\*.lib"],
     },
     "libimagequant": {
-        # e5d454b: Merge tag '2.12.6' into msvc
-        "url": "https://github.com/ImageOptim/libimagequant/archive/e5d454bc7f5eb63ee50c84a83a7fa5ac94f68ec4.zip",  # noqa: E501
-        "filename": "libimagequant-e5d454bc7f5eb63ee50c84a83a7fa5ac94f68ec4.zip",
-        "dir": "libimagequant-e5d454bc7f5eb63ee50c84a83a7fa5ac94f68ec4",
+        # commit: Merge branch 'master' into msvc (matches 2.17.0 tag)
+        "url": "https://github.com/ImageOptim/libimagequant/archive/e4c1334be0eff290af5e2b4155057c2953a313ab.zip",  # noqa: E501
+        "filename": "libimagequant-e4c1334be0eff290af5e2b4155057c2953a313ab.zip",
+        "dir": "libimagequant-e4c1334be0eff290af5e2b4155057c2953a313ab",
         "patch": {
             "CMakeLists.txt": {
-                "add_library": "add_compile_options(-openmp-)\r\nadd_library",
-                " SHARED": " STATIC",
+                "if(OPENMP_FOUND)": "if(false)",
+                "install": "#install",
             }
         },
         "build": [
             # lint: do not inline
             cmd_cmake(),
             cmd_nmake(target="clean"),
-            cmd_nmake(),
+            cmd_nmake(target="imagequant_a"),
+            cmd_copy("imagequant_a.lib", "imagequant.lib"),
         ],
         "headers": [r"*.h"],
-        "libs": [r"*.lib"],
+        "libs": [r"imagequant.lib"],
     },
     "harfbuzz": {
-        "url": "https://github.com/harfbuzz/harfbuzz/archive/2.7.4.zip",
-        "filename": "harfbuzz-2.7.4.zip",
-        "dir": "harfbuzz-2.7.4",
+        "url": "https://github.com/harfbuzz/harfbuzz/archive/4.2.0.zip",
+        "filename": "harfbuzz-4.2.0.zip",
+        "dir": "harfbuzz-4.2.0",
         "build": [
             cmd_cmake("-DHB_HAVE_FREETYPE:BOOL=TRUE"),
             cmd_nmake(target="clean"),
@@ -287,30 +292,16 @@
         "libs": [r"*.lib"],
     },
     "fribidi": {
-        "url": "https://github.com/fribidi/fribidi/archive/v1.0.10.zip",
-        "filename": "fribidi-1.0.10.zip",
-        "dir": "fribidi-1.0.10",
+        "url": "https://github.com/fribidi/fribidi/archive/v1.0.11.zip",
+        "filename": "fribidi-1.0.11.zip",
+        "dir": "fribidi-1.0.11",
         "build": [
             cmd_copy(r"{winbuild_dir}\fribidi.cmake", r"CMakeLists.txt"),
             cmd_cmake(),
             cmd_nmake(target="clean"),
             cmd_nmake(target="fribidi"),
         ],
-        "headers": [r"lib\*.h"],
-        "libs": [r"*.lib"],
-    },
-    "libraqm": {
-        "url": "https://github.com/HOST-Oman/libraqm/archive/v0.7.1.zip",
-        "filename": "libraqm-0.7.1.zip",
-        "dir": "libraqm-0.7.1",
-        "build": [
-            cmd_copy(r"{winbuild_dir}\raqm.cmake", r"CMakeLists.txt"),
-            cmd_cmake(),
-            cmd_nmake(target="clean"),
-            cmd_nmake(target="libraqm"),
-        ],
-        "headers": [r"src\*.h"],
-        "bins": [r"libraqm.dll"],
+        "bins": [r"*.dll"],
     },
 }
 
@@ -449,6 +440,7 @@
             assert patch_from in text
             text = text.replace(patch_from, patch_to)
         with open(patch_file, "w") as f:
+            print(f"Patching {patch_file}")
             f.write(text)
 
     banner = f"Building {name} ({dir})"
@@ -472,7 +464,7 @@
         if dep_name in disabled:
             continue
         script = build_dep(dep_name)
-        lines.append(fr'cmd.exe /c "{{build_dir}}\{script}"')
+        lines.append(rf'cmd.exe /c "{{build_dir}}\{script}"')
         lines.append("if errorlevel 1 echo Build failed! && exit /B 1")
     lines.append("@echo All Pillow dependencies built successfully!")
     write_script("build_dep_all.cmd", lines)
@@ -484,9 +476,7 @@
         cmd_cd("{pillow_dir}"),
         *prefs["header"],
         cmd_set("DISTUTILS_USE_SDK", "1"),  # use same compiler to build Pillow
-        cmd_set("MSSdk", "1"),  # for PyPy3.6
-        cmd_set("py_vcruntime_redist", "true"),  # use /MD, not /MT
-        r'"{python_dir}\{python_exe}" setup.py build_ext %*',
+        r'"{python_dir}\{python_exe}" setup.py build_ext --vendor-raqm --vendor-fribidi %*',  # noqa: E501
     ]
 
     write_script("build_pillow.cmd", lines)
@@ -502,7 +492,10 @@
     python_dir = os.environ.get("PYTHON")
     python_exe = os.environ.get("EXECUTABLE", "python.exe")
     architecture = os.environ.get(
-        "ARCHITECTURE", "x86" if struct.calcsize("P") == 4 else "x64"
+        "ARCHITECTURE",
+        "ARM64"
+        if platform.machine() == "ARM64"
+        else ("x86" if struct.calcsize("P") == 4 else "x64"),
     )
     build_dir = os.environ.get("PILLOW_BUILD", os.path.join(winbuild_dir, "build"))
     sources_dir = ""
@@ -511,8 +504,8 @@
             verbose = True
         elif arg == "--no-imagequant":
             disabled += ["libimagequant"]
-        elif arg == "--no-raqm":
-            disabled += ["fribidi", "libraqm"]
+        elif arg == "--no-raqm" or arg == "--no-fribidi":
+            disabled += ["fribidi"]
         elif arg.startswith("--depends="):
             depends_dir = arg[10:]
         elif arg.startswith("--python="):
('Tests', 'test_imagecms.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -8,7 +8,13 @@
 
 from PIL import Image, ImageMode, features
 
-from .helper import assert_image, assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image,
+    assert_image_equal,
+    assert_image_similar,
+    assert_image_similar_tofile,
+    hopper,
+)
 
 try:
     from PIL import ImageCms
@@ -134,7 +140,7 @@
     skip_missing()
     assert ImageCms.getDefaultIntent(SRGB) == 0
     support = ImageCms.isIntentSupported(
-        SRGB, ImageCms.INTENT_ABSOLUTE_COLORIMETRIC, ImageCms.DIRECTION_INPUT
+        SRGB, ImageCms.Intent.ABSOLUTE_COLORIMETRIC, ImageCms.Direction.INPUT
     )
     assert support == 1
 
@@ -147,7 +153,7 @@
     #     ["sRGB built-in", "", "WhitePoint : D65 (daylight)", "", ""]
     assert ImageCms.getDefaultIntent(p) == 0
     support = ImageCms.isIntentSupported(
-        p, ImageCms.INTENT_ABSOLUTE_COLORIMETRIC, ImageCms.DIRECTION_INPUT
+        p, ImageCms.Intent.ABSOLUTE_COLORIMETRIC, ImageCms.Direction.INPUT
     )
     assert support == 1
 
@@ -240,8 +246,7 @@
 
     # i.save('temp.lab.tif')  # visually verified vs PS.
 
-    with Image.open("Tests/images/hopper.Lab.tif") as target:
-        assert_image_similar(i, target, 3.5)
+    assert_image_similar_tofile(i, "Tests/images/hopper.Lab.tif", 3.5)
 
 
 def test_lab_srgb():
@@ -298,7 +303,7 @@
     def assert_truncated_tuple_equal(tup1, tup2, digits=10):
         # Helper function to reduce precision of tuples of floats
         # recursively and then check equality.
-        power = 10 ** digits
+        power = 10**digits
 
         def truncate_tuple(tuple_or_float):
             return tuple(
@@ -588,3 +593,13 @@
                 )
 
                 assert_image_equal(test_image.convert(dst_format[2]), reference_image)
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        ImageCms.Intent: "INTENT_",
+        ImageCms.Direction: "DIRECTION_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(ImageCms, prefix + name) == enum[name]
('Tests', 'test_qt_image_toqimage.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,8 @@
 import pytest
 
-from PIL import Image, ImageQt
+from PIL import ImageQt
 
-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper
 
 pytestmark = pytest.mark.skipif(
     not ImageQt.qt_is_installed, reason="Qt bindings are not installed"
@@ -40,5 +40,4 @@
         data.save(tempfile)
 
         # Check that it actually worked.
-        with Image.open(tempfile) as reloaded:
-            assert_image_equal(reloaded, src)
+        assert_image_equal_tofile(src, tempfile)
('Tests', 'check_large_memory.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,7 +23,7 @@
 XDIM = 48000
 
 
-pytestmark = pytest.mark.skipif(sys.maxsize <= 2 ** 32, reason="requires 64-bit system")
+pytestmark = pytest.mark.skipif(sys.maxsize <= 2**32, reason="requires 64-bit system")
 
 
 def _write_png(tmp_path, xdim, ydim):
@@ -33,7 +33,7 @@
 
 
 def test_large(tmp_path):
-    """ succeeded prepatch"""
+    """succeeded prepatch"""
     _write_png(tmp_path, XDIM, YDIM)
 
 
('Tests', 'test_tiff_ifdrational.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -27,6 +27,8 @@
 
     _test_equal(1, 2, Fraction(1, 2))
     _test_equal(1, 2, IFDRational(1, 2))
+
+    _test_equal(7, 5, 1.4)
 
 
 def test_ranges():
('Tests', 'test_image_paste.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -45,7 +45,7 @@
 
     @cached_property
     def mask_L(self):
-        return self.gradient_L.transpose(Image.ROTATE_270)
+        return self.gradient_L.transpose(Image.Transpose.ROTATE_270)
 
     @cached_property
     def gradient_L(self):
@@ -62,8 +62,18 @@
             "RGB",
             [
                 self.gradient_L,
-                self.gradient_L.transpose(Image.ROTATE_90),
-                self.gradient_L.transpose(Image.ROTATE_180),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_90),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_180),
+            ],
+        )
+
+    @cached_property
+    def gradient_LA(self):
+        return Image.merge(
+            "LA",
+            [
+                self.gradient_L,
+                self.gradient_L.transpose(Image.Transpose.ROTATE_90),
             ],
         )
 
@@ -73,9 +83,9 @@
             "RGBA",
             [
                 self.gradient_L,
-                self.gradient_L.transpose(Image.ROTATE_90),
-                self.gradient_L.transpose(Image.ROTATE_180),
-                self.gradient_L.transpose(Image.ROTATE_270),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_90),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_180),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_270),
             ],
         )
 
@@ -85,9 +95,9 @@
             "RGBa",
             [
                 self.gradient_L,
-                self.gradient_L.transpose(Image.ROTATE_90),
-                self.gradient_L.transpose(Image.ROTATE_180),
-                self.gradient_L.transpose(Image.ROTATE_270),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_90),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_180),
+                self.gradient_L.transpose(Image.Transpose.ROTATE_270),
             ],
         )
 
@@ -141,6 +151,28 @@
                     (239, 239, 207, 207),
                     (128, 1, 128, 254),
                     (207, 113, 112, 207),
+                    (255, 191, 128, 191),
+                ],
+            )
+
+    def test_image_mask_LA(self):
+        for mode in ("RGBA", "RGB", "L"):
+            im = Image.new(mode, (200, 200), "white")
+            im2 = getattr(self, "gradient_" + mode)
+
+            self.assert_9points_paste(
+                im,
+                im2,
+                self.gradient_LA,
+                [
+                    (128, 191, 255, 191),
+                    (112, 207, 206, 111),
+                    (128, 254, 128, 1),
+                    (208, 208, 239, 239),
+                    (192, 191, 191, 191),
+                    (207, 207, 112, 113),
+                    (255, 255, 255, 255),
+                    (239, 207, 207, 239),
                     (255, 191, 128, 191),
                 ],
             )
@@ -236,7 +268,7 @@
                 [
                     (127, 191, 254, 191),
                     (111, 207, 206, 110),
-                    (255, 255, 255, 0) if mode == "RGBA" else (127, 254, 127, 0),
+                    (127, 254, 127, 0),
                     (207, 207, 239, 239),
                     (191, 191, 190, 191),
                     (207, 206, 111, 112),
('Tests', 'test_file_msp.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,7 @@
 
 from PIL import Image, MspImagePlugin
 
-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper
 
 TEST_FILE = "Tests/images/hopper.msp"
 EXTRA_DIR = "Tests/images/picins"
@@ -52,8 +52,7 @@
 
 def _assert_file_image_equal(source_path, target_path):
     with Image.open(source_path) as im:
-        with Image.open(target_path) as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, target_path)
 
 
 @pytest.mark.skipif(
('Tests', 'test_image_array.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,31 +4,44 @@
 
 from .helper import hopper
 
+numpy = pytest.importorskip("numpy", reason="NumPy not installed")
+
 im = hopper().resize((128, 100))
 
 
 def test_toarray():
     def test(mode):
-        ai = im.convert(mode).__array_interface__
-        return ai["version"], ai["shape"], ai["typestr"], len(ai["data"])
+        ai = numpy.array(im.convert(mode))
+        return ai.shape, ai.dtype.str, ai.nbytes
 
-    # assert test("1") == (3, (100, 128), '|b1', 1600))
-    assert test("L") == (3, (100, 128), "|u1", 12800)
+    def test_with_dtype(dtype):
+        ai = numpy.array(im, dtype=dtype)
+        assert ai.dtype == dtype
+
+    # assert test("1") == ((100, 128), '|b1', 1600))
+    assert test("L") == ((100, 128), "|u1", 12800)
 
     # FIXME: wrong?
-    assert test("I") == (3, (100, 128), Image._ENDIAN + "i4", 51200)
+    assert test("I") == ((100, 128), Image._ENDIAN + "i4", 51200)
     # FIXME: wrong?
-    assert test("F") == (3, (100, 128), Image._ENDIAN + "f4", 51200)
+    assert test("F") == ((100, 128), Image._ENDIAN + "f4", 51200)
 
-    assert test("LA") == (3, (100, 128, 2), "|u1", 25600)
-    assert test("RGB") == (3, (100, 128, 3), "|u1", 38400)
-    assert test("RGBA") == (3, (100, 128, 4), "|u1", 51200)
-    assert test("RGBX") == (3, (100, 128, 4), "|u1", 51200)
+    assert test("LA") == ((100, 128, 2), "|u1", 25600)
+    assert test("RGB") == ((100, 128, 3), "|u1", 38400)
+    assert test("RGBA") == ((100, 128, 4), "|u1", 51200)
+    assert test("RGBX") == ((100, 128, 4), "|u1", 51200)
+
+    test_with_dtype(numpy.float64)
+    test_with_dtype(numpy.uint8)
+
+    with Image.open("Tests/images/truncated_jpeg.jpg") as im_truncated:
+        with pytest.raises(OSError):
+            numpy.array(im_truncated)
 
 
 def test_fromarray():
     class Wrapper:
-        """ Class with API matching Image.fromarray """
+        """Class with API matching Image.fromarray"""
 
         def __init__(self, img, arr_params):
             self.img = img
@@ -39,10 +52,18 @@
 
     def test(mode):
         i = im.convert(mode)
-        a = i.__array_interface__
-        a["strides"] = 1  # pretend it's non-contiguous
+        a = numpy.array(i)
         # Make wrapper instance for image, new array interface
-        wrapped = Wrapper(i, a)
+        wrapped = Wrapper(
+            i,
+            {
+                "shape": a.shape,
+                "typestr": a.dtype.str,
+                "version": 3,
+                "data": a.data,
+                "strides": 1,  # pretend it's non-contiguous
+            },
+        )
         out = Image.fromarray(wrapped)
         return out.mode, out.size, list(i.getdata()) == list(out.getdata())
 
('Tests', 'test_file_xbm.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@
 
 import pytest
 
-from PIL import Image
+from PIL import Image, XbmImagePlugin
 
 from .helper import hopper
 
@@ -63,6 +63,13 @@
         assert im.size == (128, 128)
 
 
+def test_invalid_file():
+    invalid_file = "Tests/images/flower.jpg"
+
+    with pytest.raises(SyntaxError):
+        XbmImagePlugin.XbmImageFile(invalid_file)
+
+
 def test_save_wrong_mode(tmp_path):
     im = hopper()
     out = str(tmp_path / "temp.xbm")
('Tests', 'conftest.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -10,3 +10,22 @@
             return out.getvalue()
     except Exception as e:
         return f"pytest_report_header failed: {e}"
+
+
+def pytest_configure(config):
+    config.addinivalue_line(
+        "markers",
+        "pil_noop_mark: A conditional mark where nothing special happens",
+    )
+
+    # We're marking some tests to ignore valgrind errors and XFAIL them.
+    # Ensure that the mark is defined
+    # even in cases where pytest-valgrind isn't installed
+    try:
+        config.addinivalue_line(
+            "markers",
+            "valgrind_known_error: Tests that have known issues with valgrind",
+        )
+    except Exception:
+        # valgrind is already installed
+        pass
('Tests', 'test_font_pcf.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,11 @@
 
 from PIL import FontFile, Image, ImageDraw, ImageFont, PcfFontFile
 
-from .helper import assert_image_equal, assert_image_similar, skip_unless_feature
+from .helper import (
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
+    skip_unless_feature,
+)
 
 fontname = "Tests/fonts/10x20-ISO8859-1.pcf"
 
@@ -33,8 +37,7 @@
     font.save(tempname)
 
     with Image.open(tempname.replace(".pil", ".pbm")) as loaded:
-        with Image.open("Tests/fonts/10x20.pbm") as target:
-            assert_image_equal(loaded, target)
+        assert_image_equal_tofile(loaded, "Tests/fonts/10x20.pbm")
 
     with open(tempname, "rb") as f_loaded:
         with open("Tests/fonts/10x20.pil", "rb") as f_target:
@@ -58,8 +61,7 @@
     im = Image.new("L", (130, 30), "white")
     draw = ImageDraw.Draw(im)
     draw.text((0, 0), message, "black", font=font)
-    with Image.open("Tests/images/test_draw_pbm_target.png") as target:
-        assert_image_similar(im, target, 0)
+    assert_image_similar_tofile(im, "Tests/images/test_draw_pbm_target.png", 0)
 
 
 def test_textsize(request, tmp_path):
@@ -80,8 +82,7 @@
     im = Image.new("L", (750, 30), "white")
     draw = ImageDraw.Draw(im)
     draw.text((0, 0), message, "black", font=font)
-    with Image.open("Tests/images/high_ascii_chars.png") as target:
-        assert_image_similar(im, target, 0)
+    assert_image_similar_tofile(im, "Tests/images/high_ascii_chars.png", 0)
 
 
 def test_high_characters(request, tmp_path):
('Tests', 'test_tiff_crashes.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,10 +24,23 @@
         "Tests/images/crash_1.tif",
         "Tests/images/crash_2.tif",
         "Tests/images/crash-2020-10-test.tif",
+        "Tests/images/crash-0c7e0e8e11ce787078f00b5b0ca409a167f070e0.tif",
+        "Tests/images/crash-0e16d3bfb83be87356d026d66919deaefca44dac.tif",
+        "Tests/images/crash-1152ec2d1a1a71395b6f2ce6721c38924d025bf3.tif",
+        "Tests/images/crash-1185209cf7655b5aed8ae5e77784dfdd18ab59e9.tif",
+        "Tests/images/crash-338516dbd2f0e83caddb8ce256c22db3bd6dc40f.tif",
+        "Tests/images/crash-4f085cc12ece8cde18758d42608bed6a2a2cfb1c.tif",
+        "Tests/images/crash-86214e58da443d2b80820cff9677a38a33dcbbca.tif",
+        "Tests/images/crash-f46f5b2f43c370fe65706c11449f567ecc345e74.tif",
+        "Tests/images/crash-63b1dffefc8c075ddc606c0a2f5fdc15ece78863.tif",
+        "Tests/images/crash-74d2a78403a5a59db1fb0a2b8735ac068a75f6e3.tif",
+        "Tests/images/crash-81154a65438ba5aaeca73fd502fa4850fbde60f8.tif",
+        "Tests/images/crash-0da013a13571cc8eb457a39fee8db18f8a3c7127.tif",
     ],
 )
 @pytest.mark.filterwarnings("ignore:Possibly corrupt EXIF data")
 @pytest.mark.filterwarnings("ignore:Metadata warning")
+@pytest.mark.filterwarnings("ignore:Truncated File Read")
 def test_tiff_crashes(test_file):
     try:
         with Image.open(test_file) as im:
('Tests', 'test_file_psd.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+import warnings
+
 import pytest
 
 from PIL import Image, PsdImagePlugin
@@ -29,20 +31,16 @@
 
 
 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(test_file)
         im.load()
         im.close()
 
-    pytest.warns(None, open)
-
 
 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(test_file) as im:
             im.load()
-
-    pytest.warns(None, open)
 
 
 def test_invalid_file():
@@ -57,9 +55,10 @@
         assert im.n_frames == 1
         assert not im.is_animated
 
-    with Image.open(test_file) as im:
-        assert im.n_frames == 2
-        assert im.is_animated
+    for path in [test_file, "Tests/images/negative_layer_count.psd"]:
+        with Image.open(path) as im:
+            assert im.n_frames == 2
+            assert im.is_animated
 
 
 def test_eoferror():
@@ -122,10 +121,33 @@
 
 
 def test_combined_larger_than_size():
-    # The 'combined' sizes of the individual parts is larger than the
+    # The combined size of the individual parts is larger than the
     # declared 'size' of the extra data field, resulting in a backwards seek.
 
     # If we instead take the 'size' of the extra data field as the source of truth,
     # then the seek can't be negative
     with pytest.raises(OSError):
-        Image.open("Tests/images/combined_larger_than_size.psd")
+        with Image.open("Tests/images/combined_larger_than_size.psd"):
+            pass
+
+
+@pytest.mark.parametrize(
+    "test_file,raises",
+    [
+        (
+            "Tests/images/timeout-1ee28a249896e05b83840ae8140622de8e648ba9.psd",
+            Image.UnidentifiedImageError,
+        ),
+        (
+            "Tests/images/timeout-598843abc37fc080ec36a2699ebbd44f795d3a6f.psd",
+            Image.UnidentifiedImageError,
+        ),
+        ("Tests/images/timeout-c8efc3fded6426986ba867a399791bae544f59bc.psd", OSError),
+        ("Tests/images/timeout-dedc7a4ebd856d79b4359bbcc79e8ef231ce38f6.psd", OSError),
+    ],
+)
+def test_crashes(test_file, raises):
+    with open(test_file, "rb") as f:
+        with pytest.raises(raises):
+            with Image.open(f):
+                pass
('Tests', 'test_file_dcx.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+import warnings
+
 import pytest
 
 from PIL import DcxImagePlugin, Image
@@ -31,20 +33,16 @@
 
 
 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(TEST_FILE)
         im.load()
         im.close()
 
-    pytest.warns(None, open)
-
 
 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(TEST_FILE) as im:
             im.load()
-
-    pytest.warns(None, open)
 
 
 def test_invalid_file():
('Tests', 'test_imageshow.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -51,6 +51,16 @@
         assert ImageShow.show(im)
 
 
+def test_show_without_viewers():
+    viewers = ImageShow._viewers
+    ImageShow._viewers = []
+
+    im = hopper()
+    assert not ImageShow.show(im)
+
+    ImageShow._viewers = viewers
+
+
 def test_viewer():
     viewer = ImageShow.Viewer()
 
@@ -62,4 +72,37 @@
 
 def test_viewers():
     for viewer in ImageShow._viewers:
-        viewer.get_command("test.jpg")
+        try:
+            viewer.get_command("test.jpg")
+        except NotImplementedError:
+            pass
+
+
+def test_ipythonviewer():
+    pytest.importorskip("IPython", reason="IPython not installed")
+    for viewer in ImageShow._viewers:
+        if isinstance(viewer, ImageShow.IPythonViewer):
+            test_viewer = viewer
+            break
+    else:
+        assert False
+
+    im = hopper()
+    assert test_viewer.show(im) == 1
+
+
+@pytest.mark.skipif(
+    not on_ci() or is_win32(),
+    reason="Only run on CIs; hangs on Windows CIs",
+)
+def test_file_deprecated(tmp_path):
+    f = str(tmp_path / "temp.jpg")
+    for viewer in ImageShow._viewers:
+        hopper().save(f)
+        with pytest.warns(DeprecationWarning):
+            try:
+                viewer.show_file(file=f)
+            except NotImplementedError:
+                pass
+        with pytest.raises(TypeError):
+            viewer.show_file()
('Tests', 'test_font_leaks.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,7 @@
 
 
 class TestTTypeFontLeak(PillowLeakTestCase):
-    # fails at iteration 3 in master
+    # fails at iteration 3 in main
     iterations = 10
     mem_limit = 4096  # k
 
@@ -24,7 +24,7 @@
 
 
 class TestDefaultFontLeak(TestTTypeFontLeak):
-    # fails at iteration 37 in master
+    # fails at iteration 37 in main
     iterations = 100
     mem_limit = 1024  # k
 
('Tests', 'test_qt_image_qapplication.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,16 +2,26 @@
 
 from PIL import ImageQt
 
-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper
 
 if ImageQt.qt_is_installed:
     from PIL.ImageQt import QPixmap
 
-    if ImageQt.qt_version == "side6":
+    if ImageQt.qt_version == "6":
+        from PyQt6.QtCore import QPoint
+        from PyQt6.QtGui import QImage, QPainter, QRegion
+        from PyQt6.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget
+    elif ImageQt.qt_version == "side6":
+        from PySide6.QtCore import QPoint
+        from PySide6.QtGui import QImage, QPainter, QRegion
         from PySide6.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget
     elif ImageQt.qt_version == "5":
+        from PyQt5.QtCore import QPoint
+        from PyQt5.QtGui import QImage, QPainter, QRegion
         from PyQt5.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget
     elif ImageQt.qt_version == "side2":
+        from PySide2.QtCore import QPoint
+        from PySide2.QtGui import QImage, QPainter, QRegion
         from PySide2.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget
 
     class Example(QWidget):
@@ -47,7 +57,8 @@
 
     for mode in ("1", "RGB", "RGBA", "L", "P"):
         # to QPixmap
-        data = ImageQt.toqpixmap(hopper(mode))
+        im = hopper(mode)
+        data = ImageQt.toqpixmap(im)
 
         assert isinstance(data, QPixmap)
         assert not data.isNull()
@@ -56,6 +67,20 @@
         tempfile = str(tmp_path / f"temp_{mode}.png")
         data.save(tempfile)
 
+        # Render the image
+        qimage = ImageQt.ImageQt(im)
+        data = QPixmap.fromImage(qimage)
+        qt_format = QImage.Format if ImageQt.qt_version == "6" else QImage
+        qimage = QImage(128, 128, qt_format.Format_ARGB32)
+        painter = QPainter(qimage)
+        image_label = QLabel()
+        image_label.setPixmap(data)
+        image_label.render(painter, QPoint(0, 0), QRegion(0, 0, 128, 128))
+        painter.end()
+        rendered_tempfile = str(tmp_path / f"temp_rendered_{mode}.png")
+        qimage.save(rendered_tempfile)
+        assert_image_equal_tofile(im.convert("RGBA"), rendered_tempfile)
+
         # from QPixmap
         roundtrip(hopper(mode))
 
('Tests', 'test_core_resources.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -110,9 +110,9 @@
 
         with pytest.raises(ValueError):
             Image.core.set_blocks_max(-1)
-        if sys.maxsize < 2 ** 32:
+        if sys.maxsize < 2**32:
             with pytest.raises(ValueError):
-                Image.core.set_blocks_max(2 ** 29)
+                Image.core.set_blocks_max(2**29)
 
     @pytest.mark.skipif(is_pypy(), reason="Images not collected")
     def test_set_blocks_max_stats(self):
('Tests', 'test_file_pcx.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -42,6 +42,14 @@
         # larger, odd sized images are better here to ensure that
         # we handle interrupted scan lines properly.
         _roundtrip(tmp_path, hopper(mode).resize((511, 511)))
+
+
+def test_odd_read():
+    # Reading an image with an odd stride, making it malformed
+    with Image.open("Tests/images/odd_stride.pcx") as im:
+        im.load()
+
+        assert im.size == (371, 150)
 
 
 def test_pil184():
('Tests', 'test_file_png.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,6 @@
 import re
+import sys
+import warnings
 import zlib
 from io import BytesIO
 
@@ -10,11 +12,17 @@
     PillowLeakTestCase,
     assert_image,
     assert_image_equal,
+    assert_image_equal_tofile,
     hopper,
-    is_big_endian,
     is_win32,
+    mark_if_feature_version,
     skip_unless_feature,
 )
+
+try:
+    import defusedxml.ElementTree as ElementTree
+except ImportError:
+    ElementTree = None
 
 # sample png stream
 
@@ -69,7 +77,6 @@
                     png.crc(cid, s)
         return chunks
 
-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
     def test_sanity(self, tmp_path):
 
         # internal version number
@@ -106,7 +113,8 @@
 
         test_file = "Tests/images/broken.png"
         with pytest.raises(OSError):
-            Image.open(test_file)
+            with Image.open(test_file):
+                pass
 
     def test_bad_text(self):
         # Make sure PIL can read malformed tEXt chunks (@PIL152)
@@ -324,7 +332,8 @@
 
         with Image.open(TEST_PNG_FILE) as im:
             # Assert that there is no unclosed file warning
-            pytest.warns(None, im.verify)
+            with warnings.catch_warnings():
+                im.verify()
 
         with Image.open(TEST_PNG_FILE) as im:
             im.load()
@@ -380,25 +389,12 @@
         # Check dpi roundtripping
 
         with Image.open(TEST_PNG_FILE) as im:
-            im = roundtrip(im, dpi=(100, 100))
-        assert im.info["dpi"] == (100, 100)
-
-    def test_load_dpi_rounding(self):
-        # Round up
-        with Image.open(TEST_PNG_FILE) as im:
-            assert im.info["dpi"] == (96, 96)
-
-        # Round down
-        with Image.open("Tests/images/icc_profile_none.png") as im:
-            assert im.info["dpi"] == (72, 72)
-
-    def test_save_dpi_rounding(self):
-        with Image.open(TEST_PNG_FILE) as im:
-            im = roundtrip(im, dpi=(72.2, 72.2))
-        assert im.info["dpi"] == (72, 72)
-
-        im = roundtrip(im, dpi=(72.8, 72.8))
-        assert im.info["dpi"] == (73, 73)
+            im = roundtrip(im, dpi=(100.33, 100.33))
+        assert im.info["dpi"] == (100.33, 100.33)
+
+    def test_load_float_dpi(self):
+        with Image.open(TEST_PNG_FILE) as im:
+            assert im.info["dpi"] == (95.9866, 95.9866)
 
     def test_roundtrip_text(self):
         # Check text roundtripping
@@ -464,7 +460,8 @@
 
         pngfile = BytesIO(data)
         with pytest.raises(OSError):
-            Image.open(pngfile)
+            with Image.open(pngfile):
+                pass
 
     def test_trns_rgb(self):
         # Check writing and reading of tRNS chunks for RGB images.
@@ -513,6 +510,8 @@
 
     def test_discard_icc_profile(self):
         with Image.open("Tests/images/icc_profile.png") as im:
+            assert "icc_profile" in im.info
+
             im = roundtrip(im, icc_profile=None)
         assert "icc_profile" not in im.info
 
@@ -571,8 +570,8 @@
         assert len(chunks) == 3
 
     def test_read_private_chunks(self):
-        im = Image.open("Tests/images/exif.png")
-        assert im.private_chunks == [(b"orNT", b"\x01")]
+        with Image.open("Tests/images/exif.png") as im:
+            assert im.private_chunks == [(b"orNT", b"\x01")]
 
     def test_roundtrip_private_chunk(self):
         # Check private chunk roundtripping
@@ -619,6 +618,54 @@
         with Image.open("Tests/images/hopper_idat_after_image_end.png") as im:
             assert im.text == {"TXT": "VALUE", "ZIP": "VALUE"}
 
+    def test_padded_idat(self):
+        # This image has been manually hexedited
+        # so that the IDAT chunk has padding at the end
+        # Set MAXBLOCK to the length of the actual data
+        # so that the decoder finishes reading before the chunk ends
+        MAXBLOCK = ImageFile.MAXBLOCK
+        ImageFile.MAXBLOCK = 45
+        ImageFile.LOAD_TRUNCATED_IMAGES = True
+
+        with Image.open("Tests/images/padded_idat.png") as im:
+            im.load()
+
+            ImageFile.MAXBLOCK = MAXBLOCK
+            ImageFile.LOAD_TRUNCATED_IMAGES = False
+
+            assert_image_equal_tofile(im, "Tests/images/bw_gradient.png")
+
+    def test_specify_bits(self, tmp_path):
+        im = hopper("P")
+
+        out = str(tmp_path / "temp.png")
+        im.save(out, bits=4)
+
+        with Image.open(out) as reloaded:
+            assert len(reloaded.png.im_palette[1]) == 48
+
+    def test_plte_length(self, tmp_path):
+        im = Image.new("P", (1, 1))
+        im.putpalette((1, 1, 1))
+
+        out = str(tmp_path / "temp.png")
+        im.save(str(tmp_path / "temp.png"))
+
+        with Image.open(out) as reloaded:
+            assert len(reloaded.png.im_palette[1]) == 3
+
+    def test_getxmp(self):
+        with Image.open("Tests/images/color_snakes.png") as im:
+            if ElementTree is None:
+                with pytest.warns(UserWarning):
+                    assert im.getxmp() == {}
+            else:
+                xmp = im.getxmp()
+
+                description = xmp["xmpmeta"]["RDF"]["Description"]
+                assert description["PixelXDimension"] == "10"
+                assert description["subject"]["Seq"] is None
+
     def test_exif(self):
         # With an EXIF chunk
         with Image.open("Tests/images/exif.png") as im:
@@ -654,6 +701,9 @@
             exif = reloaded._getexif()
         assert exif[274] == 1
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_exif_from_jpg(self, tmp_path):
         with Image.open("Tests/images/pil_sample_rgb.jpg") as im:
             test_file = str(tmp_path / "temp.png")
@@ -681,6 +731,32 @@
 
             with pytest.raises(EOFError):
                 im.seek(1)
+
+    @pytest.mark.parametrize("buffer", (True, False))
+    def test_save_stdout(self, buffer):
+        old_stdout = sys.stdout
+
+        if buffer:
+
+            class MyStdOut:
+                buffer = BytesIO()
+
+            mystdout = MyStdOut()
+        else:
+            mystdout = BytesIO()
+
+        sys.stdout = mystdout
+
+        with Image.open(TEST_PNG_FILE) as im:
+            im.save(sys.stdout, "PNG")
+
+        # Reset stdout
+        sys.stdout = old_stdout
+
+        if buffer:
+            mystdout = mystdout.buffer
+        with Image.open(mystdout) as reloaded:
+            assert_image_equal_tofile(reloaded, TEST_PNG_FILE)
 
 
 @pytest.mark.skipif(is_win32(), reason="Requires Unix or macOS")
('Tests', 'test_imagegrab.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,7 +6,7 @@
 
 from PIL import Image, ImageGrab
 
-from .helper import assert_image, assert_image_equal_tofile, skip_unless_feature
+from .helper import assert_image_equal_tofile, skip_unless_feature
 
 
 class TestImageGrab:
@@ -14,25 +14,20 @@
         sys.platform not in ("win32", "darwin"), reason="requires Windows or macOS"
     )
     def test_grab(self):
-        for im in [
-            ImageGrab.grab(),
-            ImageGrab.grab(include_layered_windows=True),
-            ImageGrab.grab(all_screens=True),
-        ]:
-            assert_image(im, im.mode, im.size)
+        ImageGrab.grab()
+        ImageGrab.grab(include_layered_windows=True)
+        ImageGrab.grab(all_screens=True)
 
         im = ImageGrab.grab(bbox=(10, 20, 50, 80))
-        assert_image(im, im.mode, (40, 60))
+        assert im.size == (40, 60)
 
     @skip_unless_feature("xcb")
     def test_grab_x11(self):
         try:
             if sys.platform not in ("win32", "darwin"):
-                im = ImageGrab.grab()
-                assert_image(im, im.mode, im.size)
+                ImageGrab.grab()
 
-            im2 = ImageGrab.grab(xdisplay="")
-            assert_image(im2, im2.mode, im2.size)
+            ImageGrab.grab(xdisplay="")
         except OSError as e:
             pytest.skip(str(e))
 
@@ -71,8 +66,7 @@
             assert str(e.value) == "ImageGrab.grabclipboard() is macOS and Windows only"
             return
 
-        im = ImageGrab.grabclipboard()
-        assert_image(im, im.mode, im.size)
+        ImageGrab.grabclipboard()
 
     @pytest.mark.skipif(sys.platform != "win32", reason="Windows only")
     def test_grabclipboard_file(self):
('Tests', 'test_file_bmp.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,12 @@
 
 from PIL import BmpImagePlugin, Image
 
-from .helper import assert_image_equal, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
+    hopper,
+)
 
 
 def test_sanity(tmp_path):
@@ -63,7 +68,7 @@
 
     output.seek(0)
     with Image.open(output) as reloaded:
-        assert reloaded.info["dpi"] == dpi
+        assert reloaded.info["dpi"] == (72.008961115161, 72.008961115161)
 
 
 def test_save_bmp_with_dpi(tmp_path):
@@ -71,6 +76,7 @@
     # Arrange
     outfile = str(tmp_path / "temp.jpg")
     with Image.open("Tests/images/hopper.bmp") as im:
+        assert im.info["dpi"] == (95.98654816726399, 95.98654816726399)
 
         # Act
         im.save(outfile, "JPEG", dpi=im.info["dpi"])
@@ -78,31 +84,17 @@
         # Assert
         with Image.open(outfile) as reloaded:
             reloaded.load()
-            assert im.info["dpi"] == reloaded.info["dpi"]
-            assert im.size == reloaded.size
+            assert reloaded.info["dpi"] == (96, 96)
+            assert reloaded.size == im.size
             assert reloaded.format == "JPEG"
 
 
-def test_load_dpi_rounding():
-    # Round up
-    with Image.open("Tests/images/hopper.bmp") as im:
-        assert im.info["dpi"] == (96, 96)
-
-    # Round down
-    with Image.open("Tests/images/hopper_roundDown.bmp") as im:
-        assert im.info["dpi"] == (72, 72)
-
-
-def test_save_dpi_rounding(tmp_path):
+def test_save_float_dpi(tmp_path):
     outfile = str(tmp_path / "temp.bmp")
     with Image.open("Tests/images/hopper.bmp") as im:
-        im.save(outfile, dpi=(72.2, 72.2))
+        im.save(outfile, dpi=(72.21216100543306, 72.21216100543306))
         with Image.open(outfile) as reloaded:
-            assert reloaded.info["dpi"] == (72, 72)
-
-        im.save(outfile, dpi=(72.8, 72.8))
-    with Image.open(outfile) as reloaded:
-        assert reloaded.info["dpi"] == (73, 73)
+            assert reloaded.info["dpi"] == (72.21216100543306, 72.21216100543306)
 
 
 def test_load_dib():
@@ -111,8 +103,7 @@
         assert im.format == "DIB"
         assert im.get_format_mimetype() == "image/bmp"
 
-        with Image.open("Tests/images/clipboard_target.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/clipboard_target.png")
 
 
 def test_save_dib(tmp_path):
@@ -136,5 +127,47 @@
         b, g, r = im.split()[1:]
         im = Image.merge("RGB", (r, g, b))
 
-    with Image.open("Tests/images/bmp/q/rgb32bf-xbgr.bmp") as target:
-        assert_image_equal(im, target)
+    assert_image_equal_tofile(im, "Tests/images/bmp/q/rgb32bf-xbgr.bmp")
+
+
+def test_rle8():
+    with Image.open("Tests/images/hopper_rle8.bmp") as im:
+        assert_image_similar_tofile(im.convert("RGB"), "Tests/images/hopper.bmp", 12)
+
+    # This test image has been manually hexedited
+    # to have rows with too much data
+    with Image.open("Tests/images/hopper_rle8_row_overflow.bmp") as im:
+        assert_image_similar_tofile(im.convert("RGB"), "Tests/images/hopper.bmp", 12)
+
+    # Signal end of bitmap before the image is finished
+    with open("Tests/images/bmp/g/pal8rle.bmp", "rb") as fp:
+        data = fp.read(1063) + b"\x01"
+        with Image.open(io.BytesIO(data)) as im:
+            with pytest.raises(ValueError):
+                im.load()
+
+
+@pytest.mark.parametrize(
+    "file_name,length",
+    (
+        # EOF immediately after the header
+        ("Tests/images/hopper_rle8.bmp", 1078),
+        # EOF during delta
+        ("Tests/images/bmp/q/pal8rletrns.bmp", 3670),
+        # EOF when reading data in absolute mode
+        ("Tests/images/bmp/g/pal8rle.bmp", 1064),
+    ),
+)
+def test_rle8_eof(file_name, length):
+    with open(file_name, "rb") as fp:
+        data = fp.read(length)
+        with Image.open(io.BytesIO(data)) as im:
+            with pytest.raises(ValueError):
+                im.load()
+
+
+def test_offset():
+    # This image has been hexedited
+    # to exclude the palette size from the pixel data offset
+    with Image.open("Tests/images/pal8_offset.bmp") as im:
+        assert_image_equal_tofile(im, "Tests/images/bmp/g/pal8.bmp")
('Tests', 'test_file_im.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,10 +1,11 @@
 import filecmp
+import warnings
 
 import pytest
 
 from PIL import Image, ImImagePlugin
 
-from .helper import assert_image_equal, hopper, is_pypy
+from .helper import assert_image_equal_tofile, hopper, is_pypy
 
 # sample im
 TEST_IM = "Tests/images/hopper.im"
@@ -35,20 +36,16 @@
 
 
 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(TEST_IM)
         im.load()
         im.close()
 
-    pytest.warns(None, open)
-
 
 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(TEST_IM) as im:
             im.load()
-
-    pytest.warns(None, open)
 
 
 def test_tell():
@@ -86,8 +83,7 @@
         out = str(tmp_path / "temp.im")
         im = hopper(mode)
         im.save(out)
-        with Image.open(out) as reread:
-            assert_image_equal(reread, im)
+        assert_image_equal_tofile(im, out)
 
     for mode in ["RGB", "P", "PA"]:
         roundtrip(mode)
('Tests', 'test_image_rotate.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,11 @@
 from PIL import Image
 
-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar,
+    hopper,
+)
 
 
 def rotate(im, mode, angle, center=None, translate=None):
@@ -28,6 +33,9 @@
         with Image.open("Tests/images/test-card.png") as im:
             rotate(im, im.mode, angle)
 
+        im = hopper()
+        assert_image_equal(im.rotate(angle), im.rotate(angle, expand=1))
+
 
 def test_zero():
     for angle in (0, 45, 90, 180, 270):
@@ -38,14 +46,14 @@
 def test_resample():
     # Target image creation, inspected by eye.
     # >>> im = Image.open('Tests/images/hopper.ppm')
-    # >>> im = im.rotate(45, resample=Image.BICUBIC, expand=True)
+    # >>> im = im.rotate(45, resample=Image.Resampling.BICUBIC, expand=True)
     # >>> im.save('Tests/images/hopper_45.png')
 
     with Image.open("Tests/images/hopper_45.png") as target:
         for (resample, epsilon) in (
-            (Image.NEAREST, 10),
-            (Image.BILINEAR, 5),
-            (Image.BICUBIC, 0),
+            (Image.Resampling.NEAREST, 10),
+            (Image.Resampling.BILINEAR, 5),
+            (Image.Resampling.BICUBIC, 0),
         ):
             im = hopper()
             im = im.rotate(45, resample=resample, expand=True)
@@ -54,7 +62,7 @@
 
 def test_center_0():
     im = hopper()
-    im = im.rotate(45, center=(0, 0), resample=Image.BICUBIC)
+    im = im.rotate(45, center=(0, 0), resample=Image.Resampling.BICUBIC)
 
     with Image.open("Tests/images/hopper_45.png") as target:
         target_origin = target.size[1] / 2
@@ -65,7 +73,7 @@
 
 def test_center_14():
     im = hopper()
-    im = im.rotate(45, center=(14, 14), resample=Image.BICUBIC)
+    im = im.rotate(45, center=(14, 14), resample=Image.Resampling.BICUBIC)
 
     with Image.open("Tests/images/hopper_45.png") as target:
         target_origin = target.size[1] / 2 - 14
@@ -82,7 +90,7 @@
             (target_origin, target_origin, target_origin + 128, target_origin + 128)
         )
 
-    im = im.rotate(45, translate=(5, 5), resample=Image.BICUBIC)
+    im = im.rotate(45, translate=(5, 5), resample=Image.Resampling.BICUBIC)
 
     assert_image_similar(im, target, 1)
 
@@ -113,15 +121,13 @@
 def test_rotate_no_fill():
     im = Image.new("RGB", (100, 100), "green")
     im = im.rotate(45)
-    with Image.open("Tests/images/rotate_45_no_fill.png") as target:
-        assert_image_equal(im, target)
+    assert_image_equal_tofile(im, "Tests/images/rotate_45_no_fill.png")
 
 
 def test_rotate_with_fill():
     im = Image.new("RGB", (100, 100), "green")
     im = im.rotate(45, fillcolor="white")
-    with Image.open("Tests/images/rotate_45_with_fill.png") as target:
-        assert_image_equal(im, target)
+    assert_image_equal_tofile(im, "Tests/images/rotate_45_with_fill.png")
 
 
 def test_alpha_rotate_no_fill():
('Tests', 'test_pickle.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,9 +2,12 @@
 
 import pytest
 
-from PIL import Image
+from PIL import Image, ImageDraw, ImageFont
 
-from .helper import skip_unless_feature
+from .helper import assert_image_equal, skip_unless_feature
+
+FONT_SIZE = 20
+FONT_PATH = "Tests/fonts/DejaVuSans/DejaVuSans.ttf"
 
 
 def helper_pickle_file(tmp_path, pickle, protocol, test_file, mode):
@@ -85,10 +88,55 @@
 @skip_unless_feature("webp")
 def test_pickle_tell():
     # Arrange
-    image = Image.open("Tests/images/hopper.webp")
+    with Image.open("Tests/images/hopper.webp") as image:
 
-    # Act: roundtrip
-    unpickled_image = pickle.loads(pickle.dumps(image))
+        # Act: roundtrip
+        unpickled_image = pickle.loads(pickle.dumps(image))
 
     # Assert
     assert unpickled_image.tell() == 0
+
+
+def helper_assert_pickled_font_images(font1, font2):
+    # Arrange
+    im1 = Image.new(mode="RGBA", size=(300, 100))
+    im2 = Image.new(mode="RGBA", size=(300, 100))
+    draw1 = ImageDraw.Draw(im1)
+    draw2 = ImageDraw.Draw(im2)
+    txt = "Hello World!"
+
+    # Act
+    draw1.text((10, 10), txt, font=font1)
+    draw2.text((10, 10), txt, font=font2)
+
+    # Assert
+    assert_image_equal(im1, im2)
+
+
+@pytest.mark.parametrize("protocol", list(range(0, pickle.HIGHEST_PROTOCOL + 1)))
+def test_pickle_font_string(protocol):
+    # Arrange
+    font = ImageFont.truetype(FONT_PATH, FONT_SIZE)
+
+    # Act: roundtrip
+    pickled_font = pickle.dumps(font, protocol)
+    unpickled_font = pickle.loads(pickled_font)
+
+    # Assert
+    helper_assert_pickled_font_images(font, unpickled_font)
+
+
+@pytest.mark.parametrize("protocol", list(range(0, pickle.HIGHEST_PROTOCOL + 1)))
+def test_pickle_font_file(tmp_path, protocol):
+    # Arrange
+    font = ImageFont.truetype(FONT_PATH, FONT_SIZE)
+    filename = str(tmp_path / "temp.pkl")
+
+    # Act: roundtrip
+    with open(filename, "wb") as f:
+        pickle.dump(font, f, protocol)
+    with open(filename, "rb") as f:
+        unpickled_font = pickle.load(f)
+
+    # Assert
+    helper_assert_pickled_font_images(font, unpickled_font)
('Tests', 'test_file_blp.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,21 +1,82 @@
-from PIL import Image
+import pytest
 
-from .helper import assert_image_equal
+from PIL import BlpImagePlugin, Image
+
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar,
+    hopper,
+)
+
+
+def test_load_blp1():
+    with Image.open("Tests/images/blp/blp1_jpeg.blp") as im:
+        assert_image_equal_tofile(im, "Tests/images/blp/blp1_jpeg.png")
 
 
 def test_load_blp2_raw():
     with Image.open("Tests/images/blp/blp2_raw.blp") as im:
-        with Image.open("Tests/images/blp/blp2_raw.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/blp/blp2_raw.png")
 
 
 def test_load_blp2_dxt1():
     with Image.open("Tests/images/blp/blp2_dxt1.blp") as im:
-        with Image.open("Tests/images/blp/blp2_dxt1.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/blp/blp2_dxt1.png")
 
 
 def test_load_blp2_dxt1a():
     with Image.open("Tests/images/blp/blp2_dxt1a.blp") as im:
-        with Image.open("Tests/images/blp/blp2_dxt1a.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/blp/blp2_dxt1a.png")
+
+
+def test_save(tmp_path):
+    f = str(tmp_path / "temp.blp")
+
+    for version in ("BLP1", "BLP2"):
+        im = hopper("P")
+        im.save(f, blp_version=version)
+
+        with Image.open(f) as reloaded:
+            assert_image_equal(im.convert("RGB"), reloaded)
+
+        with Image.open("Tests/images/transparent.png") as im:
+            f = str(tmp_path / "temp.blp")
+            im.convert("P").save(f, blp_version=version)
+
+            with Image.open(f) as reloaded:
+                assert_image_similar(im, reloaded, 8)
+
+    im = hopper()
+    with pytest.raises(ValueError):
+        im.save(f)
+
+
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/images/timeout-060745d3f534ad6e4128c51d336ea5489182c69d.blp",
+        "Tests/images/timeout-31c8f86233ea728339c6e586be7af661a09b5b98.blp",
+        "Tests/images/timeout-60d8b7c8469d59fc9ffff6b3a3dc0faeae6ea8ee.blp",
+        "Tests/images/timeout-8073b430977660cdd48d96f6406ddfd4114e69c7.blp",
+        "Tests/images/timeout-bba4f2e026b5786529370e5dfe9a11b1bf991f07.blp",
+        "Tests/images/timeout-d6ec061c4afdef39d3edf6da8927240bb07fe9b7.blp",
+        "Tests/images/timeout-ef9112a065e7183fa7faa2e18929b03e44ee16bf.blp",
+    ],
+)
+def test_crashes(test_file):
+    with open(test_file, "rb") as f:
+        with Image.open(f) as im:
+            with pytest.raises(OSError):
+                im.load()
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        BlpImagePlugin.Format: "BLP_FORMAT_",
+        BlpImagePlugin.Encoding: "BLP_ENCODING_",
+        BlpImagePlugin.AlphaEncoding: "BLP_ALPHA_ENCODING_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(BlpImagePlugin, prefix + name) == enum[name]
('Tests', 'test_imagefont.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,7 +13,6 @@
 from .helper import (
     assert_image_equal,
     assert_image_equal_tofile,
-    assert_image_similar,
     assert_image_similar_tofile,
     is_win32,
     skip_unless_feature,
@@ -30,7 +29,7 @@
 
 
 class TestImageFont:
-    LAYOUT_ENGINE = ImageFont.LAYOUT_BASIC
+    LAYOUT_ENGINE = ImageFont.Layout.BASIC
 
     def get_font(self):
         return ImageFont.truetype(
@@ -52,7 +51,7 @@
         ttf_copy = ttf.font_variant(size=FONT_SIZE + 1)
         assert ttf_copy.size == FONT_SIZE + 1
 
-        second_font_path = "Tests/fonts/DejaVuSans.ttf"
+        second_font_path = "Tests/fonts/DejaVuSans/DejaVuSans.ttf"
         ttf_copy = ttf.font_variant(font=second_font_path)
         assert ttf_copy.path == second_font_path
 
@@ -89,19 +88,6 @@
 
         ImageFont.truetype(tempfile, FONT_SIZE)
 
-    def test_unavailable_layout_engine(self):
-        have_raqm = ImageFont.core.HAVE_RAQM
-        ImageFont.core.HAVE_RAQM = False
-
-        try:
-            ttf = ImageFont.truetype(
-                FONT_PATH, FONT_SIZE, layout_engine=ImageFont.LAYOUT_RAQM
-            )
-        finally:
-            ImageFont.core.HAVE_RAQM = have_raqm
-
-        assert ttf.layout_engine == ImageFont.LAYOUT_BASIC
-
     def _render(self, font):
         txt = "Hello World!"
         ttf = ImageFont.truetype(font, FONT_SIZE, layout_engine=self.LAYOUT_ENGINE)
@@ -130,8 +116,21 @@
         draw.text((10, 10), txt, font=ttf)
 
         target = "Tests/images/transparent_background_text.png"
-        with Image.open(target) as target_img:
-            assert_image_similar(im, target_img, 4.09)
+        assert_image_similar_tofile(im, target, 4.09)
+
+        target = "Tests/images/transparent_background_text_L.png"
+        assert_image_similar_tofile(im.convert("L"), target, 0.01)
+
+    def test_I16(self):
+        im = Image.new(mode="I;16", size=(300, 100))
+        draw = ImageDraw.Draw(im)
+        ttf = self.get_font()
+
+        txt = "Hello World!"
+        draw.text((10, 10), txt, font=ttf)
+
+        target = "Tests/images/transparent_background_text_L.png"
+        assert_image_similar_tofile(im.convert("L"), target, 0.01)
 
     def test_textsize_equal(self):
         im = Image.new(mode="RGB", size=(300, 100))
@@ -143,11 +142,9 @@
         draw.text((10, 10), txt, font=ttf)
         draw.rectangle((10, 10, 10 + size[0], 10 + size[1]))
 
-        target = "Tests/images/rectangle_surrounding_text.png"
-        with Image.open(target) as target_img:
-
-            # Epsilon ~.5 fails with FreeType 2.7
-            assert_image_similar(im, target_img, 2.5)
+        assert_image_similar_tofile(
+            im, "Tests/images/rectangle_surrounding_text.png", 2.5
+        )
 
     @pytest.mark.parametrize(
         "text, mode, font, size, length_basic, length_raqm",
@@ -156,8 +153,8 @@
             ("text", "L", "FreeMono.ttf", 15, 36, 36),
             ("text", "1", "FreeMono.ttf", 15, 36, 36),
             # issue 4177
-            ("rrr", "L", "DejaVuSans.ttf", 18, 21, 22.21875),
-            ("rrr", "1", "DejaVuSans.ttf", 18, 24, 22.21875),
+            ("rrr", "L", "DejaVuSans/DejaVuSans.ttf", 18, 21, 22.21875),
+            ("rrr", "1", "DejaVuSans/DejaVuSans.ttf", 18, 24, 22.21875),
             # test 'l' not including extra margin
             # using exact value 2047 / 64 for raqm, checked with debugger
             ("ill", "L", "OpenSansCondensed-LightItalic.ttf", 63, 33, 31.984375),
@@ -172,7 +169,7 @@
         im = Image.new(mode, (1, 1), 0)
         d = ImageDraw.Draw(im)
 
-        if self.LAYOUT_ENGINE == ImageFont.LAYOUT_BASIC:
+        if self.LAYOUT_ENGINE == ImageFont.Layout.BASIC:
             length = d.textlength(text, f)
             assert length == length_basic
         else:
@@ -191,13 +188,10 @@
             draw.text((0, y), line, font=ttf)
             y += line_spacing
 
-        target = "Tests/images/multiline_text.png"
-        with Image.open(target) as target_img:
-
-            # some versions of freetype have different horizontal spacing.
-            # setting a tight epsilon, I'm showing the original test failure
-            # at epsilon = ~38.
-            assert_image_similar(im, target_img, 6.2)
+        # some versions of freetype have different horizontal spacing.
+        # setting a tight epsilon, I'm showing the original test failure
+        # at epsilon = ~38.
+        assert_image_similar_tofile(im, "Tests/images/multiline_text.png", 6.2)
 
     def test_render_multiline_text(self):
         ttf = self.get_font()
@@ -208,11 +202,7 @@
         draw = ImageDraw.Draw(im)
         draw.text((0, 0), TEST_TEXT, font=ttf)
 
-        target = "Tests/images/multiline_text.png"
-        with Image.open(target) as target_img:
-
-            # Epsilon ~.5 fails with FreeType 2.7
-            assert_image_similar(im, target_img, 6.2)
+        assert_image_similar_tofile(im, "Tests/images/multiline_text.png", 0.01)
 
         # Test that text() can pass on additional arguments
         # to multiline_text()
@@ -227,11 +217,9 @@
             draw = ImageDraw.Draw(im)
             draw.multiline_text((0, 0), TEST_TEXT, font=ttf, align=align)
 
-            target = "Tests/images/multiline_text" + ext + ".png"
-            with Image.open(target) as target_img:
-
-                # Epsilon ~.5 fails with FreeType 2.7
-                assert_image_similar(im, target_img, 6.2)
+            assert_image_similar_tofile(
+                im, "Tests/images/multiline_text" + ext + ".png", 0.01
+            )
 
     def test_unknown_align(self):
         im = Image.new(mode="RGB", size=(300, 100))
@@ -285,11 +273,7 @@
         draw = ImageDraw.Draw(im)
         draw.multiline_text((0, 0), TEST_TEXT, font=ttf, spacing=10)
 
-        target = "Tests/images/multiline_text_spacing.png"
-        with Image.open(target) as target_img:
-
-            # Epsilon ~.5 fails with FreeType 2.7
-            assert_image_similar(im, target_img, 6.2)
+        assert_image_similar_tofile(im, "Tests/images/multiline_text_spacing.png", 2.5)
 
     def test_rotated_transposed_font(self):
         img_grey = Image.new("L", (100, 100))
@@ -297,7 +281,7 @@
         word = "testing"
         font = self.get_font()
 
-        orientation = Image.ROTATE_90
+        orientation = Image.Transpose.ROTATE_90
         transposed_font = ImageFont.TransposedFont(font, orientation=orientation)
 
         # Original font
@@ -336,7 +320,7 @@
         # Arrange
         text = "mask this"
         font = self.get_font()
-        orientation = Image.ROTATE_90
+        orientation = Image.Transpose.ROTATE_90
         transposed_font = ImageFont.TransposedFont(font, orientation=orientation)
 
         # Act
@@ -423,15 +407,12 @@
         im = Image.new(mode="RGB", size=(300, 100))
         draw = ImageDraw.Draw(im)
 
-        target = "Tests/images/default_font.png"
-        with Image.open(target) as target_img:
-
-            # Act
-            default_font = ImageFont.load_default()
-            draw.text((10, 10), txt, font=default_font)
-
-            # Assert
-            assert_image_equal(im, target_img)
+        # Act
+        default_font = ImageFont.load_default()
+        draw.text((10, 10), txt, font=default_font)
+
+        # Assert
+        assert_image_equal_tofile(im, "Tests/images/default_font.png")
 
     def test_getsize_empty(self):
         # issue #2614
@@ -610,7 +591,7 @@
         # Arrange
         t = self.get_font()
         # Act / Assert
-        if t.layout_engine == ImageFont.LAYOUT_BASIC:
+        if t.layout_engine == ImageFont.Layout.BASIC:
             with pytest.raises(KeyError):
                 t.getmask("абвг", direction="rtl")
             with pytest.raises(KeyError):
@@ -680,13 +661,11 @@
         d.text((10, 10), "Text", font=font, fill="black")
 
         try:
-            with Image.open(path) as expected:
-                assert_image_similar(im, expected, epsilon)
+            assert_image_similar_tofile(im, path, epsilon)
         except AssertionError:
             if "_adobe" in path:
                 path = path.replace("_adobe", "_adobe_older_harfbuzz")
-                with Image.open(path) as expected:
-                    assert_image_similar(im, expected, epsilon)
+                assert_image_similar_tofile(im, path, epsilon)
             else:
                 raise
 
@@ -734,31 +713,34 @@
         font.set_variation_by_axes([100])
         self._check_text(font, "Tests/images/variation_tiny_axes.png", 32.5)
 
+    def test_textbbox_non_freetypefont(self):
+        im = Image.new("RGB", (200, 200))
+        d = ImageDraw.Draw(im)
+        default_font = ImageFont.load_default()
+        with pytest.raises(ValueError):
+            d.textbbox((0, 0), "test", font=default_font)
+
     @pytest.mark.parametrize(
-        "anchor, left, left_old, top",
+        "anchor, left, top",
         (
             # test horizontal anchors
-            ("ls", 0, 0, -36),
-            ("ms", -64, -65, -36),
-            ("rs", -128, -129, -36),
+            ("ls", 0, -36),
+            ("ms", -64, -36),
+            ("rs", -128, -36),
             # test vertical anchors
-            ("ma", -64, -65, 16),
-            ("mt", -64, -65, 0),
-            ("mm", -64, -65, -17),
-            ("mb", -64, -65, -44),
-            ("md", -64, -65, -51),
+            ("ma", -64, 16),
+            ("mt", -64, 0),
+            ("mm", -64, -17),
+            ("mb", -64, -44),
+            ("md", -64, -51),
         ),
         ids=("ls", "ms", "rs", "ma", "mt", "mm", "mb", "md"),
     )
-    def test_anchor(self, anchor, left, left_old, top):
+    def test_anchor(self, anchor, left, top):
         name, text = "quick", "Quick"
         path = f"Tests/images/test_anchor_{name}_{anchor}.png"
 
-        freetype = parse_version(features.version_module("freetype2"))
-        if freetype < parse_version("2.4"):
-            width, height = (129, 44)
-            left = left_old
-        elif self.LAYOUT_ENGINE == ImageFont.LAYOUT_RAQM:
+        if self.LAYOUT_ENGINE == ImageFont.Layout.RAQM:
             width, height = (129, 44)
         else:
             width, height = (128, 44)
@@ -777,8 +759,7 @@
 
         assert d.textbbox((0, 0), text, f, anchor=anchor) == bbox_expected
 
-        with Image.open(path) as expected:
-            assert_image_similar(im, expected, 7)
+        assert_image_similar_tofile(im, path, 7)
 
     @pytest.mark.parametrize(
         "anchor, align",
@@ -816,8 +797,7 @@
             (300, 200), text, fill="black", anchor=anchor, font=f, align=align
         )
 
-        with Image.open(target) as expected:
-            assert_image_similar(im, expected, 4)
+        assert_image_similar_tofile(im, target, 4)
 
     def test_anchor_invalid(self):
         font = self.get_font()
@@ -855,7 +835,7 @@
         layout_name = ["basic", "raqm"][self.LAYOUT_ENGINE]
         target = f"Tests/images/bitmap_font_{bpp}_{layout_name}.png"
         font = ImageFont.truetype(
-            f"Tests/fonts/DejaVuSans-24-{bpp}-stripped.ttf",
+            f"Tests/fonts/DejaVuSans/DejaVuSans-24-{bpp}-stripped.ttf",
             24,
             layout_engine=self.LAYOUT_ENGINE,
         )
@@ -865,6 +845,22 @@
         draw.text((2, 2), text, "black", font)
 
         assert_image_equal_tofile(im, target)
+
+    def test_bitmap_font_stroke(self):
+        text = "Bitmap Font"
+        layout_name = ["basic", "raqm"][self.LAYOUT_ENGINE]
+        target = f"Tests/images/bitmap_font_stroke_{layout_name}.png"
+        font = ImageFont.truetype(
+            "Tests/fonts/DejaVuSans/DejaVuSans-24-8-stripped.ttf",
+            24,
+            layout_engine=self.LAYOUT_ENGINE,
+        )
+
+        im = Image.new("RGB", (160, 35), "white")
+        draw = ImageDraw.Draw(im)
+        draw.text((2, 2), text, "black", font, stroke_width=2, stroke_fill="red")
+
+        assert_image_similar_tofile(im, target, 0.03)
 
     def test_standard_embedded_color(self):
         txt = "Hello World!"
@@ -875,10 +871,8 @@
         d = ImageDraw.Draw(im)
         d.text((10, 10), txt, font=ttf, fill="#fa6", embedded_color=True)
 
-        with Image.open("Tests/images/standard_embedded.png") as expected:
-            assert_image_similar(im, expected, 6.2)
-
-    @skip_unless_feature_version("freetype2", "2.5.0")
+        assert_image_similar_tofile(im, "Tests/images/standard_embedded.png", 6.2)
+
     def test_cbdt(self):
         try:
             font = ImageFont.truetype(
@@ -890,15 +884,13 @@
             im = Image.new("RGB", (150, 150), "white")
             d = ImageDraw.Draw(im)
 
-            d.text((10, 10), "\U0001f469", embedded_color=True, font=font)
-
-            with Image.open("Tests/images/cbdt_notocoloremoji.png") as expected:
-                assert_image_similar(im, expected, 6.2)
-        except IOError as e:
+            d.text((10, 10), "\U0001f469", font=font, embedded_color=True)
+
+            assert_image_similar_tofile(im, "Tests/images/cbdt_notocoloremoji.png", 6.2)
+        except OSError as e:  # pragma: no cover
             assert str(e) in ("unimplemented feature", "unknown file format")
-            pytest.skip("freetype compiled without libpng or unsupported")
-
-    @skip_unless_feature_version("freetype2", "2.5.0")
+            pytest.skip("freetype compiled without libpng or CBDT support")
+
     def test_cbdt_mask(self):
         try:
             font = ImageFont.truetype(
@@ -912,11 +904,48 @@
 
             d.text((10, 10), "\U0001f469", "black", font=font)
 
-            with Image.open("Tests/images/cbdt_notocoloremoji_mask.png") as expected:
-                assert_image_similar(im, expected, 6.2)
-        except IOError as e:
+            assert_image_similar_tofile(
+                im, "Tests/images/cbdt_notocoloremoji_mask.png", 6.2
+            )
+        except OSError as e:  # pragma: no cover
             assert str(e) in ("unimplemented feature", "unknown file format")
-            pytest.skip("freetype compiled without libpng or unsupported")
+            pytest.skip("freetype compiled without libpng or CBDT support")
+
+    def test_sbix(self):
+        try:
+            font = ImageFont.truetype(
+                "Tests/fonts/chromacheck-sbix.woff",
+                size=300,
+                layout_engine=self.LAYOUT_ENGINE,
+            )
+
+            im = Image.new("RGB", (400, 400), "white")
+            d = ImageDraw.Draw(im)
+
+            d.text((50, 50), "\uE901", font=font, embedded_color=True)
+
+            assert_image_similar_tofile(im, "Tests/images/chromacheck-sbix.png", 1)
+        except OSError as e:  # pragma: no cover
+            assert str(e) in ("unimplemented feature", "unknown file format")
+            pytest.skip("freetype compiled without libpng or SBIX support")
+
+    def test_sbix_mask(self):
+        try:
+            font = ImageFont.truetype(
+                "Tests/fonts/chromacheck-sbix.woff",
+                size=300,
+                layout_engine=self.LAYOUT_ENGINE,
+            )
+
+            im = Image.new("RGB", (400, 400), "white")
+            d = ImageDraw.Draw(im)
+
+            d.text((50, 50), "\uE901", (100, 0, 0), font=font)
+
+            assert_image_similar_tofile(im, "Tests/images/chromacheck-sbix_mask.png", 1)
+        except OSError as e:  # pragma: no cover
+            assert str(e) in ("unimplemented feature", "unknown file format")
+            pytest.skip("freetype compiled without libpng or SBIX support")
 
     @skip_unless_feature_version("freetype2", "2.10.0")
     def test_colr(self):
@@ -929,10 +958,9 @@
         im = Image.new("RGB", (300, 75), "white")
         d = ImageDraw.Draw(im)
 
-        d.text((15, 5), "Bungee", embedded_color=True, font=font)
-
-        with Image.open("Tests/images/colr_bungee.png") as expected:
-            assert_image_similar(im, expected, 21)
+        d.text((15, 5), "Bungee", font=font, embedded_color=True)
+
+        assert_image_similar_tofile(im, "Tests/images/colr_bungee.png", 21)
 
     @skip_unless_feature_version("freetype2", "2.10.0")
     def test_colr_mask(self):
@@ -947,36 +975,59 @@
 
         d.text((15, 5), "Bungee", "black", font=font)
 
-        with Image.open("Tests/images/colr_bungee_mask.png") as expected:
-            assert_image_similar(im, expected, 22)
+        assert_image_similar_tofile(im, "Tests/images/colr_bungee_mask.png", 22)
 
 
 @skip_unless_feature("raqm")
 class TestImageFont_RaqmLayout(TestImageFont):
-    LAYOUT_ENGINE = ImageFont.LAYOUT_RAQM
-
-
-@skip_unless_feature_version("freetype2", "2.4", "Different metrics")
+    LAYOUT_ENGINE = ImageFont.Layout.RAQM
+
+
 def test_render_mono_size():
     # issue 4177
 
     im = Image.new("P", (100, 30), "white")
     draw = ImageDraw.Draw(im)
     ttf = ImageFont.truetype(
-        "Tests/fonts/DejaVuSans.ttf", 18, layout_engine=ImageFont.LAYOUT_BASIC
+        "Tests/fonts/DejaVuSans/DejaVuSans.ttf",
+        18,
+        layout_engine=ImageFont.Layout.BASIC,
     )
 
     draw.text((10, 10), "r" * 10, "black", ttf)
     assert_image_equal_tofile(im, "Tests/images/text_mono.gif")
 
 
-def test_freetype_deprecation(monkeypatch):
-    # Arrange: mock features.version_module to return fake FreeType version
-    def fake_version_module(module):
-        return "2.7"
-
-    monkeypatch.setattr(features, "version_module", fake_version_module)
-
-    # Act / Assert
-    with pytest.warns(DeprecationWarning):
-        ImageFont.truetype(FONT_PATH, FONT_SIZE)
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/fonts/oom-e8e927ba6c0d38274a37c1567560eb33baf74627.ttf",
+    ],
+)
+def test_oom(test_file):
+    with open(test_file, "rb") as f:
+        font = ImageFont.truetype(BytesIO(f.read()))
+        with pytest.raises(Image.DecompressionBombError):
+            font.getmask("Test Text")
+
+
+def test_raqm_missing_warning(monkeypatch):
+    monkeypatch.setattr(ImageFont.core, "HAVE_RAQM", False)
+    with pytest.warns(UserWarning) as record:
+        font = ImageFont.truetype(
+            FONT_PATH, FONT_SIZE, layout_engine=ImageFont.Layout.RAQM
+        )
+    assert font.layout_engine == ImageFont.Layout.BASIC
+    assert str(record[-1].message) == (
+        "Raqm layout was requested, but Raqm is not available. "
+        "Falling back to basic layout."
+    )
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        ImageFont.Layout: "LAYOUT_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(ImageFont, prefix + name) == enum[name]
('Tests', 'test_mode_i16.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -34,7 +34,7 @@
         imOut = imIn.copy()
         verify(imOut)  # copy
 
-        imOut = imIn.transform((w, h), Image.EXTENT, (0, 0, w, h))
+        imOut = imIn.transform((w, h), Image.Transform.EXTENT, (0, 0, w, h))
         verify(imOut)  # transform
 
         filename = str(tmp_path / "temp.im")
('Tests', 'test_file_dds.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,16 +5,21 @@
 
 from PIL import DdsImagePlugin, Image
 
-from .helper import assert_image_equal
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper
 
 TEST_FILE_DXT1 = "Tests/images/dxt1-rgb-4bbp-noalpha_MipMaps-1.dds"
 TEST_FILE_DXT3 = "Tests/images/dxt3-argb-8bbp-explicitalpha_MipMaps-1.dds"
 TEST_FILE_DXT5 = "Tests/images/dxt5-argb-8bbp-interpolatedalpha_MipMaps-1.dds"
+TEST_FILE_DX10_BC5_TYPELESS = "Tests/images/bc5_typeless.dds"
+TEST_FILE_DX10_BC5_UNORM = "Tests/images/bc5_unorm.dds"
+TEST_FILE_DX10_BC5_SNORM = "Tests/images/bc5_snorm.dds"
+TEST_FILE_BC5S = "Tests/images/bc5s.dds"
 TEST_FILE_DX10_BC7 = "Tests/images/bc7-argb-8bpp_MipMaps-1.dds"
 TEST_FILE_DX10_BC7_UNORM_SRGB = "Tests/images/DXGI_FORMAT_BC7_UNORM_SRGB.dds"
 TEST_FILE_DX10_R8G8B8A8 = "Tests/images/argb-32bpp_MipMaps-1.dds"
 TEST_FILE_DX10_R8G8B8A8_UNORM_SRGB = "Tests/images/DXGI_FORMAT_R8G8B8A8_UNORM_SRGB.dds"
-TEST_FILE_UNCOMPRESSED_RGB = "Tests/images/uncompressed_rgb.dds"
+TEST_FILE_UNCOMPRESSED_RGB = "Tests/images/hopper.dds"
+TEST_FILE_UNCOMPRESSED_RGB_WITH_ALPHA = "Tests/images/uncompressed_rgb.dds"
 
 
 def test_sanity_dxt1():
@@ -31,6 +36,19 @@
         assert_image_equal(im, target)
 
 
+def test_sanity_dxt3():
+    """Check DXT3 images can be opened"""
+
+    with Image.open(TEST_FILE_DXT3) as im:
+        im.load()
+
+        assert im.format == "DDS"
+        assert im.mode == "RGBA"
+        assert im.size == (256, 256)
+
+        assert_image_equal_tofile(im, TEST_FILE_DXT3.replace(".dds", ".png"))
+
+
 def test_sanity_dxt5():
     """Check DXT5 images can be opened"""
 
@@ -41,22 +59,31 @@
     assert im.mode == "RGBA"
     assert im.size == (256, 256)
 
-    with Image.open(TEST_FILE_DXT5.replace(".dds", ".png")) as target:
-        assert_image_equal(target, im)
-
-
-def test_sanity_dxt3():
-    """Check DXT3 images can be opened"""
-
-    with Image.open(TEST_FILE_DXT3.replace(".dds", ".png")) as target:
-        with Image.open(TEST_FILE_DXT3) as im:
-            im.load()
-
-            assert im.format == "DDS"
-            assert im.mode == "RGBA"
-            assert im.size == (256, 256)
-
-            assert_image_equal(target, im)
+    assert_image_equal_tofile(im, TEST_FILE_DXT5.replace(".dds", ".png"))
+
+
+@pytest.mark.parametrize(
+    ("image_path", "expected_path"),
+    (
+        # hexeditted to be typeless
+        (TEST_FILE_DX10_BC5_TYPELESS, TEST_FILE_DX10_BC5_UNORM),
+        (TEST_FILE_DX10_BC5_UNORM, TEST_FILE_DX10_BC5_UNORM),
+        # hexeditted to use DX10 FourCC
+        (TEST_FILE_DX10_BC5_SNORM, TEST_FILE_BC5S),
+        (TEST_FILE_BC5S, TEST_FILE_BC5S),
+    ),
+)
+def test_dx10_bc5(image_path, expected_path):
+    """Check DX10 BC5 images can be opened"""
+
+    with Image.open(image_path) as im:
+        im.load()
+
+        assert im.format == "DDS"
+        assert im.mode == "RGB"
+        assert im.size == (256, 256)
+
+        assert_image_equal_tofile(im, expected_path.replace(".dds", ".png"))
 
 
 def test_dx10_bc7():
@@ -69,8 +96,7 @@
         assert im.mode == "RGBA"
         assert im.size == (256, 256)
 
-        with Image.open(TEST_FILE_DX10_BC7.replace(".dds", ".png")) as target:
-            assert_image_equal(target, im)
+        assert_image_equal_tofile(im, TEST_FILE_DX10_BC7.replace(".dds", ".png"))
 
 
 def test_dx10_bc7_unorm_srgb():
@@ -84,10 +110,9 @@
         assert im.size == (16, 16)
         assert im.info["gamma"] == 1 / 2.2
 
-        with Image.open(
-            TEST_FILE_DX10_BC7_UNORM_SRGB.replace(".dds", ".png")
-        ) as target:
-            assert_image_equal(target, im)
+        assert_image_equal_tofile(
+            im, TEST_FILE_DX10_BC7_UNORM_SRGB.replace(".dds", ".png")
+        )
 
 
 def test_dx10_r8g8b8a8():
@@ -100,8 +125,7 @@
         assert im.mode == "RGBA"
         assert im.size == (256, 256)
 
-        with Image.open(TEST_FILE_DX10_R8G8B8A8.replace(".dds", ".png")) as target:
-            assert_image_equal(target, im)
+        assert_image_equal_tofile(im, TEST_FILE_DX10_R8G8B8A8.replace(".dds", ".png"))
 
 
 def test_dx10_r8g8b8a8_unorm_srgb():
@@ -115,69 +139,85 @@
         assert im.size == (16, 16)
         assert im.info["gamma"] == 1 / 2.2
 
-        with Image.open(
-            TEST_FILE_DX10_R8G8B8A8_UNORM_SRGB.replace(".dds", ".png")
-        ) as target:
-            assert_image_equal(target, im)
+        assert_image_equal_tofile(
+            im, TEST_FILE_DX10_R8G8B8A8_UNORM_SRGB.replace(".dds", ".png")
+        )
 
 
 def test_unimplemented_dxgi_format():
     with pytest.raises(NotImplementedError):
-        Image.open("Tests/images/unimplemented_dxgi_format.dds")
+        with Image.open("Tests/images/unimplemented_dxgi_format.dds"):
+            pass
 
 
 def test_uncompressed_rgb():
     """Check uncompressed RGB images can be opened"""
 
+    # convert -format dds -define dds:compression=none hopper.jpg hopper.dds
     with Image.open(TEST_FILE_UNCOMPRESSED_RGB) as im:
-        im.load()
-
+        assert im.format == "DDS"
+        assert im.mode == "RGB"
+        assert im.size == (128, 128)
+
+        assert_image_equal_tofile(im, "Tests/images/hopper.png")
+
+    # Test image with alpha
+    with Image.open(TEST_FILE_UNCOMPRESSED_RGB_WITH_ALPHA) as im:
         assert im.format == "DDS"
         assert im.mode == "RGBA"
         assert im.size == (800, 600)
 
-        with Image.open(TEST_FILE_UNCOMPRESSED_RGB.replace(".dds", ".png")) as target:
-            assert_image_equal(target, im)
-
-
-def test__validate_true():
+        assert_image_equal_tofile(
+            im, TEST_FILE_UNCOMPRESSED_RGB_WITH_ALPHA.replace(".dds", ".png")
+        )
+
+
+def test__accept_true():
     """Check valid prefix"""
     # Arrange
     prefix = b"DDS etc"
 
     # Act
-    output = DdsImagePlugin._validate(prefix)
+    output = DdsImagePlugin._accept(prefix)
 
     # Assert
     assert output
 
 
-def test__validate_false():
+def test__accept_false():
     """Check invalid prefix"""
     # Arrange
     prefix = b"something invalid"
 
     # Act
-    output = DdsImagePlugin._validate(prefix)
+    output = DdsImagePlugin._accept(prefix)
 
     # Assert
     assert not output
 
 
+def test_invalid_file():
+    invalid_file = "Tests/images/flower.jpg"
+
+    with pytest.raises(SyntaxError):
+        DdsImagePlugin.DdsImageFile(invalid_file)
+
+
 def test_short_header():
-    """ Check a short header"""
+    """Check a short header"""
     with open(TEST_FILE_DXT5, "rb") as f:
         img_file = f.read()
 
     def short_header():
-        Image.open(BytesIO(img_file[:119]))
+        with Image.open(BytesIO(img_file[:119])):
+            pass  # pragma: no cover
 
     with pytest.raises(OSError):
         short_header()
 
 
 def test_short_file():
-    """ Check that the appropriate error is thrown for a short file"""
+    """Check that the appropriate error is thrown for a short file"""
 
     with open(TEST_FILE_DXT5, "rb") as f:
         img_file = f.read()
@@ -190,6 +230,46 @@
         short_file()
 
 
+def test_dxt5_colorblock_alpha_issue_4142():
+    """Check that colorblocks are decoded correctly in DXT5"""
+
+    with Image.open("Tests/images/dxt5-colorblock-alpha-issue-4142.dds") as im:
+        px = im.getpixel((0, 0))
+        assert px[0] != 0
+        assert px[1] != 0
+        assert px[2] != 0
+
+        px = im.getpixel((1, 0))
+        assert px[0] != 0
+        assert px[1] != 0
+        assert px[2] != 0
+
+
 def test_unimplemented_pixel_format():
     with pytest.raises(NotImplementedError):
-        Image.open("Tests/images/unimplemented_pixel_format.dds")
+        with Image.open("Tests/images/unimplemented_pixel_format.dds"):
+            pass
+
+
+def test_save_unsupported_mode(tmp_path):
+    out = str(tmp_path / "temp.dds")
+    im = hopper("HSV")
+    with pytest.raises(OSError):
+        im.save(out)
+
+
+@pytest.mark.parametrize(
+    ("mode", "test_file"),
+    [
+        ("RGB", "Tests/images/hopper.png"),
+        ("RGBA", "Tests/images/pil123rgba.png"),
+    ],
+)
+def test_save(mode, test_file, tmp_path):
+    out = str(tmp_path / "temp.dds")
+    with Image.open(test_file) as im:
+        assert im.mode == mode
+        im.save(out)
+
+        with Image.open(out) as reloaded:
+            assert_image_equal(im, reloaded)
('Tests', 'test_file_webp_metadata.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,10 @@
 from io import BytesIO
+
+import pytest
 
 from PIL import Image
 
-from .helper import skip_unless_feature
+from .helper import mark_if_feature_version, skip_unless_feature
 
 pytestmark = [
     skip_unless_feature("webp"),
@@ -39,6 +41,9 @@
         assert exif[305] == "Adobe Photoshop CS6 (Macintosh)"
 
 
+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 def test_write_exif_metadata():
     file_path = "Tests/images/flower.jpg"
     test_buffer = BytesIO()
@@ -71,6 +76,9 @@
             assert icc == expected_icc
 
 
+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 def test_write_icc_metadata():
     file_path = "Tests/images/flower2.jpg"
     test_buffer = BytesIO()
@@ -88,6 +96,9 @@
         assert webp_icc_profile == expected_icc_profile, "Webp ICC didn't match"
 
 
+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 def test_read_no_exif():
     file_path = "Tests/images/flower.jpg"
     test_buffer = BytesIO()
('Tests', 'test_image_point.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -32,7 +32,7 @@
 
 
 def test_f_lut():
-    """ Tests for floating point lut of 8bit gray image """
+    """Tests for floating point lut of 8bit gray image"""
     im = hopper("L")
     lut = [0.5 * float(x) for x in range(256)]
 
('Tests', 'test_file_sgi.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,12 @@
 
 from PIL import Image, SgiImagePlugin
 
-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar,
+    hopper,
+)
 
 
 def test_rgb():
@@ -16,10 +21,7 @@
 
 
 def test_rgb16():
-    test_file = "Tests/images/hopper16.rgb"
-
-    with Image.open(test_file) as im:
-        assert_image_equal(im, hopper())
+    assert_image_equal_tofile(hopper(), "Tests/images/hopper16.rgb")
 
 
 def test_l():
@@ -38,8 +40,7 @@
     test_file = "Tests/images/transparent.sgi"
 
     with Image.open(test_file) as im:
-        with Image.open("Tests/images/transparent.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/transparent.png")
         assert im.get_format_mimetype() == "image/sgi"
 
 
@@ -49,16 +50,14 @@
     test_file = "Tests/images/hopper.sgi"
 
     with Image.open(test_file) as im:
-        with Image.open("Tests/images/hopper.rgb") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/hopper.rgb")
 
 
 def test_rle16():
     test_file = "Tests/images/tv16.sgi"
 
     with Image.open(test_file) as im:
-        with Image.open("Tests/images/tv.rgb") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/tv.rgb")
 
 
 def test_invalid_file():
@@ -72,8 +71,14 @@
     def roundtrip(img):
         out = str(tmp_path / "temp.sgi")
         img.save(out, format="sgi")
-        with Image.open(out) as reloaded:
-            assert_image_equal(img, reloaded)
+        assert_image_equal_tofile(img, out)
+
+        out = str(tmp_path / "fp.sgi")
+        with open(out, "wb") as fp:
+            img.save(fp)
+            assert_image_equal_tofile(img, out)
+
+            assert not fp.closed
 
     for mode in ("L", "RGB", "RGBA"):
         roundtrip(hopper(mode))
@@ -89,8 +94,7 @@
         out = str(tmp_path / "temp.sgi")
         im.save(out, format="sgi", bpc=2)
 
-        with Image.open(out) as reloaded:
-            assert_image_equal(im, reloaded)
+        assert_image_equal_tofile(im, out)
 
 
 def test_unsupported_mode(tmp_path):
('Tests', 'test_file_webp_animated.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,7 @@
 import pytest
+from packaging.version import parse as parse_version
 
-from PIL import Image
+from PIL import Image, features
 
 from .helper import (
     assert_image_equal,
@@ -27,7 +28,6 @@
         assert im.is_animated
 
 
-@pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
 def test_write_animation_L(tmp_path):
     """
     Convert an animated GIF to animated WebP, then compare the frame count, and first
@@ -45,15 +45,19 @@
             # Compare first and last frames to the original animated GIF
             orig.load()
             im.load()
-            assert_image_similar(im, orig.convert("RGBA"), 25.0)
+            assert_image_similar(im, orig.convert("RGBA"), 32.9)
+
+            if is_big_endian():
+                webp = parse_version(features.version_module("webp"))
+                if webp < parse_version("1.2.2"):
+                    pytest.skip("Fails with libwebp earlier than 1.2.2")
             orig.seek(orig.n_frames - 1)
             im.seek(im.n_frames - 1)
             orig.load()
             im.load()
-            assert_image_similar(im, orig.convert("RGBA"), 25.0)
+            assert_image_similar(im, orig.convert("RGBA"), 32.9)
 
 
-@pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
 def test_write_animation_RGB(tmp_path):
     """
     Write an animated WebP from RGB frames, and ensure the frames
@@ -69,6 +73,10 @@
             assert_image_equal(im, frame1.convert("RGBA"))
 
             # Compare second frame to original
+            if is_big_endian():
+                webp = parse_version(features.version_module("webp"))
+                if webp < parse_version("1.2.2"):
+                    pytest.skip("Fails with libwebp earlier than 1.2.2")
             im.seek(1)
             im.load()
             assert_image_equal(im, frame2.convert("RGBA"))
('Tests', 'test_color_lut.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -43,107 +43,158 @@
         im = Image.new("RGB", (10, 10), 0)
 
         with pytest.raises(ValueError, match="filter"):
-            im.im.color_lut_3d("RGB", Image.CUBIC, *self.generate_identity_table(3, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BICUBIC, *self.generate_identity_table(3, 3)
+            )
 
         with pytest.raises(ValueError, match="image mode"):
             im.im.color_lut_3d(
-                "wrong", Image.LINEAR, *self.generate_identity_table(3, 3)
+                "wrong", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
             )
 
         with pytest.raises(ValueError, match="table_channels"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(5, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(5, 3)
+            )
 
         with pytest.raises(ValueError, match="table_channels"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(1, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(1, 3)
+            )
 
         with pytest.raises(ValueError, match="table_channels"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(2, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(2, 3)
+            )
 
         with pytest.raises(ValueError, match="Table size"):
             im.im.color_lut_3d(
-                "RGB", Image.LINEAR, *self.generate_identity_table(3, (1, 3, 3))
+                "RGB",
+                Image.Resampling.BILINEAR,
+                *self.generate_identity_table(3, (1, 3, 3)),
             )
 
         with pytest.raises(ValueError, match="Table size"):
             im.im.color_lut_3d(
-                "RGB", Image.LINEAR, *self.generate_identity_table(3, (66, 3, 3))
+                "RGB",
+                Image.Resampling.BILINEAR,
+                *self.generate_identity_table(3, (66, 3, 3)),
             )
 
         with pytest.raises(ValueError, match=r"size1D \* size2D \* size3D"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, 3, 2, 2, 2, [0, 0, 0] * 7)
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, 0] * 7
+            )
 
         with pytest.raises(ValueError, match=r"size1D \* size2D \* size3D"):
-            im.im.color_lut_3d("RGB", Image.LINEAR, 3, 2, 2, 2, [0, 0, 0] * 9)
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, 0] * 9
+            )
 
         with pytest.raises(TypeError):
-            im.im.color_lut_3d("RGB", Image.LINEAR, 3, 2, 2, 2, [0, 0, "0"] * 8)
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, "0"] * 8
+            )
 
         with pytest.raises(TypeError):
-            im.im.color_lut_3d("RGB", Image.LINEAR, 3, 2, 2, 2, 16)
+            im.im.color_lut_3d("RGB", Image.Resampling.BILINEAR, 3, 2, 2, 2, 16)
 
     def test_correct_args(self):
         im = Image.new("RGB", (10, 10), 0)
 
-        im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(3, 3))
-
-        im.im.color_lut_3d("CMYK", Image.LINEAR, *self.generate_identity_table(4, 3))
-
-        im.im.color_lut_3d(
-            "RGB", Image.LINEAR, *self.generate_identity_table(3, (2, 3, 3))
-        )
-
-        im.im.color_lut_3d(
-            "RGB", Image.LINEAR, *self.generate_identity_table(3, (65, 3, 3))
-        )
-
-        im.im.color_lut_3d(
-            "RGB", Image.LINEAR, *self.generate_identity_table(3, (3, 65, 3))
-        )
-
-        im.im.color_lut_3d(
-            "RGB", Image.LINEAR, *self.generate_identity_table(3, (3, 3, 65))
+        im.im.color_lut_3d(
+            "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+        )
+
+        im.im.color_lut_3d(
+            "CMYK", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)
+        )
+
+        im.im.color_lut_3d(
+            "RGB",
+            Image.Resampling.BILINEAR,
+            *self.generate_identity_table(3, (2, 3, 3)),
+        )
+
+        im.im.color_lut_3d(
+            "RGB",
+            Image.Resampling.BILINEAR,
+            *self.generate_identity_table(3, (65, 3, 3)),
+        )
+
+        im.im.color_lut_3d(
+            "RGB",
+            Image.Resampling.BILINEAR,
+            *self.generate_identity_table(3, (3, 65, 3)),
+        )
+
+        im.im.color_lut_3d(
+            "RGB",
+            Image.Resampling.BILINEAR,
+            *self.generate_identity_table(3, (3, 3, 65)),
         )
 
     def test_wrong_mode(self):
         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("L", (10, 10), 0)
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(3, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+            )
 
         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("RGB", (10, 10), 0)
-            im.im.color_lut_3d("L", Image.LINEAR, *self.generate_identity_table(3, 3))
+            im.im.color_lut_3d(
+                "L", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+            )
 
         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("L", (10, 10), 0)
-            im.im.color_lut_3d("L", Image.LINEAR, *self.generate_identity_table(3, 3))
+            im.im.color_lut_3d(
+                "L", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+            )
 
         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("RGB", (10, 10), 0)
             im.im.color_lut_3d(
-                "RGBA", Image.LINEAR, *self.generate_identity_table(3, 3)
+                "RGBA", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
             )
 
         with pytest.raises(ValueError, match="wrong mode"):
             im = Image.new("RGB", (10, 10), 0)
-            im.im.color_lut_3d("RGB", Image.LINEAR, *self.generate_identity_table(4, 3))
+            im.im.color_lut_3d(
+                "RGB", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)
+            )
 
     def test_correct_mode(self):
         im = Image.new("RGBA", (10, 10), 0)
-        im.im.color_lut_3d("RGBA", Image.LINEAR, *self.generate_identity_table(3, 3))
+        im.im.color_lut_3d(
+            "RGBA", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+        )
 
         im = Image.new("RGBA", (10, 10), 0)
-        im.im.color_lut_3d("RGBA", Image.LINEAR, *self.generate_identity_table(4, 3))
+        im.im.color_lut_3d(
+            "RGBA", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)
+        )
 
         im = Image.new("RGB", (10, 10), 0)
-        im.im.color_lut_3d("HSV", Image.LINEAR, *self.generate_identity_table(3, 3))
+        im.im.color_lut_3d(
+            "HSV", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)
+        )
 
         im = Image.new("RGB", (10, 10), 0)
-        im.im.color_lut_3d("RGBA", Image.LINEAR, *self.generate_identity_table(4, 3))
+        im.im.color_lut_3d(
+            "RGBA", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)
+        )
 
     def test_identities(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )
 
         # Fast test with small cubes
@@ -152,7 +203,9 @@
                 im,
                 im._new(
                     im.im.color_lut_3d(
-                        "RGB", Image.LINEAR, *self.generate_identity_table(3, size)
+                        "RGB",
+                        Image.Resampling.BILINEAR,
+                        *self.generate_identity_table(3, size),
                     )
                 ),
             )
@@ -162,7 +215,9 @@
             im,
             im._new(
                 im.im.color_lut_3d(
-                    "RGB", Image.LINEAR, *self.generate_identity_table(3, (2, 2, 65))
+                    "RGB",
+                    Image.Resampling.BILINEAR,
+                    *self.generate_identity_table(3, (2, 2, 65)),
                 )
             ),
         )
@@ -170,7 +225,12 @@
     def test_identities_4_channels(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )
 
         # Red channel copied to alpha
@@ -178,7 +238,9 @@
             Image.merge("RGBA", (im.split() * 2)[:4]),
             im._new(
                 im.im.color_lut_3d(
-                    "RGBA", Image.LINEAR, *self.generate_identity_table(4, 17)
+                    "RGBA",
+                    Image.Resampling.BILINEAR,
+                    *self.generate_identity_table(4, 17),
                 )
             ),
         )
@@ -189,9 +251,9 @@
             "RGBA",
             [
                 g,
-                g.transpose(Image.ROTATE_90),
-                g.transpose(Image.ROTATE_180),
-                g.transpose(Image.ROTATE_270),
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+                g.transpose(Image.Transpose.ROTATE_270),
             ],
         )
 
@@ -199,7 +261,9 @@
             im,
             im._new(
                 im.im.color_lut_3d(
-                    "RGBA", Image.LINEAR, *self.generate_identity_table(3, 17)
+                    "RGBA",
+                    Image.Resampling.BILINEAR,
+                    *self.generate_identity_table(3, 17),
                 )
             ),
         )
@@ -207,14 +271,19 @@
     def test_channels_order(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )
 
         # Reverse channels by splitting and using table
         # fmt: off
         assert_image_equal(
             Image.merge('RGB', im.split()[::-1]),
-            im._new(im.im.color_lut_3d('RGB', Image.LINEAR,
+            im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,
                     3, 2, 2, 2, [
                         0, 0, 0,  0, 0, 1,
                         0, 1, 0,  0, 1, 1,
@@ -227,11 +296,16 @@
     def test_overflow(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
-        )
-
-        # fmt: off
-        transformed = im._new(im.im.color_lut_3d('RGB', Image.LINEAR,
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
+        )
+
+        # fmt: off
+        transformed = im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,
                               3, 2, 2, 2,
                               [
                                   -1, -1, -1,   2, -1, -1,
@@ -251,7 +325,7 @@
         assert transformed[205, 205] == (255, 255, 0)
 
         # fmt: off
-        transformed = im._new(im.im.color_lut_3d('RGB', Image.LINEAR,
+        transformed = im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,
                               3, 2, 2, 2,
                               [
                                   -3, -3, -3,   5, -3, -3,
@@ -354,7 +428,12 @@
     def test_numpy_formats(self):
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )
 
         lut = ImageFilter.Color3DLUT.generate((7, 9, 11), lambda r, g, b: (r, g, b))
@@ -445,7 +524,12 @@
 
         g = Image.linear_gradient("L")
         im = Image.merge(
-            "RGB", [g, g.transpose(Image.ROTATE_90), g.transpose(Image.ROTATE_180)]
+            "RGB",
+            [
+                g,
+                g.transpose(Image.Transpose.ROTATE_90),
+                g.transpose(Image.Transpose.ROTATE_180),
+            ],
         )
         assert im == im.filter(lut)
 
('Tests', 'test_imagewin_pointers.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,3 @@
-import ctypes
 from io import BytesIO
 
 from PIL import Image, ImageWin
@@ -8,6 +7,7 @@
 # see https://github.com/python-pillow/Pillow/pull/1431#issuecomment-144692652
 
 if is_win32():
+    import ctypes
     import ctypes.wintypes
 
     class BITMAPFILEHEADER(ctypes.Structure):
@@ -110,4 +110,5 @@
         DeleteObject(dib)
         DeleteDC(hdc)
 
-        Image.open(BytesIO(bitmap)).save(opath)
+        with Image.open(BytesIO(bitmap)) as im:
+            im.save(opath)
('Tests', 'test_image_transpose.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,12 +1,4 @@
-from PIL.Image import (
-    FLIP_LEFT_RIGHT,
-    FLIP_TOP_BOTTOM,
-    ROTATE_90,
-    ROTATE_180,
-    ROTATE_270,
-    TRANSPOSE,
-    TRANSVERSE,
-)
+from PIL.Image import Transpose
 
 from . import helper
 from .helper import assert_image_equal
@@ -20,7 +12,7 @@
 def test_flip_left_right():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(FLIP_LEFT_RIGHT)
+        out = im.transpose(Transpose.FLIP_LEFT_RIGHT)
         assert out.mode == mode
         assert out.size == im.size
 
@@ -37,7 +29,7 @@
 def test_flip_top_bottom():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(FLIP_TOP_BOTTOM)
+        out = im.transpose(Transpose.FLIP_TOP_BOTTOM)
         assert out.mode == mode
         assert out.size == im.size
 
@@ -54,7 +46,7 @@
 def test_rotate_90():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(ROTATE_90)
+        out = im.transpose(Transpose.ROTATE_90)
         assert out.mode == mode
         assert out.size == im.size[::-1]
 
@@ -71,7 +63,7 @@
 def test_rotate_180():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(ROTATE_180)
+        out = im.transpose(Transpose.ROTATE_180)
         assert out.mode == mode
         assert out.size == im.size
 
@@ -88,7 +80,7 @@
 def test_rotate_270():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(ROTATE_270)
+        out = im.transpose(Transpose.ROTATE_270)
         assert out.mode == mode
         assert out.size == im.size[::-1]
 
@@ -105,7 +97,7 @@
 def test_transpose():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(TRANSPOSE)
+        out = im.transpose(Transpose.TRANSPOSE)
         assert out.mode == mode
         assert out.size == im.size[::-1]
 
@@ -122,7 +114,7 @@
 def test_tranverse():
     def transpose(mode):
         im = HOPPER[mode]
-        out = im.transpose(TRANSVERSE)
+        out = im.transpose(Transpose.TRANSVERSE)
         assert out.mode == mode
         assert out.size == im.size[::-1]
 
@@ -143,20 +135,31 @@
         def transpose(first, second):
             return im.transpose(first).transpose(second)
 
-        assert_image_equal(im, transpose(FLIP_LEFT_RIGHT, FLIP_LEFT_RIGHT))
-        assert_image_equal(im, transpose(FLIP_TOP_BOTTOM, FLIP_TOP_BOTTOM))
-        assert_image_equal(im, transpose(ROTATE_90, ROTATE_270))
-        assert_image_equal(im, transpose(ROTATE_180, ROTATE_180))
         assert_image_equal(
-            im.transpose(TRANSPOSE), transpose(ROTATE_90, FLIP_TOP_BOTTOM)
+            im, transpose(Transpose.FLIP_LEFT_RIGHT, Transpose.FLIP_LEFT_RIGHT)
         )
         assert_image_equal(
-            im.transpose(TRANSPOSE), transpose(ROTATE_270, FLIP_LEFT_RIGHT)
+            im, transpose(Transpose.FLIP_TOP_BOTTOM, Transpose.FLIP_TOP_BOTTOM)
+        )
+        assert_image_equal(im, transpose(Transpose.ROTATE_90, Transpose.ROTATE_270))
+        assert_image_equal(im, transpose(Transpose.ROTATE_180, Transpose.ROTATE_180))
+        assert_image_equal(
+            im.transpose(Transpose.TRANSPOSE),
+            transpose(Transpose.ROTATE_90, Transpose.FLIP_TOP_BOTTOM),
         )
         assert_image_equal(
-            im.transpose(TRANSVERSE), transpose(ROTATE_90, FLIP_LEFT_RIGHT)
+            im.transpose(Transpose.TRANSPOSE),
+            transpose(Transpose.ROTATE_270, Transpose.FLIP_LEFT_RIGHT),
         )
         assert_image_equal(
-            im.transpose(TRANSVERSE), transpose(ROTATE_270, FLIP_TOP_BOTTOM)
+            im.transpose(Transpose.TRANSVERSE),
+            transpose(Transpose.ROTATE_90, Transpose.FLIP_LEFT_RIGHT),
         )
-        assert_image_equal(im.transpose(TRANSVERSE), transpose(ROTATE_180, TRANSPOSE))
+        assert_image_equal(
+            im.transpose(Transpose.TRANSVERSE),
+            transpose(Transpose.ROTATE_270, Transpose.FLIP_TOP_BOTTOM),
+        )
+        assert_image_equal(
+            im.transpose(Transpose.TRANSVERSE),
+            transpose(Transpose.ROTATE_180, Transpose.TRANSPOSE),
+        )
('Tests', 'test_file_ico.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,10 +1,11 @@
 import io
+import os
 
 import pytest
 
 from PIL import IcoImagePlugin, Image, ImageDraw
 
-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper
 
 TEST_ICO_FILE = "Tests/images/hopper.ico"
 
@@ -18,6 +19,22 @@
     assert im.get_format_mimetype() == "image/x-icon"
 
 
+def test_load():
+    with Image.open(TEST_ICO_FILE) as im:
+        assert im.load()[0, 0] == (1, 1, 9, 255)
+
+
+def test_mask():
+    with Image.open("Tests/images/hopper_mask.ico") as im:
+        assert_image_equal_tofile(im, "Tests/images/hopper_mask.png")
+
+
+def test_black_and_white():
+    with Image.open("Tests/images/black_and_white.ico") as im:
+        assert im.mode == "RGBA"
+        assert im.size == (16, 16)
+
+
 def test_invalid_file():
     with open("Tests/images/flower.jpg", "rb") as fp:
         with pytest.raises(SyntaxError):
@@ -37,7 +54,9 @@
         assert im.mode == reloaded.mode
         assert (64, 64) == reloaded.size
         assert reloaded.format == "ICO"
-        assert_image_equal(reloaded, hopper().resize((64, 64), Image.LANCZOS))
+        assert_image_equal(
+            reloaded, hopper().resize((64, 64), Image.Resampling.LANCZOS)
+        )
 
     # The other one
     output.seek(0)
@@ -47,7 +66,85 @@
         assert im.mode == reloaded.mode
         assert (32, 32) == reloaded.size
         assert reloaded.format == "ICO"
-        assert_image_equal(reloaded, hopper().resize((32, 32), Image.LANCZOS))
+        assert_image_equal(
+            reloaded, hopper().resize((32, 32), Image.Resampling.LANCZOS)
+        )
+
+
+def test_no_duplicates(tmp_path):
+    temp_file = str(tmp_path / "temp.ico")
+    temp_file2 = str(tmp_path / "temp2.ico")
+
+    im = hopper()
+    sizes = [(32, 32), (64, 64)]
+    im.save(temp_file, "ico", sizes=sizes)
+
+    sizes.append(sizes[-1])
+    im.save(temp_file2, "ico", sizes=sizes)
+
+    assert os.path.getsize(temp_file) == os.path.getsize(temp_file2)
+
+
+def test_different_bit_depths(tmp_path):
+    temp_file = str(tmp_path / "temp.ico")
+    temp_file2 = str(tmp_path / "temp2.ico")
+
+    im = hopper()
+    im.save(temp_file, "ico", bitmap_format="bmp", sizes=[(128, 128)])
+
+    hopper("1").save(
+        temp_file2,
+        "ico",
+        bitmap_format="bmp",
+        sizes=[(128, 128)],
+        append_images=[im],
+    )
+
+    assert os.path.getsize(temp_file) != os.path.getsize(temp_file2)
+
+    # Test that only matching sizes of different bit depths are saved
+    temp_file3 = str(tmp_path / "temp3.ico")
+    temp_file4 = str(tmp_path / "temp4.ico")
+
+    im.save(temp_file3, "ico", bitmap_format="bmp", sizes=[(128, 128)])
+    im.save(
+        temp_file4,
+        "ico",
+        bitmap_format="bmp",
+        sizes=[(128, 128)],
+        append_images=[Image.new("P", (64, 64))],
+    )
+
+    assert os.path.getsize(temp_file3) == os.path.getsize(temp_file4)
+
+
+@pytest.mark.parametrize("mode", ("1", "L", "P", "RGB", "RGBA"))
+def test_save_to_bytes_bmp(mode):
+    output = io.BytesIO()
+    im = hopper(mode)
+    im.save(output, "ico", bitmap_format="bmp", sizes=[(32, 32), (64, 64)])
+
+    # The default image
+    output.seek(0)
+    with Image.open(output) as reloaded:
+        assert reloaded.info["sizes"] == {(32, 32), (64, 64)}
+
+        assert "RGBA" == reloaded.mode
+        assert (64, 64) == reloaded.size
+        assert reloaded.format == "ICO"
+        im = hopper(mode).resize((64, 64), Image.Resampling.LANCZOS).convert("RGBA")
+        assert_image_equal(reloaded, im)
+
+    # The other one
+    output.seek(0)
+    with Image.open(output) as reloaded:
+        reloaded.size = (32, 32)
+
+        assert "RGBA" == reloaded.mode
+        assert (32, 32) == reloaded.size
+        assert reloaded.format == "ICO"
+        im = hopper(mode).resize((32, 32), Image.Resampling.LANCZOS).convert("RGBA")
+        assert_image_equal(reloaded, im)
 
 
 def test_incorrect_size():
@@ -119,6 +216,4 @@
         im.save(outfile)
 
     with Image.open(outfile) as im:
-        im.save("Tests/images/hopper_draw.ico")
-        with Image.open("Tests/images/hopper_draw.ico") as reloaded:
-            assert_image_equal(im, reloaded)
+        assert_image_equal_tofile(im, "Tests/images/hopper_draw.ico")
('Tests', 'test_bmp_reference.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,5 @@
 import os
-
-import pytest
+import warnings
 
 from PIL import Image
 
@@ -20,15 +19,13 @@
     either"""
     for f in get_files("b"):
 
-        def open(f):
+        # Assert that there is no unclosed file warning
+        with warnings.catch_warnings():
             try:
                 with Image.open(f) as im:
                     im.load()
             except Exception:  # as msg:
                 pass
-
-        # Assert that there is no unclosed file warning
-        pytest.warns(None, open, f)
 
 
 def test_questionable():
@@ -43,6 +40,7 @@
         "rgb32fakealpha.bmp",
         "rgb24largepal.bmp",
         "pal8os2sp.bmp",
+        "pal8rletrns.bmp",
         "rgb32bf-xbgr.bmp",
     ]
     for f in get_files("q"):
('Tests', 'test_image.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,19 +1,22 @@
 import io
 import os
 import shutil
+import sys
 import tempfile
+import warnings
 
 import pytest
 
-import PIL
-from PIL import Image, ImageDraw, ImagePalette, ImageShow, UnidentifiedImageError
+from PIL import Image, ImageDraw, ImagePalette, UnidentifiedImageError
 
 from .helper import (
     assert_image_equal,
-    assert_image_similar,
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
     assert_not_all_same,
     hopper,
     is_win32,
+    mark_if_feature_version,
     skip_unless_feature,
 )
 
@@ -87,16 +90,29 @@
         # with pytest.raises(MemoryError):
         #   Image.new("L", (1000000, 1000000))
 
+    def test_repr_pretty(self):
+        class Pretty:
+            def text(self, text):
+                self.pretty_output = text
+
+        im = Image.new("L", (100, 100))
+
+        p = Pretty()
+        im._repr_pretty_(p, None)
+        assert p.pretty_output == "<PIL.Image.Image image mode=L size=100x100>"
+
     def test_open_formats(self):
         PNGFILE = "Tests/images/hopper.png"
         JPGFILE = "Tests/images/hopper.jpg"
 
         with pytest.raises(TypeError):
-            Image.open(PNGFILE, formats=123)
-
-        for formats in [["JPEG"], ("JPEG",)]:
+            with Image.open(PNGFILE, formats=123):
+                pass
+
+        for formats in [["JPEG"], ("JPEG",), ["jpeg"], ["Jpeg"], ["jPeG"], ["JpEg"]]:
             with pytest.raises(UnidentifiedImageError):
-                Image.open(PNGFILE, formats=formats)
+                with Image.open(PNGFILE, formats=formats):
+                    pass
 
             with Image.open(JPGFILE, formats=formats) as im:
                 assert im.mode == "RGB"
@@ -120,15 +136,18 @@
 
         im = io.BytesIO(b"")
         with pytest.raises(UnidentifiedImageError):
-            Image.open(im)
+            with Image.open(im):
+                pass
 
     def test_bad_mode(self):
         with pytest.raises(ValueError):
-            Image.open("filename", "bad mode")
+            with Image.open("filename", "bad mode"):
+                pass
 
     def test_stringio(self):
         with pytest.raises(ValueError):
-            Image.open(io.StringIO())
+            with Image.open(io.StringIO()):
+                pass
 
     def test_pathlib(self, tmp_path):
         from PIL.Image import Path
@@ -141,10 +160,11 @@
             assert im.mode == "RGB"
             assert im.size == (128, 128)
 
-            temp_file = str(tmp_path / "temp.jpg")
-            if os.path.exists(temp_file):
-                os.remove(temp_file)
-            im.save(Path(temp_file))
+            for ext in (".jpg", ".jp2"):
+                temp_file = str(tmp_path / ("temp." + ext))
+                if os.path.exists(temp_file):
+                    os.remove(temp_file)
+                im.save(Path(temp_file))
 
     def test_fp_name(self, tmp_path):
         temp_file = str(tmp_path / "temp.jpg")
@@ -166,8 +186,7 @@
         with tempfile.TemporaryFile() as fp:
             im.save(fp, "JPEG")
             fp.seek(0)
-            with Image.open(fp) as reloaded:
-                assert_image_similar(im, reloaded, 20)
+            assert_image_similar_tofile(im, fp, 20)
 
     def test_unknown_extension(self, tmp_path):
         im = hopper()
@@ -186,6 +205,10 @@
         assert not im.readonly
 
     @pytest.mark.skipif(is_win32(), reason="Test requires opening tempfile twice")
+    @pytest.mark.skipif(
+        sys.platform == "cygwin",
+        reason="Test requires opening an mmaped file for writing",
+    )
     def test_readonly_save(self, tmp_path):
         temp_file = str(tmp_path / "temp.bmp")
         shutil.copy("Tests/images/rgb32bf-rgba.bmp", temp_file)
@@ -339,6 +362,12 @@
         assert_image_equal(offset.crop((64, 64, 127, 127)), target.crop((0, 0, 63, 63)))
         assert offset.size == (128, 128)
 
+        # with negative offset
+        offset = src.copy()
+        offset.alpha_composite(over, (-64, -64))
+        assert_image_equal(offset.crop((0, 0, 63, 63)), target.crop((64, 64, 127, 127)))
+        assert offset.size == (128, 128)
+
         # offset and crop
         box = src.copy()
         box.alpha_composite(over, (64, 64), (0, 0, 32, 32))
@@ -363,8 +392,6 @@
         with pytest.raises(ValueError):
             source.alpha_composite(over, (0, 0), 0)
         with pytest.raises(ValueError):
-            source.alpha_composite(over, (0, -1))
-        with pytest.raises(ValueError):
             source.alpha_composite(over, (0, 0), (0, -1))
 
     def test_registered_extensions_uninitialized(self):
@@ -408,8 +435,7 @@
 
         # Assert
         assert im.size == (512, 512)
-        with Image.open("Tests/images/effect_mandelbrot.png") as im2:
-            assert_image_equal(im, im2)
+        assert_image_equal_tofile(im, "Tests/images/effect_mandelbrot.png")
 
     def test_effect_mandelbrot_bad_arguments(self):
         # Arrange
@@ -451,8 +477,7 @@
 
         # Assert
         assert im.size == (128, 128)
-        with Image.open("Tests/images/effect_spread.png") as im3:
-            assert_image_similar(im2, im3, 110)
+        assert_image_similar_tofile(im2, "Tests/images/effect_spread.png", 110)
 
     def test_effect_spread_zero(self):
         # Arrange
@@ -516,7 +541,7 @@
 
         # Arrange
         target_file = "Tests/images/linear_gradient.png"
-        for mode in ["L", "P"]:
+        for mode in ["L", "P", "I", "F"]:
 
             # Act
             im = Image.linear_gradient(mode)
@@ -542,7 +567,7 @@
 
         # Arrange
         target_file = "Tests/images/radial_gradient.png"
-        for mode in ["L", "P"]:
+        for mode in ["L", "P", "I", "F"]:
 
             # Act
             im = Image.radial_gradient(mode)
@@ -573,6 +598,10 @@
         assert ext_individual == ext_multiple
 
     def test_remap_palette(self):
+        # Test identity transform
+        with Image.open("Tests/images/hopper.gif") as im:
+            assert_image_equal(im, im.remap_palette(list(range(256))))
+
         # Test illegal image mode
         with hopper() as im:
             with pytest.raises(ValueError):
@@ -597,7 +626,7 @@
             else:
                 assert new_im.palette is None
 
-        _make_new(im, im_p, im_p.palette)
+        _make_new(im, im_p, ImagePalette.ImagePalette(list(range(256)) * 3))
         _make_new(im_p, im, None)
         _make_new(im, blank_p, ImagePalette.ImagePalette())
         _make_new(im, blank_pa, ImagePalette.ImagePalette())
@@ -612,22 +641,6 @@
             expected = Image.new(mode, (100, 100), color)
             assert_image_equal(im.convert(mode), expected)
 
-    def test_showxv_deprecation(self):
-        class TestViewer(ImageShow.Viewer):
-            def show_image(self, image, **options):
-                return True
-
-        viewer = TestViewer()
-        ImageShow.register(viewer, -1)
-
-        im = Image.new("RGB", (50, 50), "white")
-
-        with pytest.warns(DeprecationWarning):
-            Image._showxv(im)
-
-        # Restore original state
-        ImageShow._viewers.pop(0)
-
     def test_no_resource_warning_on_save(self, tmp_path):
         # https://github.com/python-pillow/Pillow/issues/835
         # Arrange
@@ -636,7 +649,17 @@
 
         # Act/Assert
         with Image.open(test_file) as im:
-            pytest.warns(None, im.save, temp_file)
+            with warnings.catch_warnings():
+                im.save(temp_file)
+
+    def test_no_new_file_on_error(self, tmp_path):
+        temp_file = str(tmp_path / "temp.jpg")
+
+        im = Image.new("RGB", (0, 0))
+        with pytest.raises(ValueError):
+            im.save(temp_file)
+
+        assert not os.path.exists(temp_file)
 
     def test_load_on_nonexclusive_multiframe(self):
         with open("Tests/images/frozenpond.mpo", "rb") as fp:
@@ -652,48 +675,64 @@
 
             assert not fp.closed
 
+    def test_empty_exif(self):
+        with Image.open("Tests/images/exif.png") as im:
+            exif = im.getexif()
+        assert dict(exif) != {}
+
+        # Test that exif data is cleared after another load
+        exif.load(None)
+        assert dict(exif) == {}
+
+        # Test loading just the EXIF header
+        exif.load(b"Exif\x00\x00")
+        assert dict(exif) == {}
+
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_exif_jpeg(self, tmp_path):
         with Image.open("Tests/images/exif-72dpi-int.jpg") as im:  # Little endian
             exif = im.getexif()
             assert 258 not in exif
             assert 274 in exif
-            assert 40960 in exif
-            assert exif[40963] == 450
+            assert 282 in exif
+            assert exif[296] == 2
             assert exif[11] == "gThumb 3.0.1"
 
             out = str(tmp_path / "temp.jpg")
             exif[258] = 8
             del exif[274]
-            del exif[40960]
-            exif[40963] = 455
+            del exif[282]
+            exif[296] = 455
             exif[11] = "Pillow test"
             im.save(out, exif=exif)
         with Image.open(out) as reloaded:
             reloaded_exif = reloaded.getexif()
             assert reloaded_exif[258] == 8
             assert 274 not in reloaded_exif
-            assert 40960 not in reloaded_exif
-            assert reloaded_exif[40963] == 455
+            assert 282 not in reloaded_exif
+            assert reloaded_exif[296] == 455
             assert reloaded_exif[11] == "Pillow test"
 
         with Image.open("Tests/images/no-dpi-in-exif.jpg") as im:  # Big endian
             exif = im.getexif()
             assert 258 not in exif
-            assert 40962 in exif
-            assert exif[40963] == 200
+            assert 306 in exif
+            assert exif[274] == 1
             assert exif[305] == "Adobe Photoshop CC 2017 (Macintosh)"
 
             out = str(tmp_path / "temp.jpg")
             exif[258] = 8
-            del exif[34665]
-            exif[40963] = 455
+            del exif[306]
+            exif[274] = 455
             exif[305] = "Pillow test"
             im.save(out, exif=exif)
         with Image.open(out) as reloaded:
             reloaded_exif = reloaded.getexif()
             assert reloaded_exif[258] == 8
-            assert 34665 not in reloaded_exif
-            assert reloaded_exif[40963] == 455
+            assert 306 not in reloaded_exif
+            assert reloaded_exif[274] == 455
             assert reloaded_exif[305] == "Pillow test"
 
     @skip_unless_feature("webp")
@@ -746,34 +785,80 @@
                 4098: 1704,
             }
 
-    @pytest.mark.parametrize(
-        "test_module",
-        [PIL, Image],
-    )
-    def test_pillow_version(self, test_module):
+            reloaded_exif = Image.Exif()
+            reloaded_exif.load(exif.tobytes())
+            assert reloaded_exif.get_ifd(0xA005) == exif.get_ifd(0xA005)
+
+    def test_exif_ifd(self):
+        with Image.open("Tests/images/flower.jpg") as im:
+            exif = im.getexif()
+        del exif.get_ifd(0x8769)[0xA005]
+
+        reloaded_exif = Image.Exif()
+        reloaded_exif.load(exif.tobytes())
+        assert reloaded_exif.get_ifd(0x8769) == exif.get_ifd(0x8769)
+
+    def test_exif_load_from_fp(self):
+        with Image.open("Tests/images/flower.jpg") as im:
+            data = im.info["exif"]
+            if data.startswith(b"Exif\x00\x00"):
+                data = data[6:]
+            fp = io.BytesIO(data)
+
+            exif = Image.Exif()
+            exif.load_from_fp(fp)
+            assert exif == {
+                271: "Canon",
+                272: "Canon PowerShot S40",
+                274: 1,
+                282: 180.0,
+                283: 180.0,
+                296: 2,
+                306: "2003:12:14 12:01:44",
+                531: 1,
+                34665: 196,
+            }
+
+    @pytest.mark.parametrize("size", ((1, 0), (0, 1), (0, 0)))
+    def test_zero_tobytes(self, size):
+        im = Image.new("RGB", size)
+        assert im.tobytes() == b""
+
+    def test_categories_deprecation(self):
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION == PIL.__version__
+            assert hopper().category == 0
 
         with pytest.warns(DeprecationWarning):
-            str(test_module.PILLOW_VERSION)
-
+            assert Image.NORMAL == 0
         with pytest.warns(DeprecationWarning):
-            assert int(test_module.PILLOW_VERSION[0]) >= 7
-
+            assert Image.SEQUENCE == 1
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION < "9.9.0"
-
+            assert Image.CONTAINER == 2
+
+    def test_constants_deprecation(self):
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION <= "9.9.0"
-
+            assert Image.NEAREST == 0
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION != "7.0.0"
+            assert Image.NONE == 0
 
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION >= "7.0.0"
-
+            assert Image.LINEAR == Image.Resampling.BILINEAR
         with pytest.warns(DeprecationWarning):
-            assert test_module.PILLOW_VERSION > "7.0.0"
+            assert Image.CUBIC == Image.Resampling.BICUBIC
+        with pytest.warns(DeprecationWarning):
+            assert Image.ANTIALIAS == Image.Resampling.LANCZOS
+
+        for enum in (
+            Image.Transpose,
+            Image.Transform,
+            Image.Resampling,
+            Image.Dither,
+            Image.Palette,
+            Image.Quantize,
+        ):
+            for name in enum.__members__:
+                with pytest.warns(DeprecationWarning):
+                    assert getattr(Image, name) == enum[name]
 
     @pytest.mark.parametrize(
         "path",
@@ -810,18 +895,6 @@
             except OSError as e:
                 assert str(e) == "buffer overrun when reading image file"
 
-    def test_show_deprecation(self, monkeypatch):
-        monkeypatch.setattr(Image, "_show", lambda *args, **kwargs: None)
-
-        im = Image.new("RGB", (50, 50), "white")
-
-        with pytest.warns(None) as raised:
-            im.show()
-        assert not raised
-
-        with pytest.warns(DeprecationWarning):
-            im.show(command="mock")
-
 
 class MockEncoder:
     pass
('Tests', 'test_imageqt.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,20 +1,27 @@
+import warnings
+
 import pytest
 
 from PIL import ImageQt
 
-from .helper import hopper
+from .helper import assert_image_similar, hopper
+
+pytestmark = pytest.mark.skipif(
+    not ImageQt.qt_is_installed, reason="Qt bindings are not installed"
+)
 
 if ImageQt.qt_is_installed:
     from PIL.ImageQt import qRgba
 
 
-@pytest.mark.skipif(not ImageQt.qt_is_installed, reason="Qt bindings are not installed")
 def test_rgb():
     # from https://doc.qt.io/archives/qt-4.8/qcolor.html
     # typedef QRgb
     # An ARGB quadruplet on the format #AARRGGBB,
     # equivalent to an unsigned int.
-    if ImageQt.qt_version == "side6":
+    if ImageQt.qt_version == "6":
+        from PyQt6.QtGui import qRgb
+    elif ImageQt.qt_version == "side6":
         from PySide6.QtGui import qRgb
     elif ImageQt.qt_version == "5":
         from PyQt5.QtGui import qRgb
@@ -25,10 +32,10 @@
 
     def checkrgb(r, g, b):
         val = ImageQt.rgb(r, g, b)
-        val = val % 2 ** 24  # drop the alpha
+        val = val % 2**24  # drop the alpha
         assert val >> 16 == r
-        assert ((val >> 8) % 2 ** 8) == g
-        assert val % 2 ** 8 == b
+        assert ((val >> 8) % 2**8) == g
+        assert val % 2**8 == b
 
     checkrgb(0, 0, 0)
     checkrgb(255, 0, 0)
@@ -36,7 +43,20 @@
     checkrgb(0, 0, 255)
 
 
-@pytest.mark.skipif(not ImageQt.qt_is_installed, reason="Qt bindings are not installed")
 def test_image():
-    for mode in ("1", "RGB", "RGBA", "L", "P"):
-        ImageQt.ImageQt(hopper(mode))
+    modes = ["1", "RGB", "RGBA", "L", "P"]
+    qt_format = ImageQt.QImage.Format if ImageQt.qt_version == "6" else ImageQt.QImage
+    if hasattr(qt_format, "Format_Grayscale16"):  # Qt 5.13+
+        modes.append("I;16")
+
+    for mode in modes:
+        im = hopper(mode)
+        roundtripped_im = ImageQt.fromqimage(ImageQt.ImageQt(im))
+        if mode not in ("RGB", "RGBA"):
+            im = im.convert("RGB")
+        assert_image_similar(roundtripped_im, im, 1)
+
+
+def test_closed_file():
+    with warnings.catch_warnings():
+        ImageQt.ImageQt("Tests/images/hopper.gif")
('Tests', 'test_file_ftex.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,15 +1,32 @@
-from PIL import Image
+import pytest
 
-from .helper import assert_image_equal, assert_image_similar
+from PIL import FtexImagePlugin, Image
+
+from .helper import assert_image_equal_tofile, assert_image_similar
 
 
 def test_load_raw():
     with Image.open("Tests/images/ftex_uncompressed.ftu") as im:
-        with Image.open("Tests/images/ftex_uncompressed.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/ftex_uncompressed.png")
 
 
 def test_load_dxt1():
     with Image.open("Tests/images/ftex_dxt1.ftc") as im:
         with Image.open("Tests/images/ftex_dxt1.png") as target:
             assert_image_similar(im, target.convert("RGBA"), 15)
+
+
+def test_invalid_file():
+    invalid_file = "Tests/images/flower.jpg"
+
+    with pytest.raises(SyntaxError):
+        FtexImagePlugin.FtexImageFile(invalid_file)
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        FtexImagePlugin.Format: "FORMAT_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(FtexImagePlugin, prefix + name) == enum[name]
('Tests', 'test_file_wmf.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@
 
 from PIL import Image, WmfImagePlugin
 
-from .helper import assert_image_similar, hopper
+from .helper import assert_image_similar_tofile, hopper
 
 
 def test_load_raw():
@@ -13,9 +13,7 @@
             # Currently, support for WMF/EMF is Windows-only
             im.load()
             # Compare to reference rendering
-            with Image.open("Tests/images/drawing_emf_ref.png") as imref:
-                imref.load()
-                assert_image_similar(im, imref, 0)
+            assert_image_similar_tofile(im, "Tests/images/drawing_emf_ref.png", 0)
 
     # Test basic WMF open and rendering
     with Image.open("Tests/images/drawing.wmf") as im:
@@ -23,9 +21,13 @@
             # Currently, support for WMF/EMF is Windows-only
             im.load()
             # Compare to reference rendering
-            with Image.open("Tests/images/drawing_wmf_ref.png") as imref:
-                imref.load()
-                assert_image_similar(im, imref, 2.0)
+            assert_image_similar_tofile(im, "Tests/images/drawing_wmf_ref.png", 2.0)
+
+
+def test_load():
+    with Image.open("Tests/images/drawing.emf") as im:
+        if hasattr(Image.core, "drawwmf"):
+            assert im.load()[0, 0] == (255, 255, 255)
 
 
 def test_register_handler(tmp_path):
@@ -48,14 +50,9 @@
     WmfImagePlugin.register_handler(original_handler)
 
 
-def test_load_dpi_rounding():
-    # Round up
+def test_load_float_dpi():
     with Image.open("Tests/images/drawing.emf") as im:
-        assert im.info["dpi"] == 1424
-
-    # Round down
-    with Image.open("Tests/images/drawing_roundDown.emf") as im:
-        assert im.info["dpi"] == 1426
+        assert im.info["dpi"] == 1423.7668161434979
 
 
 def test_load_set_dpi():
@@ -66,8 +63,7 @@
             im.load(144)
             assert im.size == (164, 164)
 
-            with Image.open("Tests/images/drawing_wmf_ref_144.png") as expected:
-                assert_image_similar(im, expected, 2.1)
+            assert_image_similar_tofile(im, "Tests/images/drawing_wmf_ref_144.png", 2.1)
 
 
 def test_save(tmp_path):
('Tests', 'test_imagepalette.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,31 +2,75 @@
 
 from PIL import Image, ImagePalette
 
-from .helper import assert_image_equal
+from .helper import assert_image_equal, assert_image_equal_tofile
 
 
 def test_sanity():
 
-    ImagePalette.ImagePalette("RGB", list(range(256)) * 3)
-    with pytest.raises(ValueError):
-        ImagePalette.ImagePalette("RGB", list(range(256)) * 2)
+    palette = ImagePalette.ImagePalette("RGB", list(range(256)) * 3)
+    assert len(palette.colors) == 256
+
+    with pytest.warns(DeprecationWarning):
+        with pytest.raises(ValueError):
+            ImagePalette.ImagePalette("RGB", list(range(256)) * 3, 10)
+
+
+def test_reload():
+    with Image.open("Tests/images/hopper.gif") as im:
+        original = im.copy()
+        im.palette.dirty = 1
+        assert_image_equal(im.convert("RGB"), original.convert("RGB"))
 
 
 def test_getcolor():
 
     palette = ImagePalette.ImagePalette()
+    assert len(palette.palette) == 0
+    assert len(palette.colors) == 0
 
     test_map = {}
     for i in range(256):
         test_map[palette.getcolor((i, i, i))] = i
+    assert len(test_map) == 256
 
-    assert len(test_map) == 256
+    # Colors can be converted between RGB and RGBA
+    rgba_palette = ImagePalette.ImagePalette("RGBA")
+    assert rgba_palette.getcolor((0, 0, 0)) == rgba_palette.getcolor((0, 0, 0, 255))
+
+    assert palette.getcolor((0, 0, 0)) == palette.getcolor((0, 0, 0, 255))
+
+    # An error is raised when the palette is full
     with pytest.raises(ValueError):
         palette.getcolor((1, 2, 3))
+    # But not if the image is not using one of the palette entries
+    palette.getcolor((1, 2, 3), image=Image.new("P", (1, 1)))
 
     # Test unknown color specifier
     with pytest.raises(ValueError):
         palette.getcolor("unknown")
+
+
+@pytest.mark.parametrize(
+    "index, palette",
+    [
+        # Test when the palette is not full
+        (0, ImagePalette.ImagePalette()),
+        # Test when the palette is full
+        (255, ImagePalette.ImagePalette("RGB", list(range(256)) * 3)),
+    ],
+)
+def test_getcolor_not_special(index, palette):
+    im = Image.new("P", (1, 1))
+
+    # Do not use transparency index as a new color
+    im.info["transparency"] = index
+    index1 = palette.getcolor((0, 0, 0), im)
+    assert index1 != index
+
+    # Do not use background index as a new color
+    im.info["background"] = index1
+    index2 = palette.getcolor((0, 0, 1), im)
+    assert index2 not in (index, index1)
 
 
 def test_file(tmp_path):
@@ -116,7 +160,7 @@
     mode, data_out = palette.getdata()
 
     # Assert
-    assert mode == "RGB;L"
+    assert mode == "RGB"
 
 
 def test_rawmode_getdata():
@@ -141,8 +185,7 @@
     img.putpalette(b"\xFF\x00\x00\x00\xFF\x00\x00\x00\xFF")  # RGB
     img.save(outfile, format="PNG")
 
-    with Image.open(outfile) as reloaded:
-        assert_image_equal(img, reloaded)
+    assert_image_equal_tofile(img, outfile)
 
 
 def test_invalid_palette():
('Tests', 'test_file_spider.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,11 +1,12 @@
 import tempfile
+import warnings
 from io import BytesIO
 
 import pytest
 
 from PIL import Image, ImageSequence, SpiderImagePlugin
 
-from .helper import assert_image_equal, hopper, is_pypy
+from .helper import assert_image_equal_tofile, hopper, is_pypy
 
 TEST_FILE = "Tests/images/hopper.spider"
 
@@ -28,20 +29,16 @@
 
 
 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(TEST_FILE)
         im.load()
         im.close()
 
-    pytest.warns(None, open)
-
 
 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(TEST_FILE) as im:
             im.load()
-
-    pytest.warns(None, open)
 
 
 def test_save(tmp_path):
@@ -136,7 +133,8 @@
     invalid_file = "Tests/images/invalid.spider"
 
     with pytest.raises(OSError):
-        Image.open(invalid_file)
+        with Image.open(invalid_file):
+            pass
 
 
 def test_nonstack_file():
@@ -159,5 +157,4 @@
     im.save(data, format="SPIDER")
 
     data.seek(0)
-    with Image.open(data) as im2:
-        assert_image_equal(im, im2)
+    assert_image_equal_tofile(im, data)
('Tests', 'test_file_eps.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,13 @@
 
 from PIL import EpsImagePlugin, Image, features
 
-from .helper import assert_image_similar, hopper, skip_unless_feature
+from .helper import (
+    assert_image_similar,
+    assert_image_similar_tofile,
+    hopper,
+    mark_if_feature_version,
+    skip_unless_feature,
+)
 
 HAS_GHOSTSCRIPT = EpsImagePlugin.has_ghostscript()
 
@@ -52,6 +58,15 @@
         assert image2_scale2.format == "EPS"
 
 
+@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason="Ghostscript not available")
+def test_load():
+    with Image.open(FILE1) as im:
+        assert im.load()[0, 0] == (255, 255, 255)
+
+        # Test again now that it has already been loaded once
+        assert im.load()[0, 0] == (255, 255, 255)
+
+
 def test_invalid_file():
     invalid_file = "Tests/images/flower.jpg"
 
@@ -59,6 +74,9 @@
         EpsImagePlugin.EpsImageFile(invalid_file)
 
 
+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 @pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason="Ghostscript not available")
 def test_cmyk():
     with Image.open("Tests/images/pil_sample_cmyk.eps") as cmyk_image:
@@ -71,8 +89,9 @@
         assert cmyk_image.mode == "RGB"
 
         if features.check("jpg"):
-            with Image.open("Tests/images/pil_sample_rgb.jpg") as target:
-                assert_image_similar(cmyk_image, target, 10)
+            assert_image_similar_tofile(
+                cmyk_image, "Tests/images/pil_sample_rgb.jpg", 10
+            )
 
 
 @pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason="Ghostscript not available")
@@ -82,6 +101,17 @@
         with Image.open("Tests/images/reqd_showpage.png") as target:
             # should not crash/hang
             plot_image.load()
+            #  fonts could be slightly different
+            assert_image_similar(plot_image, target, 6)
+
+
+@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason="Ghostscript not available")
+def test_transparency():
+    with Image.open("Tests/images/reqd_showpage.eps") as plot_image:
+        plot_image.load(transparency=True)
+        assert plot_image.mode == "RGBA"
+
+        with Image.open("Tests/images/reqd_showpage_transparency.png") as target:
             #  fonts could be slightly different
             assert_image_similar(plot_image, target, 6)
 
@@ -257,3 +287,15 @@
     assert image.mode == "RGB"
     assert image.size == (460, 352)
     assert image.format == "EPS"
+
+
+@pytest.mark.timeout(timeout=5)
+@pytest.mark.parametrize(
+    "test_file",
+    ["Tests/images/timeout-d675703545fee17acab56e5fec644c19979175de.eps"],
+)
+def test_timeout(test_file):
+    with open(test_file, "rb") as f:
+        with pytest.raises(Image.UnidentifiedImageError):
+            with Image.open(f):
+                pass
('Tests', 'test_image_transform.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -32,17 +32,24 @@
             new_im = im.transform((100, 100), transform)
         assert new_im.info["comment"] == comment
 
+    def test_palette(self):
+        with Image.open("Tests/images/hopper.gif") as im:
+            transformed = im.transform(
+                im.size, Image.Transform.AFFINE, [1, 0, 0, 0, 1, 0]
+            )
+            assert im.palette.palette == transformed.palette.palette
+
     def test_extent(self):
         im = hopper("RGB")
         (w, h) = im.size
         # fmt: off
-        transformed = im.transform(im.size, Image.EXTENT,
+        transformed = im.transform(im.size, Image.Transform.EXTENT,
                                    (0, 0,
                                     w//2, h//2),  # ul -> lr
-                                   Image.BILINEAR)
+                                   Image.Resampling.BILINEAR)
         # fmt: on
 
-        scaled = im.resize((w * 2, h * 2), Image.BILINEAR).crop((0, 0, w, h))
+        scaled = im.resize((w * 2, h * 2), Image.Resampling.BILINEAR).crop((0, 0, w, h))
 
         # undone -- precision?
         assert_image_similar(transformed, scaled, 23)
@@ -52,15 +59,18 @@
         im = hopper("RGB")
         (w, h) = im.size
         # fmt: off
-        transformed = im.transform(im.size, Image.QUAD,
+        transformed = im.transform(im.size, Image.Transform.QUAD,
                                    (0, 0, 0, h//2,
                                     # ul -> ccw around quad:
                                     w//2, h//2, w//2, 0),
-                                   Image.BILINEAR)
+                                   Image.Resampling.BILINEAR)
         # fmt: on
 
         scaled = im.transform(
-            (w, h), Image.AFFINE, (0.5, 0, 0, 0, 0.5, 0), Image.BILINEAR
+            (w, h),
+            Image.Transform.AFFINE,
+            (0.5, 0, 0, 0, 0.5, 0),
+            Image.Resampling.BILINEAR,
         )
 
         assert_image_equal(transformed, scaled)
@@ -75,9 +85,9 @@
             (w, h) = im.size
             transformed = im.transform(
                 im.size,
-                Image.EXTENT,
+                Image.Transform.EXTENT,
                 (0, 0, w * 2, h * 2),
-                Image.BILINEAR,
+                Image.Resampling.BILINEAR,
                 fillcolor="red",
             )
 
@@ -88,18 +98,21 @@
         im = hopper("RGBA")
         (w, h) = im.size
         # fmt: off
-        transformed = im.transform(im.size, Image.MESH,
+        transformed = im.transform(im.size, Image.Transform.MESH,
                                    [((0, 0, w//2, h//2),  # box
                                     (0, 0, 0, h,
                                      w, h, w, 0)),  # ul -> ccw around quad
                                     ((w//2, h//2, w, h),  # box
                                     (0, 0, 0, h,
                                      w, h, w, 0))],  # ul -> ccw around quad
-                                   Image.BILINEAR)
+                                   Image.Resampling.BILINEAR)
         # fmt: on
 
         scaled = im.transform(
-            (w // 2, h // 2), Image.AFFINE, (2, 0, 0, 0, 2, 0), Image.BILINEAR
+            (w // 2, h // 2),
+            Image.Transform.AFFINE,
+            (2, 0, 0, 0, 2, 0),
+            Image.Resampling.BILINEAR,
         )
 
         checker = Image.new("RGBA", im.size)
@@ -132,16 +145,55 @@
 
     def test_alpha_premult_resize(self):
         def op(im, sz):
-            return im.resize(sz, Image.BILINEAR)
+            return im.resize(sz, Image.Resampling.BILINEAR)
 
         self._test_alpha_premult(op)
 
     def test_alpha_premult_transform(self):
         def op(im, sz):
             (w, h) = im.size
-            return im.transform(sz, Image.EXTENT, (0, 0, w, h), Image.BILINEAR)
+            return im.transform(
+                sz, Image.Transform.EXTENT, (0, 0, w, h), Image.Resampling.BILINEAR
+            )
 
         self._test_alpha_premult(op)
+
+    def _test_nearest(self, op, mode):
+        # create white image with half transparent,
+        # do op,
+        # the image should remain white with half transparent
+        transparent, opaque = {
+            "RGBA": ((255, 255, 255, 0), (255, 255, 255, 255)),
+            "LA": ((255, 0), (255, 255)),
+        }[mode]
+        im = Image.new(mode, (10, 10), transparent)
+        im2 = Image.new(mode, (5, 10), opaque)
+        im.paste(im2, (0, 0))
+
+        im = op(im, (40, 10))
+
+        colors = im.getcolors()
+        assert colors == [
+            (20 * 10, opaque),
+            (20 * 10, transparent),
+        ]
+
+    @pytest.mark.parametrize("mode", ("RGBA", "LA"))
+    def test_nearest_resize(self, mode):
+        def op(im, sz):
+            return im.resize(sz, Image.Resampling.NEAREST)
+
+        self._test_nearest(op, mode)
+
+    @pytest.mark.parametrize("mode", ("RGBA", "LA"))
+    def test_nearest_transform(self, mode):
+        def op(im, sz):
+            (w, h) = im.size
+            return im.transform(
+                sz, Image.Transform.EXTENT, (0, 0, w, h), Image.Resampling.NEAREST
+            )
+
+        self._test_nearest(op, mode)
 
     def test_blank_fill(self):
         # attempting to hit
@@ -173,13 +225,15 @@
     def test_unknown_resampling_filter(self):
         with hopper() as im:
             (w, h) = im.size
-            for resample in (Image.BOX, "unknown"):
+            for resample in (Image.Resampling.BOX, "unknown"):
                 with pytest.raises(ValueError):
-                    im.transform((100, 100), Image.EXTENT, (0, 0, w, h), resample)
+                    im.transform(
+                        (100, 100), Image.Transform.EXTENT, (0, 0, w, h), resample
+                    )
 
 
 class TestImageTransformAffine:
-    transform = Image.AFFINE
+    transform = Image.Transform.AFFINE
 
     def _test_image(self):
         im = hopper("RGB")
@@ -207,7 +261,11 @@
         else:
             transposed = im
 
-        for resample in [Image.NEAREST, Image.BILINEAR, Image.BICUBIC]:
+        for resample in [
+            Image.Resampling.NEAREST,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.BICUBIC,
+        ]:
             transformed = im.transform(
                 transposed.size, self.transform, matrix, resample
             )
@@ -217,13 +275,13 @@
         self._test_rotate(0, None)
 
     def test_rotate_90_deg(self):
-        self._test_rotate(90, Image.ROTATE_90)
+        self._test_rotate(90, Image.Transpose.ROTATE_90)
 
     def test_rotate_180_deg(self):
-        self._test_rotate(180, Image.ROTATE_180)
+        self._test_rotate(180, Image.Transpose.ROTATE_180)
 
     def test_rotate_270_deg(self):
-        self._test_rotate(270, Image.ROTATE_270)
+        self._test_rotate(270, Image.Transpose.ROTATE_270)
 
     def _test_resize(self, scale, epsilonscale):
         im = self._test_image()
@@ -233,9 +291,9 @@
         matrix_down = [scale, 0, 0, 0, scale, 0, 0, 0]
 
         for resample, epsilon in [
-            (Image.NEAREST, 0),
-            (Image.BILINEAR, 2),
-            (Image.BICUBIC, 1),
+            (Image.Resampling.NEAREST, 0),
+            (Image.Resampling.BILINEAR, 2),
+            (Image.Resampling.BICUBIC, 1),
         ]:
             transformed = im.transform(size_up, self.transform, matrix_up, resample)
             transformed = transformed.transform(
@@ -266,9 +324,9 @@
         matrix_down = [1, 0, x, 0, 1, y, 0, 0]
 
         for resample, epsilon in [
-            (Image.NEAREST, 0),
-            (Image.BILINEAR, 1.5),
-            (Image.BICUBIC, 1),
+            (Image.Resampling.NEAREST, 0),
+            (Image.Resampling.BILINEAR, 1.5),
+            (Image.Resampling.BICUBIC, 1),
         ]:
             transformed = im.transform(size_up, self.transform, matrix_up, resample)
             transformed = transformed.transform(
@@ -288,4 +346,4 @@
 
 class TestImageTransformPerspective(TestImageTransformAffine):
     # Repeat all tests for AFFINE transformations with PERSPECTIVE
-    transform = Image.PERSPECTIVE
+    transform = Image.Transform.PERSPECTIVE
('Tests', '32bit_segfault_check.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,8 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 
 import sys
 
 from PIL import Image
 
-if sys.maxsize < 2 ** 32:
+if sys.maxsize < 2**32:
     im = Image.new("L", (999999, 999999), 0)
('Tests', 'test_image_resize.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -7,7 +7,12 @@
 
 from PIL import Image
 
-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_equal_tofile,
+    assert_image_similar,
+    hopper,
+)
 
 
 class TestImagingCoreResize:
@@ -30,33 +35,33 @@
             "I;16",
         ]:  # exotic mode
             im = hopper(mode)
-            r = self.resize(im, (15, 12), Image.NEAREST)
+            r = self.resize(im, (15, 12), Image.Resampling.NEAREST)
             assert r.mode == mode
             assert r.size == (15, 12)
             assert r.im.bands == im.im.bands
 
     def test_convolution_modes(self):
         with pytest.raises(ValueError):
-            self.resize(hopper("1"), (15, 12), Image.BILINEAR)
-        with pytest.raises(ValueError):
-            self.resize(hopper("P"), (15, 12), Image.BILINEAR)
-        with pytest.raises(ValueError):
-            self.resize(hopper("I;16"), (15, 12), Image.BILINEAR)
+            self.resize(hopper("1"), (15, 12), Image.Resampling.BILINEAR)
+        with pytest.raises(ValueError):
+            self.resize(hopper("P"), (15, 12), Image.Resampling.BILINEAR)
+        with pytest.raises(ValueError):
+            self.resize(hopper("I;16"), (15, 12), Image.Resampling.BILINEAR)
         for mode in ["L", "I", "F", "RGB", "RGBA", "CMYK", "YCbCr"]:
             im = hopper(mode)
-            r = self.resize(im, (15, 12), Image.BILINEAR)
+            r = self.resize(im, (15, 12), Image.Resampling.BILINEAR)
             assert r.mode == mode
             assert r.size == (15, 12)
             assert r.im.bands == im.im.bands
 
     def test_reduce_filters(self):
         for f in [
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ]:
             r = self.resize(hopper("RGB"), (15, 12), f)
             assert r.mode == "RGB"
@@ -64,12 +69,12 @@
 
     def test_enlarge_filters(self):
         for f in [
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ]:
             r = self.resize(hopper("RGB"), (212, 195), f)
             assert r.mode == "RGB"
@@ -90,12 +95,12 @@
         samples["dirty"].putpixel((1, 1), 128)
 
         for f in [
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ]:
             # samples resized with current filter
             references = {
@@ -119,12 +124,12 @@
 
     def test_enlarge_zero(self):
         for f in [
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ]:
             r = self.resize(Image.new("RGB", (0, 0), "white"), (212, 195), f)
             assert r.mode == "RGB"
@@ -135,11 +140,22 @@
         with pytest.raises(ValueError):
             self.resize(hopper(), (10, 10), 9)
 
+    def test_cross_platform(self, tmp_path):
+        # This test is intended for only check for consistent behaviour across
+        # platforms. So if a future Pillow change requires that the test file
+        # be updated, that is okay.
+        im = hopper().resize((64, 64))
+        temp_file = str(tmp_path / "temp.gif")
+        im.save(temp_file)
+
+        with Image.open(temp_file) as reloaded:
+            assert_image_equal_tofile(reloaded, "Tests/images/hopper_resized.gif")
+
 
 @pytest.fixture
 def gradients_image():
-    im = Image.open("Tests/images/radial_gradients.png")
-    im.load()
+    with Image.open("Tests/images/radial_gradients.png") as im:
+        im.load()
     try:
         yield im
     finally:
@@ -148,15 +164,19 @@
 
 class TestReducingGapResize:
     def test_reducing_gap_values(self, gradients_image):
-        ref = gradients_image.resize((52, 34), Image.BICUBIC, reducing_gap=None)
-        im = gradients_image.resize((52, 34), Image.BICUBIC)
+        ref = gradients_image.resize(
+            (52, 34), Image.Resampling.BICUBIC, reducing_gap=None
+        )
+        im = gradients_image.resize((52, 34), Image.Resampling.BICUBIC)
         assert_image_equal(ref, im)
 
         with pytest.raises(ValueError):
-            gradients_image.resize((52, 34), Image.BICUBIC, reducing_gap=0)
-
-        with pytest.raises(ValueError):
-            gradients_image.resize((52, 34), Image.BICUBIC, reducing_gap=0.99)
+            gradients_image.resize((52, 34), Image.Resampling.BICUBIC, reducing_gap=0)
+
+        with pytest.raises(ValueError):
+            gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, reducing_gap=0.99
+            )
 
     def test_reducing_gap_1(self, gradients_image):
         for box, epsilon in [
@@ -164,9 +184,9 @@
             ((1.1, 2.2, 510.8, 510.9), 4),
             ((3, 10, 410, 256), 10),
         ]:
-            ref = gradients_image.resize((52, 34), Image.BICUBIC, box=box)
-            im = gradients_image.resize(
-                (52, 34), Image.BICUBIC, box=box, reducing_gap=1.0
+            ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=1.0
             )
 
             with pytest.raises(AssertionError):
@@ -180,9 +200,9 @@
             ((1.1, 2.2, 510.8, 510.9), 1.5),
             ((3, 10, 410, 256), 1),
         ]:
-            ref = gradients_image.resize((52, 34), Image.BICUBIC, box=box)
-            im = gradients_image.resize(
-                (52, 34), Image.BICUBIC, box=box, reducing_gap=2.0
+            ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=2.0
             )
 
             with pytest.raises(AssertionError):
@@ -196,9 +216,9 @@
             ((1.1, 2.2, 510.8, 510.9), 1),
             ((3, 10, 410, 256), 0.5),
         ]:
-            ref = gradients_image.resize((52, 34), Image.BICUBIC, box=box)
-            im = gradients_image.resize(
-                (52, 34), Image.BICUBIC, box=box, reducing_gap=3.0
+            ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=3.0
             )
 
             with pytest.raises(AssertionError):
@@ -208,9 +228,9 @@
 
     def test_reducing_gap_8(self, gradients_image):
         for box in [None, (1.1, 2.2, 510.8, 510.9), (3, 10, 410, 256)]:
-            ref = gradients_image.resize((52, 34), Image.BICUBIC, box=box)
-            im = gradients_image.resize(
-                (52, 34), Image.BICUBIC, box=box, reducing_gap=8.0
+            ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=8.0
             )
 
             assert_image_equal(ref, im)
@@ -220,8 +240,10 @@
             ((0, 0, 512, 512), 5.5),
             ((0.9, 1.7, 128, 128), 9.5),
         ]:
-            ref = gradients_image.resize((52, 34), Image.BOX, box=box)
-            im = gradients_image.resize((52, 34), Image.BOX, box=box, reducing_gap=1.0)
+            ref = gradients_image.resize((52, 34), Image.Resampling.BOX, box=box)
+            im = gradients_image.resize(
+                (52, 34), Image.Resampling.BOX, box=box, reducing_gap=1.0
+            )
 
             assert_image_similar(ref, im, epsilon)
 
@@ -245,8 +267,12 @@
     def test_default_filter(self):
         for mode in "L", "RGB", "I", "F":
             im = hopper(mode)
-            assert im.resize((20, 20), Image.BICUBIC) == im.resize((20, 20))
+            assert im.resize((20, 20), Image.Resampling.BICUBIC) == im.resize((20, 20))
 
         for mode in "1", "P":
             im = hopper(mode)
-            assert im.resize((20, 20), Image.NEAREST) == im.resize((20, 20))
+            assert im.resize((20, 20), Image.Resampling.NEAREST) == im.resize((20, 20))
+
+        for mode in "I;16", "I;16L", "I;16B", "BGR;15", "BGR;16":
+            im = hopper(mode)
+            assert im.resize((20, 20), Image.Resampling.NEAREST) == im.resize((20, 20))
('Tests', 'test_format_hsv.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -77,7 +77,7 @@
 
 
 def test_wedge():
-    src = wedge().resize((3 * 32, 32), Image.BILINEAR)
+    src = wedge().resize((3 * 32, 32), Image.Resampling.BILINEAR)
     im = src.convert("HSV")
     comparable = to_hsv_colorsys(src)
 
('Tests', 'test_file_tiff_metadata.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -122,7 +122,7 @@
 
 
 def test_write_metadata(tmp_path):
-    """ Test metadata writing through the python code """
+    """Test metadata writing through the python code"""
     with Image.open("Tests/images/hopper.tif") as img:
         f = str(tmp_path / "temp.tiff")
         img.save(f, tiffinfo=img.tag)
@@ -179,6 +179,27 @@
     assert TAG_IDS["BestQualityScale"] == 50780
 
 
+def test_iptc(tmp_path):
+    out = str(tmp_path / "temp.tiff")
+    with Image.open("Tests/images/hopper.Lab.tif") as im:
+        im.save(out)
+
+
+def test_undefined_zero(tmp_path):
+    # Check that the tag has not been changed since this test was created
+    tag = TiffTags.TAGS_V2[45059]
+    assert tag.type == TiffTags.UNDEFINED
+    assert tag.length == 0
+
+    info = TiffImagePlugin.ImageFileDirectory(b"II*\x00\x08\x00\x00\x00")
+    info[45059] = b"test"
+
+    # Assert that the tag value does not change by setting it to itself
+    original = info[45059]
+    info[45059] = info[45059]
+    assert info[45059] == original
+
+
 def test_empty_metadata():
     f = io.BytesIO(b"II*\x00\x08\x00\x00\x00")
     head = f.read(8)
@@ -237,7 +258,7 @@
     im = hopper()
     info = TiffImagePlugin.ImageFileDirectory_v2()
 
-    max_long = 2 ** 32 - 1
+    max_long = 2**32 - 1
 
     # 4 bytes unsigned long
     numerator = max_long
@@ -269,8 +290,8 @@
     info = TiffImagePlugin.ImageFileDirectory_v2()
 
     # pair of 4 byte signed longs
-    numerator = 2 ** 31 - 1
-    denominator = -(2 ** 31)
+    numerator = 2**31 - 1
+    denominator = -(2**31)
 
     info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)
 
@@ -281,8 +302,8 @@
         assert numerator == reloaded.tag_v2[37380].numerator
         assert denominator == reloaded.tag_v2[37380].denominator
 
-    numerator = -(2 ** 31)
-    denominator = 2 ** 31 - 1
+    numerator = -(2**31)
+    denominator = 2**31 - 1
 
     info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)
 
@@ -294,7 +315,7 @@
         assert denominator == reloaded.tag_v2[37380].denominator
 
     # out of bounds of 4 byte signed long
-    numerator = -(2 ** 31) - 1
+    numerator = -(2**31) - 1
     denominator = 1
 
     info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)
@@ -303,7 +324,7 @@
     im.save(out, tiffinfo=info, compression="raw")
 
     with Image.open(out) as reloaded:
-        assert 2 ** 31 - 1 == reloaded.tag_v2[37380].numerator
+        assert 2**31 - 1 == reloaded.tag_v2[37380].numerator
         assert -1 == reloaded.tag_v2[37380].denominator
 
 
@@ -355,3 +376,30 @@
 
     # Should not raise ValueError.
     pytest.warns(UserWarning, lambda: ifd[277])
+
+
+def test_tag_group_data():
+    base_ifd = TiffImagePlugin.ImageFileDirectory_v2()
+    interop_ifd = TiffImagePlugin.ImageFileDirectory_v2(group=40965)
+    for ifd in (base_ifd, interop_ifd):
+        ifd[2] = "test"
+        ifd[256] = 10
+
+    assert base_ifd.tagtype[256] == 4
+    assert interop_ifd.tagtype[256] != base_ifd.tagtype[256]
+
+    assert interop_ifd.tagtype[2] == 7
+    assert base_ifd.tagtype[2] != interop_ifd.tagtype[256]
+
+
+def test_empty_subifd(tmp_path):
+    out = str(tmp_path / "temp.jpg")
+
+    im = hopper()
+    exif = im.getexif()
+    exif[TiffImagePlugin.EXIFIFD] = {}
+    im.save(out, exif=exif)
+
+    with Image.open(out) as reloaded:
+        exif = reloaded.getexif()
+        assert exif.get_ifd(TiffImagePlugin.EXIFIFD) == {}
('Tests', 'test_image_access.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,3 @@
-import ctypes
 import os
 import subprocess
 import sys
@@ -23,6 +22,11 @@
     except ImportError:
         cffi = None
 
+try:
+    import numpy
+except ImportError:
+    numpy = None
+
 
 class AccessTest:
     # initial value
@@ -66,6 +70,10 @@
         pix1 = im1.load()
         pix2 = im2.load()
 
+        for x, y in ((0, "0"), ("0", 0)):
+            with pytest.raises(TypeError):
+                pix1[x, y]
+
         for y in range(im1.size[1]):
             for x in range(im1.size[0]):
                 pix2[x, y] = pix1[x, y]
@@ -108,6 +116,13 @@
                 pix2[x, y] = pix1[x, y]
 
         assert_image_equal(im1, im2)
+
+    @pytest.mark.skipif(numpy is None, reason="NumPy not installed")
+    def test_numpy(self):
+        im = hopper()
+        pix = im.load()
+
+        assert pix[numpy.int32(1), numpy.int32(2)] == (18, 20, 59)
 
 
 class TestImageGetPixel(AccessTest):
@@ -138,14 +153,17 @@
 
         # Check 0
         im = Image.new(mode, (0, 0), None)
-        with pytest.raises(IndexError):
+        assert im.load() is not None
+
+        error = ValueError if self._need_cffi_access else IndexError
+        with pytest.raises(error):
             im.putpixel((0, 0), c)
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.getpixel((0, 0))
         # Check 0 negative index
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.putpixel((-1, -1), c)
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.getpixel((-1, -1))
 
         # check initial color
@@ -160,10 +178,10 @@
 
         # Check 0
         im = Image.new(mode, (0, 0), c)
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.getpixel((0, 0))
         # Check 0 negative index
-        with pytest.raises(IndexError):
+        with pytest.raises(error):
             im.getpixel((-1, -1))
 
     def test_basic(self):
@@ -189,10 +207,10 @@
         # see https://github.com/python-pillow/Pillow/issues/452
         # pixelaccess is using signed int* instead of uint*
         for mode in ("I;16", "I;16B"):
-            self.check(mode, 2 ** 15 - 1)
-            self.check(mode, 2 ** 15)
-            self.check(mode, 2 ** 15 + 1)
-            self.check(mode, 2 ** 16 - 1)
+            self.check(mode, 2**15 - 1)
+            self.check(mode, 2**15)
+            self.check(mode, 2**15 + 1)
+            self.check(mode, 2**16 - 1)
 
     def test_p_putpixel_rgb_rgba(self):
         for color in [(255, 0, 0), (255, 0, 0, 255)]:
@@ -339,6 +357,24 @@
             with pytest.raises(TypeError, match="color must be int or tuple"):
                 im.putpixel((0, 0), v)
 
+    @pytest.mark.parametrize(
+        ("mode", "band_numbers", "match"),
+        (
+            ("L", (0, 2), "color must be int or single-element tuple"),
+            ("LA", (0, 3), "color must be int, or tuple of one or two elements"),
+            (
+                "RGB",
+                (0, 2, 5),
+                "color must be int, or tuple of one, three or four elements",
+            ),
+        ),
+    )
+    def test_putpixel_invalid_number_of_bands(self, mode, band_numbers, match):
+        im = hopper(mode)
+        for band_number in band_numbers:
+            with pytest.raises(TypeError, match=match):
+                im.putpixel((0, 0), (0,) * band_number)
+
     @pytest.mark.parametrize("mode", IMAGE_MODES2)
     def test_putpixel_type_error2(self, mode):
         im = hopper(mode)
@@ -352,7 +388,7 @@
     def test_putpixel_overflow_error(self, mode):
         im = hopper(mode)
         with pytest.raises(OverflowError):
-            im.putpixel((0, 0), 2 ** 80)
+            im.putpixel((0, 0), 2**80)
 
     def test_putpixel_unrecognized_mode(self):
         im = hopper("BGR;15")
@@ -367,6 +403,8 @@
         "not from shell",
     )
     def test_embeddable(self):
+        import ctypes
+
         with open("embed_pil.c", "w") as fh:
             fh.write(
                 """
('Tests', 'test_font_pcf_charsets.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,11 @@
 
 from PIL import FontFile, Image, ImageDraw, ImageFont, PcfFontFile
 
-from .helper import assert_image_equal, assert_image_similar, skip_unless_feature
+from .helper import (
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
+    skip_unless_feature,
+)
 
 fontname = "Tests/fonts/ter-x20b.pcf"
 
@@ -47,8 +51,7 @@
     font.save(tempname)
 
     with Image.open(tempname.replace(".pil", ".pbm")) as loaded:
-        with Image.open(f"Tests/fonts/ter-x20b-{encoding}.pbm") as target:
-            assert_image_equal(loaded, target)
+        assert_image_equal_tofile(loaded, f"Tests/fonts/ter-x20b-{encoding}.pbm")
 
     with open(tempname, "rb") as f_loaded:
         with open(f"Tests/fonts/ter-x20b-{encoding}.pil", "rb") as f_target:
@@ -79,8 +82,7 @@
     draw = ImageDraw.Draw(im)
     message = charsets[encoding]["message"].encode(encoding)
     draw.text((0, 0), message, "black", font=font)
-    with Image.open(charsets[encoding]["image1"]) as target:
-        assert_image_similar(im, target, 0)
+    assert_image_similar_tofile(im, charsets[encoding]["image1"], 0)
 
 
 def test_draw_iso8859_1(request, tmp_path):
('Tests', 'test_image_putdata.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,5 +1,7 @@
 import sys
 from array import array
+
+import pytest
 
 from PIL import Image
 
@@ -36,7 +38,7 @@
     assert put(0xFFFFFFFF) == (255, 255, 255, 255)
     assert put(-1) == (255, 255, 255, 255)
     assert put(-1) == (255, 255, 255, 255)
-    if sys.maxsize > 2 ** 32:
+    if sys.maxsize > 2**32:
         assert put(sys.maxsize) == (255, 255, 255, 255)
     else:
         assert put(sys.maxsize) == (255, 255, 255, 127)
@@ -45,6 +47,12 @@
 def test_pypy_performance():
     im = Image.new("L", (256, 256))
     im.putdata(list(range(256)) * 256)
+
+
+def test_mode_with_L_with_float():
+    im = Image.new("L", (1, 1), 0)
+    im.putdata([2.0])
+    assert im.getpixel((0, 0)) == 2
 
 
 def test_mode_i():
@@ -87,3 +95,18 @@
     im.putdata(arr)
 
     assert len(im.getdata()) == len(arr)
+
+
+def test_not_flattened():
+    im = Image.new("L", (1, 1))
+    with pytest.raises(TypeError):
+        im.putdata([[0]])
+    with pytest.raises(TypeError):
+        im.putdata([[0]], 2)
+
+    with pytest.raises(TypeError):
+        im = Image.new("I", (1, 1))
+        im.putdata([[0]])
+    with pytest.raises(TypeError):
+        im = Image.new("F", (1, 1))
+        im.putdata([[0]])
('Tests', 'test_file_sun.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,7 @@
 
 from PIL import Image, SunImagePlugin
 
-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import assert_image_equal_tofile, assert_image_similar, hopper
 
 EXTRA_DIR = "Tests/images/sunraster"
 
@@ -29,8 +29,7 @@
 
 def test_im1():
     with Image.open("Tests/images/sunraster.im1") as im:
-        with Image.open("Tests/images/sunraster.im1.png") as target:
-            assert_image_equal(im, target)
+        assert_image_equal_tofile(im, "Tests/images/sunraster.im1.png")
 
 
 @pytest.mark.skipif(
@@ -46,7 +45,4 @@
         with Image.open(path) as im:
             im.load()
             assert isinstance(im, SunImagePlugin.SunImageFile)
-            target_path = f"{os.path.splitext(path)[0]}.png"
-            # im.save(target_file)
-            with Image.open(target_path) as target:
-                assert_image_equal(im, target)
+            assert_image_equal_tofile(im, f"{os.path.splitext(path)[0]}.png")
('Tests', 'test_decompression_bomb.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -10,8 +10,7 @@
 
 
 class TestDecompressionBomb:
-    @classmethod
-    def teardown_class(cls):
+    def teardown_method(self, method):
         Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT
 
     def test_no_warning_small_file(self):
@@ -52,17 +51,21 @@
             with Image.open(TEST_FILE):
                 pass
 
+    @pytest.mark.xfail(reason="different exception")
     def test_exception_ico(self):
         with pytest.raises(Image.DecompressionBombError):
-            Image.open("Tests/images/decompression_bomb.ico")
+            with Image.open("Tests/images/decompression_bomb.ico"):
+                pass
 
     def test_exception_gif(self):
         with pytest.raises(Image.DecompressionBombError):
-            Image.open("Tests/images/decompression_bomb.gif")
+            with Image.open("Tests/images/decompression_bomb.gif"):
+                pass
 
     def test_exception_bmp(self):
         with pytest.raises(Image.DecompressionBombError):
-            Image.open("Tests/images/bmp/b/reallybig.bmp")
+            with Image.open("Tests/images/bmp/b/reallybig.bmp"):
+                pass
 
 
 class TestDecompressionCrop:
@@ -83,21 +86,12 @@
             pytest.warns(Image.DecompressionBombWarning, src.crop, box)
 
     def test_crop_decompression_checks(self):
-
         im = Image.new("RGB", (100, 100))
 
-        good_values = ((-9999, -9999, -9990, -9990), (-999, -999, -990, -990))
-
-        warning_values = ((-160, -160, 99, 99), (160, 160, -99, -99))
-
-        error_values = ((-99909, -99990, 99999, 99999), (99909, 99990, -99999, -99999))
-
-        for value in good_values:
+        for value in ((-9999, -9999, -9990, -9990), (-999, -999, -990, -990)):
             assert im.crop(value).size == (9, 9)
 
-        for value in warning_values:
-            pytest.warns(Image.DecompressionBombWarning, im.crop, value)
+        pytest.warns(Image.DecompressionBombWarning, im.crop, (-160, -160, 99, 99))
 
-        for value in error_values:
-            with pytest.raises(Image.DecompressionBombError):
-                im.crop(value)
+        with pytest.raises(Image.DecompressionBombError):
+            im.crop((-99909, -99990, 99999, 99999))
('Tests', 'test_imagechops.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -368,11 +368,11 @@
 
 def test_soft_light():
     # Arrange
-    im1 = Image.open("Tests/images/hopper.png")
-    im2 = Image.open("Tests/images/hopper-XYZ.png")
-
-    # Act
-    new = ImageChops.soft_light(im1, im2)
+    with Image.open("Tests/images/hopper.png") as im1:
+        with Image.open("Tests/images/hopper-XYZ.png") as im2:
+
+            # Act
+            new = ImageChops.soft_light(im1, im2)
 
     # Assert
     assert new.getpixel((64, 64)) == (163, 54, 32)
@@ -381,11 +381,11 @@
 
 def test_hard_light():
     # Arrange
-    im1 = Image.open("Tests/images/hopper.png")
-    im2 = Image.open("Tests/images/hopper-XYZ.png")
-
-    # Act
-    new = ImageChops.hard_light(im1, im2)
+    with Image.open("Tests/images/hopper.png") as im1:
+        with Image.open("Tests/images/hopper-XYZ.png") as im2:
+
+            # Act
+            new = ImageChops.hard_light(im1, im2)
 
     # Assert
     assert new.getpixel((64, 64)) == (144, 50, 27)
@@ -394,11 +394,11 @@
 
 def test_overlay():
     # Arrange
-    im1 = Image.open("Tests/images/hopper.png")
-    im2 = Image.open("Tests/images/hopper-XYZ.png")
-
-    # Act
-    new = ImageChops.overlay(im1, im2)
+    with Image.open("Tests/images/hopper.png") as im1:
+        with Image.open("Tests/images/hopper-XYZ.png") as im2:
+
+            # Act
+            new = ImageChops.overlay(im1, im2)
 
     # Assert
     assert new.getpixel((64, 64)) == (159, 50, 27)
('Tests', 'check_large_memory_numpy.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,7 +19,7 @@
 XDIM = 48000
 
 
-pytestmark = pytest.mark.skipif(sys.maxsize <= 2 ** 32, reason="requires 64-bit system")
+pytestmark = pytest.mark.skipif(sys.maxsize <= 2**32, reason="requires 64-bit system")
 
 
 def _write_png(tmp_path, xdim, ydim):
@@ -31,7 +31,7 @@
 
 
 def test_large(tmp_path):
-    """ succeeded prepatch"""
+    """succeeded prepatch"""
     _write_png(tmp_path, XDIM, YDIM)
 
 
('Tests', 'test_file_webp.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,11 +1,14 @@
 import io
 import re
+import sys
+import warnings
 
 import pytest
 
 from PIL import Image, WebPImagePlugin, features
 
 from .helper import (
+    assert_image_equal,
     assert_image_similar,
     assert_image_similar_tofile,
     hopper,
@@ -103,6 +106,26 @@
         hopper().save(buffer_method, format="WEBP", method=6)
         assert buffer_no_args.getbuffer() != buffer_method.getbuffer()
 
+    @skip_unless_feature("webp_anim")
+    def test_save_all(self, tmp_path):
+        temp_file = str(tmp_path / "temp.webp")
+        im = Image.new("RGB", (1, 1))
+        im2 = Image.new("RGB", (1, 1), "#f00")
+        im.save(temp_file, save_all=True, append_images=[im2])
+
+        with Image.open(temp_file) as reloaded:
+            assert_image_equal(im, reloaded)
+
+            reloaded.seek(1)
+            assert_image_similar(im2, reloaded, 1)
+
+    def test_icc_profile(self, tmp_path):
+        self._roundtrip(tmp_path, self.rgb_mode, 12.5, {"icc_profile": None})
+        if _webp.HAVE_WEBPANIM:
+            self._roundtrip(
+                tmp_path, self.rgb_mode, 12.5, {"icc_profile": None, "save_all": True}
+            )
+
     def test_write_unsupported_mode_L(self, tmp_path):
         """
         Saving a black-and-white file to WebP format should work, and be
@@ -118,6 +141,14 @@
         """
 
         self._roundtrip(tmp_path, "P", 50.0)
+
+    @pytest.mark.skipif(sys.maxsize <= 2**32, reason="Requires 64-bit system")
+    def test_write_encoding_error_message(self, tmp_path):
+        temp_file = str(tmp_path / "temp.webp")
+        im = Image.new("RGB", (15000, 15000))
+        with pytest.raises(ValueError) as e:
+            im.save(temp_file, method=0)
+        assert str(e.value) == "encoding error 6"
 
     def test_WebPEncode_with_invalid_args(self):
         """
@@ -145,7 +176,8 @@
         file_path = "Tests/images/hopper.webp"
         with Image.open(file_path) as image:
             temp_file = str(tmp_path / "temp.webp")
-            pytest.warns(None, image.save, temp_file)
+            with warnings.catch_warnings():
+                image.save(temp_file)
 
     def test_file_pointer_could_be_reused(self):
         file_path = "Tests/images/hopper.webp"
@@ -153,9 +185,14 @@
             Image.open(blob).load()
             Image.open(blob).load()
 
-    @skip_unless_feature("webp")
     @skip_unless_feature("webp_anim")
     def test_background_from_gif(self, tmp_path):
+        # Save L mode GIF with background
+        with Image.open("Tests/images/no_palette_with_background.gif") as im:
+            out_webp = str(tmp_path / "temp.webp")
+            im.save(out_webp, save_all=True)
+
+        # Save P mode GIF with background
         with Image.open("Tests/images/chi.gif") as im:
             original_value = im.convert("RGB").getpixel((1, 1))
 
@@ -165,11 +202,22 @@
 
         # Save as GIF
         out_gif = str(tmp_path / "temp.gif")
-        Image.open(out_webp).save(out_gif)
+        with Image.open(out_webp) as im:
+            im.save(out_gif)
 
         with Image.open(out_gif) as reread:
             reread_value = reread.convert("RGB").getpixel((1, 1))
-        difference = sum(
-            [abs(original_value[i] - reread_value[i]) for i in range(0, 3)]
-        )
+        difference = sum(abs(original_value[i] - reread_value[i]) for i in range(0, 3))
         assert difference < 5
+
+    @skip_unless_feature("webp_anim")
+    def test_duration(self, tmp_path):
+        with Image.open("Tests/images/dispose_bgnd.gif") as im:
+            assert im.info["duration"] == 1000
+
+            out_webp = str(tmp_path / "temp.webp")
+            im.save(out_webp, save_all=True)
+
+        with Image.open(out_webp) as reloaded:
+            reloaded.load()
+            assert reloaded.info["duration"] == 1000
('Tests', 'createfontdatachunk.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 import base64
 import os
 
('Tests', 'test_imagestat.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -51,8 +51,8 @@
     st = ImageStat.Stat(im)
 
     assert st.extrema[0] == (128, 128)
-    assert st.sum[0] == 128 ** 3
-    assert st.sum2[0] == 128 ** 4
+    assert st.sum[0] == 128**3
+    assert st.sum2[0] == 128**4
     assert st.mean[0] == 128
     assert st.median[0] == 128
     assert st.rms[0] == 128
('Tests', 'test_image_getpalette.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+from PIL import Image
+
 from .helper import hopper
 
 
@@ -17,3 +19,26 @@
     assert palette("RGBA") is None
     assert palette("CMYK") is None
     assert palette("YCbCr") is None
+
+
+def test_palette_rawmode():
+    im = Image.new("P", (1, 1))
+    im.putpalette((1, 2, 3))
+
+    for rawmode in ("RGB", None):
+        rgb = im.getpalette(rawmode)
+        assert rgb == [1, 2, 3]
+
+    # Convert the RGB palette to RGBA
+    rgba = im.getpalette("RGBA")
+    assert rgba == [1, 2, 3, 255]
+
+    im.putpalette((1, 2, 3, 4), "RGBA")
+
+    # Convert the RGBA palette to RGB
+    rgb = im.getpalette("RGB")
+    assert rgb == [1, 2, 3]
+
+    for rawmode in ("RGBA", None):
+        rgba = im.getpalette(rawmode)
+        assert rgba == [1, 2, 3, 4]
('Tests', 'test_file_fli.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,10 @@
+import warnings
+
 import pytest
 
 from PIL import FliImagePlugin, Image
 
-from .helper import assert_image_equal, is_pypy
+from .helper import assert_image_equal_tofile, is_pypy
 
 # created as an export of a palette image from Gimp2.6
 # save as...-> hopper.fli, default options.
@@ -38,20 +40,16 @@
 
 
 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(static_test_file)
         im.load()
         im.close()
 
-    pytest.warns(None, open)
-
 
 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(static_test_file) as im:
             im.load()
-
-    pytest.warns(None, open)
 
 
 def test_tell():
@@ -122,5 +120,32 @@
     with Image.open(animated_test_file) as im:
         im.seek(50)
 
-        with Image.open("Tests/images/a_fli.png") as expected:
-            assert_image_equal(im, expected)
+        assert_image_equal_tofile(im, "Tests/images/a_fli.png")
+
+
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/images/timeout-9139147ce93e20eb14088fe238e541443ffd64b3.fli",
+        "Tests/images/timeout-bff0a9dc7243a8e6ede2408d2ffa6a9964698b87.fli",
+    ],
+)
+@pytest.mark.timeout(timeout=3)
+def test_timeouts(test_file):
+    with open(test_file, "rb") as f:
+        with Image.open(f) as im:
+            with pytest.raises(OSError):
+                im.load()
+
+
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/images/crash-5762152299364352.fli",
+    ],
+)
+def test_crash(test_file):
+    with open(test_file, "rb") as f:
+        with Image.open(f) as im:
+            with pytest.raises(OSError):
+                im.load()
('Tests', 'test_imagemorph.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -3,7 +3,7 @@
 
 from PIL import Image, ImageMorph, _imagingmorph
 
-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal_tofile, hopper
 
 
 def string_to_img(image_string):
@@ -57,8 +57,7 @@
 
 
 def test_str_to_img():
-    with Image.open("Tests/images/morph_a.png") as im:
-        assert_image_equal(A, im)
+    assert_image_equal_tofile(A, "Tests/images/morph_a.png")
 
 
 def create_lut():
@@ -236,19 +235,19 @@
     )
 
 
-def test_non_binary_images():
+def test_incorrect_mode():
     im = hopper("RGB")
     mop = ImageMorph.MorphOp(op_name="erosion8")
 
-    with pytest.raises(Exception) as e:
+    with pytest.raises(ValueError) as e:
         mop.apply(im)
-    assert str(e.value) == "Image must be binary, meaning it must use mode L"
-    with pytest.raises(Exception) as e:
+    assert str(e.value) == "Image mode must be L"
+    with pytest.raises(ValueError) as e:
         mop.match(im)
-    assert str(e.value) == "Image must be binary, meaning it must use mode L"
-    with pytest.raises(Exception) as e:
+    assert str(e.value) == "Image mode must be L"
+    with pytest.raises(ValueError) as e:
         mop.get_on_pixels(im)
-    assert str(e.value) == "Image must be binary, meaning it must use mode L"
+    assert str(e.value) == "Image mode must be L"
 
 
 def test_add_patterns():
('Tests', 'test_imagefile.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@
 
 import pytest
 
-from PIL import EpsImagePlugin, Image, ImageFile, features
+from PIL import BmpImagePlugin, EpsImagePlugin, Image, ImageFile, _binary, features
 
 from .helper import (
     assert_image,
@@ -23,7 +23,7 @@
     def test_parser(self):
         def roundtrip(format):
 
-            im = hopper("L").resize((1000, 1000), Image.NEAREST)
+            im = hopper("L").resize((1000, 1000), Image.Resampling.NEAREST)
             if format in ("MSP", "XBM"):
                 im = im.convert("1")
 
@@ -82,6 +82,19 @@
             p.feed(data)
             assert (48, 48) == p.image.size
 
+    @skip_unless_feature("webp")
+    @skip_unless_feature("webp_anim")
+    def test_incremental_webp(self):
+        with ImageFile.Parser() as p:
+            with open("Tests/images/hopper.webp", "rb") as f:
+                p.feed(f.read(1024))
+
+                # Check that insufficient data was given in the first feed
+                assert not p.image
+
+                p.feed(f.read())
+            assert (128, 128) == p.image.size
+
     @skip_unless_feature("zlib")
     def test_safeblock(self):
         im1 = hopper()
@@ -93,12 +106,6 @@
             ImageFile.SAFEBLOCK = SAFEBLOCK
 
         assert_image_equal(im1, im2)
-
-    def test_raise_ioerror(self):
-        with pytest.raises(IOError):
-            with pytest.warns(DeprecationWarning) as record:
-                ImageFile.raise_ioerror(1)
-        assert len(record) == 1
 
     def test_raise_oserror(self):
         with pytest.raises(OSError):
@@ -117,6 +124,37 @@
         with pytest.raises(OSError):
             p.close()
 
+    def test_no_format(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        class DummyImageFile(ImageFile.ImageFile):
+            def _open(self):
+                self.mode = "RGB"
+                self._size = (1, 1)
+
+        im = DummyImageFile(buf)
+        assert im.format is None
+        assert im.get_format_mimetype() is None
+
+    def test_oserror(self):
+        im = Image.new("RGB", (1, 1))
+        with pytest.raises(OSError):
+            im.save(BytesIO(), "JPEG2000", num_resolutions=2)
+
+    def test_truncated(self):
+        b = BytesIO(
+            b"BM000000000000"  # head_data
+            + _binary.o32le(
+                ImageFile.SAFEBLOCK + 1 + 4
+            )  # header_size, so BmpImagePlugin will try to read SAFEBLOCK + 1 bytes
+            + (
+                b"0" * ImageFile.SAFEBLOCK
+            )  # only SAFEBLOCK bytes, so that the header is truncated
+        )
+        with pytest.raises(OSError) as e:
+            BmpImagePlugin.BmpImageFile(b)
+        assert str(e.value) == "Truncated File Read"
+
     @skip_unless_feature("zlib")
     def test_truncated_with_errors(self):
         with Image.open("Tests/images/truncated_image.png") as im:
@@ -156,6 +194,14 @@
     def decode(self, buffer):
         # eof
         return -1, 0
+
+
+class MockPyEncoder(ImageFile.PyEncoder):
+    def encode(self, buffer):
+        return 1, 1, b""
+
+    def cleanup(self):
+        self.cleanup_called = True
 
 
 xoff, yoff, xsize, ysize = 10, 20, 100, 100
@@ -169,53 +215,58 @@
         self.tile = [("MOCK", (xoff, yoff, xoff + xsize, yoff + ysize), 32, None)]
 
 
-class TestPyDecoder:
-    def get_decoder(self):
-        decoder = MockPyDecoder(None)
-
-        def closure(mode, *args):
-            decoder.__init__(mode, *args)
-            return decoder
-
-        Image.register_decoder("MOCK", closure)
-        return decoder
-
+class CodecsTest:
+    @classmethod
+    def setup_class(cls):
+        cls.decoder = MockPyDecoder(None)
+        cls.encoder = MockPyEncoder(None)
+
+        def decoder_closure(mode, *args):
+            cls.decoder.__init__(mode, *args)
+            return cls.decoder
+
+        def encoder_closure(mode, *args):
+            cls.encoder.__init__(mode, *args)
+            return cls.encoder
+
+        Image.register_decoder("MOCK", decoder_closure)
+        Image.register_encoder("MOCK", encoder_closure)
+
+
+class TestPyDecoder(CodecsTest):
     def test_setimage(self):
         buf = BytesIO(b"\x00" * 255)
 
         im = MockImageFile(buf)
-        d = self.get_decoder()
 
         im.load()
 
-        assert d.state.xoff == xoff
-        assert d.state.yoff == yoff
-        assert d.state.xsize == xsize
-        assert d.state.ysize == ysize
-
-        with pytest.raises(ValueError):
-            d.set_as_raw(b"\x00")
+        assert self.decoder.state.xoff == xoff
+        assert self.decoder.state.yoff == yoff
+        assert self.decoder.state.xsize == xsize
+        assert self.decoder.state.ysize == ysize
+
+        with pytest.raises(ValueError):
+            self.decoder.set_as_raw(b"\x00")
 
     def test_extents_none(self):
         buf = BytesIO(b"\x00" * 255)
 
         im = MockImageFile(buf)
         im.tile = [("MOCK", None, 32, None)]
-        d = self.get_decoder()
 
         im.load()
 
-        assert d.state.xoff == 0
-        assert d.state.yoff == 0
-        assert d.state.xsize == 200
-        assert d.state.ysize == 200
+        assert self.decoder.state.xoff == 0
+        assert self.decoder.state.yoff == 0
+        assert self.decoder.state.xsize == 200
+        assert self.decoder.state.ysize == 200
 
     def test_negsize(self):
         buf = BytesIO(b"\x00" * 255)
 
         im = MockImageFile(buf)
         im.tile = [("MOCK", (xoff, yoff, -10, yoff + ysize), 32, None)]
-        self.get_decoder()
 
         with pytest.raises(ValueError):
             im.load()
@@ -229,7 +280,6 @@
 
         im = MockImageFile(buf)
         im.tile = [("MOCK", (xoff, yoff, xoff + xsize + 100, yoff + ysize), 32, None)]
-        self.get_decoder()
 
         with pytest.raises(ValueError):
             im.load()
@@ -238,14 +288,92 @@
         with pytest.raises(ValueError):
             im.load()
 
-    def test_no_format(self):
-        buf = BytesIO(b"\x00" * 255)
-
-        im = MockImageFile(buf)
-        assert im.format is None
-        assert im.get_format_mimetype() is None
-
-    def test_oserror(self):
-        im = Image.new("RGB", (1, 1))
-        with pytest.raises(OSError):
-            im.save(BytesIO(), "JPEG2000")
+    def test_decode(self):
+        decoder = ImageFile.PyDecoder(None)
+        with pytest.raises(NotImplementedError):
+            decoder.decode(None)
+
+
+class TestPyEncoder(CodecsTest):
+    def test_setimage(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        im = MockImageFile(buf)
+
+        fp = BytesIO()
+        ImageFile._save(
+            im, fp, [("MOCK", (xoff, yoff, xoff + xsize, yoff + ysize), 0, "RGB")]
+        )
+
+        assert self.encoder.state.xoff == xoff
+        assert self.encoder.state.yoff == yoff
+        assert self.encoder.state.xsize == xsize
+        assert self.encoder.state.ysize == ysize
+
+    def test_extents_none(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        im = MockImageFile(buf)
+        im.tile = [("MOCK", None, 32, None)]
+
+        fp = BytesIO()
+        ImageFile._save(im, fp, [("MOCK", None, 0, "RGB")])
+
+        assert self.encoder.state.xoff == 0
+        assert self.encoder.state.yoff == 0
+        assert self.encoder.state.xsize == 200
+        assert self.encoder.state.ysize == 200
+
+    def test_negsize(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        im = MockImageFile(buf)
+
+        fp = BytesIO()
+        self.encoder.cleanup_called = False
+        with pytest.raises(ValueError):
+            ImageFile._save(
+                im, fp, [("MOCK", (xoff, yoff, -10, yoff + ysize), 0, "RGB")]
+            )
+        assert self.encoder.cleanup_called
+
+        with pytest.raises(ValueError):
+            ImageFile._save(
+                im, fp, [("MOCK", (xoff, yoff, xoff + xsize, -10), 0, "RGB")]
+            )
+
+    def test_oversize(self):
+        buf = BytesIO(b"\x00" * 255)
+
+        im = MockImageFile(buf)
+
+        fp = BytesIO()
+        with pytest.raises(ValueError):
+            ImageFile._save(
+                im,
+                fp,
+                [("MOCK", (xoff, yoff, xoff + xsize + 100, yoff + ysize), 0, "RGB")],
+            )
+
+        with pytest.raises(ValueError):
+            ImageFile._save(
+                im,
+                fp,
+                [("MOCK", (xoff, yoff, xoff + xsize, yoff + ysize + 100), 0, "RGB")],
+            )
+
+    def test_encode(self):
+        encoder = ImageFile.PyEncoder(None)
+        with pytest.raises(NotImplementedError):
+            encoder.encode(None)
+
+        bytes_consumed, errcode = encoder.encode_to_pyfd()
+        assert bytes_consumed == 0
+        assert ImageFile.ERRORS[errcode] == "bad configuration"
+
+        encoder._pushes_fd = True
+        with pytest.raises(NotImplementedError):
+            encoder.encode_to_pyfd()
+
+        with pytest.raises(NotImplementedError):
+            encoder.encode_to_file(None, None)
('Tests', 'test_image_thumbnail.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -88,6 +88,8 @@
         assert im.size == (64, 64)
 
 
+# valgrind test is failing with memory allocated in libjpeg
+@pytest.mark.valgrind_known_error(reason="Known Failing")
 def test_DCT_scaling_edges():
     # Make an image with red borders and size (N * 8) + 1 to cross DCT grid
     im = Image.new("RGB", (257, 257), "red")
@@ -95,24 +97,24 @@
 
     thumb = fromstring(tostring(im, "JPEG", quality=99, subsampling=0))
     # small reducing_gap to amplify the effect
-    thumb.thumbnail((32, 32), Image.BICUBIC, reducing_gap=1.0)
+    thumb.thumbnail((32, 32), Image.Resampling.BICUBIC, reducing_gap=1.0)
 
-    ref = im.resize((32, 32), Image.BICUBIC)
+    ref = im.resize((32, 32), Image.Resampling.BICUBIC)
     # This is still JPEG, some error is present. Without the fix it is 11.5
     assert_image_similar(thumb, ref, 1.5)
 
 
 def test_reducing_gap_values():
     im = hopper()
-    im.thumbnail((18, 18), Image.BICUBIC)
+    im.thumbnail((18, 18), Image.Resampling.BICUBIC)
 
     ref = hopper()
-    ref.thumbnail((18, 18), Image.BICUBIC, reducing_gap=2.0)
+    ref.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=2.0)
     # reducing_gap=2.0 should be the default
     assert_image_equal(ref, im)
 
     ref = hopper()
-    ref.thumbnail((18, 18), Image.BICUBIC, reducing_gap=None)
+    ref.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=None)
     with pytest.raises(AssertionError):
         assert_image_equal(ref, im)
 
@@ -123,9 +125,9 @@
     with Image.open("Tests/images/hopper.jpg") as ref:
         # thumbnail should call draft with reducing_gap scale
         ref.draft(None, (18 * 3, 18 * 3))
-        ref = ref.resize((18, 18), Image.BICUBIC)
+        ref = ref.resize((18, 18), Image.Resampling.BICUBIC)
 
         with Image.open("Tests/images/hopper.jpg") as im:
-            im.thumbnail((18, 18), Image.BICUBIC, reducing_gap=3.0)
+            im.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=3.0)
 
             assert_image_equal(ref, im)
('Tests', 'test_file_gbr.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,27 @@
 
 from PIL import GbrImagePlugin, Image
 
-from .helper import assert_image_equal
+from .helper import assert_image_equal_tofile
+
+
+def test_gbr_file():
+    with Image.open("Tests/images/gbr.gbr") as im:
+        assert_image_equal_tofile(im, "Tests/images/gbr.png")
+
+
+def test_load():
+    with Image.open("Tests/images/gbr.gbr") as im:
+        assert im.load()[0, 0] == (0, 0, 0, 0)
+
+        # Test again now that it has already been loaded once
+        assert im.load()[0, 0] == (0, 0, 0, 0)
+
+
+def test_multiple_load_operations():
+    with Image.open("Tests/images/gbr.gbr") as im:
+        im.load()
+        im.load()
+        assert_image_equal_tofile(im, "Tests/images/gbr.png")
 
 
 def test_invalid_file():
@@ -10,17 +30,3 @@
 
     with pytest.raises(SyntaxError):
         GbrImagePlugin.GbrImageFile(invalid_file)
-
-
-def test_gbr_file():
-    with Image.open("Tests/images/gbr.gbr") as im:
-        with Image.open("Tests/images/gbr.png") as target:
-            assert_image_equal(target, im)
-
-
-def test_multiple_load_operations():
-    with Image.open("Tests/images/gbr.gbr") as im:
-        im.load()
-        im.load()
-        with Image.open("Tests/images/gbr.png") as target:
-            assert_image_equal(target, im)
('Tests', 'test_file_ppm.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,8 +1,11 @@
+import sys
+from io import BytesIO
+
 import pytest
 
-from PIL import Image
+from PIL import Image, UnidentifiedImageError
 
-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import assert_image_equal_tofile, assert_image_similar, hopper
 
 # sample ppm stream
 TEST_FILE = "Tests/images/hopper.ppm"
@@ -10,33 +13,66 @@
 
 def test_sanity():
     with Image.open(TEST_FILE) as im:
-        im.load()
         assert im.mode == "RGB"
         assert im.size == (128, 128)
-        assert im.format, "PPM"
+        assert im.format == "PPM"
         assert im.get_format_mimetype() == "image/x-portable-pixmap"
+
+
+@pytest.mark.parametrize(
+    "data, mode, pixels",
+    (
+        (b"P5 3 1 4 \x00\x02\x04", "L", (0, 128, 255)),
+        (b"P5 3 1 257 \x00\x00\x00\x80\x01\x01", "I", (0, 32640, 65535)),
+        # P6 with maxval < 255
+        (
+            b"P6 3 1 17 \x00\x01\x02\x08\x09\x0A\x0F\x10\x11",
+            "RGB",
+            (
+                (0, 15, 30),
+                (120, 135, 150),
+                (225, 240, 255),
+            ),
+        ),
+        # P6 with maxval > 255
+        # Scale down to 255, since there is no RGB mode with more than 8-bit
+        (
+            b"P6 3 1 257 \x00\x00\x00\x01\x00\x02"
+            b"\x00\x80\x00\x81\x00\x82\x01\x00\x01\x01\xFF\xFF",
+            "RGB",
+            (
+                (0, 1, 2),
+                (127, 128, 129),
+                (254, 255, 255),
+            ),
+        ),
+    ),
+)
+def test_arbitrary_maxval(data, mode, pixels):
+    fp = BytesIO(data)
+    with Image.open(fp) as im:
+        assert im.size == (3, 1)
+        assert im.mode == mode
+
+        px = im.load()
+        assert tuple(px[x, 0] for x in range(3)) == pixels
 
 
 def test_16bit_pgm():
     with Image.open("Tests/images/16_bit_binary.pgm") as im:
-        im.load()
         assert im.mode == "I"
         assert im.size == (20, 100)
         assert im.get_format_mimetype() == "image/x-portable-graymap"
 
-        with Image.open("Tests/images/16_bit_binary_pgm.png") as tgt:
-            assert_image_equal(im, tgt)
+        assert_image_equal_tofile(im, "Tests/images/16_bit_binary_pgm.png")
 
 
 def test_16bit_pgm_write(tmp_path):
     with Image.open("Tests/images/16_bit_binary.pgm") as im:
-        im.load()
-
         f = str(tmp_path / "temp.pgm")
         im.save(f, "PPM")
 
-        with Image.open(f) as reloaded:
-            assert_image_equal(im, reloaded)
+        assert_image_equal_tofile(im, f)
 
 
 def test_pnm(tmp_path):
@@ -46,17 +82,67 @@
         f = str(tmp_path / "temp.pnm")
         im.save(f)
 
-        with Image.open(f) as reloaded:
-            assert_image_equal(im, reloaded)
+        assert_image_equal_tofile(im, f)
+
+
+def test_magic(tmp_path):
+    path = str(tmp_path / "temp.ppm")
+    with open(path, "wb") as f:
+        f.write(b"PyInvalid")
+
+    with pytest.raises(UnidentifiedImageError):
+        with Image.open(path):
+            pass
+
+
+def test_header_with_comments(tmp_path):
+    path = str(tmp_path / "temp.ppm")
+    with open(path, "wb") as f:
+        f.write(b"P6 #comment\n#comment\r12#comment\r8\n128 #comment\n255\n")
+
+    with Image.open(path) as im:
+        assert im.size == (128, 128)
+
+
+def test_non_integer_token(tmp_path):
+    path = str(tmp_path / "temp.ppm")
+    with open(path, "wb") as f:
+        f.write(b"P6\nTEST")
+
+    with pytest.raises(ValueError):
+        with Image.open(path):
+            pass
+
+
+def test_token_too_long(tmp_path):
+    path = str(tmp_path / "temp.ppm")
+    with open(path, "wb") as f:
+        f.write(b"P6\n 01234567890")
+
+    with pytest.raises(ValueError) as e:
+        with Image.open(path):
+            pass
+
+    assert str(e.value) == "Token too long in file header: b'01234567890'"
 
 
 def test_truncated_file(tmp_path):
+    # Test EOF in header
     path = str(tmp_path / "temp.pgm")
     with open(path, "w") as f:
         f.write("P6")
 
-    with pytest.raises(ValueError):
-        Image.open(path)
+    with pytest.raises(ValueError) as e:
+        with Image.open(path):
+            pass
+
+    assert str(e.value) == "Reached EOF while reading header"
+
+    # Test EOF for PyDecoder
+    fp = BytesIO(b"P5 3 1 4")
+    with Image.open(fp) as im:
+        with pytest.raises(ValueError):
+            im.load()
 
 
 def test_neg_ppm():
@@ -66,7 +152,8 @@
     # sizes.
 
     with pytest.raises(OSError):
-        Image.open("Tests/images/negative_size.ppm")
+        with Image.open("Tests/images/negative_size.ppm"):
+            pass
 
 
 def test_mimetypes(tmp_path):
@@ -81,3 +168,30 @@
         f.write("PyCMYK\n128 128\n255")
     with Image.open(path) as im:
         assert im.get_format_mimetype() == "image/x-portable-anymap"
+
+
+@pytest.mark.parametrize("buffer", (True, False))
+def test_save_stdout(buffer):
+    old_stdout = sys.stdout
+
+    if buffer:
+
+        class MyStdOut:
+            buffer = BytesIO()
+
+        mystdout = MyStdOut()
+    else:
+        mystdout = BytesIO()
+
+    sys.stdout = mystdout
+
+    with Image.open(TEST_FILE) as im:
+        im.save(sys.stdout, "PPM")
+
+    # Reset stdout
+    sys.stdout = old_stdout
+
+    if buffer:
+        mystdout = mystdout.buffer
+    with Image.open(mystdout) as reloaded:
+        assert_image_equal_tofile(reloaded, TEST_FILE)
('Tests', 'test_file_tiff.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,10 +1,11 @@
 import os
+import warnings
 from io import BytesIO
 
 import pytest
 
-from PIL import Image, TiffImagePlugin
-from PIL.TiffImagePlugin import RESOLUTION_UNIT, SUBIFD, X_RESOLUTION, Y_RESOLUTION
+from PIL import Image, ImageFile, TiffImagePlugin
+from PIL.TiffImagePlugin import RESOLUTION_UNIT, X_RESOLUTION, Y_RESOLUTION
 
 from .helper import (
     assert_image_equal,
@@ -16,6 +17,11 @@
     is_win32,
 )
 
+try:
+    import defusedxml.ElementTree as ElementTree
+except ImportError:
+    ElementTree = None
+
 
 class TestFileTiff:
     def test_sanity(self, tmp_path):
@@ -59,19 +65,15 @@
         pytest.warns(ResourceWarning, open)
 
     def test_closed_file(self):
-        def open():
+        with warnings.catch_warnings():
             im = Image.open("Tests/images/multipage.tiff")
             im.load()
             im.close()
 
-        pytest.warns(None, open)
-
     def test_context_manager(self):
-        def open():
+        with warnings.catch_warnings():
             with Image.open("Tests/images/multipage.tiff") as im:
                 im.load()
-
-        pytest.warns(None, open)
 
     def test_mac_tiff(self):
         # Read RGBa images from macOS [@PIL136]
@@ -85,11 +87,22 @@
 
             assert_image_similar_tofile(im, "Tests/images/pil136.png", 1)
 
-    def test_wrong_bits_per_sample(self):
-        with Image.open("Tests/images/tiff_wrong_bits_per_sample.tiff") as im:
-            assert im.mode == "RGBA"
-            assert im.size == (52, 53)
-            assert im.tile == [("raw", (0, 0, 52, 53), 160, ("RGBA", 0, 1))]
+    def test_bigtiff(self):
+        with Image.open("Tests/images/hopper_bigtiff.tif") as im:
+            assert_image_equal_tofile(im, "Tests/images/hopper.tif")
+
+    @pytest.mark.parametrize(
+        "file_name,mode,size,offset",
+        [
+            ("tiff_wrong_bits_per_sample.tiff", "RGBA", (52, 53), 160),
+            ("tiff_wrong_bits_per_sample_2.tiff", "RGB", (16, 16), 8),
+        ],
+    )
+    def test_wrong_bits_per_sample(self, file_name, mode, size, offset):
+        with Image.open("Tests/images/" + file_name) as im:
+            assert im.mode == mode
+            assert im.size == size
+            assert im.tile == [("raw", (0, 0) + size, offset, (mode, 0, 1))]
             im.load()
 
     def test_set_legacy_api(self):
@@ -137,46 +150,33 @@
             im._setup()
             assert im.info["dpi"] == (71.0, 71.0)
 
-    def test_load_dpi_rounding(self):
-        for resolutionUnit, dpi in ((None, (72, 73)), (2, (72, 73)), (3, (183, 185))):
-            with Image.open(
-                "Tests/images/hopper_roundDown_" + str(resolutionUnit) + ".tif"
-            ) as im:
-                assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit
-                assert im.info["dpi"] == (dpi[0], dpi[0])
-
-            with Image.open(
-                "Tests/images/hopper_roundUp_" + str(resolutionUnit) + ".tif"
-            ) as im:
-                assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit
-                assert im.info["dpi"] == (dpi[1], dpi[1])
-
-    def test_save_dpi_rounding(self, tmp_path):
+    @pytest.mark.parametrize(
+        "resolutionUnit, dpi",
+        [(None, 72.8), (2, 72.8), (3, 184.912)],
+    )
+    def test_load_float_dpi(self, resolutionUnit, dpi):
+        with Image.open(
+            "Tests/images/hopper_float_dpi_" + str(resolutionUnit) + ".tif"
+        ) as im:
+            assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit
+            assert im.info["dpi"] == (dpi, dpi)
+
+    def test_save_float_dpi(self, tmp_path):
         outfile = str(tmp_path / "temp.tif")
         with Image.open("Tests/images/hopper.tif") as im:
-            for dpi in (72.2, 72.8):
-                im.save(outfile, dpi=(dpi, dpi))
-
-                with Image.open(outfile) as reloaded:
-                    reloaded.load()
-                    assert (round(dpi), round(dpi)) == reloaded.info["dpi"]
-
-    def test_subifd(self, tmp_path):
-        outfile = str(tmp_path / "temp.tif")
-        with Image.open("Tests/images/g4_orientation_6.tif") as im:
-            im.tag_v2[SUBIFD] = 10000
-
-            # Should not segfault
-            im.save(outfile)
+            dpi = (72.2, 72.2)
+            im.save(outfile, dpi=dpi)
+
+            with Image.open(outfile) as reloaded:
+                assert reloaded.info["dpi"] == dpi
 
     def test_save_setting_missing_resolution(self):
         b = BytesIO()
-        Image.open("Tests/images/10ct_32bit_128.tiff").save(
-            b, format="tiff", resolution=123.45
-        )
+        with Image.open("Tests/images/10ct_32bit_128.tiff") as im:
+            im.save(b, format="tiff", resolution=123.45)
         with Image.open(b) as im:
-            assert float(im.tag_v2[X_RESOLUTION]) == 123.45
-            assert float(im.tag_v2[Y_RESOLUTION]) == 123.45
+            assert im.tag_v2[X_RESOLUTION] == 123.45
+            assert im.tag_v2[Y_RESOLUTION] == 123.45
 
     def test_invalid_file(self):
         invalid_file = "Tests/images/flower.jpg"
@@ -224,6 +224,15 @@
         # Bytes are in image native order (big endian)
         assert b[0] == ord(b"\x01")
         assert b[1] == ord(b"\xe0")
+
+    def test_16bit_r(self):
+        with Image.open("Tests/images/16bit.r.tif") as im:
+            assert im.getpixel((0, 0)) == 480
+            assert im.mode == "I;16"
+
+            b = im.tobytes()
+        assert b[0] == ord(b"\xe0")
+        assert b[1] == ord(b"\x01")
 
     def test_16bit_s(self):
         with Image.open("Tests/images/16bit.s.tif") as im:
@@ -256,7 +265,8 @@
 
     def test_unknown_pixel_mode(self):
         with pytest.raises(OSError):
-            Image.open("Tests/images/hopper_unknown_pixel_mode.tif")
+            with Image.open("Tests/images/hopper_unknown_pixel_mode.tif"):
+                pass
 
     def test_n_frames(self):
         for path, n_frames in [
@@ -308,6 +318,19 @@
             im.load()
             assert im.size == (20, 20)
             assert im.convert("RGB").getpixel((0, 0)) == (0, 0, 255)
+
+    def test_frame_order(self):
+        # A frame can't progress to itself after reading
+        with Image.open("Tests/images/multipage_single_frame_loop.tiff") as im:
+            assert im.n_frames == 1
+
+        # A frame can't progress to a frame that has already been read
+        with Image.open("Tests/images/multipage_multiple_frame_loop.tiff") as im:
+            assert im.n_frames == 2
+
+        # Frames don't have to be in sequence
+        with Image.open("Tests/images/multipage_out_of_order.tiff") as im:
+            assert im.n_frames == 3
 
     def test___str__(self):
         filename = "Tests/images/pil136.tiff"
@@ -396,6 +419,75 @@
     def test_ifd_tag_type(self):
         with Image.open("Tests/images/ifd_tag_type.tiff") as im:
             assert 0x8825 in im.tag_v2
+
+    def test_exif(self, tmp_path):
+        def check_exif(exif):
+            assert sorted(exif.keys()) == [
+                256,
+                257,
+                258,
+                259,
+                262,
+                271,
+                272,
+                273,
+                277,
+                278,
+                279,
+                282,
+                283,
+                284,
+                296,
+                297,
+                305,
+                339,
+                700,
+                34665,
+                34853,
+                50735,
+            ]
+            assert exif[256] == 640
+            assert exif[271] == "FLIR"
+
+            gps = exif.get_ifd(0x8825)
+            assert list(gps.keys()) == [0, 1, 2, 3, 4, 5, 6, 18]
+            assert gps[0] == b"\x03\x02\x00\x00"
+            assert gps[18] == "WGS-84"
+
+        outfile = str(tmp_path / "temp.tif")
+        with Image.open("Tests/images/ifd_tag_type.tiff") as im:
+            exif = im.getexif()
+            check_exif(exif)
+
+            im.save(outfile, exif=exif)
+
+        outfile2 = str(tmp_path / "temp2.tif")
+        with Image.open(outfile) as im:
+            exif = im.getexif()
+            check_exif(exif)
+
+            im.save(outfile2, exif=exif.tobytes())
+
+        with Image.open(outfile2) as im:
+            exif = im.getexif()
+            check_exif(exif)
+
+    def test_exif_frames(self):
+        # Test that EXIF data can change across frames
+        with Image.open("Tests/images/g4-multi.tiff") as im:
+            assert im.getexif()[273] == (328, 815)
+
+            im.seek(1)
+            assert im.getexif()[273] == (1408, 1907)
+
+    @pytest.mark.parametrize("mode", ("1", "L"))
+    def test_photometric(self, mode, tmp_path):
+        filename = str(tmp_path / "temp.tif")
+        im = hopper(mode)
+        im.save(filename, tiffinfo={262: 0})
+        with Image.open(filename) as reloaded:
+            assert reloaded.tag_v2[262] == 0
+            assert_image_equal(im, reloaded)
 
     def test_seek(self):
         filename = "Tests/images/pil136.tiff"
@@ -491,8 +583,7 @@
             tmpfile = str(tmp_path / "temp.tif")
             im.save(tmpfile)
 
-            with Image.open(tmpfile) as reloaded:
-                assert_image_equal(im, reloaded)
+            assert_image_equal_tofile(im, tmpfile)
 
     def test_strip_raw(self):
         infile = "Tests/images/tiff_strip_raw.tif"
@@ -520,6 +611,17 @@
         with Image.open(infile) as im:
             assert_image_equal_tofile(im, "Tests/images/tiff_adobe_deflate.png")
 
+    def test_planar_configuration_save(self, tmp_path):
+        infile = "Tests/images/tiff_tiled_planar_raw.tif"
+        with Image.open(infile) as im:
+            assert im._planar_configuration == 2
+
+            outfile = str(tmp_path / "temp.tif")
+            im.save(outfile)
+
+            with Image.open(outfile) as reloaded:
+                assert_image_equal_tofile(reloaded, infile)
+
     def test_palette(self, tmp_path):
         def roundtrip(mode):
             outfile = str(tmp_path / "temp.tif")
@@ -577,6 +679,66 @@
         with Image.open(tmpfile) as reloaded:
             assert b"Dummy value" == reloaded.info["icc_profile"]
 
+    def test_save_icc_profile(self, tmp_path):
+        im = hopper()
+        assert "icc_profile" not in im.info
+
+        outfile = str(tmp_path / "temp.tif")
+        icc_profile = b"Dummy value"
+        im.save(outfile, icc_profile=icc_profile)
+
+        with Image.open(outfile) as reloaded:
+            assert reloaded.info["icc_profile"] == icc_profile
+
+    def test_discard_icc_profile(self, tmp_path):
+        outfile = str(tmp_path / "temp.tif")
+
+        with Image.open("Tests/images/icc_profile.png") as im:
+            assert "icc_profile" in im.info
+
+            im.save(outfile, icc_profile=None)
+
+        with Image.open(outfile) as reloaded:
+            assert "icc_profile" not in reloaded.info
+
+    def test_getxmp(self):
+        with Image.open("Tests/images/lab.tif") as im:
+            if ElementTree is None:
+                with pytest.warns(UserWarning):
+                    assert im.getxmp() == {}
+            else:
+                xmp = im.getxmp()
+
+                description = xmp["xmpmeta"]["RDF"]["Description"]
+                assert description[0]["format"] == "image/tiff"
+                assert description[3]["BitsPerSample"]["Seq"]["li"] == ["8", "8", "8"]
+
+    def test_get_photoshop_blocks(self):
+        with Image.open("Tests/images/lab.tif") as im:
+            assert list(im.get_photoshop_blocks().keys()) == [
+                1061,
+                1002,
+                1005,
+                1062,
+                1037,
+                1049,
+                1011,
+                1034,
+                10000,
+                1013,
+                1016,
+                1032,
+                1054,
+                1050,
+                1064,
+                1041,
+                1044,
+                1036,
+                1057,
+                4000,
+                4001,
+            ]
+
     def test_close_on_load_exclusive(self, tmp_path):
         # similar to test_fd_leak, but runs on unixlike os
         tmpfile = str(tmp_path / "temp.tif")
@@ -606,14 +768,25 @@
     # Ignore this UserWarning which triggers for four tags:
     # "Possibly corrupt EXIF data.  Expecting to read 50404352 bytes but..."
     @pytest.mark.filterwarnings("ignore:Possibly corrupt EXIF data")
+    # Ignore this UserWarning:
+    @pytest.mark.filterwarnings("ignore:Truncated File Read")
     @pytest.mark.skipif(
         not os.path.exists("Tests/images/string_dimension.tiff"),
         reason="Extra image files not installed",
     )
     def test_string_dimension(self):
         # Assert that an error is raised if one of the dimensions is a string
-        with pytest.raises(ValueError):
-            Image.open("Tests/images/string_dimension.tiff")
+        with Image.open("Tests/images/string_dimension.tiff") as im:
+            with pytest.raises(OSError):
+                im.load()
+
+    @pytest.mark.timeout(6)
+    @pytest.mark.filterwarnings("ignore:Truncated File Read")
+    def test_timeout(self):
+        with Image.open("Tests/images/timeout-6646305047838720") as im:
+            ImageFile.LOAD_TRUNCATED_IMAGES = True
+            im.load()
+            ImageFile.LOAD_TRUNCATED_IMAGES = False
 
 
 @pytest.mark.skipif(not is_win32(), reason="Windows only")
('Tests', 'test_file_apng.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -120,9 +120,9 @@
     #     save_all=True,
     #     append_images=[green, blue],
     #     disposal=[
-    #         PngImagePlugin.APNG_DISPOSE_OP_NONE,
-    #         PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,
-    #         PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS
+    #         PngImagePlugin.Disposal.OP_NONE,
+    #         PngImagePlugin.Disposal.OP_PREVIOUS,
+    #         PngImagePlugin.Disposal.OP_PREVIOUS
     #     ],
     # )
     with Image.open("Tests/images/apng/dispose_op_previous_frame.png") as im:
@@ -249,8 +249,8 @@
         assert im.mode == "P"
         im.seek(im.n_frames - 1)
         im = im.convert("RGBA")
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+        assert im.getpixel((0, 0)) == (255, 0, 0, 0)
+        assert im.getpixel((64, 32)) == (255, 0, 0, 0)
 
     with Image.open("Tests/images/apng/mode_palette_1bit_alpha.png") as im:
         assert im.mode == "P"
@@ -312,7 +312,7 @@
             exception = e
         assert exception is None
 
-    with pytest.raises(SyntaxError):
+    with pytest.raises(OSError):
         with Image.open("Tests/images/apng/syntax_num_frames_high.png") as im:
             im.seek(im.n_frames - 1)
             im.load()
@@ -433,10 +433,18 @@
 
     # test removal of duplicated frames
     frame = Image.new("RGBA", (128, 64), (255, 0, 0, 255))
-    frame.save(test_file, save_all=True, append_images=[frame], duration=[500, 250])
+    frame.save(
+        test_file, save_all=True, append_images=[frame, frame], duration=[500, 100, 150]
+    )
     with Image.open(test_file) as im:
         im.load()
         assert im.n_frames == 1
+        assert im.info.get("duration") == 750
+
+    # test info duration
+    frame.info["duration"] = 750
+    frame.save(test_file, save_all=True)
+    with Image.open(test_file) as im:
         assert im.info.get("duration") == 750
 
 
@@ -447,31 +455,31 @@
     green = Image.new("RGBA", size, (0, 255, 0, 255))
     transparent = Image.new("RGBA", size, (0, 0, 0, 0))
 
-    # test APNG_DISPOSE_OP_NONE
+    # test OP_NONE
     red.save(
         test_file,
         save_all=True,
         append_images=[green, transparent],
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
-    )
-    with Image.open(test_file) as im:
-        im.seek(2)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
-
-    # test APNG_DISPOSE_OP_BACKGROUND
+        disposal=PngImagePlugin.Disposal.OP_NONE,
+        blend=PngImagePlugin.Blend.OP_OVER,
+    )
+    with Image.open(test_file) as im:
+        im.seek(2)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+
+    # test OP_BACKGROUND
     disposal = [
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        PngImagePlugin.APNG_DISPOSE_OP_BACKGROUND,
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
+        PngImagePlugin.Disposal.OP_NONE,
+        PngImagePlugin.Disposal.OP_BACKGROUND,
+        PngImagePlugin.Disposal.OP_NONE,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[red, transparent],
         disposal=disposal,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
+        blend=PngImagePlugin.Blend.OP_OVER,
     )
     with Image.open(test_file) as im:
         im.seek(2)
@@ -479,26 +487,26 @@
         assert im.getpixel((64, 32)) == (0, 0, 0, 0)
 
     disposal = [
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        PngImagePlugin.APNG_DISPOSE_OP_BACKGROUND,
+        PngImagePlugin.Disposal.OP_NONE,
+        PngImagePlugin.Disposal.OP_BACKGROUND,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[green],
         disposal=disposal,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
-    )
-    with Image.open(test_file) as im:
-        im.seek(1)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
-
-    # test APNG_DISPOSE_OP_PREVIOUS
+        blend=PngImagePlugin.Blend.OP_OVER,
+    )
+    with Image.open(test_file) as im:
+        im.seek(1)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+
+    # test OP_PREVIOUS
     disposal = [
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
+        PngImagePlugin.Disposal.OP_NONE,
+        PngImagePlugin.Disposal.OP_PREVIOUS,
+        PngImagePlugin.Disposal.OP_NONE,
     ]
     red.save(
         test_file,
@@ -506,7 +514,7 @@
         append_images=[green, red, transparent],
         default_image=True,
         disposal=disposal,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
+        blend=PngImagePlugin.Blend.OP_OVER,
     )
     with Image.open(test_file) as im:
         im.seek(3)
@@ -514,20 +522,31 @@
         assert im.getpixel((64, 32)) == (0, 255, 0, 255)
 
     disposal = [
-        PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,
+        PngImagePlugin.Disposal.OP_NONE,
+        PngImagePlugin.Disposal.OP_PREVIOUS,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[green],
         disposal=disposal,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
-    )
-    with Image.open(test_file) as im:
-        im.seek(1)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+        blend=PngImagePlugin.Blend.OP_OVER,
+    )
+    with Image.open(test_file) as im:
+        im.seek(1)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+
+    # test info disposal
+    red.info["disposal"] = PngImagePlugin.Disposal.OP_BACKGROUND
+    red.save(
+        test_file,
+        save_all=True,
+        append_images=[Image.new("RGBA", (10, 10), (0, 255, 0, 255))],
+    )
+    with Image.open(test_file) as im:
+        im.seek(1)
+        assert im.getpixel((64, 32)) == (0, 0, 0, 0)
 
 
 def test_apng_save_disposal_previous(tmp_path):
@@ -537,12 +556,12 @@
     red = Image.new("RGBA", size, (255, 0, 0, 255))
     green = Image.new("RGBA", size, (0, 255, 0, 255))
 
-    # test APNG_DISPOSE_OP_NONE
+    # test OP_NONE
     transparent.save(
         test_file,
         save_all=True,
         append_images=[red, green],
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,
+        disposal=PngImagePlugin.Disposal.OP_PREVIOUS,
     )
     with Image.open(test_file) as im:
         im.seek(2)
@@ -557,17 +576,17 @@
     green = Image.new("RGBA", size, (0, 255, 0, 255))
     transparent = Image.new("RGBA", size, (0, 0, 0, 0))
 
-    # test APNG_BLEND_OP_SOURCE on solid color
+    # test OP_SOURCE on solid color
     blend = [
-        PngImagePlugin.APNG_BLEND_OP_OVER,
-        PngImagePlugin.APNG_BLEND_OP_SOURCE,
+        PngImagePlugin.Blend.OP_OVER,
+        PngImagePlugin.Blend.OP_SOURCE,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[red, green],
         default_image=True,
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,
+        disposal=PngImagePlugin.Disposal.OP_NONE,
         blend=blend,
     )
     with Image.open(test_file) as im:
@@ -575,17 +594,17 @@
         assert im.getpixel((0, 0)) == (0, 255, 0, 255)
         assert im.getpixel((64, 32)) == (0, 255, 0, 255)
 
-    # test APNG_BLEND_OP_SOURCE on transparent color
+    # test OP_SOURCE on transparent color
     blend = [
-        PngImagePlugin.APNG_BLEND_OP_OVER,
-        PngImagePlugin.APNG_BLEND_OP_SOURCE,
+        PngImagePlugin.Blend.OP_OVER,
+        PngImagePlugin.Blend.OP_SOURCE,
     ]
     red.save(
         test_file,
         save_all=True,
         append_images=[red, transparent],
         default_image=True,
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,
+        disposal=PngImagePlugin.Disposal.OP_NONE,
         blend=blend,
     )
     with Image.open(test_file) as im:
@@ -593,19 +612,36 @@
         assert im.getpixel((0, 0)) == (0, 0, 0, 0)
         assert im.getpixel((64, 32)) == (0, 0, 0, 0)
 
-    # test APNG_BLEND_OP_OVER
+    # test OP_OVER
     red.save(
         test_file,
         save_all=True,
         append_images=[green, transparent],
         default_image=True,
-        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,
-        blend=PngImagePlugin.APNG_BLEND_OP_OVER,
-    )
-    with Image.open(test_file) as im:
-        im.seek(1)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
-        im.seek(2)
-        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
-        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+        disposal=PngImagePlugin.Disposal.OP_NONE,
+        blend=PngImagePlugin.Blend.OP_OVER,
+    )
+    with Image.open(test_file) as im:
+        im.seek(1)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+        im.seek(2)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+        assert im.getpixel((64, 32)) == (0, 255, 0, 255)
+
+    # test info blend
+    red.info["blend"] = PngImagePlugin.Blend.OP_OVER
+    red.save(test_file, save_all=True, append_images=[green, transparent])
+    with Image.open(test_file) as im:
+        im.seek(2)
+        assert im.getpixel((0, 0)) == (0, 255, 0, 255)
+
+
+def test_constants_deprecation():
+    for enum, prefix in {
+        PngImagePlugin.Disposal: "APNG_DISPOSE_",
+        PngImagePlugin.Blend: "APNG_BLEND_",
+    }.items():
+        for name in enum.__members__:
+            with pytest.warns(DeprecationWarning):
+                assert getattr(PngImagePlugin, prefix + name) == enum[name]
('Tests', 'test_imagetk.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -75,8 +75,9 @@
         assert im_tk.width() == 100
         assert im_tk.height() == 100
 
-        # reloaded = ImageTk.getimage(im_tk)
-        # assert_image_equal(reloaded, im)
+        im = Image.new(mode, (100, 100))
+        reloaded = ImageTk.getimage(im_tk)
+        assert_image_equal(reloaded.convert(mode), im)
 
 
 def test_bitmapimage():
('Tests', 'test_file_gribstub.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -45,3 +45,35 @@
     # Act / Assert: stub cannot save without an implemented handler
     with pytest.raises(OSError):
         im.save(tmpfile)
+
+
+def test_handler(tmp_path):
+    class TestHandler:
+        opened = False
+        loaded = False
+        saved = False
+
+        def open(self, im):
+            self.opened = True
+
+        def load(self, im):
+            self.loaded = True
+            return Image.new("RGB", (1, 1))
+
+        def save(self, im, fp, filename):
+            self.saved = True
+
+    handler = TestHandler()
+    GribStubImagePlugin.register_handler(handler)
+    with Image.open(TEST_FILE) as im:
+        assert handler.opened
+        assert not handler.loaded
+
+        im.load()
+        assert handler.loaded
+
+        temp_file = str(tmp_path / "temp.grib")
+        im.save(temp_file)
+        assert handler.saved
+
+    GribStubImagePlugin._handler = None
('Tests', 'helper.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -29,7 +29,6 @@
         def upload(a, b):
             a.show()
             b.show()
-
 
 elif "GITHUB_ACTIONS" in os.environ:
     HAS_UPLOADER = True
@@ -43,7 +42,6 @@
             a.save(os.path.join(tmpdir, "a.png"))
             b.save(os.path.join(tmpdir, "b.png"))
             return tmpdir
-
 
 else:
     try:
@@ -171,6 +169,21 @@
     version_required = parse_version(version_required)
     version_available = parse_version(features.version(feature))
     return pytest.mark.skipif(version_available < version_required, reason=reason)
+
+
+def mark_if_feature_version(mark, feature, version_blacklist, reason=None):
+    if not features.check(feature):
+        return pytest.mark.pil_noop_mark()
+    if reason is None:
+        reason = f"{feature} is {version_blacklist}"
+    version_required = parse_version(version_blacklist)
+    version_available = parse_version(features.version(feature))
+    if (
+        version_available.major == version_required.major
+        and version_available.minor == version_required.minor
+    ):
+        return mark(reason=reason)
+    return pytest.mark.pil_noop_mark()
 
 
 @pytest.mark.skipif(sys.platform.startswith("win32"), reason="Requires Unix or macOS")
@@ -257,8 +270,23 @@
     return bool(shutil.which("ppmquant") and shutil.which("ppmtogif"))
 
 
-def imagemagick_available():
-    return bool(IMCONVERT and shutil.which(IMCONVERT))
+def magick_command():
+    if sys.platform == "win32":
+        magickhome = os.environ.get("MAGICK_HOME", "")
+        if magickhome:
+            imagemagick = [os.path.join(magickhome, "convert.exe")]
+            graphicsmagick = [os.path.join(magickhome, "gm.exe"), "convert"]
+        else:
+            imagemagick = None
+            graphicsmagick = None
+    else:
+        imagemagick = ["convert"]
+        graphicsmagick = ["gm", "convert"]
+
+    if imagemagick and shutil.which(imagemagick[0]):
+        return imagemagick
+    elif graphicsmagick and shutil.which(graphicsmagick[0]):
+        return graphicsmagick
 
 
 def on_appveyor():
@@ -296,14 +324,6 @@
     return sysconfig.get_platform() == "mingw"
 
 
-if sys.platform == "win32":
-    IMCONVERT = os.environ.get("MAGICK_HOME", "")
-    if IMCONVERT:
-        IMCONVERT = os.path.join(IMCONVERT, "convert.exe")
-else:
-    IMCONVERT = "convert"
-
-
 class cached_property:
     def __init__(self, func):
         self.func = func
('Tests', 'test_image_crop.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -47,16 +47,12 @@
     assert crop(-25, 75, 25, 125) == (1875, 625)
 
 
-def test_negative_crop():
-    # Check negative crop size (@PIL171)
+@pytest.mark.parametrize("box", ((8, 2, 2, 8), (2, 8, 8, 2), (8, 8, 2, 2)))
+def test_negative_crop(box):
+    im = Image.new("RGB", (10, 10))
 
-    im = Image.new("L", (512, 512))
-    im = im.crop((400, 400, 200, 200))
-
-    assert im.size == (0, 0)
-    assert len(im.getdata()) == 0
-    with pytest.raises(IndexError):
-        im.getdata()[0]
+    with pytest.raises(ValueError):
+        im.crop(box)
 
 
 def test_crop_float():
('Tests', 'test_file_tga.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,7 +6,7 @@
 
 from PIL import Image
 
-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper
 
 _TGA_DIR = os.path.join("Tests", "images", "tga")
 _TGA_DIR_COMMON = os.path.join(_TGA_DIR, "common")
@@ -65,6 +65,16 @@
                         roundtrip(original_im)
 
 
+def test_palette_depth_16(tmp_path):
+    with Image.open("Tests/images/p_16.tga") as im:
+        assert_image_equal_tofile(im.convert("RGB"), "Tests/images/p_16.png")
+
+        out = str(tmp_path / "temp.png")
+        im.save(out)
+        with Image.open(out) as reloaded:
+            assert_image_equal_tofile(reloaded.convert("RGB"), "Tests/images/p_16.png")
+
+
 def test_id_field():
     # tga file with id field
     test_file = "Tests/images/tga_id_field.tga"
@@ -85,6 +95,11 @@
 
         # Assert
         assert im.size == (199, 199)
+
+
+def test_cross_scan_line():
+    with Image.open("Tests/images/cross_scan_line.tga") as im:
+        assert_image_equal_tofile(im, "Tests/images/cross_scan_line.png")
 
 
 def test_save(tmp_path):
@@ -112,6 +127,14 @@
         im.save(out)
 
 
+def test_save_mapdepth():
+    # This image has been manually hexedited from 200x32_p_bl_raw.tga
+    # to include an origin
+    test_file = "Tests/images/200x32_p_bl_raw_origin.tga"
+    with Image.open(test_file) as im:
+        assert_image_equal_tofile(im, "Tests/images/tga/common/200x32_p.png")
+
+
 def test_save_id_section(tmp_path):
     test_file = "Tests/images/rgb32rle.tga"
     with Image.open(test_file) as im:
@@ -151,6 +174,15 @@
         im.save(out, orientation=1)
     with Image.open(out) as test_im:
         assert test_im.info["orientation"] == 1
+
+
+def test_horizontal_orientations():
+    # These images have been manually hexedited to have the relevant orientations
+    with Image.open("Tests/images/rgb32rle_top_right.tga") as im:
+        assert im.load()[90, 90][:3] == (0, 0, 0)
+
+    with Image.open("Tests/images/rgb32rle_bottom_right.tga") as im:
+        assert im.load()[90, 90][:3] == (0, 255, 0)
 
 
 def test_save_rle(tmp_path):
('Tests', 'test_file_jpeg2k.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,16 +1,19 @@
+import os
 import re
 from io import BytesIO
 
 import pytest
 
-from PIL import Image, ImageFile, Jpeg2KImagePlugin, features
+from PIL import Image, ImageFile, Jpeg2KImagePlugin, UnidentifiedImageError, features
 
 from .helper import (
     assert_image_equal,
     assert_image_similar,
-    is_big_endian,
+    assert_image_similar_tofile,
     skip_unless_feature,
 )
+
+EXTRA_DIR = "Tests/images/jpeg2000"
 
 pytestmark = skip_unless_feature("jpg_2000")
 
@@ -27,9 +30,9 @@
     im.save(out, "JPEG2000", **options)
     test_bytes = out.tell()
     out.seek(0)
-    im = Image.open(out)
-    im.bytes = test_bytes  # for testing only
-    im.load()
+    with Image.open(out) as im:
+        im.bytes = test_bytes  # for testing only
+        im.load()
     return im
 
 
@@ -62,9 +65,7 @@
 def test_bytesio():
     with open("Tests/images/test-card-lossless.jp2", "rb") as f:
         data = BytesIO(f.read())
-    with Image.open(data) as im:
-        im.load()
-        assert_image_similar(im, test_card, 1.0e-3)
+    assert_image_similar_tofile(test_card, data, 1.0e-3)
 
 
 # These two test pre-written JPEG 2000 files that were not written with
@@ -80,9 +81,9 @@
 
 
 def test_lossy_tiled():
-    with Image.open("Tests/images/test-card-lossy-tiled.jp2") as im:
-        im.load()
-        assert_image_similar(im, test_card, 2.0)
+    assert_image_similar_tofile(
+        test_card, "Tests/images/test-card-lossy-tiled.jp2", 2.0
+    )
 
 
 def test_lossless_rt():
@@ -125,6 +126,16 @@
     assert_image_equal(im, test_card)
 
 
+def test_default_num_resolutions():
+    for num_resolutions in range(2, 6):
+        d = 1 << (num_resolutions - 1)
+        im = test_card.resize((d - 1, d - 1))
+        with pytest.raises(OSError):
+            roundtrip(im, num_resolutions=num_resolutions)
+        reloaded = roundtrip(im)
+        assert_image_equal(im, reloaded)
+
+
 def test_reduce():
     with Image.open("Tests/images/test-card-lossless.jp2") as im:
         assert callable(im.reduce)
@@ -137,6 +148,38 @@
 
         im.thumbnail((40, 40))
         assert im.size == (40, 30)
+
+
+def test_load_dpi():
+    with Image.open("Tests/images/test-card-lossless.jp2") as im:
+        assert im.info["dpi"] == (71.9836, 71.9836)
+
+    with Image.open("Tests/images/zero_dpi.jp2") as im:
+        assert "dpi" not in im.info
+
+
+def test_restricted_icc_profile():
+    ImageFile.LOAD_TRUNCATED_IMAGES = True
+    try:
+        # JPEG2000 image with a restricted ICC profile and a known colorspace
+        with Image.open("Tests/images/balloon_eciRGBv2_aware.jp2") as im:
+            assert im.mode == "RGB"
+    finally:
+        ImageFile.LOAD_TRUNCATED_IMAGES = False
+
+
+def test_header_errors():
+    for path in (
+        "Tests/images/invalid_header_length.jp2",
+        "Tests/images/not_enough_data.jp2",
+    ):
+        with pytest.raises(UnidentifiedImageError):
+            with Image.open(path):
+                pass
+
+    with pytest.raises(OSError):
+        with Image.open("Tests/images/expected_to_read.jp2"):
+            pass
 
 
 def test_layers_type(tmp_path):
@@ -166,6 +209,49 @@
         assert_image_similar(im, test_card, 0.4)
 
 
+@pytest.mark.parametrize(
+    "name, args, offset, data",
+    (
+        ("foo.j2k", {}, 0, b"\xff\x4f"),
+        ("foo.jp2", {}, 4, b"jP"),
+        (None, {"no_jp2": True}, 0, b"\xff\x4f"),
+        ("foo.j2k", {"no_jp2": True}, 0, b"\xff\x4f"),
+        ("foo.jp2", {"no_jp2": True}, 0, b"\xff\x4f"),
+        ("foo.j2k", {"no_jp2": False}, 0, b"\xff\x4f"),
+        ("foo.jp2", {"no_jp2": False}, 4, b"jP"),
+        ("foo.jp2", {"no_jp2": False}, 4, b"jP"),
+    ),
+)
+def test_no_jp2(name, args, offset, data):
+    out = BytesIO()
+    if name:
+        out.name = name
+    test_card.save(out, "JPEG2000", **args)
+    out.seek(offset)
+    assert out.read(2) == data
+
+
+def test_mct():
+    # Three component
+    for val in (0, 1):
+        out = BytesIO()
+        test_card.save(out, "JPEG2000", mct=val, no_jp2=True)
+
+        assert out.getvalue()[59] == val
+        with Image.open(out) as im:
+            assert_image_similar(im, test_card, 1.0e-3)
+
+    # Single component should have MCT disabled
+    for val in (0, 1):
+        out = BytesIO()
+        with Image.open("Tests/images/16bit.cropped.jp2") as jp2:
+            jp2.save(out, "JPEG2000", mct=val, no_jp2=True)
+
+        assert out.getvalue()[53] == 0
+        with Image.open(out) as im:
+            assert_image_similar(im, jp2, 1.0e-3)
+
+
 def test_rgba():
     # Arrange
     with Image.open("Tests/images/rgb_trns_ycbc.j2k") as j2k:
@@ -190,18 +276,14 @@
         assert jp2.mode == "I;16"
 
 
-@pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
 def test_16bit_monochrome_jp2_like_tiff():
     with Image.open("Tests/images/16bit.cropped.tif") as tiff_16bit:
-        with Image.open("Tests/images/16bit.cropped.jp2") as jp2:
-            assert_image_similar(jp2, tiff_16bit, 1e-3)
-
-
-@pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+        assert_image_similar_tofile(tiff_16bit, "Tests/images/16bit.cropped.jp2", 1e-3)
+
+
 def test_16bit_monochrome_j2k_like_tiff():
     with Image.open("Tests/images/16bit.cropped.tif") as tiff_16bit:
-        with Image.open("Tests/images/16bit.cropped.j2k") as j2k:
-            assert_image_similar(j2k, tiff_16bit, 1e-3)
+        assert_image_similar_tofile(tiff_16bit, "Tests/images/16bit.cropped.j2k", 1e-3)
 
 
 def test_16bit_j2k_roundtrips():
@@ -219,7 +301,8 @@
 def test_unbound_local():
     # prepatch, a malformed jp2 file could cause an UnboundLocalError exception.
     with pytest.raises(OSError):
-        Image.open("Tests/images/unbound_variable.jp2")
+        with Image.open("Tests/images/unbound_variable.jp2"):
+            pass
 
 
 def test_parser_feed():
@@ -233,3 +316,42 @@
 
     # Assert
     assert p.image.size == (640, 480)
+
+
+@pytest.mark.skipif(
+    not os.path.exists(EXTRA_DIR), reason="Extra image files not installed"
+)
+@pytest.mark.parametrize("name", ("subsampling_1", "subsampling_2", "zoo1", "zoo2"))
+def test_subsampling_decode(name):
+    test = f"{EXTRA_DIR}/{name}.jp2"
+    reference = f"{EXTRA_DIR}/{name}.ppm"
+
+    with Image.open(test) as im:
+        epsilon = 3  # for YCbCr images
+        with Image.open(reference) as im2:
+            width, height = im2.size
+            if name[-1] == "2":
+                # RGB reference images are downscaled
+                epsilon = 3e-3
+                width, height = width * 2, height * 2
+            expected = im2.resize((width, height), Image.Resampling.NEAREST)
+        assert_image_similar(im, expected, epsilon)
+
+
+@pytest.mark.parametrize(
+    "test_file",
+    [
+        "Tests/images/crash-4fb027452e6988530aa5dabee76eecacb3b79f8a.j2k",
+        "Tests/images/crash-7d4c83eb92150fb8f1653a697703ae06ae7c4998.j2k",
+        "Tests/images/crash-ccca68ff40171fdae983d924e127a721cab2bd50.j2k",
+        "Tests/images/crash-d2c93af851d3ab9a19e34503626368b2ecde9c03.j2k",
+    ],
+)
+def test_crashes(test_file):
+    with open(test_file, "rb") as f:
+        with Image.open(f) as im:
+            # Valgrind should not complain here
+            try:
+                im.load()
+            except OSError:
+                pass
('Tests', 'test_image_mode.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,6 +21,7 @@
     assert m.bands == ("1",)
     assert m.basemode == "L"
     assert m.basetype == "L"
+    assert m.typestr == "|b1"
 
     for mode in (
         "I;16",
@@ -45,6 +46,7 @@
     assert m.bands == ("R", "G", "B")
     assert m.basemode == "RGB"
     assert m.basetype == "L"
+    assert m.typestr == "|u1"
 
 
 def test_properties():
@@ -65,6 +67,5 @@
     check("RGB", "RGB", "L", 3, ("R", "G", "B"))
     check("RGBA", "RGB", "L", 4, ("R", "G", "B", "A"))
     check("RGBX", "RGB", "L", 4, ("R", "G", "B", "X"))
-    check("RGBX", "RGB", "L", 4, ("R", "G", "B", "X"))
     check("CMYK", "RGB", "L", 4, ("C", "M", "Y", "K"))
     check("YCbCr", "RGB", "L", 3, ("Y", "Cb", "Cr"))
('Tests', 'test_image_resample.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,12 @@
 
 from PIL import Image, ImageDraw
 
-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_similar,
+    hopper,
+    mark_if_feature_version,
+)
 
 
 class TestImagingResampleVulnerability:
@@ -19,7 +24,7 @@
         ):
             with pytest.raises(MemoryError):
                 # any resampling filter will do here
-                im.im.resize((xsize, ysize), Image.BILINEAR)
+                im.im.resize((xsize, ysize), Image.Resampling.BILINEAR)
 
     def test_invalid_size(self):
         im = hopper()
@@ -98,7 +103,7 @@
     def test_reduce_box(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (8, 8), 0xE1)
-            case = case.resize((4, 4), Image.BOX)
+            case = case.resize((4, 4), Image.Resampling.BOX)
             # fmt: off
             data = ("e1 e1"
                     "e1 e1")
@@ -109,7 +114,7 @@
     def test_reduce_bilinear(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (8, 8), 0xE1)
-            case = case.resize((4, 4), Image.BILINEAR)
+            case = case.resize((4, 4), Image.Resampling.BILINEAR)
             # fmt: off
             data = ("e1 c9"
                     "c9 b7")
@@ -120,7 +125,7 @@
     def test_reduce_hamming(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (8, 8), 0xE1)
-            case = case.resize((4, 4), Image.HAMMING)
+            case = case.resize((4, 4), Image.Resampling.HAMMING)
             # fmt: off
             data = ("e1 da"
                     "da d3")
@@ -131,7 +136,7 @@
     def test_reduce_bicubic(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (12, 12), 0xE1)
-            case = case.resize((6, 6), Image.BICUBIC)
+            case = case.resize((6, 6), Image.Resampling.BICUBIC)
             # fmt: off
             data = ("e1 e3 d4"
                     "e3 e5 d6"
@@ -143,7 +148,7 @@
     def test_reduce_lanczos(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (16, 16), 0xE1)
-            case = case.resize((8, 8), Image.LANCZOS)
+            case = case.resize((8, 8), Image.Resampling.LANCZOS)
             # fmt: off
             data = ("e1 e0 e4 d7"
                     "e0 df e3 d6"
@@ -156,7 +161,7 @@
     def test_enlarge_box(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (2, 2), 0xE1)
-            case = case.resize((4, 4), Image.BOX)
+            case = case.resize((4, 4), Image.Resampling.BOX)
             # fmt: off
             data = ("e1 e1"
                     "e1 e1")
@@ -167,7 +172,7 @@
     def test_enlarge_bilinear(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (2, 2), 0xE1)
-            case = case.resize((4, 4), Image.BILINEAR)
+            case = case.resize((4, 4), Image.Resampling.BILINEAR)
             # fmt: off
             data = ("e1 b0"
                     "b0 98")
@@ -178,7 +183,7 @@
     def test_enlarge_hamming(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (2, 2), 0xE1)
-            case = case.resize((4, 4), Image.HAMMING)
+            case = case.resize((4, 4), Image.Resampling.HAMMING)
             # fmt: off
             data = ("e1 d2"
                     "d2 c5")
@@ -189,7 +194,7 @@
     def test_enlarge_bicubic(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (4, 4), 0xE1)
-            case = case.resize((8, 8), Image.BICUBIC)
+            case = case.resize((8, 8), Image.Resampling.BICUBIC)
             # fmt: off
             data = ("e1 e5 ee b9"
                     "e5 e9 f3 bc"
@@ -202,7 +207,7 @@
     def test_enlarge_lanczos(self):
         for mode in ["RGBX", "RGB", "La", "L"]:
             case = self.make_case(mode, (6, 6), 0xE1)
-            case = case.resize((12, 12), Image.LANCZOS)
+            case = case.resize((12, 12), Image.Resampling.LANCZOS)
             data = (
                 "e1 e0 db ed f5 b8"
                 "e0 df da ec f3 b7"
@@ -215,7 +220,9 @@
                 self.check_case(channel, self.make_sample(data, (12, 12)))
 
     def test_box_filter_correct_range(self):
-        im = Image.new("RGB", (8, 8), "#1688ff").resize((100, 100), Image.BOX)
+        im = Image.new("RGB", (8, 8), "#1688ff").resize(
+            (100, 100), Image.Resampling.BOX
+        )
         ref = Image.new("RGB", (100, 100), "#1688ff")
         assert_image_equal(im, ref)
 
@@ -223,7 +230,7 @@
 class TestCoreResampleConsistency:
     def make_case(self, mode, fill):
         im = Image.new(mode, (512, 9), fill)
-        return im.resize((9, 512), Image.LANCZOS), im.load()[0, 0]
+        return im.resize((9, 512), Image.Resampling.LANCZOS), im.load()[0, 0]
 
     def run_case(self, case):
         channel, color = case
@@ -278,20 +285,20 @@
     @pytest.mark.xfail(reason="Current implementation isn't precise enough")
     def test_levels_rgba(self):
         case = self.make_levels_case("RGBA")
-        self.run_levels_case(case.resize((512, 32), Image.BOX))
-        self.run_levels_case(case.resize((512, 32), Image.BILINEAR))
-        self.run_levels_case(case.resize((512, 32), Image.HAMMING))
-        self.run_levels_case(case.resize((512, 32), Image.BICUBIC))
-        self.run_levels_case(case.resize((512, 32), Image.LANCZOS))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BOX))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BILINEAR))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.HAMMING))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BICUBIC))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.LANCZOS))
 
     @pytest.mark.xfail(reason="Current implementation isn't precise enough")
     def test_levels_la(self):
         case = self.make_levels_case("LA")
-        self.run_levels_case(case.resize((512, 32), Image.BOX))
-        self.run_levels_case(case.resize((512, 32), Image.BILINEAR))
-        self.run_levels_case(case.resize((512, 32), Image.HAMMING))
-        self.run_levels_case(case.resize((512, 32), Image.BICUBIC))
-        self.run_levels_case(case.resize((512, 32), Image.LANCZOS))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BOX))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BILINEAR))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.HAMMING))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.BICUBIC))
+        self.run_levels_case(case.resize((512, 32), Image.Resampling.LANCZOS))
 
     def make_dirty_case(self, mode, clean_pixel, dirty_pixel):
         i = Image.new(mode, (64, 64), dirty_pixel)
@@ -316,19 +323,27 @@
 
     def test_dirty_pixels_rgba(self):
         case = self.make_dirty_case("RGBA", (255, 255, 0, 128), (0, 0, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.BOX), (255, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.BILINEAR), (255, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.HAMMING), (255, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.BICUBIC), (255, 255, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.LANCZOS), (255, 255, 0))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BOX), (255, 255, 0))
+        self.run_dirty_case(
+            case.resize((20, 20), Image.Resampling.BILINEAR), (255, 255, 0)
+        )
+        self.run_dirty_case(
+            case.resize((20, 20), Image.Resampling.HAMMING), (255, 255, 0)
+        )
+        self.run_dirty_case(
+            case.resize((20, 20), Image.Resampling.BICUBIC), (255, 255, 0)
+        )
+        self.run_dirty_case(
+            case.resize((20, 20), Image.Resampling.LANCZOS), (255, 255, 0)
+        )
 
     def test_dirty_pixels_la(self):
         case = self.make_dirty_case("LA", (255, 128), (0, 0))
-        self.run_dirty_case(case.resize((20, 20), Image.BOX), (255,))
-        self.run_dirty_case(case.resize((20, 20), Image.BILINEAR), (255,))
-        self.run_dirty_case(case.resize((20, 20), Image.HAMMING), (255,))
-        self.run_dirty_case(case.resize((20, 20), Image.BICUBIC), (255,))
-        self.run_dirty_case(case.resize((20, 20), Image.LANCZOS), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BOX), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BILINEAR), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.HAMMING), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BICUBIC), (255,))
+        self.run_dirty_case(case.resize((20, 20), Image.Resampling.LANCZOS), (255,))
 
 
 class TestCoreResamplePasses:
@@ -341,26 +356,26 @@
     def test_horizontal(self):
         im = hopper("L")
         with self.count(1):
-            im.resize((im.size[0] - 10, im.size[1]), Image.BILINEAR)
+            im.resize((im.size[0] - 10, im.size[1]), Image.Resampling.BILINEAR)
 
     def test_vertical(self):
         im = hopper("L")
         with self.count(1):
-            im.resize((im.size[0], im.size[1] - 10), Image.BILINEAR)
+            im.resize((im.size[0], im.size[1] - 10), Image.Resampling.BILINEAR)
 
     def test_both(self):
         im = hopper("L")
         with self.count(2):
-            im.resize((im.size[0] - 10, im.size[1] - 10), Image.BILINEAR)
+            im.resize((im.size[0] - 10, im.size[1] - 10), Image.Resampling.BILINEAR)
 
     def test_box_horizontal(self):
         im = hopper("L")
         box = (20, 0, im.size[0] - 20, im.size[1])
         with self.count(1):
             # the same size, but different box
-            with_box = im.resize(im.size, Image.BILINEAR, box)
+            with_box = im.resize(im.size, Image.Resampling.BILINEAR, box)
         with self.count(2):
-            cropped = im.crop(box).resize(im.size, Image.BILINEAR)
+            cropped = im.crop(box).resize(im.size, Image.Resampling.BILINEAR)
         assert_image_similar(with_box, cropped, 0.1)
 
     def test_box_vertical(self):
@@ -368,9 +383,9 @@
         box = (0, 20, im.size[0], im.size[1] - 20)
         with self.count(1):
             # the same size, but different box
-            with_box = im.resize(im.size, Image.BILINEAR, box)
+            with_box = im.resize(im.size, Image.Resampling.BILINEAR, box)
         with self.count(2):
-            cropped = im.crop(box).resize(im.size, Image.BILINEAR)
+            cropped = im.crop(box).resize(im.size, Image.Resampling.BILINEAR)
         assert_image_similar(with_box, cropped, 0.1)
 
 
@@ -383,7 +398,7 @@
             draw = ImageDraw.Draw(i)
             draw.rectangle((0, 0, i.size[0] // 2 - 1, 0), test_color)
 
-            px = i.resize((5, i.size[1]), Image.BICUBIC).load()
+            px = i.resize((5, i.size[1]), Image.Resampling.BICUBIC).load()
             if px[2, 0] != test_color // 2:
                 assert test_color // 2 == px[2, 0]
 
@@ -391,7 +406,7 @@
         # regression test for the wrong coefficients calculation
         # due to bug https://github.com/python-pillow/Pillow/issues/2161
         im = Image.new("RGBA", (1280, 1280), (0x20, 0x40, 0x60, 0xFF))
-        histogram = im.resize((256, 256), Image.BICUBIC).histogram()
+        histogram = im.resize((256, 256), Image.Resampling.BICUBIC).histogram()
 
         # first channel
         assert histogram[0x100 * 0 + 0x20] == 0x10000
@@ -407,12 +422,12 @@
     def test_wrong_arguments(self):
         im = hopper()
         for resample in (
-            Image.NEAREST,
-            Image.BOX,
-            Image.BILINEAR,
-            Image.HAMMING,
-            Image.BICUBIC,
-            Image.LANCZOS,
+            Image.Resampling.NEAREST,
+            Image.Resampling.BOX,
+            Image.Resampling.BILINEAR,
+            Image.Resampling.HAMMING,
+            Image.Resampling.BICUBIC,
+            Image.Resampling.LANCZOS,
         ):
             im.resize((32, 32), resample, (0, 0, im.width, im.height))
             im.resize((32, 32), resample, (20, 20, im.width, im.height))
@@ -451,20 +466,26 @@
         for y0, y1 in split_range(dst_size[1], ytiles):
             for x0, x1 in split_range(dst_size[0], xtiles):
                 box = (x0 * scale[0], y0 * scale[1], x1 * scale[0], y1 * scale[1])
-                tile = im.resize((x1 - x0, y1 - y0), Image.BICUBIC, box)
+                tile = im.resize((x1 - x0, y1 - y0), Image.Resampling.BICUBIC, box)
                 tiled.paste(tile, (x0, y0))
         return tiled
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_tiles(self):
         with Image.open("Tests/images/flower.jpg") as im:
             assert im.size == (480, 360)
             dst_size = (251, 188)
-            reference = im.resize(dst_size, Image.BICUBIC)
+            reference = im.resize(dst_size, Image.Resampling.BICUBIC)
 
             for tiles in [(1, 1), (3, 3), (9, 7), (100, 100)]:
                 tiled = self.resize_tiled(im, dst_size, *tiles)
                 assert_image_similar(reference, tiled, 0.01)
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_subsample(self):
         # This test shows advantages of the subpixel resizing
         # after supersampling (e.g. during JPEG decoding).
@@ -472,12 +493,16 @@
             assert im.size == (480, 360)
             dst_size = (48, 36)
             # Reference is cropped image resized to destination
-            reference = im.crop((0, 0, 473, 353)).resize(dst_size, Image.BICUBIC)
-            # Image.BOX emulates supersampling (480 / 8 = 60, 360 / 8 = 45)
-            supersampled = im.resize((60, 45), Image.BOX)
-
-        with_box = supersampled.resize(dst_size, Image.BICUBIC, (0, 0, 59.125, 44.125))
-        without_box = supersampled.resize(dst_size, Image.BICUBIC)
+            reference = im.crop((0, 0, 473, 353)).resize(
+                dst_size, Image.Resampling.BICUBIC
+            )
+            # Image.Resampling.BOX emulates supersampling (480 / 8 = 60, 360 / 8 = 45)
+            supersampled = im.resize((60, 45), Image.Resampling.BOX)
+
+        with_box = supersampled.resize(
+            dst_size, Image.Resampling.BICUBIC, (0, 0, 59.125, 44.125)
+        )
+        without_box = supersampled.resize(dst_size, Image.Resampling.BICUBIC)
 
         # error with box should be much smaller than without
         assert_image_similar(reference, with_box, 6)
@@ -485,7 +510,7 @@
             assert_image_similar(reference, without_box, 5)
 
     def test_formats(self):
-        for resample in [Image.NEAREST, Image.BILINEAR]:
+        for resample in [Image.Resampling.NEAREST, Image.Resampling.BILINEAR]:
             for mode in ["RGB", "L", "RGBA", "LA", "I", ""]:
                 im = hopper(mode)
                 box = (20, 20, im.size[0] - 20, im.size[1] - 20)
@@ -503,7 +528,7 @@
             ((40, 50), (10, 0, 50, 50)),
             ((40, 50), (10, 20, 50, 70)),
         ]:
-            res = im.resize(size, Image.LANCZOS, box)
+            res = im.resize(size, Image.Resampling.LANCZOS, box)
             assert res.size == size
             assert_image_equal(res, im.crop(box), f">>> {size} {box}")
 
@@ -517,7 +542,7 @@
             ((40, 50), (10.4, 0.4, 50.4, 50.4)),
             ((40, 50), (10.4, 20.4, 50.4, 70.4)),
         ]:
-            res = im.resize(size, Image.LANCZOS, box)
+            res = im.resize(size, Image.Resampling.LANCZOS, box)
             assert res.size == size
             with pytest.raises(AssertionError, match=r"difference \d"):
                 # check that the difference at least that much
@@ -527,7 +552,7 @@
         # Can skip resize for one dimension
         im = hopper()
 
-        for flt in [Image.NEAREST, Image.BICUBIC]:
+        for flt in [Image.Resampling.NEAREST, Image.Resampling.BICUBIC]:
             for size, box in [
                 ((40, 50), (0, 0, 40, 90)),
                 ((40, 50), (0, 20, 40, 90)),
@@ -548,7 +573,7 @@
         # Can skip resize for one dimension
         im = hopper()
 
-        for flt in [Image.NEAREST, Image.BICUBIC]:
+        for flt in [Image.Resampling.NEAREST, Image.Resampling.BICUBIC]:
             for size, box in [
                 ((40, 50), (0, 0, 90, 50)),
                 ((40, 50), (20, 0, 90, 50)),
('Tests', 'test_image_quantize.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,41 +1,40 @@
 import pytest
+from packaging.version import parse as parse_version
 
-from PIL import Image
+from PIL import Image, features
 
-from .helper import assert_image, assert_image_similar, hopper, is_ppc64le
+from .helper import assert_image_similar, hopper, is_ppc64le, skip_unless_feature
 
 
 def test_sanity():
     image = hopper()
     converted = image.quantize()
-    assert_image(converted, "P", converted.size)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 10)
 
     image = hopper()
     converted = image.quantize(palette=hopper("P"))
-    assert_image(converted, "P", converted.size)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 60)
 
 
-@pytest.mark.xfail(is_ppc64le(), reason="failing on ppc64le on GHA")
+@skip_unless_feature("libimagequant")
 def test_libimagequant_quantize():
     image = hopper()
-    try:
-        converted = image.quantize(100, Image.LIBIMAGEQUANT)
-    except ValueError as ex:  # pragma: no cover
-        if "dependency" in str(ex).lower():
-            pytest.skip("libimagequant support not available")
-        else:
-            raise
-    assert_image(converted, "P", converted.size)
+    if is_ppc64le():
+        libimagequant = parse_version(features.version_feature("libimagequant"))
+        if libimagequant < parse_version("4"):
+            pytest.skip("Fails with libimagequant earlier than 4.0.0 on ppc64le")
+    converted = image.quantize(100, Image.Quantize.LIBIMAGEQUANT)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 15)
     assert len(converted.getcolors()) == 100
 
 
 def test_octree_quantize():
     image = hopper()
-    converted = image.quantize(100, Image.FASTOCTREE)
-    assert_image(converted, "P", converted.size)
+    converted = image.quantize(100, Image.Quantize.FASTOCTREE)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 20)
     assert len(converted.getcolors()) == 100
 
@@ -52,7 +51,7 @@
     with Image.open("Tests/images/caption_6_33_22.png") as image:
         image = image.convert("RGB")
     converted = image.quantize()
-    assert_image(converted, "P", converted.size)
+    assert converted.mode == "P"
     assert_image_similar(converted.convert("RGB"), image, 1)
 
 
@@ -61,8 +60,9 @@
     with Image.open("Tests/images/caption_6_33_22.png") as palette:
         palette = palette.convert("P")
 
-    converted = image.quantize(dither=0, palette=palette)
-    assert_image(converted, "P", converted.size)
+    converted = image.quantize(dither=Image.Dither.NONE, palette=palette)
+    assert converted.mode == "P"
+    assert converted.palette.palette == palette.palette.palette
 
 
 def test_quantize_dither_diff():
@@ -70,7 +70,56 @@
     with Image.open("Tests/images/caption_6_33_22.png") as palette:
         palette = palette.convert("P")
 
-    dither = image.quantize(dither=1, palette=palette)
-    nodither = image.quantize(dither=0, palette=palette)
+    dither = image.quantize(dither=Image.Dither.FLOYDSTEINBERG, palette=palette)
+    nodither = image.quantize(dither=Image.Dither.NONE, palette=palette)
 
     assert dither.tobytes() != nodither.tobytes()
+
+
+def test_colors():
+    im = hopper()
+    colors = 2
+    converted = im.quantize(colors)
+    assert len(converted.palette.palette) == colors * len("RGB")
+
+
+def test_transparent_colors_equal():
+    im = Image.new("RGBA", (1, 2), (0, 0, 0, 0))
+    px = im.load()
+    px[0, 1] = (255, 255, 255, 0)
+
+    converted = im.quantize()
+    converted_px = converted.load()
+    assert converted_px[0, 0] == converted_px[0, 1]
+
+
+@pytest.mark.parametrize(
+    "method, color",
+    (
+        (Image.Quantize.MEDIANCUT, (0, 0, 0)),
+        (Image.Quantize.MAXCOVERAGE, (0, 0, 0)),
+        (Image.Quantize.FASTOCTREE, (0, 0, 0)),
+        (Image.Quantize.FASTOCTREE, (0, 0, 0, 0)),
+    ),
+)
+def test_palette(method, color):
+    im = Image.new("RGBA" if len(color) == 4 else "RGB", (1, 1), color)
+
+    converted = im.quantize(method=method)
+    converted_px = converted.load()
+    assert converted_px[0, 0] == converted.palette.colors[color]
+
+
+def test_small_palette():
+    # Arrange
+    im = hopper()
+
+    colors = (255, 0, 0, 0, 0, 255)
+    p = Image.new("P", (1, 1))
+    p.putpalette(colors)
+
+    # Act
+    im = im.quantize(palette=p)
+
+    # Assert
+    assert len(im.getcolors()) == 2
('Tests', 'test_imagedraw2.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,7 +4,8 @@
 
 from .helper import (
     assert_image_equal,
-    assert_image_similar,
+    assert_image_equal_tofile,
+    assert_image_similar_tofile,
     hopper,
     skip_unless_feature,
 )
@@ -61,7 +62,7 @@
     draw.ellipse(bbox, pen, brush)
 
     # Assert
-    assert_image_similar(im, Image.open(expected), 1)
+    assert_image_similar_tofile(im, expected, 1)
 
 
 def test_ellipse1():
@@ -82,7 +83,7 @@
     draw.ellipse(((0, 0), (W - 1, H - 1)), brush)
 
     # Assert
-    assert_image_similar(im, Image.open("Tests/images/imagedraw_ellipse_edge.png"), 1)
+    assert_image_similar_tofile(im, "Tests/images/imagedraw_ellipse_edge.png", 1)
 
 
 def helper_line(points):
@@ -95,7 +96,7 @@
     draw.line(points, pen)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_line.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_line.png")
 
 
 def test_line1_pen():
@@ -118,7 +119,7 @@
     draw.line(POINTS1, pen, brush)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_line.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_line.png")
 
 
 def helper_polygon(points):
@@ -132,7 +133,7 @@
     draw.polygon(points, pen, brush)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_polygon.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_polygon.png")
 
 
 def test_polygon1():
@@ -154,7 +155,7 @@
     draw.rectangle(bbox, pen, brush)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_rectangle.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rectangle.png")
 
 
 def test_rectangle1():
@@ -178,7 +179,7 @@
     draw.rectangle(bbox, brush)
 
     # Assert
-    assert_image_similar(im, Image.open(expected), 1)
+    assert_image_similar_tofile(im, expected, 1)
 
 
 @skip_unless_feature("freetype2")
@@ -193,7 +194,7 @@
     draw.text((5, 5), "ImageDraw2", font)
 
     # Assert
-    assert_image_similar(im, Image.open(expected), 13)
+    assert_image_similar_tofile(im, expected, 13)
 
 
 @skip_unless_feature("freetype2")
('Tests', 'test_file_palm.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,9 +5,7 @@
 
 from PIL import Image
 
-from .helper import IMCONVERT, assert_image_equal, hopper, imagemagick_available
-
-_roundtrip = imagemagick_available()
+from .helper import assert_image_equal, hopper, magick_command
 
 
 def helper_save_as_palm(tmp_path, mode):
@@ -23,13 +21,10 @@
     assert os.path.getsize(outfile) > 0
 
 
-def open_with_imagemagick(tmp_path, f):
-    if not imagemagick_available():
-        raise OSError()
-
+def open_with_magick(magick, tmp_path, f):
     outfile = str(tmp_path / "temp.png")
     rc = subprocess.call(
-        [IMCONVERT, f, outfile], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT
+        magick + [f, outfile], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT
     )
     if rc:
         raise OSError
@@ -37,14 +32,15 @@
 
 
 def roundtrip(tmp_path, mode):
-    if not _roundtrip:
+    magick = magick_command()
+    if not magick:
         return
 
     im = hopper(mode)
     outfile = str(tmp_path / "temp.palm")
 
     im.save(outfile)
-    converted = open_with_imagemagick(tmp_path, outfile)
+    converted = open_with_magick(magick, tmp_path, outfile)
     assert_image_equal(converted, im)
 
 
('Tests', 'test_file_icns.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,11 +1,12 @@
 import io
-import sys
+import os
+import warnings
 
 import pytest
 
-from PIL import IcnsImagePlugin, Image, features
+from PIL import IcnsImagePlugin, Image, _binary, features
 
-from .helper import assert_image_equal, assert_image_similar
+from .helper import assert_image_equal, assert_image_similar_tofile
 
 # sample icon file
 TEST_FILE = "Tests/images/pillow.icns"
@@ -19,14 +20,22 @@
     with Image.open(TEST_FILE) as im:
 
         # Assert that there is no unclosed file warning
-        pytest.warns(None, im.load)
+        with warnings.catch_warnings():
+            im.load()
 
         assert im.mode == "RGBA"
         assert im.size == (1024, 1024)
         assert im.format == "ICNS"
 
 
-@pytest.mark.skipif(sys.platform != "darwin", reason="Requires macOS")
+def test_load():
+    with Image.open(TEST_FILE) as im:
+        assert im.load()[0, 0] == (0, 0, 0, 0)
+
+        # Test again now that it has already been loaded once
+        assert im.load()[0, 0] == (0, 0, 0, 0)
+
+
 def test_save(tmp_path):
     temp_file = str(tmp_path / "temp.icns")
 
@@ -38,8 +47,12 @@
         assert reread.size == (1024, 1024)
         assert reread.format == "ICNS"
 
+    file_length = os.path.getsize(temp_file)
+    with open(temp_file, "rb") as fp:
+        fp.seek(4)
+        assert _binary.i32be(fp.read(4)) == file_length
 
-@pytest.mark.skipif(sys.platform != "darwin", reason="Requires macOS")
+
 def test_save_append_images(tmp_path):
     temp_file = str(tmp_path / "temp.icns")
     provided_im = Image.new("RGBA", (32, 32), (255, 0, 0, 128))
@@ -47,8 +60,7 @@
     with Image.open(TEST_FILE) as im:
         im.save(temp_file, append_images=[provided_im])
 
-        with Image.open(temp_file) as reread:
-            assert_image_similar(reread, im, 1)
+        assert_image_similar_tofile(im, temp_file, 1)
 
         with Image.open(temp_file) as reread:
             reread.size = (16, 16, 2)
@@ -56,7 +68,6 @@
             assert_image_equal(reread, provided_im)
 
 
-@pytest.mark.skipif(sys.platform != "darwin", reason="Requires macOS")
 def test_save_fp():
     fp = io.BytesIO()
 
@@ -101,12 +112,9 @@
 
 
 def test_jp2_icon():
-    # This icon was made by using Uli Kusterer's oldiconutil to replace
-    # the PNG images with JPEG 2000 ones.  The advantage of doing this is
-    # that OS X 10.5 supports JPEG 2000 but not PNG; some commercial
-    # software therefore does just this.
-
-    # (oldiconutil is here: https://github.com/uliwitness/oldiconutil)
+    # This icon uses JPEG 2000 images instead of the PNG images.
+    # The advantage of doing this is that OS X 10.5 supports JPEG 2000
+    # but not PNG; some commercial software therefore does just this.
 
     if not ENABLE_JPEG2K:
         return
@@ -139,3 +147,11 @@
     with io.BytesIO(b"invalid\n") as fp:
         with pytest.raises(SyntaxError):
             IcnsImagePlugin.IcnsFile(fp)
+
+
+def test_icns_decompression_bomb():
+    with Image.open(
+        "Tests/images/oom-8ed3316a4109213ca96fb8a256a0bfefdece1461.icns"
+    ) as im:
+        with pytest.raises(Image.DecompressionBombError):
+            im.load()
('Tests', 'test_file_libtiff.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -4,11 +4,11 @@
 import os
 import re
 from collections import namedtuple
-from ctypes import c_float
 
 import pytest
 
 from PIL import Image, ImageFilter, TiffImagePlugin, TiffTags, features
+from PIL.TiffImagePlugin import SAMPLEFORMAT, STRIPOFFSETS, SUBIFD
 
 from .helper import (
     assert_image_equal,
@@ -16,7 +16,7 @@
     assert_image_similar,
     assert_image_similar_tofile,
     hopper,
-    is_big_endian,
+    mark_if_feature_version,
     skip_unless_feature,
 )
 
@@ -96,24 +96,22 @@
             self._assert_noerr(tmp_path, im)
 
     def test_g4_eq_png(self):
-        """ Checking that we're actually getting the data that we expect"""
+        """Checking that we're actually getting the data that we expect"""
         with Image.open("Tests/images/hopper_bw_500.png") as png:
-            with Image.open("Tests/images/hopper_g4_500.tif") as g4:
-                assert_image_equal(g4, png)
+            assert_image_equal_tofile(png, "Tests/images/hopper_g4_500.tif")
 
     # see https://github.com/python-pillow/Pillow/issues/279
     def test_g4_fillorder_eq_png(self):
-        """ Checking that we're actually getting the data that we expect"""
-        with Image.open("Tests/images/g4-fillorder-test.png") as png:
-            with Image.open("Tests/images/g4-fillorder-test.tif") as g4:
-                assert_image_equal(g4, png)
+        """Checking that we're actually getting the data that we expect"""
+        with Image.open("Tests/images/g4-fillorder-test.tif") as g4:
+            assert_image_equal_tofile(g4, "Tests/images/g4-fillorder-test.png")
 
     def test_g4_write(self, tmp_path):
         """Checking to see that the saved image is the same as what we wrote"""
         test_file = "Tests/images/hopper_g4_500.tif"
         with Image.open(test_file) as orig:
             out = str(tmp_path / "temp.tif")
-            rot = orig.transpose(Image.ROTATE_90)
+            rot = orig.transpose(Image.Transpose.ROTATE_90)
             assert rot.size == (500, 500)
             rot.save(out)
 
@@ -138,7 +136,7 @@
             assert_image_equal_tofile(im, "Tests/images/tiff_adobe_deflate.png")
 
     def test_write_metadata(self, tmp_path):
-        """ Test metadata writing through libtiff """
+        """Test metadata writing through libtiff"""
         for legacy_api in [False, True]:
             f = str(tmp_path / "temp.tiff")
             with Image.open("Tests/images/hopper_g4.tif") as img:
@@ -169,14 +167,11 @@
                     val = original[tag]
                     if tag.endswith("Resolution"):
                         if legacy_api:
-                            assert (
-                                c_float(val[0][0] / val[0][1]).value
-                                == c_float(value[0][0] / value[0][1]).value
+                            assert val[0][0] / val[0][1] == (
+                                4294967295 / 113653537
                             ), f"{tag} didn't roundtrip"
                         else:
-                            assert (
-                                c_float(val).value == c_float(value).value
-                            ), f"{tag} didn't roundtrip"
+                            assert val == 37.79000115940079, f"{tag} didn't roundtrip"
                     else:
                         assert val == value, f"{tag} didn't roundtrip"
 
@@ -185,6 +180,7 @@
             for field in requested_fields:
                 assert field in reloaded, f"{field} not in metadata"
 
+    @pytest.mark.valgrind_known_error(reason="Known invalid metadata")
     def test_additional_metadata(self, tmp_path):
         # these should not crash. Seriously dummy data, most of it doesn't make
         # any sense, so we're running up against limits where we're asking
@@ -218,7 +214,7 @@
             values = {
                 2: "test",
                 3: 1,
-                4: 2 ** 20,
+                4: 2**20,
                 5: TiffImagePlugin.IFDRational(100, 1),
                 12: 1.05,
             }
@@ -323,6 +319,14 @@
             )
         TiffImagePlugin.WRITE_LIBTIFF = False
 
+    def test_subifd(self, tmp_path):
+        outfile = str(tmp_path / "temp.tif")
+        with Image.open("Tests/images/g4_orientation_6.tif") as im:
+            im.tag_v2[SUBIFD] = 10000
+
+            # Should not segfault
+            im.save(outfile)
+
     def test_xmlpacket_tag(self, tmp_path):
         TiffImagePlugin.WRITE_LIBTIFF = True
 
@@ -427,10 +431,7 @@
         im = im.filter(ImageFilter.GaussianBlur(4))
         im.save(out, compression="tiff_adobe_deflate")
 
-        with Image.open(out) as im2:
-            im2.load()
-
-            assert_image_equal(im, im2)
+        assert_image_equal_tofile(im, out)
 
     def test_compressions(self, tmp_path):
         # Test various tiff compressions and assert similar image content but reduced
@@ -443,8 +444,7 @@
         for compression in ("packbits", "tiff_lzw"):
             im.save(out, compression=compression)
             size_compressed = os.path.getsize(out)
-            with Image.open(out) as im2:
-                assert_image_equal(im, im2)
+            assert_image_equal_tofile(im, out)
 
         im.save(out, compression="jpeg")
         size_jpeg = os.path.getsize(out)
@@ -453,8 +453,7 @@
 
         im.save(out, compression="jpeg", quality=30)
         size_jpeg_30 = os.path.getsize(out)
-        with Image.open(out) as im3:
-            assert_image_similar(im2, im3, 30)
+        assert_image_similar_tofile(im2, out, 30)
 
         assert size_raw > size_compressed
         assert size_compressed > size_jpeg
@@ -467,6 +466,14 @@
 
         with Image.open(out) as reloaded:
             assert reloaded.info["compression"] == "jpeg"
+
+    def test_tiff_deflate_compression(self, tmp_path):
+        im = hopper("RGB")
+        out = str(tmp_path / "temp.tif")
+        im.save(out, compression="tiff_deflate")
+
+        with Image.open(out) as reloaded:
+            assert reloaded.info["compression"] == "tiff_adobe_deflate"
 
     def test_quality(self, tmp_path):
         im = hopper("RGB")
@@ -488,8 +495,7 @@
         out = str(tmp_path / "temp.tif")
 
         im.save(out, compression="tiff_adobe_deflate")
-        with Image.open(out) as im2:
-            assert_image_equal(im, im2)
+        assert_image_equal_tofile(im, out)
 
     def test_palette_save(self, tmp_path):
         im = hopper("P")
@@ -565,6 +571,17 @@
                 im.seek(0)
                 # Should not raise ValueError: I/O operation on closed file
                 im.load()
+
+        TiffImagePlugin.READ_LIBTIFF = False
+
+    def test_multipage_seek_backwards(self):
+        TiffImagePlugin.READ_LIBTIFF = True
+        with Image.open("Tests/images/multipage.tiff") as im:
+            im.seek(1)
+            im.load()
+
+            im.seek(0)
+            assert im.convert("RGB").getpixel((0, 0)) == (0, 128, 0)
 
         TiffImagePlugin.READ_LIBTIFF = False
 
@@ -639,8 +656,7 @@
             pilim.save(buffer_io, format="tiff", compression=compression)
             buffer_io.seek(0)
 
-            with Image.open(buffer_io) as pilim_load:
-                assert_image_similar(pilim, pilim_load, 0)
+            assert_image_similar_tofile(pilim, buffer_io, 0)
 
         save_bytesio()
         save_bytesio("raw")
@@ -649,6 +665,15 @@
 
         TiffImagePlugin.WRITE_LIBTIFF = False
         TiffImagePlugin.READ_LIBTIFF = False
+
+    def test_save_ycbcr(self, tmp_path):
+        im = hopper("YCbCr")
+        outfile = str(tmp_path / "temp.tif")
+        im.save(outfile, compression="jpeg")
+
+        with Image.open(outfile) as reloaded:
+            assert reloaded.tag_v2[530] == (1, 1)
+            assert reloaded.tag_v2[532] == (0, 255, 128, 255, 128, 255)
 
     def test_crashing_metadata(self, tmp_path):
         # issue 1597
@@ -796,6 +821,17 @@
 
             assert_image_equal_tofile(im, "Tests/images/copyleft.png", mode="RGB")
 
+    def test_sampleformat_write(self, tmp_path):
+        im = Image.new("F", (1, 1))
+        out = str(tmp_path / "temp.tif")
+        TiffImagePlugin.WRITE_LIBTIFF = True
+        im.save(out)
+        TiffImagePlugin.WRITE_LIBTIFF = False
+
+        with Image.open(out) as reloaded:
+            assert reloaded.mode == "F"
+            assert reloaded.getexif()[SAMPLEFORMAT] == 3
+
     def test_lzw(self):
         with Image.open("Tests/images/hopper_lzw.tif") as im:
             assert im.mode == "RGB"
@@ -814,13 +850,17 @@
         with Image.open(infile) as im:
             assert_image_similar_tofile(im, "Tests/images/pil_sample_cmyk.jpg", 0.5)
 
-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_strip_ycbcr_jpeg_2x2_sampling(self):
         infile = "Tests/images/tiff_strip_ycbcr_jpeg_2x2_sampling.tif"
         with Image.open(infile) as im:
             assert_image_similar_tofile(im, "Tests/images/flower.jpg", 0.5)
 
-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_strip_ycbcr_jpeg_1x1_sampling(self):
         infile = "Tests/images/tiff_strip_ycbcr_jpeg_1x1_sampling.tif"
         with Image.open(infile) as im:
@@ -831,22 +871,87 @@
         with Image.open(infile) as im:
             assert_image_similar_tofile(im, "Tests/images/pil_sample_cmyk.jpg", 0.5)
 
-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_tiled_ycbcr_jpeg_1x1_sampling(self):
         infile = "Tests/images/tiff_tiled_ycbcr_jpeg_1x1_sampling.tif"
         with Image.open(infile) as im:
             assert_image_equal_tofile(im, "Tests/images/flower2.jpg")
 
-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_tiled_ycbcr_jpeg_2x2_sampling(self):
         infile = "Tests/images/tiff_tiled_ycbcr_jpeg_2x2_sampling.tif"
         with Image.open(infile) as im:
             assert_image_similar_tofile(im, "Tests/images/flower.jpg", 0.5)
 
-    @pytest.mark.xfail(is_big_endian(), reason="Fails on big-endian")
+    def test_strip_planar_rgb(self):
+        # gdal_translate -co TILED=no -co INTERLEAVE=BAND -co COMPRESS=LZW \
+        # tiff_strip_raw.tif tiff_strip_planar_lzw.tiff
+        infile = "Tests/images/tiff_strip_planar_lzw.tiff"
+        with Image.open(infile) as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_adobe_deflate.png")
+
+    def test_tiled_planar_rgb(self):
+        # gdal_translate -co TILED=yes -co INTERLEAVE=BAND -co COMPRESS=LZW \
+        # tiff_tiled_raw.tif tiff_tiled_planar_lzw.tiff
+        infile = "Tests/images/tiff_tiled_planar_lzw.tiff"
+        with Image.open(infile) as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_adobe_deflate.png")
+
+    def test_tiled_planar_16bit_RGB(self):
+        # gdal_translate -co TILED=yes -co INTERLEAVE=BAND -co COMPRESS=LZW \
+        # tiff_16bit_RGB.tiff tiff_tiled_planar_16bit_RGB.tiff
+        with Image.open("Tests/images/tiff_tiled_planar_16bit_RGB.tiff") as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_16bit_RGB_target.png")
+
+    def test_strip_planar_16bit_RGB(self):
+        # gdal_translate -co TILED=no -co INTERLEAVE=BAND -co COMPRESS=LZW \
+        # tiff_16bit_RGB.tiff tiff_strip_planar_16bit_RGB.tiff
+        with Image.open("Tests/images/tiff_strip_planar_16bit_RGB.tiff") as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_16bit_RGB_target.png")
+
+    def test_tiled_planar_16bit_RGBa(self):
+        # gdal_translate -co TILED=yes \
+        # -co INTERLEAVE=BAND -co COMPRESS=LZW -co ALPHA=PREMULTIPLIED \
+        # tiff_16bit_RGBa.tiff tiff_tiled_planar_16bit_RGBa.tiff
+        with Image.open("Tests/images/tiff_tiled_planar_16bit_RGBa.tiff") as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_16bit_RGBa_target.png")
+
+    def test_strip_planar_16bit_RGBa(self):
+        # gdal_translate -co TILED=no \
+        # -co INTERLEAVE=BAND -co COMPRESS=LZW -co ALPHA=PREMULTIPLIED \
+        # tiff_16bit_RGBa.tiff tiff_strip_planar_16bit_RGBa.tiff
+        with Image.open("Tests/images/tiff_strip_planar_16bit_RGBa.tiff") as im:
+            assert_image_equal_tofile(im, "Tests/images/tiff_16bit_RGBa_target.png")
+
+    @pytest.mark.parametrize("compression", (None, "jpeg"))
+    def test_block_tile_tags(self, compression, tmp_path):
+        im = hopper()
+        out = str(tmp_path / "temp.tif")
+
+        tags = {
+            TiffImagePlugin.TILEWIDTH: 256,
+            TiffImagePlugin.TILELENGTH: 256,
+            TiffImagePlugin.TILEOFFSETS: 256,
+            TiffImagePlugin.TILEBYTECOUNTS: 256,
+        }
+        im.save(out, exif=tags, compression=compression)
+
+        with Image.open(out) as reloaded:
+            for tag in tags.keys():
+                assert tag not in reloaded.getexif()
+
     def test_old_style_jpeg(self):
-        infile = "Tests/images/old-style-jpeg-compression.tif"
-        with Image.open(infile) as im:
+        with Image.open("Tests/images/old-style-jpeg-compression.tif") as im:
+            assert_image_equal_tofile(im, "Tests/images/old-style-jpeg-compression.png")
+
+    def test_open_missing_samplesperpixel(self):
+        with Image.open(
+            "Tests/images/old-style-jpeg-compression-no-samplesperpixel.tif"
+        ) as im:
             assert_image_equal_tofile(im, "Tests/images/old-style-jpeg-compression.png")
 
     def test_no_rows_per_strip(self):
@@ -864,6 +969,7 @@
 
                     assert_image_similar(base_im, im, 0.7)
 
+    @pytest.mark.valgrind_known_error(reason="Backtrace in Python Core")
     def test_sampleformat_not_corrupted(self):
         # Assert that a TIFF image with SampleFormat=UINT tag is not corrupted
         # when saving to a new file.
@@ -894,3 +1000,34 @@
             # Assert that the error code is IMAGING_CODEC_MEMORY
             assert str(e.value) == "-9"
         TiffImagePlugin.READ_LIBTIFF = False
+
+    @pytest.mark.parametrize("compression", ("tiff_adobe_deflate", "jpeg"))
+    def test_save_multistrip(self, compression, tmp_path):
+        im = hopper("RGB").resize((256, 256))
+        out = str(tmp_path / "temp.tif")
+        im.save(out, compression=compression)
+
+        with Image.open(out) as im:
+            # Assert that there are multiple strips
+            assert len(im.tag_v2[STRIPOFFSETS]) > 1
+
+    def test_save_single_strip(self, tmp_path):
+        im = hopper("RGB").resize((256, 256))
+        out = str(tmp_path / "temp.tif")
+
+        TiffImagePlugin.STRIP_SIZE = 2**18
+        try:
+
+            im.save(out, compression="tiff_adobe_deflate")
+
+            with Image.open(out) as im:
+                assert len(im.tag_v2[STRIPOFFSETS]) == 1
+        finally:
+            TiffImagePlugin.STRIP_SIZE = 65536
+
+    @pytest.mark.parametrize("compression", ("tiff_adobe_deflate", None))
+    def test_save_zero(self, compression, tmp_path):
+        im = Image.new("RGB", (0, 0))
+        out = str(tmp_path / "temp.tif")
+        with pytest.raises(SystemError):
+            im.save(out, compression=compression)
('Tests', 'test_map.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -3,10 +3,6 @@
 import pytest
 
 from PIL import Image
-
-from .helper import is_win32
-
-pytestmark = pytest.mark.skipif(is_win32(), reason="Win32 does not call map_buffer")
 
 
 def test_overflow():
@@ -27,7 +23,20 @@
     Image.MAX_IMAGE_PIXELS = max_pixels
 
 
-@pytest.mark.skipif(sys.maxsize <= 2 ** 32, reason="Requires 64-bit system")
+def test_tobytes():
+    # Note that this image triggers the decompression bomb warning:
+    max_pixels = Image.MAX_IMAGE_PIXELS
+    Image.MAX_IMAGE_PIXELS = None
+
+    # Previously raised an access violation on Windows
+    with Image.open("Tests/images/l2rgb_read.bmp") as im:
+        with pytest.raises((ValueError, MemoryError, OSError)):
+            im.tobytes()
+
+    Image.MAX_IMAGE_PIXELS = max_pixels
+
+
+@pytest.mark.skipif(sys.maxsize <= 2**32, reason="Requires 64-bit system")
 def test_ysize():
     numpy = pytest.importorskip("numpy", reason="NumPy not installed")
 
('Tests', 'test_imageops.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,6 +5,7 @@
 from .helper import (
     assert_image_equal,
     assert_image_similar,
+    assert_image_similar_tofile,
     assert_tuple_approx_equal,
     hopper,
 )
@@ -28,12 +29,16 @@
     ImageOps.autocontrast(hopper("L"), cutoff=(2, 10))
     ImageOps.autocontrast(hopper("L"), ignore=[0, 255])
     ImageOps.autocontrast(hopper("L"), mask=hopper("L"))
+    ImageOps.autocontrast(hopper("L"), preserve_tone=True)
 
     ImageOps.colorize(hopper("L"), (0, 0, 0), (255, 255, 255))
     ImageOps.colorize(hopper("L"), "black", "white")
 
     ImageOps.pad(hopper("L"), (128, 128))
     ImageOps.pad(hopper("RGB"), (128, 128))
+
+    ImageOps.contain(hopper("L"), (128, 128))
+    ImageOps.contain(hopper("RGB"), (128, 128))
 
     ImageOps.crop(hopper("L"), 1)
     ImageOps.crop(hopper("RGB"), 1)
@@ -58,6 +63,7 @@
     ImageOps.grayscale(hopper("L"))
     ImageOps.grayscale(hopper("RGB"))
 
+    ImageOps.invert(hopper("1"))
     ImageOps.invert(hopper("L"))
     ImageOps.invert(hopper("RGB"))
 
@@ -97,6 +103,13 @@
         assert new_im.size == (1000, 755)
 
 
+@pytest.mark.parametrize("new_size", ((256, 256), (512, 256), (256, 512)))
+def test_contain(new_size):
+    im = hopper()
+    new_im = ImageOps.contain(im, new_size)
+    assert new_im.size == (256, 256)
+
+
 def test_pad():
     # Same ratio
     im = hopper()
@@ -112,10 +125,9 @@
             new_im = ImageOps.pad(im, new_size, color=color, centering=centering)
             assert new_im.size == new_size
 
-            with Image.open(
-                "Tests/images/imageops_pad_" + label + "_" + str(i) + ".jpg"
-            ) as target:
-                assert_image_similar(new_im, target, 6)
+            assert_image_similar_tofile(
+                new_im, "Tests/images/imageops_pad_" + label + "_" + str(i) + ".jpg", 6
+            )
 
 
 def test_pil163():
@@ -143,6 +155,33 @@
 
     newimg = ImageOps.scale(i, 0.5)
     assert newimg.size == (25, 25)
+
+
+@pytest.mark.parametrize("border", (10, (1, 2, 3, 4)))
+def test_expand_palette(border):
+    with Image.open("Tests/images/p_16.tga") as im:
+        im_expanded = ImageOps.expand(im, border, (255, 0, 0))
+
+        if isinstance(border, int):
+            left = top = right = bottom = border
+        else:
+            left, top, right, bottom = border
+        px = im_expanded.convert("RGB").load()
+        for x in range(im_expanded.width):
+            for b in range(top):
+                assert px[x, b] == (255, 0, 0)
+            for b in range(bottom):
+                assert px[x, im_expanded.height - 1 - b] == (255, 0, 0)
+        for y in range(im_expanded.height):
+            for b in range(left):
+                assert px[b, y] == (255, 0, 0)
+            for b in range(right):
+                assert px[im_expanded.width - 1 - b, y] == (255, 0, 0)
+
+        im_cropped = im_expanded.crop(
+            (left, top, im_expanded.width - right, im_expanded.height - bottom)
+        )
+        assert_image_equal(im_cropped, im)
 
 
 def test_colorize_2color():
@@ -291,6 +330,7 @@
                     else:
                         assert transposed_im.info["exif"] != original_exif
 
+                        assert 0x0112 in im.getexif()
                         assert 0x0112 not in transposed_im.getexif()
 
                     # Repeat the operation to test that it does not keep transposing
@@ -303,6 +343,28 @@
                     "Tests/images/hopper_orientation_" + str(i) + ext
                 ) as orientation_im:
                     check(orientation_im)
+
+    # Orientation from "XML:com.adobe.xmp" info key
+    with Image.open("Tests/images/xmp_tags_orientation.png") as im:
+        assert im.getexif()[0x0112] == 3
+
+        transposed_im = ImageOps.exif_transpose(im)
+        assert 0x0112 not in transposed_im.getexif()
+
+    # Orientation from "Raw profile type exif" info key
+    # This test image has been manually hexedited from exif_imagemagick.png
+    # to have a different orientation
+    with Image.open("Tests/images/exif_imagemagick_orientation.png") as im:
+        assert im.getexif()[0x0112] == 3
+
+        transposed_im = ImageOps.exif_transpose(im)
+        assert 0x0112 not in transposed_im.getexif()
+
+    # Orientation set directly on Image.Exif
+    im = hopper()
+    im.getexif()[0x0112] = 3
+    transposed_im = ImageOps.exif_transpose(im)
+    assert 0x0112 not in transposed_im.getexif()
 
 
 def test_autocontrast_cutoff():
@@ -336,7 +398,7 @@
         assert ImageStat.Stat(result_nomask).median == [128]
 
 
-def test_auto_contrast_mask_real_input():
+def test_autocontrast_mask_real_input():
     # Test the autocontrast with a rectangular mask
     with Image.open("Tests/images/iptc.jpg") as img:
 
@@ -362,3 +424,52 @@
             threshold=2,
             msg="autocontrast without mask pixel incorrect",
         )
+
+
+def test_autocontrast_preserve_tone():
+    def autocontrast(mode, preserve_tone):
+        im = hopper(mode)
+        return ImageOps.autocontrast(im, preserve_tone=preserve_tone).histogram()
+
+    assert autocontrast("RGB", True) != autocontrast("RGB", False)
+    assert autocontrast("L", True) == autocontrast("L", False)
+
+
+def test_autocontrast_preserve_gradient():
+    gradient = Image.linear_gradient("L")
+
+    # test with a grayscale gradient that extends to 0,255.
+    # Should be a noop.
+    out = ImageOps.autocontrast(gradient, cutoff=0, preserve_tone=True)
+
+    assert_image_equal(gradient, out)
+
+    # cutoff the top and bottom
+    # autocontrast should make the first and last histogram entries equal
+    # and, with rounding, should be 10% of the image pixels
+    out = ImageOps.autocontrast(gradient, cutoff=10, preserve_tone=True)
+    hist = out.histogram()
+    assert hist[0] == hist[-1]
+    assert hist[-1] == 256 * round(256 * 0.10)
+
+    # in rgb
+    img = gradient.convert("RGB")
+    out = ImageOps.autocontrast(img, cutoff=0, preserve_tone=True)
+    assert_image_equal(img, out)
+
+
+@pytest.mark.parametrize(
+    "color", ((255, 255, 255), (127, 255, 0), (127, 127, 127), (0, 0, 0))
+)
+def test_autocontrast_preserve_one_color(color):
+    img = Image.new("RGB", (10, 10), color)
+
+    # single color images shouldn't change
+    out = ImageOps.autocontrast(img, cutoff=0, preserve_tone=True)
+    assert_image_equal(img, out)  # single color, no cutoff
+
+    # even if there is a cutoff
+    out = ImageOps.autocontrast(
+        img, cutoff=10, preserve_tone=True
+    )  # single color 10 cutoff
+    assert_image_equal(img, out)
('Tests', 'test_image_putpalette.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@
 
 from PIL import Image, ImagePalette
 
-from .helper import assert_image_equal, hopper
+from .helper import assert_image_equal, assert_image_equal_tofile, hopper
 
 
 def test_putpalette():
@@ -36,9 +36,15 @@
 def test_imagepalette():
     im = hopper("P")
     im.putpalette(ImagePalette.negative())
+    assert_image_equal_tofile(im.convert("RGB"), "Tests/images/palette_negative.png")
+
     im.putpalette(ImagePalette.random())
+
     im.putpalette(ImagePalette.sepia())
+    assert_image_equal_tofile(im.convert("RGB"), "Tests/images/palette_sepia.png")
+
     im.putpalette(ImagePalette.wedge())
+    assert_image_equal_tofile(im.convert("RGB"), "Tests/images/palette_wedge.png")
 
 
 def test_putpalette_with_alpha_values():
@@ -56,3 +62,17 @@
         im.putpalette(palette_with_alpha_values, "RGBA")
 
         assert_image_equal(im.convert("RGBA"), expected)
+
+
+@pytest.mark.parametrize(
+    "mode, palette",
+    (
+        ("RGBA", (1, 2, 3, 4)),
+        ("RGBAX", (1, 2, 3, 4, 0)),
+    ),
+)
+def test_rgba_palette(mode, palette):
+    im = Image.new("P", (1, 1))
+    im.putpalette(palette, mode)
+    assert im.getpalette() == [1, 2, 3]
+    assert im.palette.colors == {(1, 2, 3, 4): 0}
('Tests', 'test_file_pdf.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -8,7 +8,7 @@
 
 from PIL import Image, PdfParser
 
-from .helper import hopper
+from .helper import hopper, mark_if_feature_version
 
 
 def helper_save_as_pdf(tmp_path, mode, **kwargs):
@@ -30,7 +30,7 @@
     with open(outfile, "rb") as fp:
         contents = fp.read()
     size = tuple(
-        int(d) for d in contents.split(b"/MediaBox [ 0 0 ")[1].split(b"]")[0].split()
+        float(d) for d in contents.split(b"/MediaBox [ 0 0 ")[1].split(b"]")[0].split()
     )
     assert im.size == size
 
@@ -42,7 +42,8 @@
     mode = "1"
 
     # Act / Assert
-    helper_save_as_pdf(tmp_path, mode)
+    outfile = helper_save_as_pdf(tmp_path, mode)
+    assert os.path.getsize(outfile) < 15000
 
 
 def test_greyscale(tmp_path):
@@ -85,6 +86,30 @@
         im.save(outfile)
 
 
+def test_resolution(tmp_path):
+    im = hopper()
+
+    outfile = str(tmp_path / "temp.pdf")
+    im.save(outfile, resolution=150)
+
+    with open(outfile, "rb") as fp:
+        contents = fp.read()
+
+    size = tuple(
+        float(d)
+        for d in contents.split(b"stream\nq ")[1].split(b" 0 0 cm")[0].split(b" 0 0 ")
+    )
+    assert size == (61.44, 61.44)
+
+    size = tuple(
+        float(d) for d in contents.split(b"/MediaBox [ 0 0 ")[1].split(b"]")[0].split()
+    )
+    assert size == (61.44, 61.44)
+
+
+@mark_if_feature_version(
+    pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+)
 def test_save_all(tmp_path):
     # Single frame image
     helper_save_as_pdf(tmp_path, "RGB", save_all=True)
@@ -285,3 +310,14 @@
     f = io.BytesIO(f.getvalue())
     im.save(f, format="PDF", append=True)
     assert len(f.getvalue()) > initial_size
+
+
+@pytest.mark.timeout(1)
+@pytest.mark.parametrize("newline", (b"\r", b"\n"))
+def test_redos(newline):
+    malicious = b" trailer<<>>" + newline * 3456
+
+    # This particular exception isn't relevant here.
+    # The important thing is it doesn't timeout, cause a ReDoS (CVE-2021-25292).
+    with pytest.raises(PdfParser.PdfFormatError):
+        PdfParser.PdfParser(buf=malicious)
('Tests', 'check_fli_oob.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 
 from PIL import Image
 
@@ -61,8 +61,8 @@
 
 
 for path in repro_ss2 + repro_lc + repro_advance + repro_brun + repro_copy:
-    im = Image.open(path)
-    try:
-        im.load()
-    except Exception as msg:
-        print(msg)
+    with Image.open(path) as im:
+        try:
+            im.load()
+        except Exception as msg:
+            print(msg)
('Tests', 'test_imagepath.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -70,8 +70,10 @@
     coords = ["a", "b"]
 
     # Act / Assert
-    with pytest.raises(SystemError):
+    with pytest.raises(ValueError) as e:
         ImagePath.Path(coords)
+
+    assert str(e.value) == "incorrect coordinate type"
 
 
 def test_path_odd_number_of_coordinates():
@@ -90,6 +92,8 @@
     [
         ([0, 1, 2, 3], (0.0, 1.0, 2.0, 3.0)),
         ([3, 2, 1, 0], (1.0, 0.0, 3.0, 2.0)),
+        (0, (0.0, 0.0, 0.0, 0.0)),
+        (1, (0.0, 0.0, 0.0, 0.0)),
     ],
 )
 def test_getbbox(coords, expected):
('Tests', 'test_file_mcidas.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,7 @@
 
 from PIL import Image, McIdasImagePlugin
 
-from .helper import assert_image_equal
+from .helper import assert_image_equal_tofile
 
 
 def test_invalid_file():
@@ -27,5 +27,4 @@
         assert im.format == "MCIDAS"
         assert im.mode == "I"
         assert im.size == (1800, 400)
-        with Image.open(saved_file) as im2:
-            assert_image_equal(im, im2)
+        assert_image_equal_tofile(im, saved_file)
('Tests', 'test_file_wal.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,15 +1,25 @@
 from PIL import WalImageFile
+
+from .helper import assert_image_equal_tofile
+
+TEST_FILE = "Tests/images/hopper.wal"
 
 
 def test_open():
-    # Arrange
-    TEST_FILE = "Tests/images/hopper.wal"
+    with WalImageFile.open(TEST_FILE) as im:
+        assert im.format == "WAL"
+        assert im.format_description == "Quake2 Texture"
+        assert im.mode == "P"
+        assert im.size == (128, 128)
 
-    # Act
-    im = WalImageFile.open(TEST_FILE)
+        assert isinstance(im, WalImageFile.WalImageFile)
 
-    # Assert
-    assert im.format == "WAL"
-    assert im.format_description == "Quake2 Texture"
-    assert im.mode == "P"
-    assert im.size == (128, 128)
+        assert_image_equal_tofile(im, "Tests/images/hopper_wal.png")
+
+
+def test_load():
+    with WalImageFile.open(TEST_FILE) as im:
+        assert im.load()[0, 0] == 122
+
+        # Test again now that it has already been loaded once
+        assert im.load()[0, 0] == 122
('Tests', 'test_image_convert.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -41,11 +41,15 @@
 def test_default():
 
     im = hopper("P")
-    assert_image(im, "P", im.size)
-    im = im.convert()
-    assert_image(im, "RGB", im.size)
-    im = im.convert()
-    assert_image(im, "RGB", im.size)
+    assert im.mode == "P"
+    converted_im = im.convert()
+    assert_image(converted_im, "RGB", im.size)
+    converted_im = im.convert()
+    assert_image(converted_im, "RGB", im.size)
+
+    im.info["transparency"] = 0
+    converted_im = im.convert()
+    assert_image(converted_im, "RGBA", im.size)
 
 
 # ref https://github.com/python-pillow/Pillow/issues/274
@@ -66,12 +70,24 @@
     with Image.open("Tests/images/16bit.cropped.tif") as im:
         _test_float_conversion(im)
 
+    for color in (65535, 65536):
+        im = Image.new("I", (1, 1), color)
+        im_i16 = im.convert("I;16")
+        assert im_i16.getpixel((0, 0)) == 65535
+
 
 def test_16bit_workaround():
     with Image.open("Tests/images/16bit.cropped.tif") as im:
         _test_float_conversion(im.convert("I"))
 
 
+def test_opaque():
+    alpha = hopper("P").convert("PA").getchannel("A")
+
+    solid = Image.new("L", (128, 128), 255)
+    assert_image_equal(alpha, solid)
+
+
 def test_rgba_p():
     im = hopper("RGBA")
     im.putalpha(hopper("L"))
@@ -89,29 +105,33 @@
     f = str(tmp_path / "temp.png")
 
     im_l = im.convert("L")
-    assert im_l.info["transparency"] == 0  # undone
+    assert im_l.info["transparency"] == 1  # undone
     im_l.save(f)
 
     im_rgb = im.convert("RGB")
-    assert im_rgb.info["transparency"] == (0, 0, 0)  # undone
+    assert im_rgb.info["transparency"] == (0, 1, 2)  # undone
     im_rgb.save(f)
 
 
 # ref https://github.com/python-pillow/Pillow/issues/664
 
 
-def test_trns_p_rgba():
+@pytest.mark.parametrize("mode", ("LA", "PA", "RGBA"))
+def test_trns_p_transparency(mode):
     # Arrange
     im = hopper("P")
     im.info["transparency"] = 128
 
     # Act
-    im_rgba = im.convert("RGBA")
+    converted_im = im.convert(mode)
 
     # Assert
-    assert "transparency" not in im_rgba.info
-    # https://github.com/python-pillow/Pillow/issues/2702
-    assert im_rgba.palette is None
+    assert "transparency" not in converted_im.info
+    if mode == "PA":
+        assert converted_im.palette is not None
+    else:
+        # https://github.com/python-pillow/Pillow/issues/2702
+        assert converted_im.palette is None
 
 
 def test_trns_l(tmp_path):
@@ -120,6 +140,10 @@
 
     f = str(tmp_path / "temp.png")
 
+    im_la = im.convert("LA")
+    assert "transparency" not in im_la.info
+    im_la.save(f)
+
     im_rgb = im.convert("RGB")
     assert im_rgb.info["transparency"] == (128, 128, 128)  # undone
     im_rgb.save(f)
@@ -128,8 +152,8 @@
     assert "transparency" in im_p.info
     im_p.save(f)
 
-    im_p = pytest.warns(UserWarning, im.convert, "P", palette=Image.ADAPTIVE)
-    assert "transparency" not in im_p.info
+    im_p = im.convert("P", palette=Image.Palette.ADAPTIVE)
+    assert "transparency" in im_p.info
     im_p.save(f)
 
 
@@ -151,9 +175,29 @@
     assert "transparency" not in im_rgba.info
     im_rgba.save(f)
 
-    im_p = pytest.warns(UserWarning, im.convert, "P", palette=Image.ADAPTIVE)
+    im_p = pytest.warns(UserWarning, im.convert, "P", palette=Image.Palette.ADAPTIVE)
     assert "transparency" not in im_p.info
     im_p.save(f)
+
+    im = Image.new("RGB", (1, 1))
+    im.info["transparency"] = im.getpixel((0, 0))
+    im_p = im.convert("P", palette=Image.Palette.ADAPTIVE)
+    assert im_p.info["transparency"] == im_p.getpixel((0, 0))
+    im_p.save(f)
+
+
+@pytest.mark.parametrize("convert_mode", ("L", "LA", "I"))
+def test_l_macro_rounding(convert_mode):
+    for mode in ("P", "PA"):
+        im = Image.new(mode, (1, 1))
+        im.palette.getcolor((0, 1, 2))
+
+        converted_im = im.convert(convert_mode)
+        px = converted_im.load()
+        converted_color = px[0, 0]
+        if convert_mode == "LA":
+            converted_color = converted_color[0]
+        assert converted_color == 1
 
 
 def test_gif_with_rgba_palette_to_p():
@@ -161,7 +205,7 @@
     with Image.open("Tests/images/hopper.gif") as im:
         im.info["transparency"] = 255
         im.load()
-        assert im.palette.mode == "RGBA"
+        assert im.palette.mode == "RGB"
         im_p = im.convert("P")
 
     # Should not raise ValueError: unrecognized raw mode
('Tests', 'test_image_reduce.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -97,7 +97,7 @@
         bands = [gradients_image]
         for _ in mode_info.bands[1:]:
             # rotate previous image
-            band = bands[-1].transpose(Image.ROTATE_90)
+            band = bands[-1].transpose(Image.Transpose.ROTATE_90)
             bands.append(band)
         # Correct alpha channel by transforming completely transparent pixels.
         # Low alpha values also emphasize error after alpha multiplication.
@@ -138,24 +138,26 @@
     reference = Image.new(im.mode, reduced.size)
     area_size = (im.size[0] // factor[0], im.size[1] // factor[1])
     area_box = (0, 0, area_size[0] * factor[0], area_size[1] * factor[1])
-    area = im.resize(area_size, Image.BOX, area_box)
+    area = im.resize(area_size, Image.Resampling.BOX, area_box)
     reference.paste(area, (0, 0))
 
     if area_size[0] < reduced.size[0]:
         assert reduced.size[0] - area_size[0] == 1
         last_column_box = (area_box[2], 0, im.size[0], area_box[3])
-        last_column = im.resize((1, area_size[1]), Image.BOX, last_column_box)
+        last_column = im.resize(
+            (1, area_size[1]), Image.Resampling.BOX, last_column_box
+        )
         reference.paste(last_column, (area_size[0], 0))
 
     if area_size[1] < reduced.size[1]:
         assert reduced.size[1] - area_size[1] == 1
         last_row_box = (0, area_box[3], area_box[2], im.size[1])
-        last_row = im.resize((area_size[0], 1), Image.BOX, last_row_box)
+        last_row = im.resize((area_size[0], 1), Image.Resampling.BOX, last_row_box)
         reference.paste(last_row, (0, area_size[1]))
 
     if area_size[0] < reduced.size[0] and area_size[1] < reduced.size[1]:
         last_pixel_box = (area_box[2], area_box[3], im.size[0], im.size[1])
-        last_pixel = im.resize((1, 1), Image.BOX, last_pixel_box)
+        last_pixel = im.resize((1, 1), Image.Resampling.BOX, last_pixel_box)
         reference.paste(last_pixel, area_size)
 
     assert_compare_images(reduced, reference, average_diff, max_diff)
('Tests', 'test_psdraw.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,6 +1,8 @@
 import os
 import sys
-from io import StringIO
+from io import BytesIO
+
+import pytest
 
 from PIL import Image, PSDraw
 
@@ -44,10 +46,21 @@
     assert os.path.getsize(tempfile) > 0
 
 
-def test_stdout():
+@pytest.mark.parametrize("buffer", (True, False))
+def test_stdout(buffer):
     # Temporarily redirect stdout
     old_stdout = sys.stdout
-    sys.stdout = mystdout = StringIO()
+
+    if buffer:
+
+        class MyStdOut:
+            buffer = BytesIO()
+
+        mystdout = MyStdOut()
+    else:
+        mystdout = BytesIO()
+
+    sys.stdout = mystdout
 
     ps = PSDraw.PSDraw()
     _create_document(ps)
@@ -55,4 +68,6 @@
     # Reset stdout
     sys.stdout = old_stdout
 
-    assert mystdout.getvalue() != ""
+    if buffer:
+        mystdout = mystdout.buffer
+    assert mystdout.getvalue() != b""
('Tests', 'test_sgi_crash.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,3 @@
-#!/usr/bin/env python
 import pytest
 
 from PIL import Image
@@ -11,10 +10,17 @@
         "Tests/images/sgi_crash.bin",
         "Tests/images/crash-6b7f2244da6d0ae297ee0754a424213444e92778.sgi",
         "Tests/images/ossfuzz-5730089102868480.sgi",
+        "Tests/images/crash-754d9c7ec485ffb76a90eeaab191ef69a2a3a3cd.sgi",
+        "Tests/images/crash-465703f71a0f0094873a3e0e82c9f798161171b8.sgi",
+        "Tests/images/crash-64834657ee604b8797bf99eac6a194c124a9a8ba.sgi",
+        "Tests/images/crash-abcf1c97b8fe42a6c68f1fb0b978530c98d57ced.sgi",
+        "Tests/images/crash-b82e64d4f3f76d7465b6af535283029eda211259.sgi",
+        "Tests/images/crash-c1b2595b8b0b92cc5f38b6635e98e3a119ade807.sgi",
+        "Tests/images/crash-db8bfa78b19721225425530c5946217720d7df4e.sgi",
     ],
 )
 def test_crashes(test_file):
     with open(test_file, "rb") as f:
-        im = Image.open(f)
-        with pytest.raises(OSError):
-            im.load()
+        with Image.open(f) as im:
+            with pytest.raises(OSError):
+                im.load()
('Tests', 'check_j2k_dos.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,4 +5,7 @@
 
 from PIL import Image
 
-Image.open(BytesIO(b"\x00\x00\x00\x0cjP\x20\x20\x0d\x0a\x87\x0a\x00\x00\x00\x00hang"))
+with Image.open(
+    BytesIO(b"\x00\x00\x00\x0cjP\x20\x20\x0d\x0a\x87\x0a\x00\x00\x00\x00hang")
+):
+    pass
('Tests', 'test_imagedraw.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,6 +6,7 @@
 
 from .helper import (
     assert_image_equal,
+    assert_image_equal_tofile,
     assert_image_similar_tofile,
     hopper,
     skip_unless_feature,
@@ -96,7 +97,7 @@
     draw.arc(BBOX1, start=start, end=end)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_arc_end_le_start.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_arc_end_le_start.png")
 
 
 def test_arc_no_loops():
@@ -174,7 +175,7 @@
     draw.arc([110, 10, 189, 189], 20, 150, width=20, fill="white")
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_arc_high.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_arc_high.png")
 
 
 def test_bitmap():
@@ -182,13 +183,13 @@
     im = Image.new("RGB", (W, H))
     draw = ImageDraw.Draw(im)
     with Image.open("Tests/images/pil123rgba.png") as small:
-        small = small.resize((50, 50), Image.NEAREST)
+        small = small.resize((50, 50), Image.Resampling.NEAREST)
 
         # Act
         draw.bitmap((10, 10), small)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_bitmap.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_bitmap.png")
 
 
 def helper_chord(mode, bbox, start, end):
@@ -247,8 +248,7 @@
     draw.chord(BBOX1, 10, 260, fill="red", outline="yellow", width=0)
 
     # Assert
-    with Image.open("Tests/images/imagedraw_chord_zero_width.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_chord_zero_width.png")
 
 
 def test_chord_too_fat():
@@ -260,7 +260,7 @@
     draw.chord([-150, -150, 99, 99], 15, 60, width=10, fill="white", outline="red")
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_chord_too_fat.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_chord_too_fat.png")
 
 
 def helper_ellipse(mode, bbox):
@@ -319,7 +319,7 @@
         im = Image.new("RGB", (width, 100))
         draw = ImageDraw.Draw(im)
         draw.ellipse(bbox, fill="green", outline="blue")
-        assert_image_equal(im, im.transpose(Image.FLIP_LEFT_RIGHT))
+        assert_image_equal(im, im.transpose(Image.Transpose.FLIP_LEFT_RIGHT))
 
 
 def test_ellipse_width():
@@ -367,8 +367,7 @@
     draw.ellipse(BBOX1, fill="green", outline="blue", width=0)
 
     # Assert
-    with Image.open("Tests/images/imagedraw_ellipse_zero_width.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_ellipse_zero_width.png")
 
 
 def ellipse_various_sizes_helper(filled):
@@ -395,17 +394,15 @@
 def test_ellipse_various_sizes():
     im = ellipse_various_sizes_helper(False)
 
-    with Image.open("Tests/images/imagedraw_ellipse_various_sizes.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_ellipse_various_sizes.png")
 
 
 def test_ellipse_various_sizes_filled():
     im = ellipse_various_sizes_helper(True)
 
-    with Image.open(
-        "Tests/images/imagedraw_ellipse_various_sizes_filled.png"
-    ) as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(
+        im, "Tests/images/imagedraw_ellipse_various_sizes_filled.png"
+    )
 
 
 def helper_line(points):
@@ -417,7 +414,7 @@
     draw.line(points, fill="yellow", width=2)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_line.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_line.png")
 
 
 def test_line1():
@@ -446,7 +443,7 @@
     draw.shape(s, fill=1)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_shape1.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_shape1.png")
 
 
 def test_shape2():
@@ -467,7 +464,24 @@
     draw.shape(s, outline="blue")
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_shape2.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_shape2.png")
+
+
+def test_transform():
+    # Arrange
+    im = Image.new("RGB", (100, 100), "white")
+    expected = im.copy()
+    draw = ImageDraw.Draw(im)
+
+    # Act
+    s = ImageDraw.Outline()
+    s.line(0, 0)
+    s.transform((0, 0, 0, 0, 0, 0))
+
+    draw.shape(s, fill=1)
+
+    # Assert
+    assert_image_equal(im, expected)
 
 
 def helper_pieslice(bbox, start, end):
@@ -526,8 +540,7 @@
     draw.pieslice(BBOX1, 10, 260, fill="white", outline="blue", width=0)
 
     # Assert
-    with Image.open("Tests/images/imagedraw_pieslice_zero_width.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_pieslice_zero_width.png")
 
 
 def test_pieslice_wide():
@@ -539,7 +552,37 @@
     draw.pieslice([0, 0, 199, 99], 190, 170, width=10, fill="white", outline="red")
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_pieslice_wide.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_pieslice_wide.png")
+
+
+def test_pieslice_no_spikes():
+    im = Image.new("RGB", (161, 161), "white")
+    draw = ImageDraw.Draw(im)
+    cxs = (
+        [140] * 3
+        + list(range(140, 19, -20))
+        + [20] * 5
+        + list(range(20, 141, 20))
+        + [140] * 2
+    )
+    cys = (
+        list(range(80, 141, 20))
+        + [140] * 5
+        + list(range(140, 19, -20))
+        + [20] * 5
+        + list(range(20, 80, 20))
+    )
+
+    for cx, cy, angle in zip(cxs, cys, range(0, 360, 15)):
+        draw.pieslice(
+            [cx - 100, cy - 100, cx + 100, cy + 100], angle, angle + 1, fill="black"
+        )
+        draw.point([cx, cy], fill="red")
+
+    im_pre_erase = im.copy()
+    draw.rectangle([21, 21, 139, 139], fill="white")
+
+    assert_image_equal(im, im_pre_erase)
 
 
 def helper_point(points):
@@ -551,7 +594,7 @@
     draw.point(points, fill="yellow")
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_point.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_point.png")
 
 
 def test_point1():
@@ -571,7 +614,7 @@
     draw.polygon(points, fill="red", outline="blue")
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_polygon.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_polygon.png")
 
 
 def test_polygon1():
@@ -595,7 +638,7 @@
         draw.polygon(KITE_POINTS, fill="blue", outline="yellow")
 
         # Assert
-        assert_image_equal(im, Image.open(expected))
+        assert_image_equal_tofile(im, expected)
 
 
 def test_polygon_1px_high():
@@ -609,7 +652,20 @@
     draw.polygon([(0, 1), (0, 1), (2, 1), (2, 1)], "#f00")
 
     # Assert
-    assert_image_equal(im, Image.open(expected))
+    assert_image_equal_tofile(im, expected)
+
+
+def test_polygon_translucent():
+    # Arrange
+    im = Image.new("RGB", (W, H))
+    draw = ImageDraw.Draw(im, "RGBA")
+
+    # Act
+    draw.polygon([(20, 80), (80, 80), (80, 20)], fill=(0, 255, 0, 127))
+
+    # Assert
+    expected = "Tests/images/imagedraw_polygon_translucent.png"
+    assert_image_equal_tofile(im, expected)
 
 
 def helper_rectangle(bbox):
@@ -621,7 +677,7 @@
     draw.rectangle(bbox, fill="black", outline="green")
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_rectangle.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rectangle.png")
 
 
 def test_rectangle1():
@@ -656,7 +712,7 @@
     draw.rectangle(BBOX1, outline="green", width=5)
 
     # Assert
-    assert_image_equal(im, Image.open(expected))
+    assert_image_equal_tofile(im, expected)
 
 
 def test_rectangle_width_fill():
@@ -669,7 +725,7 @@
     draw.rectangle(BBOX1, fill="blue", outline="green", width=5)
 
     # Assert
-    assert_image_equal(im, Image.open(expected))
+    assert_image_equal_tofile(im, expected)
 
 
 def test_rectangle_zero_width():
@@ -681,8 +737,7 @@
     draw.rectangle(BBOX1, fill="blue", outline="green", width=0)
 
     # Assert
-    with Image.open("Tests/images/imagedraw_rectangle_zero_width.png") as expected:
-        assert_image_equal(im, expected)
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rectangle_zero_width.png")
 
 
 def test_rectangle_I16():
@@ -694,8 +749,95 @@
     draw.rectangle(BBOX1, fill="black", outline="green")
 
     # Assert
-    assert_image_equal(
-        im.convert("I"), Image.open("Tests/images/imagedraw_rectangle_I.png")
+    assert_image_equal_tofile(im.convert("I"), "Tests/images/imagedraw_rectangle_I.png")
+
+
+def test_rectangle_translucent_outline():
+    # Arrange
+    im = Image.new("RGB", (W, H))
+    draw = ImageDraw.Draw(im, "RGBA")
+
+    # Act
+    draw.rectangle(BBOX1, fill="black", outline=(0, 255, 0, 127), width=5)
+
+    # Assert
+    assert_image_equal_tofile(
+        im, "Tests/images/imagedraw_rectangle_translucent_outline.png"
+    )
+
+
+@pytest.mark.parametrize(
+    "xy",
+    [(10, 20, 190, 180), ([10, 20], [190, 180]), ((10, 20), (190, 180))],
+)
+def test_rounded_rectangle(xy):
+    # Arrange
+    im = Image.new("RGB", (200, 200))
+    draw = ImageDraw.Draw(im)
+
+    # Act
+    draw.rounded_rectangle(xy, 30, fill="red", outline="green", width=5)
+
+    # Assert
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rounded_rectangle.png")
+
+
+@pytest.mark.parametrize(
+    "xy, radius, type",
+    [
+        ((10, 20, 190, 180), 30.5, "given"),
+        ((10, 10, 181, 190), 90, "width"),
+        ((10, 20, 190, 181), 85, "height"),
+    ],
+)
+def test_rounded_rectangle_non_integer_radius(xy, radius, type):
+    # Arrange
+    im = Image.new("RGB", (200, 200))
+    draw = ImageDraw.Draw(im)
+
+    # Act
+    draw.rounded_rectangle(xy, radius, fill="red", outline="green", width=5)
+
+    # Assert
+    assert_image_equal_tofile(
+        im,
+        "Tests/images/imagedraw_rounded_rectangle_non_integer_radius_" + type + ".png",
+    )
+
+
+def test_rounded_rectangle_zero_radius():
+    # Arrange
+    im = Image.new("RGB", (W, H))
+    draw = ImageDraw.Draw(im)
+
+    # Act
+    draw.rounded_rectangle(BBOX1, 0, fill="blue", outline="green", width=5)
+
+    # Assert
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_rectangle_width_fill.png")
+
+
+@pytest.mark.parametrize(
+    "xy, suffix",
+    [
+        ((20, 10, 80, 90), "x"),
+        ((10, 20, 90, 80), "y"),
+        ((20, 20, 80, 80), "both"),
+    ],
+)
+def test_rounded_rectangle_translucent(xy, suffix):
+    # Arrange
+    im = Image.new("RGB", (W, H))
+    draw = ImageDraw.Draw(im, "RGBA")
+
+    # Act
+    draw.rounded_rectangle(
+        xy, 30, fill=(255, 0, 0, 127), outline=(0, 255, 0, 127), width=5
+    )
+
+    # Assert
+    assert_image_equal_tofile(
+        im, "Tests/images/imagedraw_rounded_rectangle_" + suffix + ".png"
     )
 
 
@@ -749,7 +891,7 @@
     )
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_floodfill2.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_floodfill2.png")
 
 
 def test_floodfill_thresh():
@@ -765,7 +907,7 @@
     ImageDraw.floodfill(im, centre_point, ImageColor.getrgb("red"), thresh=30)
 
     # Assert
-    assert_image_equal(im, Image.open("Tests/images/imagedraw_floodfill2.png"))
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_floodfill2.png")
 
 
 def test_floodfill_not_negative():
@@ -782,9 +924,7 @@
     ImageDraw.floodfill(im, (int(W / 4), int(H / 4)), ImageColor.getrgb("red"))
 
     # Assert
-    assert_image_equal(
-        im, Image.open("Tests/images/imagedraw_floodfill_not_negative.png")
-    )
+    assert_image_equal_tofile(im, "Tests/images/imagedraw_floodfill_not_negative.png")
 
 
 def create_base_image_draw(
@@ -799,147 +939,156 @@
 
 
 def test_square():
-    with Image.open(os.path.join(IMAGES_PATH, "square.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((10, 10))
-        draw.polygon([(2, 2), (2, 7), (7, 7), (7, 2)], BLACK)
-        assert_image_equal(img, expected, "square as normal polygon failed")
-        img, draw = create_base_image_draw((10, 10))
-        draw.polygon([(7, 7), (7, 2), (2, 2), (2, 7)], BLACK)
-        assert_image_equal(img, expected, "square as inverted polygon failed")
-        img, draw = create_base_image_draw((10, 10))
-        draw.rectangle((2, 2, 7, 7), BLACK)
-        assert_image_equal(img, expected, "square as normal rectangle failed")
-        img, draw = create_base_image_draw((10, 10))
-        draw.rectangle((7, 7, 2, 2), BLACK)
-        assert_image_equal(img, expected, "square as inverted rectangle failed")
+    expected = os.path.join(IMAGES_PATH, "square.png")
+    img, draw = create_base_image_draw((10, 10))
+    draw.polygon([(2, 2), (2, 7), (7, 7), (7, 2)], BLACK)
+    assert_image_equal_tofile(img, expected, "square as normal polygon failed")
+    img, draw = create_base_image_draw((10, 10))
+    draw.polygon([(7, 7), (7, 2), (2, 2), (2, 7)], BLACK)
+    assert_image_equal_tofile(img, expected, "square as inverted polygon failed")
+    img, draw = create_base_image_draw((10, 10))
+    draw.rectangle((2, 2, 7, 7), BLACK)
+    assert_image_equal_tofile(img, expected, "square as normal rectangle failed")
+    img, draw = create_base_image_draw((10, 10))
+    draw.rectangle((7, 7, 2, 2), BLACK)
+    assert_image_equal_tofile(img, expected, "square as inverted rectangle failed")
 
 
 def test_triangle_right():
-    with Image.open(os.path.join(IMAGES_PATH, "triangle_right.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.polygon([(3, 5), (17, 5), (10, 12)], BLACK)
-        assert_image_equal(img, expected, "triangle right failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.polygon([(3, 5), (17, 5), (10, 12)], BLACK)
+    assert_image_equal_tofile(
+        img, os.path.join(IMAGES_PATH, "triangle_right.png"), "triangle right failed"
+    )
+
+
+@pytest.mark.parametrize(
+    "fill, suffix",
+    ((BLACK, "width"), (None, "width_no_fill")),
+)
+def test_triangle_right_width(fill, suffix):
+    img, draw = create_base_image_draw((100, 100))
+    draw.polygon([(15, 25), (85, 25), (50, 60)], fill, WHITE, width=5)
+    assert_image_equal_tofile(
+        img, os.path.join(IMAGES_PATH, "triangle_right_" + suffix + ".png")
+    )
 
 
 def test_line_horizontal():
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_horizontal_w2px_normal.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 14, 5), BLACK, 2)
-        assert_image_equal(
-            img, expected, "line straight horizontal normal 2px wide failed"
-        )
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_horizontal_w2px_inverted.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((14, 5, 5, 5), BLACK, 2)
-        assert_image_equal(
-            img, expected, "line straight horizontal inverted 2px wide failed"
-        )
-    with Image.open(os.path.join(IMAGES_PATH, "line_horizontal_w3px.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 14, 5), BLACK, 3)
-        assert_image_equal(
-            img, expected, "line straight horizontal normal 3px wide failed"
-        )
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((14, 5, 5, 5), BLACK, 3)
-        assert_image_equal(
-            img, expected, "line straight horizontal inverted 3px wide failed"
-        )
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_horizontal_w101px.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((200, 110))
-        draw.line((5, 55, 195, 55), BLACK, 101)
-        assert_image_equal(img, expected, "line straight horizontal 101px wide failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 14, 5), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_horizontal_w2px_normal.png"),
+        "line straight horizontal normal 2px wide failed",
+    )
+
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((14, 5, 5, 5), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_horizontal_w2px_inverted.png"),
+        "line straight horizontal inverted 2px wide failed",
+    )
+
+    expected = os.path.join(IMAGES_PATH, "line_horizontal_w3px.png")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 14, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line straight horizontal normal 3px wide failed"
+    )
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((14, 5, 5, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line straight horizontal inverted 3px wide failed"
+    )
+
+    img, draw = create_base_image_draw((200, 110))
+    draw.line((5, 55, 195, 55), BLACK, 101)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_horizontal_w101px.png"),
+        "line straight horizontal 101px wide failed",
+    )
 
 
 def test_line_h_s1_w2():
     pytest.skip("failing")
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_horizontal_slope1px_w2px.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 14, 6), BLACK, 2)
-        assert_image_equal(img, expected, "line horizontal 1px slope 2px wide failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 14, 6), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_horizontal_slope1px_w2px.png"),
+        "line horizontal 1px slope 2px wide failed",
+    )
 
 
 def test_line_vertical():
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_vertical_w2px_normal.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 5, 14), BLACK, 2)
-        assert_image_equal(
-            img, expected, "line straight vertical normal 2px wide failed"
-        )
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_vertical_w2px_inverted.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 14, 5, 5), BLACK, 2)
-        assert_image_equal(
-            img, expected, "line straight vertical inverted 2px wide failed"
-        )
-    with Image.open(os.path.join(IMAGES_PATH, "line_vertical_w3px.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 5, 14), BLACK, 3)
-        assert_image_equal(
-            img, expected, "line straight vertical normal 3px wide failed"
-        )
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 14, 5, 5), BLACK, 3)
-        assert_image_equal(
-            img, expected, "line straight vertical inverted 3px wide failed"
-        )
-    with Image.open(os.path.join(IMAGES_PATH, "line_vertical_w101px.png")) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((110, 200))
-        draw.line((55, 5, 55, 195), BLACK, 101)
-        assert_image_equal(img, expected, "line straight vertical 101px wide failed")
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_vertical_slope1px_w2px.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 6, 14), BLACK, 2)
-        assert_image_equal(img, expected, "line vertical 1px slope 2px wide failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 5, 14), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_vertical_w2px_normal.png"),
+        "line straight vertical normal 2px wide failed",
+    )
+
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 14, 5, 5), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_vertical_w2px_inverted.png"),
+        "line straight vertical inverted 2px wide failed",
+    )
+
+    expected = os.path.join(IMAGES_PATH, "line_vertical_w3px.png")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 5, 14), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line straight vertical normal 3px wide failed"
+    )
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 14, 5, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line straight vertical inverted 3px wide failed"
+    )
+
+    img, draw = create_base_image_draw((110, 200))
+    draw.line((55, 5, 55, 195), BLACK, 101)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_vertical_w101px.png"),
+        "line straight vertical 101px wide failed",
+    )
+
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 6, 14), BLACK, 2)
+    assert_image_equal_tofile(
+        img,
+        os.path.join(IMAGES_PATH, "line_vertical_slope1px_w2px.png"),
+        "line vertical 1px slope 2px wide failed",
+    )
 
 
 def test_line_oblique_45():
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_oblique_45_w3px_a.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 5, 14, 14), BLACK, 3)
-        assert_image_equal(img, expected, "line oblique 45 normal 3px wide A failed")
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((14, 14, 5, 5), BLACK, 3)
-        assert_image_equal(img, expected, "line oblique 45 inverted 3px wide A failed")
-    with Image.open(
-        os.path.join(IMAGES_PATH, "line_oblique_45_w3px_b.png")
-    ) as expected:
-        expected.load()
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((14, 5, 5, 14), BLACK, 3)
-        assert_image_equal(img, expected, "line oblique 45 normal 3px wide B failed")
-        img, draw = create_base_image_draw((20, 20))
-        draw.line((5, 14, 14, 5), BLACK, 3)
-        assert_image_equal(img, expected, "line oblique 45 inverted 3px wide B failed")
+    expected = os.path.join(IMAGES_PATH, "line_oblique_45_w3px_a.png")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 5, 14, 14), BLACK, 3)
+    assert_image_equal_tofile(img, expected, "line oblique 45 normal 3px wide A failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((14, 14, 5, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line oblique 45 inverted 3px wide A failed"
+    )
+
+    expected = os.path.join(IMAGES_PATH, "line_oblique_45_w3px_b.png")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((14, 5, 5, 14), BLACK, 3)
+    assert_image_equal_tofile(img, expected, "line oblique 45 normal 3px wide B failed")
+    img, draw = create_base_image_draw((20, 20))
+    draw.line((5, 14, 14, 5), BLACK, 3)
+    assert_image_equal_tofile(
+        img, expected, "line oblique 45 inverted 3px wide B failed"
+    )
 
 
 def test_wide_line_dot():
@@ -1185,7 +1334,7 @@
     draw = ImageDraw.Draw(im)
     bounding_circle = ((W // 2, H // 2), 25)
     draw.regular_polygon(bounding_circle, n_sides, rotation=rotation, fill="red")
-    assert_image_equal(im, Image.open(filename))
+    assert_image_equal_tofile(im, filename)
 
 
 @pytest.mark.parametrize(
@@ -1272,3 +1421,34 @@
     with pytest.raises(expected_error) as e:
         ImageDraw._compute_regular_polygon_vertices(bounding_circle, n_sides, rotation)
     assert str(e.value) == error_message
+
+
+def test_continuous_horizontal_edges_polygon():
+    xy = [
+        (2, 6),
+        (6, 6),
+        (12, 6),
+        (12, 12),
+        (8, 12),
+        (8, 8),
+        (4, 8),
+        (2, 8),
+    ]
+    img, draw = create_base_image_draw((16, 16))
+    draw.polygon(xy, BLACK)
+    expected = os.path.join(IMAGES_PATH, "continuous_horizontal_edges_polygon.png")
+    assert_image_equal_tofile(
+        img, expected, "continuous horizontal edges polygon failed"
+    )
+
+
+def test_discontiguous_corners_polygon():
+    img, draw = create_base_image_draw((84, 68))
+    draw.polygon(((1, 21), (34, 4), (71, 1), (38, 18)), BLACK)
+    draw.polygon(((71, 44), (38, 27), (1, 24)), BLACK)
+    draw.polygon(
+        ((38, 66), (5, 49), (77, 49), (47, 66), (82, 63), (82, 47), (1, 47), (1, 63)),
+        BLACK,
+    )
+    expected = os.path.join(IMAGES_PATH, "discontiguous_corners_polygon.png")
+    assert_image_similar_tofile(img, expected, 1)
('Tests', 'test_lib_pack.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -320,6 +320,23 @@
         self.assert_unpack("RGB", "G", 1, (0, 1, 0), (0, 2, 0), (0, 3, 0))
         self.assert_unpack("RGB", "B", 1, (0, 0, 1), (0, 0, 2), (0, 0, 3))
 
+        self.assert_unpack("RGB", "R;16B", 2, (1, 0, 0), (3, 0, 0), (5, 0, 0))
+        self.assert_unpack("RGB", "G;16B", 2, (0, 1, 0), (0, 3, 0), (0, 5, 0))
+        self.assert_unpack("RGB", "B;16B", 2, (0, 0, 1), (0, 0, 3), (0, 0, 5))
+
+        self.assert_unpack("RGB", "R;16L", 2, (2, 0, 0), (4, 0, 0), (6, 0, 0))
+        self.assert_unpack("RGB", "G;16L", 2, (0, 2, 0), (0, 4, 0), (0, 6, 0))
+        self.assert_unpack("RGB", "B;16L", 2, (0, 0, 2), (0, 0, 4), (0, 0, 6))
+
+        if sys.byteorder == "little":
+            self.assert_unpack("RGB", "R;16N", 2, (2, 0, 0), (4, 0, 0), (6, 0, 0))
+            self.assert_unpack("RGB", "G;16N", 2, (0, 2, 0), (0, 4, 0), (0, 6, 0))
+            self.assert_unpack("RGB", "B;16N", 2, (0, 0, 2), (0, 0, 4), (0, 0, 6))
+        else:
+            self.assert_unpack("RGB", "R;16N", 2, (1, 0, 0), (3, 0, 0), (5, 0, 0))
+            self.assert_unpack("RGB", "G;16N", 2, (0, 1, 0), (0, 3, 0), (0, 5, 0))
+            self.assert_unpack("RGB", "B;16N", 2, (0, 0, 1), (0, 0, 3), (0, 0, 5))
+
     def test_RGBA(self):
         self.assert_unpack("RGBA", "LA", 2, (1, 1, 1, 2), (3, 3, 3, 4), (5, 5, 5, 6))
         self.assert_unpack(
@@ -449,6 +466,43 @@
         self.assert_unpack("RGBA", "G", 1, (0, 1, 0, 0), (0, 2, 0, 0), (0, 3, 0, 0))
         self.assert_unpack("RGBA", "B", 1, (0, 0, 1, 0), (0, 0, 2, 0), (0, 0, 3, 0))
         self.assert_unpack("RGBA", "A", 1, (0, 0, 0, 1), (0, 0, 0, 2), (0, 0, 0, 3))
+
+        self.assert_unpack("RGBA", "R;16B", 2, (1, 0, 0, 0), (3, 0, 0, 0), (5, 0, 0, 0))
+        self.assert_unpack("RGBA", "G;16B", 2, (0, 1, 0, 0), (0, 3, 0, 0), (0, 5, 0, 0))
+        self.assert_unpack("RGBA", "B;16B", 2, (0, 0, 1, 0), (0, 0, 3, 0), (0, 0, 5, 0))
+        self.assert_unpack("RGBA", "A;16B", 2, (0, 0, 0, 1), (0, 0, 0, 3), (0, 0, 0, 5))
+
+        self.assert_unpack("RGBA", "R;16L", 2, (2, 0, 0, 0), (4, 0, 0, 0), (6, 0, 0, 0))
+        self.assert_unpack("RGBA", "G;16L", 2, (0, 2, 0, 0), (0, 4, 0, 0), (0, 6, 0, 0))
+        self.assert_unpack("RGBA", "B;16L", 2, (0, 0, 2, 0), (0, 0, 4, 0), (0, 0, 6, 0))
+        self.assert_unpack("RGBA", "A;16L", 2, (0, 0, 0, 2), (0, 0, 0, 4), (0, 0, 0, 6))
+
+        if sys.byteorder == "little":
+            self.assert_unpack(
+                "RGBA", "R;16N", 2, (2, 0, 0, 0), (4, 0, 0, 0), (6, 0, 0, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "G;16N", 2, (0, 2, 0, 0), (0, 4, 0, 0), (0, 6, 0, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "B;16N", 2, (0, 0, 2, 0), (0, 0, 4, 0), (0, 0, 6, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "A;16N", 2, (0, 0, 0, 2), (0, 0, 0, 4), (0, 0, 0, 6)
+            )
+        else:
+            self.assert_unpack(
+                "RGBA", "R;16N", 2, (1, 0, 0, 0), (3, 0, 0, 0), (5, 0, 0, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "G;16N", 2, (0, 1, 0, 0), (0, 3, 0, 0), (0, 5, 0, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "B;16N", 2, (0, 0, 1, 0), (0, 0, 3, 0), (0, 0, 5, 0)
+            )
+            self.assert_unpack(
+                "RGBA", "A;16N", 2, (0, 0, 0, 1), (0, 0, 0, 3), (0, 0, 0, 5)
+            )
 
     def test_RGBa(self):
         self.assert_unpack(
('Tests', 'test_image_getdata.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,7 +14,7 @@
 
 def test_roundtrip():
     def getdata(mode):
-        im = hopper(mode).resize((32, 30), Image.NEAREST)
+        im = hopper(mode).resize((32, 30), Image.Resampling.NEAREST)
         data = im.getdata()
         return data[0], len(data), len(list(data))
 
('Tests', 'test_numpy.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+import warnings
+
 import pytest
 
 from PIL import Image
@@ -31,7 +33,7 @@
         return i
 
     # Check supported 1-bit integer formats
-    assert_image(to_image(numpy.bool, 1, 1), "1", TEST_IMAGE_SIZE)
+    assert_image(to_image(bool, 1, 1), "1", TEST_IMAGE_SIZE)
     assert_image(to_image(numpy.bool8, 1, 1), "1", TEST_IMAGE_SIZE)
 
     # Check supported 8-bit integer formats
@@ -65,7 +67,7 @@
         to_image(numpy.int64)
 
     # Check floating-point formats
-    assert_image(to_image(numpy.float), "F", TEST_IMAGE_SIZE)
+    assert_image(to_image(float), "F", TEST_IMAGE_SIZE)
     with pytest.raises(TypeError):
         to_image(numpy.float16)
     assert_image(to_image(numpy.float32), "F", TEST_IMAGE_SIZE)
@@ -189,9 +191,10 @@
     assert len(im.getdata()) == len(arr)
 
 
-def test_roundtrip_eye():
-    for dtype in (
-        numpy.bool,
+@pytest.mark.parametrize(
+    "dtype",
+    (
+        bool,
         numpy.bool8,
         numpy.int8,
         numpy.int16,
@@ -199,12 +202,14 @@
         numpy.uint8,
         numpy.uint16,
         numpy.uint32,
-        numpy.float,
+        float,
         numpy.float32,
         numpy.float64,
-    ):
-        arr = numpy.eye(10, dtype=dtype)
-        numpy.testing.assert_array_equal(arr, numpy.array(Image.fromarray(arr)))
+    ),
+)
+def test_roundtrip_eye(dtype):
+    arr = numpy.eye(10, dtype=dtype)
+    numpy.testing.assert_array_equal(arr, numpy.array(Image.fromarray(arr)))
 
 
 def test_zero_size():
@@ -218,7 +223,7 @@
 
 def test_bool():
     # https://github.com/python-pillow/Pillow/issues/2044
-    a = numpy.zeros((10, 2), dtype=numpy.bool)
+    a = numpy.zeros((10, 2), dtype=bool)
     a[0][0] = True
 
     im2 = Image.fromarray(a)
@@ -234,4 +239,5 @@
     with Image.open(test_file) as im:
 
         # Act/Assert
-        pytest.warns(None, lambda: array(im))
+        with warnings.catch_warnings():
+            array(im)
('Tests', 'test_file_tar.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,5 @@
+import warnings
+
 import pytest
 
 from PIL import Image, TarIO, features
@@ -31,16 +33,12 @@
 
 
 def test_close():
-    def open():
+    with warnings.catch_warnings():
         tar = TarIO.TarIO(TEST_TAR_FILE, "hopper.jpg")
         tar.close()
 
-    pytest.warns(None, open)
-
 
 def test_contextmanager():
-    def open():
+    with warnings.catch_warnings():
         with TarIO.TarIO(TEST_TAR_FILE, "hopper.jpg"):
             pass
-
-    pytest.warns(None, open)
('Tests', 'check_jp2_overflow.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 
 # Reproductions/tests for OOB read errors in FliDecode.c
 
@@ -19,8 +19,8 @@
 repro = ("00r0_gray_l.jp2", "00r1_graya_la.jp2")
 
 for path in repro:
-    im = Image.open(path)
-    try:
-        im.load()
-    except Exception as msg:
-        print(msg)
+    with Image.open(path) as im:
+        try:
+            im.load()
+        except Exception as msg:
+            print(msg)
('Tests', 'check_imaging_leaks.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 import pytest
 
 from PIL import Image
('Tests', 'test_file_fpx.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,4 +21,5 @@
 
 def test_fpx_invalid_number_of_bands():
     with pytest.raises(OSError, match="Invalid number of bands"):
-        Image.open("Tests/images/input_bw_five_bands.fpx")
+        with Image.open("Tests/images/input_bw_five_bands.fpx"):
+            pass
('Tests', 'test_imagemath.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,9 +1,11 @@
+import pytest
+
 from PIL import Image, ImageMath
 
 
 def pixel(im):
     if hasattr(im, "im"):
-        return "{} {}".format(im.mode, repr(im.getpixel((0, 0))))
+        return f"{im.mode} {repr(im.getpixel((0, 0)))}"
     else:
         if isinstance(im, int):
             return int(im)  # hack to deal with booleans
@@ -50,6 +52,19 @@
     assert pixel(ImageMath.eval("float(B)**33", images)) == "F 8589934592.0"
 
 
+@pytest.mark.parametrize(
+    "expression",
+    (
+        "exec('pass')",
+        "(lambda: exec('pass'))()",
+        "(lambda: (lambda: exec('pass'))())()",
+    ),
+)
+def test_prevent_exec(expression):
+    with pytest.raises(ValueError):
+        ImageMath.eval(expression)
+
+
 def test_logical():
     assert pixel(ImageMath.eval("not A", images)) == 0
     assert pixel(ImageMath.eval("A and B", images)) == "L 2"
('Tests', 'test_file_gif.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,4 @@
+import warnings
 from io import BytesIO
 
 import pytest
@@ -6,6 +7,7 @@
 
 from .helper import (
     assert_image_equal,
+    assert_image_equal_tofile,
     assert_image_similar,
     hopper,
     is_pypy,
@@ -38,27 +40,68 @@
 
 
 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(TEST_GIF)
         im.load()
         im.close()
 
-    pytest.warns(None, open)
-
 
 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(TEST_GIF) as im:
             im.load()
 
-    pytest.warns(None, open)
-
 
 def test_invalid_file():
     invalid_file = "Tests/images/flower.jpg"
 
     with pytest.raises(SyntaxError):
         GifImagePlugin.GifImageFile(invalid_file)
+
+
+def test_l_mode_transparency():
+    with Image.open("Tests/images/no_palette_with_transparency.gif") as im:
+        assert im.mode == "L"
+        assert im.load()[0, 0] == 128
+        assert im.info["transparency"] == 255
+
+        im.seek(1)
+        assert im.mode == "L"
+        assert im.load()[0, 0] == 128
+
+
+def test_strategy():
+    with Image.open("Tests/images/chi.gif") as im:
+        expected_zero = im.convert("RGB")
+
+        im.seek(1)
+        expected_one = im.convert("RGB")
+
+    try:
+        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_ALWAYS
+        with Image.open("Tests/images/chi.gif") as im:
+            assert im.mode == "RGB"
+            assert_image_equal(im, expected_zero)
+
+        GifImagePlugin.LOADING_STRATEGY = (
+            GifImagePlugin.LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY
+        )
+        # Stay in P mode with only a global palette
+        with Image.open("Tests/images/chi.gif") as im:
+            assert im.mode == "P"
+
+            im.seek(1)
+            assert im.mode == "P"
+            assert_image_equal(im.convert("RGB"), expected_one)
+
+        # Change to RGB mode when a frame has an individual palette
+        with Image.open("Tests/images/iss634.gif") as im:
+            assert im.mode == "P"
+
+            im.seek(1)
+            assert im.mode == "RGB"
+    finally:
+        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST
 
 
 def test_optimize():
@@ -162,6 +205,32 @@
         assert reread.n_frames == 5
 
 
+@pytest.mark.parametrize(
+    "path, mode",
+    (
+        ("Tests/images/dispose_bgnd.gif", "RGB"),
+        # Hexeditted copy of dispose_bgnd to add transparency
+        ("Tests/images/dispose_bgnd_rgba.gif", "RGBA"),
+    ),
+)
+def test_loading_multiple_palettes(path, mode):
+    with Image.open(path) as im:
+        assert im.mode == "P"
+        first_frame_colors = im.palette.colors.keys()
+        original_color = im.convert("RGB").load()[0, 0]
+
+        im.seek(1)
+        assert im.mode == mode
+        if mode == "RGBA":
+            im = im.convert("RGB")
+
+        # Check a color only from the old palette
+        assert im.load()[0, 0] == original_color
+
+        # Check a color from the new palette
+        assert im.load()[24, 24] not in first_frame_colors
+
+
 def test_headers_saving_for_animated_gifs(tmp_path):
     important_headers = ["background", "version", "duration", "loop"]
     # Multiframe image
@@ -183,8 +252,8 @@
     with Image.open(TEST_GIF) as im:
         im = im.convert("RGB")
 
-        im = im.resize((100, 100), Image.LANCZOS)
-        im2 = im.convert("P", palette=Image.ADAPTIVE, colors=256)
+        im = im.resize((100, 100), Image.Resampling.LANCZOS)
+        im2 = im.convert("P", palette=Image.Palette.ADAPTIVE, colors=256)
 
         f = str(tmp_path / "temp.gif")
         im2.save(f, optimize=True)
@@ -284,6 +353,22 @@
             assert im.is_animated == (n_frames != 1)
 
 
+def test_no_change():
+    # Test n_frames does not change the image
+    with Image.open("Tests/images/dispose_bgnd.gif") as im:
+        im.seek(1)
+        expected = im.copy()
+        assert im.n_frames == 5
+        assert_image_equal(im, expected)
+
+    # Test is_animated does not change the image
+    with Image.open("Tests/images/dispose_bgnd.gif") as im:
+        im.seek(3)
+        expected = im.copy()
+        assert im.is_animated
+        assert_image_equal(im, expected)
+
+
 def test_eoferror():
     with Image.open(TEST_GIF) as im:
         n_frames = im.n_frames
@@ -295,6 +380,12 @@
 
         # Test that seeking to the last frame does not raise an error
         im.seek(n_frames - 1)
+
+
+def test_first_frame_transparency():
+    with Image.open("Tests/images/first_frame_transparency.gif") as im:
+        px = im.load()
+        assert px[0, 0] == im.info["transparency"]
 
 
 def test_dispose_none():
@@ -317,8 +408,7 @@
     with Image.open("Tests/images/dispose_none_load_end.gif") as img:
         img.seek(1)
 
-        with Image.open("Tests/images/dispose_none_load_end_second.gif") as expected:
-            assert_image_equal(img, expected)
+        assert_image_equal_tofile(img, "Tests/images/dispose_none_load_end_second.png")
 
 
 def test_dispose_background():
@@ -331,6 +421,47 @@
             pass
 
 
+def test_dispose_background_transparency():
+    with Image.open("Tests/images/dispose_bgnd_transparency.gif") as img:
+        img.seek(2)
+        px = img.load()
+        assert px[35, 30][3] == 0
+
+
+@pytest.mark.parametrize(
+    "loading_strategy, expected_colors",
+    (
+        (
+            GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST,
+            (
+                (2, 1, 2),
+                ((0, 255, 24, 255), (0, 0, 255, 255), (0, 255, 24, 255)),
+                ((0, 0, 0, 0), (0, 0, 255, 255), (0, 0, 0, 0)),
+            ),
+        ),
+        (
+            GifImagePlugin.LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY,
+            (
+                (2, 1, 2),
+                (0, 1, 0),
+                (2, 1, 2),
+            ),
+        ),
+    ),
+)
+def test_transparent_dispose(loading_strategy, expected_colors):
+    GifImagePlugin.LOADING_STRATEGY = loading_strategy
+    try:
+        with Image.open("Tests/images/transparent_dispose.gif") as img:
+            for frame in range(3):
+                img.seek(frame)
+                for x in range(3):
+                    color = img.getpixel((x, 0))
+                    assert color == expected_colors[frame][x]
+    finally:
+        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST
+
+
 def test_dispose_previous():
     with Image.open("Tests/images/dispose_prev.gif") as img:
         try:
@@ -339,6 +470,25 @@
                 assert img.disposal_method == 3
         except EOFError:
             pass
+
+
+def test_dispose_previous_first_frame():
+    with Image.open("Tests/images/dispose_prev_first_frame.gif") as im:
+        im.seek(1)
+        assert_image_equal_tofile(
+            im, "Tests/images/dispose_prev_first_frame_seeked.png"
+        )
+
+
+def test_previous_frame_loaded():
+    with Image.open("Tests/images/dispose_none.gif") as img:
+        img.load()
+        img.seek(1)
+        img.load()
+        img.seek(2)
+        with Image.open("Tests/images/dispose_none.gif") as img_skipped:
+            img_skipped.seek(2)
+            assert_image_equal(img_skipped, img)
 
 
 def test_save_dispose(tmp_path):
@@ -373,14 +523,15 @@
 def test_dispose2_palette(tmp_path):
     out = str(tmp_path / "temp.gif")
 
-    # 4 backgrounds: White, Grey, Black, Red
+    # Four colors: white, grey, black, red
     circles = [(255, 255, 255), (153, 153, 153), (0, 0, 0), (255, 0, 0)]
 
     im_list = []
     for circle in circles:
+        # Red background
         img = Image.new("RGB", (100, 100), (255, 0, 0))
 
-        # Red circle in center of each frame
+        # Circle in center of each frame
         d = ImageDraw.Draw(img)
         d.ellipse([(40, 40), (60, 60)], fill=circle)
 
@@ -465,15 +616,28 @@
 
     with Image.open(out) as im:
         im.seek(1)
-        assert im.getpixel((0, 0)) == 0
-
-
-def test_iss634():
+        assert im.getpixel((0, 0)) == (255, 0, 0)
+
+
+def test_transparency_in_second_frame():
+    with Image.open("Tests/images/different_transparency.gif") as im:
+        assert im.info["transparency"] == 0
+
+        # Seek to the second frame
+        im.seek(im.tell() + 1)
+        assert "transparency" not in im.info
+
+        assert_image_equal_tofile(im, "Tests/images/different_transparency_merged.png")
+
+
+def test_no_transparency_in_second_frame():
     with Image.open("Tests/images/iss634.gif") as img:
         # Seek to the second frame
         img.seek(img.tell() + 1)
+        assert "transparency" not in img.info
+
         # All transparent pixels should be replaced with the color from the first frame
-        assert img.histogram()[img.info["transparency"]] == 0
+        assert img.histogram()[255] == 0
 
 
 def test_duration(tmp_path):
@@ -629,8 +793,7 @@
 
 def test_zero_comment_subblocks():
     with Image.open("Tests/images/hopper_zero_comment_subblocks.gif") as im:
-        with Image.open(TEST_GIF) as expected:
-            assert_image_equal(im, expected)
+        assert_image_equal_tofile(im, TEST_GIF)
 
 
 def test_version(tmp_path):
@@ -718,10 +881,10 @@
     # Single frame
     im = Image.new("RGB", (1, 1))
     im.info["transparency"] = (255, 0, 0)
-    pytest.warns(UserWarning, im.save, out)
+    im.save(out)
 
     with Image.open(out) as reloaded:
-        assert "transparency" not in reloaded.info
+        assert "transparency" in reloaded.info
 
     # Multiple frames
     im = Image.new("RGB", (1, 1))
@@ -733,6 +896,17 @@
         assert "transparency" not in reloaded.info
 
 
+def test_rgba_transparency(tmp_path):
+    out = str(tmp_path / "temp.gif")
+
+    im = hopper("P")
+    im.save(out, save_all=True, append_images=[Image.new("RGBA", im.size)])
+
+    with Image.open(out) as reloaded:
+        reloaded.seek(1)
+        assert_image_equal(hopper("P").convert("RGB"), reloaded)
+
+
 def test_bbox(tmp_path):
     out = str(tmp_path / "temp.gif")
 
@@ -763,7 +937,7 @@
     # Forcing a non-straight grayscale palette.
 
     im = hopper("P")
-    palette = bytes([255 - i // 3 for i in range(768)])
+    palette = bytes(255 - i // 3 for i in range(768))
 
     out = str(tmp_path / "temp.gif")
     im.save(out, palette=palette)
@@ -773,6 +947,29 @@
         assert_image_equal(reloaded, im)
 
 
+def test_palette_save_all_P(tmp_path):
+    frames = []
+    colors = ((255, 0, 0), (0, 255, 0))
+    for color in colors:
+        frame = Image.new("P", (100, 100))
+        frame.putpalette(color)
+        frames.append(frame)
+
+    out = str(tmp_path / "temp.gif")
+    frames[0].save(
+        out, save_all=True, palette=[255, 0, 0, 0, 255, 0], append_images=frames[1:]
+    )
+
+    with Image.open(out) as im:
+        # Assert that the frames are correct, and each frame has the same palette
+        assert_image_equal(im.convert("RGB"), frames[0].convert("RGB"))
+        assert im.palette.palette == im.global_palette.palette
+
+        im.seek(1)
+        assert_image_equal(im.convert("RGB"), frames[1].convert("RGB"))
+        assert im.palette.palette == im.global_palette.palette
+
+
 def test_palette_save_ImagePalette(tmp_path):
     # Pass in a different palette, as an ImagePalette.ImagePalette
     # effectively the same as test_palette_save_P
@@ -785,7 +982,7 @@
 
     with Image.open(out) as reloaded:
         im.putpalette(palette)
-        assert_image_equal(reloaded, im)
+        assert_image_equal(reloaded.convert("RGB"), im.convert("RGB"))
 
 
 def test_save_I(tmp_path):
@@ -803,11 +1000,11 @@
 def test_getdata():
     # Test getheader/getdata against legacy values.
     # Create a 'P' image with holes in the palette.
-    im = Image._wedge().resize((16, 16), Image.NEAREST)
+    im = Image._wedge().resize((16, 16), Image.Resampling.NEAREST)
     im.putpalette(ImagePalette.ImagePalette("RGB"))
     im.info = {"background": 0}
 
-    passed_palette = bytes([255 - i // 3 for i in range(768)])
+    passed_palette = bytes(255 - i // 3 for i in range(768))
 
     GifImagePlugin._FORCE_OPTIMIZE = True
     try:
@@ -839,5 +1036,28 @@
 def test_extents():
     with Image.open("Tests/images/test_extents.gif") as im:
         assert im.size == (100, 100)
+
+        # Check that n_frames does not change the size
+        assert im.n_frames == 2
+        assert im.size == (100, 100)
+
         im.seek(1)
         assert im.size == (150, 150)
+
+
+def test_missing_background():
+    # The Global Color Table Flag isn't set, so there is no background color index,
+    # but the disposal method is "Restore to background color"
+    with Image.open("Tests/images/missing_background.gif") as im:
+        im.seek(1)
+        assert_image_equal_tofile(im, "Tests/images/missing_background_first_frame.png")
+
+
+def test_saving_rgba(tmp_path):
+    out = str(tmp_path / "temp.gif")
+    with Image.open("Tests/images/transparent.png") as im:
+        im.save(out)
+
+    with Image.open(out) as reloaded:
+        reloaded_rgba = reloaded.convert("RGBA")
+        assert reloaded_rgba.load()[0, 0][3] == 0
('Tests', 'test_file_webp_alpha.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -2,7 +2,12 @@
 
 from PIL import Image
 
-from .helper import assert_image_equal, assert_image_similar, hopper
+from .helper import (
+    assert_image_equal,
+    assert_image_similar,
+    assert_image_similar_tofile,
+    hopper,
+)
 
 _webp = pytest.importorskip("PIL._webp", reason="WebP support not installed")
 
@@ -29,8 +34,7 @@
 
         image.tobytes()
 
-        with Image.open("Tests/images/transparent.png") as target:
-            assert_image_similar(image, target, 20.0)
+        assert_image_similar_tofile(image, "Tests/images/transparent.png", 20.0)
 
 
 def test_write_lossless_rgb(tmp_path):
('Tests', 'test_imagecolor.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -191,3 +191,12 @@
     assert (255, 255) == ImageColor.getcolor("white", "LA")
     assert (163, 33) == ImageColor.getcolor("rgba(0, 255, 115, 33)", "LA")
     Image.new("LA", (1, 1), "white")
+
+
+def test_color_too_long():
+    # Arrange
+    color_too_long = "hsl(" + "1" * 40 + "," + "1" * 40 + "%," + "1" * 40 + "%)"
+
+    # Act / Assert
+    with pytest.raises(ValueError):
+        ImageColor.getrgb(color_too_long)
('Tests', 'test_file_bufrstub.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -45,3 +45,35 @@
     # Act / Assert: stub cannot save without an implemented handler
     with pytest.raises(OSError):
         im.save(tmpfile)
+
+
+def test_handler(tmp_path):
+    class TestHandler:
+        opened = False
+        loaded = False
+        saved = False
+
+        def open(self, im):
+            self.opened = True
+
+        def load(self, im):
+            self.loaded = True
+            return Image.new("RGB", (1, 1))
+
+        def save(self, im, fp, filename):
+            self.saved = True
+
+    handler = TestHandler()
+    BufrStubImagePlugin.register_handler(handler)
+    with Image.open(TEST_FILE) as im:
+        assert handler.opened
+        assert not handler.loaded
+
+        im.load()
+        assert handler.loaded
+
+        temp_file = str(tmp_path / "temp.bufr")
+        im.save(temp_file)
+        assert handler.saved
+
+    BufrStubImagePlugin._handler = None
('Tests', 'check_icns_dos.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -5,4 +5,5 @@
 
 from PIL import Image
 
-Image.open(BytesIO(b"icns\x00\x00\x00\x10hang\x00\x00\x00\x00"))
+with Image.open(BytesIO(b"icns\x00\x00\x00\x10hang\x00\x00\x00\x00")):
+    pass
('Tests', 'test_file_mpo.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,3 +1,4 @@
+import warnings
 from io import BytesIO
 
 import pytest
@@ -41,20 +42,16 @@
 
 
 def test_closed_file():
-    def open():
+    with warnings.catch_warnings():
         im = Image.open(test_files[0])
         im.load()
         im.close()
 
-    pytest.warns(None, open)
-
 
 def test_context_manager():
-    def open():
+    with warnings.catch_warnings():
         with Image.open(test_files[0]) as im:
             im.load()
-
-    pytest.warns(None, open)
 
 
 def test_app():
@@ -88,6 +85,23 @@
         im.seek(1)
         assert im.size == (680, 480)
 
+        im.seek(0)
+        assert im.size == (640, 480)
+
+
+def test_ignore_frame_size():
+    # Ignore the different size of the second frame
+    # since this is not a "Large Thumbnail" image
+    with Image.open("Tests/images/ignore_frame_size.mpo") as im:
+        assert im.size == (64, 64)
+
+        im.seek(1)
+        assert (
+            im.mpinfo[0xB002][1]["Attribute"]["MPType"]
+            == "Multi-Frame Image: (Disparity)"
+        )
+        assert im.size == (64, 64)
+
 
 def test_parallax():
     # Nintendo
@@ -132,7 +146,7 @@
         with Image.open(test_file) as im:
             mpinfo = im._getmp()
         frameNumber = 0
-        for mpentry in mpinfo[45058]:
+        for mpentry in mpinfo[0xB002]:
             mpattr = mpentry["Attribute"]
             if frameNumber:
                 assert not mpattr["RepresentativeImageFlag"]
('Tests', 'test_pdfparser.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -115,6 +115,6 @@
     assert pdf_repr(True) == b"true"
     assert pdf_repr(False) == b"false"
     assert pdf_repr(None) == b"null"
-    assert pdf_repr(b"a)/b\\(c") == br"(a\)/b\\\(c)"
+    assert pdf_repr(b"a)/b\\(c") == rb"(a\)/b\\\(c)"
     assert pdf_repr([123, True, {"a": PdfName(b"b")}]) == b"[ 123 true <<\n/a /b\n>> ]"
     assert pdf_repr(PdfBinary(b"\x90\x1F\xA0")) == b"<901FA0>"
('Tests', 'test_imagefontctl.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,16 +1,11 @@
 import pytest
-from packaging.version import parse as parse_version
-
-from PIL import Image, ImageDraw, ImageFont, features
-
-from .helper import (
-    assert_image_similar,
-    skip_unless_feature,
-    skip_unless_feature_version,
-)
+
+from PIL import Image, ImageDraw, ImageFont
+
+from .helper import assert_image_similar_tofile, skip_unless_feature
 
 FONT_SIZE = 20
-FONT_PATH = "Tests/fonts/DejaVuSans.ttf"
+FONT_PATH = "Tests/fonts/DejaVuSans/DejaVuSans.ttf"
 
 pytestmark = skip_unless_feature("raqm")
 
@@ -31,8 +26,7 @@
     draw.text((0, 0), "اهلا عمان", font=ttf, fill=500)
 
     target = "Tests/images/test_text.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
 
 def test_y_offset():
@@ -43,8 +37,7 @@
     draw.text((0, 0), "العالم العربي", font=ttf, fill=500)
 
     target = "Tests/images/test_y_offset.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 1.7)
+    assert_image_similar_tofile(im, target, 1.7)
 
 
 def test_complex_unicode_text():
@@ -55,8 +48,7 @@
     draw.text((0, 0), "السلام عليكم", font=ttf, fill=500)
 
     target = "Tests/images/test_complex_unicode_text.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
     ttf = ImageFont.truetype("Tests/fonts/KhmerOSBattambang-Regular.ttf", FONT_SIZE)
 
@@ -65,8 +57,7 @@
     draw.text((0, 0), "លោកុប្បត្តិ", font=ttf, fill=500)
 
     target = "Tests/images/test_complex_unicode_text2.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 2.33)
+    assert_image_similar_tofile(im, target, 2.33)
 
 
 def test_text_direction_rtl():
@@ -77,8 +68,7 @@
     draw.text((0, 0), "English عربي", font=ttf, fill=500, direction="rtl")
 
     target = "Tests/images/test_direction_rtl.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
 
 def test_text_direction_ltr():
@@ -89,8 +79,7 @@
     draw.text((0, 0), "سلطنة عمان Oman", font=ttf, fill=500, direction="ltr")
 
     target = "Tests/images/test_direction_ltr.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
 
 def test_text_direction_rtl2():
@@ -101,8 +90,7 @@
     draw.text((0, 0), "Oman سلطنة عمان", font=ttf, fill=500, direction="rtl")
 
     target = "Tests/images/test_direction_ltr.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
 
 def test_text_direction_ttb():
@@ -117,8 +105,7 @@
             pytest.skip("libraqm 0.7 or greater not available")
 
     target = "Tests/images/test_direction_ttb.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 2.8)
+    assert_image_similar_tofile(im, target, 2.8)
 
 
 def test_text_direction_ttb_stroke():
@@ -141,8 +128,7 @@
             pytest.skip("libraqm 0.7 or greater not available")
 
     target = "Tests/images/test_direction_ttb_stroke.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 19.4)
+    assert_image_similar_tofile(im, target, 19.4)
 
 
 def test_ligature_features():
@@ -152,8 +138,7 @@
     draw = ImageDraw.Draw(im)
     draw.text((0, 0), "filling", font=ttf, fill=500, features=["-liga"])
     target = "Tests/images/test_ligature_features.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
     liga_size = ttf.getsize("fi", features=["-liga"])
     assert liga_size == (13, 19)
@@ -167,8 +152,7 @@
     draw.text((0, 0), "TeToAV", font=ttf, fill=500, features=["-kern"])
 
     target = "Tests/images/test_kerning_features.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
 
 def test_arabictext_features():
@@ -185,8 +169,7 @@
     )
 
     target = "Tests/images/test_arabictext_features.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
 
 def test_x_max_and_y_offset():
@@ -197,8 +180,7 @@
     draw.text((0, 0), "لح", font=ttf, fill=500)
 
     target = "Tests/images/test_x_max_and_y_offset.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
 
 def test_language():
@@ -209,8 +191,7 @@
     draw.text((0, 0), "абвг", font=ttf, fill=500, language="sr")
 
     target = "Tests/images/test_language.png"
-    with Image.open(target) as target_img:
-        assert_image_similar(im, target_img, 0.5)
+    assert_image_similar_tofile(im, target, 0.5)
 
 
 @pytest.mark.parametrize("mode", ("L", "1"))
@@ -266,11 +247,6 @@
             pytest.skip("libraqm 0.7 or greater not available")
 
 
-# FreeType 2.5.1 README: Miscellaneous Changes:
-# Improved computation of emulated vertical metrics for TrueType fonts.
-@skip_unless_feature_version(
-    "freetype2", "2.5.1", "FreeType <2.5.1 has incompatible ttb metrics"
-)
 @pytest.mark.parametrize("anchor", ("lt", "mm", "rb", "sm"))
 def test_anchor_ttb(anchor):
     text = "f"
@@ -287,8 +263,7 @@
         if str(ex) == "libraqm 0.7 or greater required for 'ttb' direction":
             pytest.skip("libraqm 0.7 or greater not available")
 
-    with Image.open(path) as expected:
-        assert_image_similar(im, expected, 1)  # fails at 5
+    assert_image_similar_tofile(im, path, 1)  # fails at 5
 
 
 combine_tests = (
@@ -330,14 +305,6 @@
     "name, text, anchor, dir, epsilon", combine_tests, ids=[r[0] for r in combine_tests]
 )
 def test_combine(name, text, dir, anchor, epsilon):
-    if (
-        parse_version(features.version_module("freetype2")) < parse_version("2.5.1")
-        and dir == "ttb"
-    ):
-        # FreeType 2.5.1 README: Miscellaneous Changes:
-        # Improved computation of emulated vertical metrics for TrueType fonts.
-        pytest.skip("FreeType <2.5.1 has incompatible ttb metrics")
-
     path = f"Tests/images/test_combine_{name}.png"
     f = ImageFont.truetype("Tests/fonts/NotoSans-Regular.ttf", 48)
 
@@ -351,8 +318,7 @@
         if str(ex) == "libraqm 0.7 or greater required for 'ttb' direction":
             pytest.skip("libraqm 0.7 or greater not available")
 
-    with Image.open(path) as expected:
-        assert_image_similar(im, expected, epsilon)
+    assert_image_similar_tofile(im, path, epsilon)
 
 
 @pytest.mark.parametrize(
@@ -384,8 +350,7 @@
     d.rectangle(bbox, outline="red")
     d.multiline_text((200, 200), text, fill="black", anchor=anchor, font=f, align=align)
 
-    with Image.open(path) as expected:
-        assert_image_similar(im, expected, 0.015)
+    assert_image_similar_tofile(im, path, 0.015)
 
 
 def test_anchor_invalid_ttb():
('Tests', 'test_file_hdf5stub.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -46,3 +46,35 @@
             im.save(dummy_filename)
         with pytest.raises(OSError):
             Hdf5StubImagePlugin._save(im, dummy_fp, dummy_filename)
+
+
+def test_handler(tmp_path):
+    class TestHandler:
+        opened = False
+        loaded = False
+        saved = False
+
+        def open(self, im):
+            self.opened = True
+
+        def load(self, im):
+            self.loaded = True
+            return Image.new("RGB", (1, 1))
+
+        def save(self, im, fp, filename):
+            self.saved = True
+
+    handler = TestHandler()
+    Hdf5StubImagePlugin.register_handler(handler)
+    with Image.open(TEST_FILE) as im:
+        assert handler.opened
+        assert not handler.loaded
+
+        im.load()
+        assert handler.loaded
+
+        temp_file = str(tmp_path / "temp.h5")
+        im.save(temp_file)
+        assert handler.saved
+
+    Hdf5StubImagePlugin._handler = None
('Tests', 'test_file_jpeg.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,5 +1,6 @@
 import os
 import re
+import warnings
 from io import BytesIO
 
 import pytest
@@ -17,13 +18,21 @@
 from .helper import (
     assert_image,
     assert_image_equal,
+    assert_image_equal_tofile,
     assert_image_similar,
+    assert_image_similar_tofile,
     cjpeg_available,
     djpeg_available,
     hopper,
     is_win32,
+    mark_if_feature_version,
     skip_unless_feature,
 )
+
+try:
+    import defusedxml.ElementTree as ElementTree
+except ImportError:
+    ElementTree = None
 
 TEST_FILE = "Tests/images/hopper.jpg"
 
@@ -59,6 +68,13 @@
             assert im.format == "JPEG"
             assert im.get_format_mimetype() == "image/jpeg"
 
+    @pytest.mark.parametrize("size", ((1, 0), (0, 1), (0, 0)))
+    def test_zero(self, size, tmp_path):
+        f = str(tmp_path / "temp.jpg")
+        im = Image.new("RGB", size)
+        with pytest.raises(ValueError):
+            im.save(f)
+
     def test_app(self):
         # Test APP/COM reader (@PIL135)
         with Image.open(TEST_FILE) as im:
@@ -77,26 +93,26 @@
         f = "Tests/images/pil_sample_cmyk.jpg"
         with Image.open(f) as im:
             # the source image has red pixels in the upper left corner.
-            c, m, y, k = [x / 255.0 for x in im.getpixel((0, 0))]
+            c, m, y, k = (x / 255.0 for x in im.getpixel((0, 0)))
             assert c == 0.0
             assert m > 0.8
             assert y > 0.8
             assert k == 0.0
             # the opposite corner is black
-            c, m, y, k = [
+            c, m, y, k = (
                 x / 255.0 for x in im.getpixel((im.size[0] - 1, im.size[1] - 1))
-            ]
+            )
             assert k > 0.9
             # roundtrip, and check again
             im = self.roundtrip(im)
-            c, m, y, k = [x / 255.0 for x in im.getpixel((0, 0))]
+            c, m, y, k = (x / 255.0 for x in im.getpixel((0, 0)))
             assert c == 0.0
             assert m > 0.8
             assert y > 0.8
             assert k == 0.0
-            c, m, y, k = [
+            c, m, y, k = (
                 x / 255.0 for x in im.getpixel((im.size[0] - 1, im.size[1] - 1))
-            ]
+            )
             assert k > 0.9
 
     @pytest.mark.parametrize(
@@ -114,6 +130,9 @@
         assert test(100, 200) == (100, 200)
         assert test(0) is None  # square pixels
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_icc(self, tmp_path):
         # Test ICC support
         with Image.open("Tests/images/rgb.jpg") as im1:
@@ -153,6 +172,9 @@
         test(ImageFile.MAXBLOCK + 1)  # full buffer block plus one byte
         test(ImageFile.MAXBLOCK * 4 + 3)  # large block
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_large_icc_meta(self, tmp_path):
         # https://github.com/python-pillow/Pillow/issues/148
         # Sometimes the meta data on the icc_profile block is bigger than
@@ -257,14 +279,14 @@
             del exif[0x8769]
 
             # Assert that it needs to be transposed
-            assert exif[0x0112] == Image.TRANSVERSE
+            assert exif[0x0112] == Image.Transpose.TRANSVERSE
 
             # Assert that the GPS IFD is present and empty
-            assert exif[0x8825] == {}
+            assert exif.get_ifd(0x8825) == {}
 
             transposed = ImageOps.exif_transpose(im)
         exif = transposed.getexif()
-        assert exif[0x8825] == {}
+        assert exif.get_ifd(0x8825) == {}
 
         # Assert that it was transposed
         assert 0x0112 not in exif
@@ -419,6 +441,9 @@
         with Image.open(filename):
             pass
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_truncated_jpeg_should_read_all_the_data(self):
         filename = "Tests/images/truncated_jpeg.jpg"
         ImageFile.LOAD_TRUNCATED_IMAGES = True
@@ -437,6 +462,9 @@
             with pytest.raises(OSError):
                 im.load()
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_qtables(self, tmp_path):
         def _n_qtables_helper(n, test_file):
             with Image.open(test_file) as im:
@@ -446,7 +474,7 @@
                 assert len(im.quantization) == n
                 reloaded = self.roundtrip(im, qtables="keep")
                 assert im.quantization == reloaded.quantization
-                assert reloaded.quantization[0].typecode == "B"
+                assert max(reloaded.quantization[0]) <= 255
 
         with Image.open("Tests/images/hopper.jpg") as im:
             qtables = im.quantization
@@ -458,7 +486,8 @@
 
             # valid bounds for baseline qtable
             bounds_qtable = [int(s) for s in ("255 1 " * 32).split(None)]
-            self.roundtrip(im, qtables=[bounds_qtable])
+            im2 = self.roundtrip(im, qtables=[bounds_qtable])
+            assert im2.quantization == {0: bounds_qtable}
 
             # values from wizard.txt in jpeg9-a src package.
             standard_l_qtable = [
@@ -569,11 +598,17 @@
             assert max(im2.quantization[0]) <= 255
             assert max(im2.quantization[1]) <= 255
 
+    def test_convert_dict_qtables_deprecation(self):
+        with pytest.warns(DeprecationWarning):
+            qtable = {0: [1, 2, 3, 4]}
+            qtable2 = JpegImagePlugin.convert_dict_qtables(qtable)
+            assert qtable == qtable2
+
     @pytest.mark.skipif(not djpeg_available(), reason="djpeg not available")
     def test_load_djpeg(self):
         with Image.open(TEST_FILE) as img:
             img.load_djpeg()
-            assert_image_similar(img, Image.open(TEST_FILE), 5)
+            assert_image_similar_tofile(img, TEST_FILE, 5)
 
     @pytest.mark.skipif(not cjpeg_available(), reason="cjpeg not available")
     def test_save_cjpeg(self, tmp_path):
@@ -581,7 +616,7 @@
             tempfile = str(tmp_path / "temp.jpg")
             JpegImagePlugin._save_cjpeg(img, 0, tempfile)
             # Default save quality is 75%, so a tiny bit of difference is alright
-            assert_image_similar(img, Image.open(tempfile), 17)
+            assert_image_similar_tofile(img, tempfile, 17)
 
     def test_no_duplicate_0x1001_tag(self):
         # Arrange
@@ -603,7 +638,7 @@
             reloaded.save(f, quality="keep", optimize=True)
 
     def test_bad_mpo_header(self):
-        """ Treat unknown MPO as JPEG """
+        """Treat unknown MPO as JPEG"""
         # Arrange
 
         # Act
@@ -641,15 +676,6 @@
                 reloaded.load()
                 assert im.info["dpi"] == reloaded.info["dpi"]
 
-    def test_load_dpi_rounding(self):
-        # Round up
-        with Image.open("Tests/images/iptc_roundUp.jpg") as im:
-            assert im.info["dpi"] == (44, 44)
-
-        # Round down
-        with Image.open("Tests/images/iptc_roundDown.jpg") as im:
-            assert im.info["dpi"] == (2, 2)
-
     def test_save_dpi_rounding(self, tmp_path):
         outfile = str(tmp_path / "temp.jpg")
         with Image.open("Tests/images/hopper.jpg") as im:
@@ -700,6 +726,15 @@
             # This should return the default, and not raise a ZeroDivisionError
             assert im.info.get("dpi") == (72, 72)
 
+    def test_dpi_exif_string(self):
+        # Arrange
+        # 0x011A tag in this exif contains string '300300\x02'
+        with Image.open("Tests/images/broken_exif_dpi.jpg") as im:
+
+            # Act / Assert
+            # This should return the default
+            assert im.info.get("dpi") == (72, 72)
+
     def test_no_dpi_in_exif(self):
         # Arrange
         # This is photoshop-200dpi.jpg with resolution removed from EXIF:
@@ -720,15 +755,17 @@
             # OSError for unidentified image.
             assert im.info.get("dpi") == (72, 72)
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_exif_x_resolution(self, tmp_path):
         with Image.open("Tests/images/flower.jpg") as im:
             exif = im.getexif()
             assert exif[282] == 180
 
             out = str(tmp_path / "out.jpg")
-            with pytest.warns(None) as record:
+            with warnings.catch_warnings():
                 im.save(out, exif=exif)
-            assert len(record) == 0
 
         with Image.open(out) as reloaded:
             assert reloaded.getexif()[282] == 180
@@ -750,6 +787,9 @@
             # Act / Assert
             assert im._getexif()[306] == "2017:03:13 23:03:09"
 
+    @mark_if_feature_version(
+        pytest.mark.valgrind_known_error, "libjpeg_turbo", "2.0", reason="Known Failing"
+    )
     def test_photoshop(self):
         with Image.open("Tests/images/photoshop-200dpi.jpg") as im:
             assert im.info["photoshop"][0x03ED] == {
@@ -761,8 +801,7 @@
 
             # Test that the image can still load, even with broken Photoshop data
             # This image had the APP13 length hexedited to be smaller
-            with Image.open("Tests/images/photoshop-200dpi-broken.jpg") as im_broken:
-                assert_image_equal(im_broken, im)
+            assert_image_equal_tofile(im, "Tests/images/photoshop-200dpi-broken.jpg")
 
         # This image does not contain a Photoshop header string
         with Image.open("Tests/images/app13.jpg") as im:
@@ -775,6 +814,20 @@
             apps_13_lengths = [len(v) for k, v in im.applist if k == "APP13"]
             assert [65504, 24] == apps_13_lengths
 
+    def test_adobe_transform(self):
+        with Image.open("Tests/images/pil_sample_rgb.jpg") as im:
+            assert im.info["adobe_transform"] == 1
+
+        with Image.open("Tests/images/pil_sample_cmyk.jpg") as im:
+            assert im.info["adobe_transform"] == 2
+
+        # This image has been manually hexedited
+        # so that the APP14 reports its length to be 11,
+        # leaving no room for "adobe_transform"
+        with Image.open("Tests/images/truncated_app14.jpg") as im:
+            assert "adobe" in im.info
+            assert "adobe_transform" not in im.info
+
     def test_icc_after_SOF(self):
         with Image.open("Tests/images/icc-after-SOF.jpg") as im:
             assert im.info["icc_profile"] == b"profile"
@@ -792,10 +845,61 @@
 
         buffer.read = read
         with pytest.raises(UnidentifiedImageError):
-            Image.open(buffer)
+            with Image.open(buffer):
+                pass
 
         # Assert the entire file has not been read
         assert 0 < buffer.max_pos < size
+
+    def test_getxmp(self):
+        with Image.open("Tests/images/xmp_test.jpg") as im:
+            if ElementTree is None:
+                with pytest.warns(UserWarning):
+                    assert im.getxmp() == {}
+            else:
+                xmp = im.getxmp()
+
+                description = xmp["xmpmeta"]["RDF"]["Description"]
+                assert description["DerivedFrom"] == {
+                    "documentID": "8367D410E636EA95B7DE7EBA1C43A412",
+                    "originalDocumentID": "8367D410E636EA95B7DE7EBA1C43A412",
+                }
+                assert description["Look"]["Description"]["Group"]["Alt"]["li"] == {
+                    "lang": "x-default",
+                    "text": "Profiles",
+                }
+                assert description["ToneCurve"]["Seq"]["li"] == ["0, 0", "255, 255"]
+
+                # Attribute
+                assert description["Version"] == "10.4"
+
+        if ElementTree is not None:
+            with Image.open("Tests/images/hopper.jpg") as im:
+                assert im.getxmp() == {}
+
+    @pytest.mark.timeout(timeout=1)
+    def test_eof(self):
+        # Even though this decoder never says that it is finished
+        # the image should still end when there is no new data
+        class InfiniteMockPyDecoder(ImageFile.PyDecoder):
+            def decode(self, buffer):
+                return 0, 0
+
+        decoder = InfiniteMockPyDecoder(None)
+
+        def closure(mode, *args):
+            decoder.__init__(mode, *args)
+            return decoder
+
+        Image.register_decoder("INFINITE", closure)
+
+        with Image.open(TEST_FILE) as im:
+            im.tile = [
+                ("INFINITE", (0, 0, 128, 128), 0, ("RGB", 0, 1)),
+            ]
+            ImageFile.LOAD_TRUNCATED_IMAGES = True
+            im.load()
+            ImageFile.LOAD_TRUNCATED_IMAGES = False
 
 
 @pytest.mark.skipif(not is_win32(), reason="Windows only")
('src/PIL', 'MpoImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,9 +21,8 @@
 from . import Image, ImageFile, JpegImagePlugin
 from ._binary import i16be as i16
 
-
-def _accept(prefix):
-    return JpegImagePlugin._accept(prefix)
+# def _accept(prefix):
+#     return JpegImagePlugin._accept(prefix)
 
 
 def _save(im, fp, filename):
@@ -47,6 +46,7 @@
         self._after_jpeg_open()
 
     def _after_jpeg_open(self, mpheader=None):
+        self._initial_size = self.size
         self.mpinfo = mpheader if mpheader is not None else self._getmp()
         self.n_frames = self.mpinfo[0xB001]
         self.__mpoffsets = [
@@ -78,13 +78,16 @@
         segment = self.fp.read(2)
         if not segment:
             raise ValueError("No data found for frame")
+        self._size = self._initial_size
         if i16(segment) == 0xFFE1:  # APP1
             n = i16(self.fp.read(2)) - 2
             self.info["exif"] = ImageFile._safe_read(self.fp, n)
 
-            exif = self.getexif()
-            if 40962 in exif and 40963 in exif:
-                self._size = (exif[40962], exif[40963])
+            mptype = self.mpinfo[0xB002][frame]["Attribute"]["MPType"]
+            if mptype.startswith("Large Thumbnail"):
+                exif = self.getexif().get_ifd(0x8769)
+                if 40962 in exif and 40963 in exif:
+                    self._size = (exif[40962], exif[40963])
         elif "exif" in self.info:
             del self.info["exif"]
 
('src/PIL', 'ImageMode.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,6 +13,8 @@
 # See the README file for information on usage and redistribution.
 #
 
+import sys
+
 # mode descriptor cache
 _modes = None
 
@@ -20,11 +22,12 @@
 class ModeDescriptor:
     """Wrapper for mode strings."""
 
-    def __init__(self, mode, bands, basemode, basetype):
+    def __init__(self, mode, bands, basemode, basetype, typestr):
         self.mode = mode
         self.bands = bands
         self.basemode = basemode
         self.basetype = basetype
+        self.typestr = typestr
 
     def __str__(self):
         return self.mode
@@ -35,30 +38,54 @@
     global _modes
     if not _modes:
         # initialize mode cache
-
-        from . import Image
-
         modes = {}
-        # core modes
-        for m, (basemode, basetype, bands) in Image._MODEINFO.items():
-            modes[m] = ModeDescriptor(m, bands, basemode, basetype)
-        # extra experimental modes
-        modes["RGBa"] = ModeDescriptor("RGBa", ("R", "G", "B", "a"), "RGB", "L")
-        modes["LA"] = ModeDescriptor("LA", ("L", "A"), "L", "L")
-        modes["La"] = ModeDescriptor("La", ("L", "a"), "L", "L")
-        modes["PA"] = ModeDescriptor("PA", ("P", "A"), "RGB", "L")
+        endian = "<" if sys.byteorder == "little" else ">"
+        for m, (basemode, basetype, bands, typestr) in {
+            # core modes
+            # Bits need to be extended to bytes
+            "1": ("L", "L", ("1",), "|b1"),
+            "L": ("L", "L", ("L",), "|u1"),
+            "I": ("L", "I", ("I",), endian + "i4"),
+            "F": ("L", "F", ("F",), endian + "f4"),
+            "P": ("P", "L", ("P",), "|u1"),
+            "RGB": ("RGB", "L", ("R", "G", "B"), "|u1"),
+            "RGBX": ("RGB", "L", ("R", "G", "B", "X"), "|u1"),
+            "RGBA": ("RGB", "L", ("R", "G", "B", "A"), "|u1"),
+            "CMYK": ("RGB", "L", ("C", "M", "Y", "K"), "|u1"),
+            "YCbCr": ("RGB", "L", ("Y", "Cb", "Cr"), "|u1"),
+            # UNDONE - unsigned |u1i1i1
+            "LAB": ("RGB", "L", ("L", "A", "B"), "|u1"),
+            "HSV": ("RGB", "L", ("H", "S", "V"), "|u1"),
+            # extra experimental modes
+            "RGBa": ("RGB", "L", ("R", "G", "B", "a"), "|u1"),
+            "BGR;15": ("RGB", "L", ("B", "G", "R"), endian + "u2"),
+            "BGR;16": ("RGB", "L", ("B", "G", "R"), endian + "u2"),
+            "BGR;24": ("RGB", "L", ("B", "G", "R"), endian + "u3"),
+            "BGR;32": ("RGB", "L", ("B", "G", "R"), endian + "u4"),
+            "LA": ("L", "L", ("L", "A"), "|u1"),
+            "La": ("L", "L", ("L", "a"), "|u1"),
+            "PA": ("RGB", "L", ("P", "A"), "|u1"),
+        }.items():
+            modes[m] = ModeDescriptor(m, bands, basemode, basetype, typestr)
         # mapping modes
-        for i16mode in (
-            "I;16",
-            "I;16S",
-            "I;16L",
-            "I;16LS",
-            "I;16B",
-            "I;16BS",
-            "I;16N",
-            "I;16NS",
-        ):
-            modes[i16mode] = ModeDescriptor(i16mode, ("I",), "L", "L")
+        for i16mode, typestr in {
+            # I;16 == I;16L, and I;32 == I;32L
+            "I;16": "<u2",
+            "I;16S": "<i2",
+            "I;16L": "<u2",
+            "I;16LS": "<i2",
+            "I;16B": ">u2",
+            "I;16BS": ">i2",
+            "I;16N": endian + "u2",
+            "I;16NS": endian + "i2",
+            "I;32": "<u4",
+            "I;32B": ">u4",
+            "I;32L": "<u4",
+            "I;32S": "<i4",
+            "I;32BS": ">i4",
+            "I;32LS": "<i4",
+        }.items():
+            modes[i16mode] = ModeDescriptor(i16mode, ("I",), "L", "L", typestr)
         # set global mode cache atomically
         _modes = modes
     return _modes[mode]
('src/PIL', 'PngImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -37,6 +37,7 @@
 import struct
 import warnings
 import zlib
+from enum import IntEnum
 
 from . import Image, ImageChops, ImageFile, ImagePalette, ImageSequence
 from ._binary import i16be as i16
@@ -47,7 +48,7 @@
 
 logger = logging.getLogger(__name__)
 
-is_cid = re.compile(br"\w\w\w\w").match
+is_cid = re.compile(rb"\w\w\w\w").match
 
 
 _MAGIC = b"\211PNG\r\n\032\n"
@@ -94,36 +95,62 @@
 
 
 # APNG frame disposal modes
-APNG_DISPOSE_OP_NONE = 0
-"""
-No disposal is done on this frame before rendering the next frame.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
-APNG_DISPOSE_OP_BACKGROUND = 1
-"""
-This frame’s modified region is cleared to fully transparent black before rendering
-the next frame.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
-APNG_DISPOSE_OP_PREVIOUS = 2
-"""
-This frame’s modified region is reverted to the previous frame’s contents before
-rendering the next frame.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
+class Disposal(IntEnum):
+    OP_NONE = 0
+    """
+    No disposal is done on this frame before rendering the next frame.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+    OP_BACKGROUND = 1
+    """
+    This frame’s modified region is cleared to fully transparent black before rendering
+    the next frame.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+    OP_PREVIOUS = 2
+    """
+    This frame’s modified region is reverted to the previous frame’s contents before
+    rendering the next frame.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+
 
 # APNG frame blend modes
-APNG_BLEND_OP_SOURCE = 0
-"""
-All color components of this frame, including alpha, overwrite the previous output
-image contents.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
-APNG_BLEND_OP_OVER = 1
-"""
-This frame should be alpha composited with the previous output image contents.
-See :ref:`Saving APNG sequences<apng-saving>`.
-"""
+class Blend(IntEnum):
+    OP_SOURCE = 0
+    """
+    All color components of this frame, including alpha, overwrite the previous output
+    image contents.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+    OP_OVER = 1
+    """
+    This frame should be alpha composited with the previous output image contents.
+    See :ref:`Saving APNG sequences<apng-saving>`.
+    """
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {Disposal: "APNG_DISPOSE_", Blend: "APNG_BLEND_"}.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
 
 
 def _safe_zlib_decompress(s):
@@ -500,7 +527,7 @@
         px, py = i32(s, 0), i32(s, 4)
         unit = s[8]
         if unit == 1:  # meter
-            dpi = int(px * 0.0254 + 0.5), int(py * 0.0254 + 0.5)
+            dpi = px * 0.0254, py * 0.0254
             self.im_info["dpi"] = dpi
         elif unit == 0:
             self.im_info["aspect"] = px, py
@@ -861,13 +888,13 @@
                 raise EOFError
 
         # setup frame disposal (actual disposal done when needed in the next _seek())
-        if self._prev_im is None and self.dispose_op == APNG_DISPOSE_OP_PREVIOUS:
-            self.dispose_op = APNG_DISPOSE_OP_BACKGROUND
-
-        if self.dispose_op == APNG_DISPOSE_OP_PREVIOUS:
+        if self._prev_im is None and self.dispose_op == Disposal.OP_PREVIOUS:
+            self.dispose_op = Disposal.OP_BACKGROUND
+
+        if self.dispose_op == Disposal.OP_PREVIOUS:
             self.dispose = self._prev_im.copy()
             self.dispose = self._crop(self.dispose, self.dispose_extent)
-        elif self.dispose_op == APNG_DISPOSE_OP_BACKGROUND:
+        elif self.dispose_op == Disposal.OP_BACKGROUND:
             self.dispose = Image.core.fill(self.mode, self.size)
             self.dispose = self._crop(self.dispose, self.dispose_extent)
         else:
@@ -920,6 +947,8 @@
 
     def load_end(self):
         """internal: finished reading image data"""
+        if self.__idat != 0:
+            self.fp.read(self.__idat)
         while True:
             self.fp.read(4)  # CRC
 
@@ -954,7 +983,7 @@
             self.png.close()
             self.png = None
         else:
-            if self._prev_im and self.blend_op == APNG_BLEND_OP_OVER:
+            if self._prev_im and self.blend_op == Blend.OP_OVER:
                 updated = self._crop(self.im, self.dispose_extent)
                 self._prev_im.paste(
                     updated, self.dispose_extent, updated.convert("RGBA")
@@ -968,13 +997,26 @@
             self.load()
         if "exif" not in self.info and "Raw profile type exif" not in self.info:
             return None
-        return dict(self.getexif())
+        return self.getexif()._get_merged_dict()
 
     def getexif(self):
         if "exif" not in self.info:
             self.load()
 
         return super().getexif()
+
+    def getxmp(self):
+        """
+        Returns a dictionary containing the XMP tags.
+        Requires defusedxml to be installed.
+
+        :returns: XMP tags in a dictionary.
+        """
+        return (
+            self._getxmp(self.info["XML:com.adobe.xmp"])
+            if "XML:com.adobe.xmp" in self.info
+            else {}
+        )
 
     def _close__fp(self):
         try:
@@ -1047,8 +1089,8 @@
     default_image = im.encoderinfo.get("default_image", im.info.get("default_image"))
     duration = im.encoderinfo.get("duration", im.info.get("duration", 0))
     loop = im.encoderinfo.get("loop", im.info.get("loop", 0))
-    disposal = im.encoderinfo.get("disposal", im.info.get("disposal"))
-    blend = im.encoderinfo.get("blend", im.info.get("blend"))
+    disposal = im.encoderinfo.get("disposal", im.info.get("disposal", Disposal.OP_NONE))
+    blend = im.encoderinfo.get("blend", im.info.get("blend", Blend.OP_SOURCE))
 
     if default_image:
         chain = itertools.chain(im.encoderinfo.get("append_images", []))
@@ -1078,10 +1120,10 @@
                 previous = im_frames[-1]
                 prev_disposal = previous["encoderinfo"].get("disposal")
                 prev_blend = previous["encoderinfo"].get("blend")
-                if prev_disposal == APNG_DISPOSE_OP_PREVIOUS and len(im_frames) < 2:
-                    prev_disposal = APNG_DISPOSE_OP_BACKGROUND
-
-                if prev_disposal == APNG_DISPOSE_OP_BACKGROUND:
+                if prev_disposal == Disposal.OP_PREVIOUS and len(im_frames) < 2:
+                    prev_disposal = Disposal.OP_BACKGROUND
+
+                if prev_disposal == Disposal.OP_BACKGROUND:
                     base_im = previous["im"]
                     dispose = Image.core.fill("RGBA", im.size, (0, 0, 0, 0))
                     bbox = previous["bbox"]
@@ -1090,7 +1132,7 @@
                     else:
                         bbox = (0, 0) + im.size
                     base_im.paste(dispose, bbox)
-                elif prev_disposal == APNG_DISPOSE_OP_PREVIOUS:
+                elif prev_disposal == Disposal.OP_PREVIOUS:
                     base_im = im_frames[-2]["im"]
                 else:
                     base_im = previous["im"]
@@ -1103,12 +1145,8 @@
                     and prev_disposal == encoderinfo.get("disposal")
                     and prev_blend == encoderinfo.get("blend")
                 ):
-                    duration = encoderinfo.get("duration", 0)
-                    if duration:
-                        if "duration" in previous["encoderinfo"]:
-                            previous["encoderinfo"]["duration"] += duration
-                        else:
-                            previous["encoderinfo"]["duration"] = duration
+                    if isinstance(duration, (list, tuple)):
+                        previous["encoderinfo"]["duration"] += encoderinfo["duration"]
                     continue
             else:
                 bbox = None
@@ -1135,9 +1173,10 @@
             bbox = frame_data["bbox"]
             im_frame = im_frame.crop(bbox)
         size = im_frame.size
-        duration = int(round(frame_data["encoderinfo"].get("duration", 0)))
-        disposal = frame_data["encoderinfo"].get("disposal", APNG_DISPOSE_OP_NONE)
-        blend = frame_data["encoderinfo"].get("blend", APNG_BLEND_OP_SOURCE)
+        encoderinfo = frame_data["encoderinfo"]
+        frame_duration = int(round(encoderinfo.get("duration", duration)))
+        frame_disposal = encoderinfo.get("disposal", disposal)
+        frame_blend = encoderinfo.get("blend", blend)
         # frame control
         chunk(
             fp,
@@ -1147,10 +1186,10 @@
             o32(size[1]),  # height
             o32(bbox[0]),  # x_offset
             o32(bbox[1]),  # y_offset
-            o16(duration),  # delay_numerator
+            o16(frame_duration),  # delay_numerator
             o16(1000),  # delay_denominator
-            o8(disposal),  # dispose_op
-            o8(blend),  # blend_op
+            o8(frame_disposal),  # dispose_op
+            o8(frame_blend),  # blend_op
         )
         seq_num += 1
         # frame data
@@ -1186,23 +1225,21 @@
         # attempt to minimize storage requirements for palette images
         if "bits" in im.encoderinfo:
             # number of bits specified by user
-            colors = 1 << im.encoderinfo["bits"]
+            colors = min(1 << im.encoderinfo["bits"], 256)
         else:
             # check palette contents
             if im.palette:
-                colors = max(min(len(im.palette.getdata()[1]) // 3, 256), 2)
+                colors = max(min(len(im.palette.getdata()[1]) // 3, 256), 1)
             else:
                 colors = 256
 
-        if colors <= 2:
-            bits = 1
-        elif colors <= 4:
-            bits = 2
-        elif colors <= 16:
-            bits = 4
-        else:
-            bits = 8
-        if bits != 8:
+        if colors <= 16:
+            if colors <= 2:
+                bits = 1
+            elif colors <= 4:
+                bits = 2
+            else:
+                bits = 4
             mode = f"{mode};{bits}"
 
     # encoder options
@@ -1270,7 +1307,7 @@
                     chunk(fp, cid, data)
 
     if im.mode == "P":
-        palette_byte_number = (2 ** bits) * 3
+        palette_byte_number = colors * 3
         palette_bytes = im.im.getpalette("RGB")[:palette_byte_number]
         while len(palette_bytes) < palette_byte_number:
             palette_bytes += b"\0"
@@ -1281,7 +1318,7 @@
     if transparency or transparency == 0:
         if im.mode == "P":
             # limit to actual palette size
-            alpha_bytes = 2 ** bits
+            alpha_bytes = colors
             if isinstance(transparency, bytes):
                 chunk(fp, b"tRNS", transparency[:alpha_bytes])
             else:
@@ -1302,7 +1339,7 @@
     else:
         if im.mode == "P" and im.im.getpalettemode() == "RGBA":
             alpha = im.im.getpalette("RGBA", "A")
-            alpha_bytes = 2 ** bits
+            alpha_bytes = colors
             chunk(fp, b"tRNS", alpha[:alpha_bytes])
 
     dpi = im.encoderinfo.get("dpi")
('src/PIL', 'XbmImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -25,7 +25,7 @@
 
 # XBM header
 xbm_head = re.compile(
-    br"\s*#define[ \t]+.*_width[ \t]+(?P<width>[0-9]+)[\r\n]+"
+    rb"\s*#define[ \t]+.*_width[ \t]+(?P<width>[0-9]+)[\r\n]+"
     b"#define[ \t]+.*_height[ \t]+(?P<height>[0-9]+)[\r\n]+"
     b"(?P<hotspot>"
     b"#define[ \t]+[^_]*_x_hot[ \t]+(?P<xhot>[0-9]+)[\r\n]+"
@@ -52,18 +52,19 @@
 
         m = xbm_head.match(self.fp.read(512))
 
-        if m:
+        if not m:
+            raise SyntaxError("not a XBM file")
 
-            xsize = int(m.group("width"))
-            ysize = int(m.group("height"))
+        xsize = int(m.group("width"))
+        ysize = int(m.group("height"))
 
-            if m.group("hotspot"):
-                self.info["hotspot"] = (int(m.group("xhot")), int(m.group("yhot")))
+        if m.group("hotspot"):
+            self.info["hotspot"] = (int(m.group("xhot")), int(m.group("yhot")))
 
-            self.mode = "1"
-            self._size = xsize, ysize
+        self.mode = "1"
+        self._size = xsize, ysize
 
-            self.tile = [("xbm", (0, 0) + self.size, m.end(), None)]
+        self.tile = [("xbm", (0, 0) + self.size, m.end(), None)]
 
 
 def _save(im, fp, filename):
('src/PIL', 'PcxImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -66,13 +66,13 @@
         version = s[1]
         bits = s[3]
         planes = s[65]
-        ignored_stride = i16(s, 66)
+        provided_stride = i16(s, 66)
         logger.debug(
             "PCX version %s, bits %s, planes %s, stride %s",
             version,
             bits,
             planes,
-            ignored_stride,
+            provided_stride,
         )
 
         self.info["dpi"] = i16(s, 12), i16(s, 14)
@@ -110,10 +110,15 @@
         self.mode = mode
         self._size = bbox[2] - bbox[0], bbox[3] - bbox[1]
 
-        # don't trust the passed in stride. Calculate for ourselves.
-        # CVE-2020-35655
+        # Don't trust the passed in stride.
+        # Calculate the approximate position for ourselves.
+        # CVE-2020-35653
         stride = (self._size[0] * bits + 7) // 8
-        stride += stride % 2
+
+        # While the specification states that this must be even,
+        # not all images follow this
+        if provided_stride != stride:
+            stride += stride % 2
 
         bbox = (0, 0) + self.size
         logger.debug("size: %sx%s", *self.size)
('src/PIL', 'ImageFile.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -28,9 +28,9 @@
 #
 
 import io
+import itertools
 import struct
 import sys
-import warnings
 
 from . import Image
 from ._util import isPath
@@ -49,7 +49,11 @@
     -8: "bad configuration",
     -9: "out of memory error",
 }
-"""Dict of known error codes returned from :meth:`.PyDecoder.decode`."""
+"""
+Dict of known error codes returned from :meth:`.PyDecoder.decode`,
+:meth:`.PyEncoder.encode` :meth:`.PyEncoder.encode_to_pyfd` and
+:meth:`.PyEncoder.encode_to_file`.
+"""
 
 
 #
@@ -65,15 +69,6 @@
     if not message:
         message = f"decoder error {error}"
     raise OSError(message + " when reading image file")
-
-
-def raise_ioerror(error):
-    warnings.warn(
-        "raise_ioerror is deprecated and will be removed in Pillow 9 (2022-01-02). "
-        "Use raise_oserror instead.",
-        DeprecationWarning,
-    )
-    return raise_oserror(error)
 
 
 def _tilesort(t):
@@ -192,24 +187,14 @@
                 and args[0] in Image._MAPMODES
             ):
                 try:
-                    if hasattr(Image.core, "map"):
-                        # use built-in mapper  WIN32 only
-                        self.map = Image.core.map(self.filename)
-                        self.map.seek(offset)
-                        self.im = self.map.readimage(
-                            self.mode, self.size, args[1], args[2]
-                        )
-                    else:
-                        # use mmap, if possible
-                        import mmap
-
-                        with open(self.filename) as fp:
-                            self.map = mmap.mmap(
-                                fp.fileno(), 0, access=mmap.ACCESS_READ
-                            )
-                        self.im = Image.core.map_buffer(
-                            self.map, self.size, decoder_name, offset, args
-                        )
+                    # use mmap, if possible
+                    import mmap
+
+                    with open(self.filename) as fp:
+                        self.map = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)
+                    self.im = Image.core.map_buffer(
+                        self.map, self.size, decoder_name, offset, args
+                    )
                     readonly = 1
                     # After trashing self.im,
                     # we might need to reload the palette data.
@@ -230,16 +215,23 @@
             except AttributeError:
                 prefix = b""
 
+            # Remove consecutive duplicates that only differ by their offset
+            self.tile = [
+                list(tiles)[-1]
+                for _, tiles in itertools.groupby(
+                    self.tile, lambda tile: (tile[0], tile[1], tile[3])
+                )
+            ]
             for decoder_name, extents, offset, args in self.tile:
+                seek(offset)
                 decoder = Image._getdecoder(
                     self.mode, decoder_name, args, self.decoderconfig
                 )
                 try:
-                    seek(offset)
                     decoder.setimage(self.im, extents)
                     if decoder.pulls_fd:
                         decoder.setfd(self.fp)
-                        status, err_code = decoder.decode(b"")
+                        err_code = decoder.decode(b"")[1]
                     else:
                         b = prefix
                         while True:
@@ -340,6 +332,7 @@
         # become the other object (!)
         self.__class__ = image.__class__
         self.__dict__ = image.__dict__
+        return image.load()
 
     def _load(self):
         """(Hook) Find actual image loader."""
@@ -503,46 +496,36 @@
     # But, it would need at least the image size in most cases. RawEncode is
     # a tricky case.
     bufsize = max(MAXBLOCK, bufsize, im.size[0] * 4)  # see RawEncode.c
-    if fp == sys.stdout:
-        fp.flush()
-        return
     try:
         fh = fp.fileno()
         fp.flush()
-    except (AttributeError, io.UnsupportedOperation) as exc:
-        # compress to Python file-compatible object
-        for e, b, o, a in tile:
-            e = Image._getencoder(im.mode, e, a, im.encoderconfig)
-            if o > 0:
-                fp.seek(o)
-            e.setimage(im.im, b)
-            if e.pushes_fd:
-                e.setfd(fp)
-                l, s = e.encode_to_pyfd()
+        exc = None
+    except (AttributeError, io.UnsupportedOperation) as e:
+        exc = e
+    for e, b, o, a in tile:
+        if o > 0:
+            fp.seek(o)
+        encoder = Image._getencoder(im.mode, e, a, im.encoderconfig)
+        try:
+            encoder.setimage(im.im, b)
+            if encoder.pushes_fd:
+                encoder.setfd(fp)
+                l, s = encoder.encode_to_pyfd()
             else:
-                while True:
-                    l, s, d = e.encode(bufsize)
-                    fp.write(d)
-                    if s:
-                        break
+                if exc:
+                    # compress to Python file-compatible object
+                    while True:
+                        l, s, d = encoder.encode(bufsize)
+                        fp.write(d)
+                        if s:
+                            break
+                else:
+                    # slight speedup: compress to real file object
+                    s = encoder.encode_to_file(fh, bufsize)
             if s < 0:
                 raise OSError(f"encoder error {s} when writing image file") from exc
-            e.cleanup()
-    else:
-        # slight speedup: compress to real file object
-        for e, b, o, a in tile:
-            e = Image._getencoder(im.mode, e, a, im.encoderconfig)
-            if o > 0:
-                fp.seek(o)
-            e.setimage(im.im, b)
-            if e.pushes_fd:
-                e.setfd(fp)
-                l, s = e.encode_to_pyfd()
-            else:
-                s = e.encode_to_file(fh, bufsize)
-            if s < 0:
-                raise OSError(f"encoder error {s} when writing image file")
-            e.cleanup()
+        finally:
+            encoder.cleanup()
     if hasattr(fp, "flush"):
         fp.flush()
 
@@ -555,19 +538,28 @@
 
     :param fp: File handle.  Must implement a <b>read</b> method.
     :param size: Number of bytes to read.
-    :returns: A string containing up to <i>size</i> bytes of data.
+    :returns: A string containing <i>size</i> bytes of data.
+
+    Raises an OSError if the file is truncated and the read cannot be completed
+
     """
     if size <= 0:
         return b""
     if size <= SAFEBLOCK:
-        return fp.read(size)
+        data = fp.read(size)
+        if len(data) < size:
+            raise OSError("Truncated File Read")
+        return data
     data = []
-    while size > 0:
-        block = fp.read(min(size, SAFEBLOCK))
+    remaining_size = size
+    while remaining_size > 0:
+        block = fp.read(min(remaining_size, SAFEBLOCK))
         if not block:
             break
         data.append(block)
-        size -= len(block)
+        remaining_size -= len(block)
+    if sum(len(d) for d in data) < size:
+        raise OSError("Truncated File Read")
     return b"".join(data)
 
 
@@ -582,16 +574,7 @@
         return (self.xoff, self.yoff, self.xoff + self.xsize, self.yoff + self.ysize)
 
 
-class PyDecoder:
-    """
-    Python implementation of a format decoder. Override this class and
-    add the decoding logic in the :meth:`decode` method.
-
-    See :ref:`Writing Your Own File Decoder in Python<file-decoders-py>`
-    """
-
-    _pulls_fd = False
-
+class PyCodec:
     def __init__(self, mode, *args):
         self.im = None
         self.state = PyCodecState()
@@ -601,31 +584,16 @@
 
     def init(self, args):
         """
-        Override to perform decoder specific initialization
+        Override to perform codec specific initialization
 
         :param args: Array of args items from the tile entry
         :returns: None
         """
         self.args = args
 
-    @property
-    def pulls_fd(self):
-        return self._pulls_fd
-
-    def decode(self, buffer):
-        """
-        Override to perform the decoding process.
-
-        :param buffer: A bytes object with the data to be decoded.
-        :returns: A tuple of ``(bytes consumed, errcode)``.
-            If finished with decoding return <0 for the bytes consumed.
-            Err codes are from :data:`.ImageFile.ERRORS`.
-        """
-        raise NotImplementedError()
-
     def cleanup(self):
         """
-        Override to perform decoder specific cleanup
+        Override to perform codec specific cleanup
 
         :returns: None
         """
@@ -633,16 +601,16 @@
 
     def setfd(self, fd):
         """
-        Called from ImageFile to set the python file-like object
-
-        :param fd: A python file-like object
+        Called from ImageFile to set the Python file-like object
+
+        :param fd: A Python file-like object
         :returns: None
         """
         self.fd = fd
 
     def setimage(self, im, extents=None):
         """
-        Called from ImageFile to set the core output image for the decoder
+        Called from ImageFile to set the core output image for the codec
 
         :param im: A core image object
         :param extents: a 4 tuple of (x0, y0, x1, y1) defining the rectangle
@@ -675,6 +643,32 @@
         ):
             raise ValueError("Tile cannot extend outside image")
 
+
+class PyDecoder(PyCodec):
+    """
+    Python implementation of a format decoder. Override this class and
+    add the decoding logic in the :meth:`decode` method.
+
+    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`
+    """
+
+    _pulls_fd = False
+
+    @property
+    def pulls_fd(self):
+        return self._pulls_fd
+
+    def decode(self, buffer):
+        """
+        Override to perform the decoding process.
+
+        :param buffer: A bytes object with the data to be decoded.
+        :returns: A tuple of ``(bytes consumed, errcode)``.
+            If finished with decoding return -1 for the bytes consumed.
+            Err codes are from :data:`.ImageFile.ERRORS`.
+        """
+        raise NotImplementedError()
+
     def set_as_raw(self, data, rawmode=None):
         """
         Convenience method to set the internal image from a stream of raw data
@@ -695,3 +689,60 @@
             raise ValueError("not enough image data")
         if s[1] != 0:
             raise ValueError("cannot decode image data")
+
+
+class PyEncoder(PyCodec):
+    """
+    Python implementation of a format encoder. Override this class and
+    add the decoding logic in the :meth:`encode` method.
+
+    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`
+    """
+
+    _pushes_fd = False
+
+    @property
+    def pushes_fd(self):
+        return self._pushes_fd
+
+    def encode(self, bufsize):
+        """
+        Override to perform the encoding process.
+
+        :param bufsize: Buffer size.
+        :returns: A tuple of ``(bytes encoded, errcode, bytes)``.
+            If finished with encoding return 1 for the error code.
+            Err codes are from :data:`.ImageFile.ERRORS`.
+        """
+        raise NotImplementedError()
+
+    def encode_to_pyfd(self):
+        """
+        If ``pushes_fd`` is ``True``, then this method will be used,
+        and ``encode()`` will only be called once.
+
+        :returns: A tuple of ``(bytes consumed, errcode)``.
+            Err codes are from :data:`.ImageFile.ERRORS`.
+        """
+        if not self.pushes_fd:
+            return 0, -8  # bad configuration
+        bytes_consumed, errcode, data = self.encode(0)
+        if data:
+            self.fd.write(data)
+        return bytes_consumed, errcode
+
+    def encode_to_file(self, fh, bufsize):
+        """
+        :param fh: File handle.
+        :param bufsize: Buffer size.
+
+        :returns: If finished successfully, return 0.
+            Otherwise, return an error code. Err codes are from
+            :data:`.ImageFile.ERRORS`.
+        """
+        errcode = 0
+        while errcode == 0:
+            status, errcode, buf = self.encode(bufsize)
+            if status > 0:
+                fh.write(buf[status:])
+        return errcode
('src/PIL', 'SpiderImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -238,17 +238,18 @@
     if 1024 % lenbyt != 0:
         labrec += 1
     labbyt = labrec * lenbyt
+    nvalues = int(labbyt / 4)
+    if nvalues < 23:
+        return []
+
     hdr = []
-    nvalues = int(labbyt / 4)
     for i in range(nvalues):
         hdr.append(0.0)
-
-    if len(hdr) < 23:
-        return []
 
     # NB these are Fortran indices
     hdr[1] = 1.0  # nslice (=1 for an image)
     hdr[2] = float(nrow)  # number of rows per slice
+    hdr[3] = float(nrow)  # number of records in the image
     hdr[5] = 1.0  # iform for 2D image
     hdr[12] = float(nsam)  # number of pixels per line
     hdr[13] = float(labrec)  # number of records in file header
@@ -259,10 +260,7 @@
     hdr = hdr[1:]
     hdr.append(0.0)
     # pack binary data into a string
-    hdrstr = []
-    for v in hdr:
-        hdrstr.append(struct.pack("f", v))
-    return hdrstr
+    return [struct.pack("f", v) for v in hdr]
 
 
 def _save(im, fp, filename):
@@ -296,7 +294,7 @@
 if __name__ == "__main__":
 
     if len(sys.argv) < 2:
-        print("Syntax: python SpiderImagePlugin.py [infile] [outfile]")
+        print("Syntax: python3 SpiderImagePlugin.py [infile] [outfile]")
         sys.exit()
 
     filename = sys.argv[1]
@@ -316,7 +314,7 @@
             outfile = sys.argv[2]
 
             # perform some image operation
-            im = im.transpose(Image.FLIP_LEFT_RIGHT)
+            im = im.transpose(Image.Transpose.FLIP_LEFT_RIGHT)
             print(
                 f"saving a flipped version of {os.path.basename(filename)} "
                 f"as {outfile} "
('src/PIL', 'FitsStubImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -9,7 +9,9 @@
 # See the README file for information on usage and redistribution.
 #
 
-from . import Image, ImageFile
+import warnings
+
+from . import FitsImagePlugin, Image, ImageFile
 
 _handler = None
 
@@ -23,35 +25,39 @@
     global _handler
     _handler = handler
 
+    warnings.warn(
+        "FitsStubImagePlugin is deprecated and will be removed in Pillow "
+        "10 (2023-07-01). FITS images can now be read without a handler through "
+        "FitsImagePlugin instead.",
+        DeprecationWarning,
+    )
 
-# --------------------------------------------------------------------
-# Image adapter
+    # Override FitsImagePlugin with this handler
+    # for backwards compatibility
+    try:
+        Image.ID.remove(FITSStubImageFile.format)
+    except ValueError:
+        pass
 
-
-def _accept(prefix):
-    return prefix[:6] == b"SIMPLE"
+    Image.register_open(
+        FITSStubImageFile.format, FITSStubImageFile, FitsImagePlugin._accept
+    )
 
 
 class FITSStubImageFile(ImageFile.StubImageFile):
 
-    format = "FITS"
-    format_description = "FITS"
+    format = FitsImagePlugin.FitsImageFile.format
+    format_description = FitsImagePlugin.FitsImageFile.format_description
 
     def _open(self):
-
         offset = self.fp.tell()
 
-        if not _accept(self.fp.read(6)):
-            raise SyntaxError("Not a FITS file")
-
-        # FIXME: add more sanity checks here; mandatory header items
-        # include SIMPLE, BITPIX, NAXIS, etc.
+        im = FitsImagePlugin.FitsImageFile(self.fp)
+        self._size = im.size
+        self.mode = im.mode
+        self.tile = []
 
         self.fp.seek(offset)
-
-        # make something up
-        self.mode = "F"
-        self._size = 1, 1
 
         loader = self._load()
         if loader:
@@ -62,15 +68,10 @@
 
 
 def _save(im, fp, filename):
-    if _handler is None or not hasattr("_handler", "save"):
-        raise OSError("FITS save handler not installed")
-    _handler.save(im, fp, filename)
+    raise OSError("FITS save handler not installed")
 
 
 # --------------------------------------------------------------------
 # Registry
 
-Image.register_open(FITSStubImageFile.format, FITSStubImageFile, _accept)
 Image.register_save(FITSStubImageFile.format, _save)
-
-Image.register_extensions(FITSStubImageFile.format, [".fit", ".fits"])
('src/PIL', 'GribStubImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -59,7 +59,7 @@
 
 
 def _save(im, fp, filename):
-    if _handler is None or not hasattr("_handler", "save"):
+    if _handler is None or not hasattr(_handler, "save"):
         raise OSError("GRIB save handler not installed")
     _handler.save(im, fp, filename)
 
('src/PIL', 'ImageStat.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -91,7 +91,7 @@
         for i in range(0, len(self.h), 256):
             sum2 = 0.0
             for j in range(256):
-                sum2 += (j ** 2) * float(self.h[i + j])
+                sum2 += (j**2) * float(self.h[i + j])
             v.append(sum2)
         return v
 
('src/PIL', 'GimpPaletteFile.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -38,7 +38,7 @@
                 break
 
             # skip fields and comment lines
-            if re.match(br"\w+:|#", s):
+            if re.match(rb"\w+:|#", s):
                 continue
             if len(s) > 100:
                 raise SyntaxError("bad palette file")
('src/PIL', 'ImageColor.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,14 +24,16 @@
 
 def getrgb(color):
     """
-     Convert a color string to an RGB tuple. If the string cannot be parsed,
-     this function raises a :py:exc:`ValueError` exception.
+     Convert a color string to an RGB or RGBA tuple. If the string cannot be
+     parsed, this function raises a :py:exc:`ValueError` exception.
 
     .. versionadded:: 1.1.4
 
     :param color: A color string
     :return: ``(red, green, blue[, alpha])``
     """
+    if len(color) > 100:
+        raise ValueError("color specifier is too long")
     color = color.lower()
 
     rgb = colormap.get(color, None)
('src/PIL', 'MspImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,7 +21,7 @@
 # Figure 205. Windows Paint Version 1: "DanM" Format
 # Figure 206. Windows Paint Version 2: "LinS" Format. Used in Windows V2.03
 #
-# See also: http://www.fileformat.info/format/mspaint/egff.htm
+# See also: https://www.fileformat.info/format/mspaint/egff.htm
 
 import io
 import struct
@@ -73,7 +73,7 @@
 
 class MspDecoder(ImageFile.PyDecoder):
     # The algo for the MSP decoder is from
-    # http://www.fileformat.info/format/mspaint/egff.htm
+    # https://www.fileformat.info/format/mspaint/egff.htm
     # cc-by-attribution -- That page references is taken from the
     # Encyclopedia of Graphics File Formats and is licensed by
     # O'Reilly under the Creative Common/Attribution license
@@ -148,7 +148,7 @@
 
         self.set_as_raw(img.getvalue(), ("1", 0, 1))
 
-        return 0, 0
+        return -1, 0
 
 
 Image.register_decoder("MSP", MspDecoder)
('src/PIL', 'MicImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -68,7 +68,7 @@
         self.is_animated = self._n_frames > 1
 
         if len(self.images) > 1:
-            self.category = Image.CONTAINER
+            self._category = Image.CONTAINER
 
         self.seek(0)
 
('src/PIL', '_version.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,2 +1,2 @@
 # Master version for Pillow
-__version__ = "8.1.0"
+__version__ = "9.1.0"
('src/PIL', 'ImtImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -22,7 +22,7 @@
 #
 # --------------------------------------------------------------------
 
-field = re.compile(br"([a-z]*) ([^ \r\n]*)")
+field = re.compile(rb"([a-z]*) ([^ \r\n]*)")
 
 
 ##
('src/PIL', 'GifImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -28,11 +28,24 @@
 import math
 import os
 import subprocess
+from enum import IntEnum
 
 from . import Image, ImageChops, ImageFile, ImagePalette, ImageSequence
 from ._binary import i16le as i16
 from ._binary import o8
 from ._binary import o16le as o16
+
+
+class LoadingStrategy(IntEnum):
+    """.. versionadded:: 9.1.0"""
+
+    RGB_AFTER_FIRST = 0
+    RGB_AFTER_DIFFERENT_PALETTE_ONLY = 1
+    RGB_ALWAYS = 2
+
+
+#: .. versionadded:: 9.1.0
+LOADING_STRATEGY = LoadingStrategy.RGB_AFTER_FIRST
 
 # --------------------------------------------------------------------
 # Identify/read GIF files
@@ -61,6 +74,12 @@
             return self.fp.read(s[0])
         return None
 
+    def _is_palette_needed(self, p):
+        for i in range(0, len(p), 3):
+            if not (i // 3 == p[i] == p[i + 1] == p[i + 2]):
+                return True
+        return False
+
     def _open(self):
 
         # Screen
@@ -79,11 +98,9 @@
             self.info["background"] = s[11]
             # check if palette contains colour indices
             p = self.fp.read(3 << bits)
-            for i in range(0, len(p), 3):
-                if not (i // 3 == p[i] == p[i + 1] == p[i + 2]):
-                    p = ImagePalette.raw("RGB", p)
-                    self.global_palette = self.palette = p
-                    break
+            if self._is_palette_needed(p):
+                p = ImagePalette.raw("RGB", p)
+                self.global_palette = self.palette = p
 
         self.__fp = self.fp  # FIXME: hack
         self.__rewind = self.fp.tell()
@@ -97,7 +114,7 @@
             current = self.tell()
             try:
                 while True:
-                    self.seek(self.tell() + 1)
+                    self._seek(self.tell() + 1, False)
             except EOFError:
                 self._n_frames = self.tell() + 1
             self.seek(current)
@@ -110,22 +127,23 @@
                 self._is_animated = self._n_frames != 1
             else:
                 current = self.tell()
-
-                try:
-                    self.seek(1)
+                if current:
                     self._is_animated = True
-                except EOFError:
-                    self._is_animated = False
-
-                self.seek(current)
+                else:
+                    try:
+                        self._seek(1, False)
+                        self._is_animated = True
+                    except EOFError:
+                        self._is_animated = False
+
+                    self.seek(current)
         return self._is_animated
 
     def seek(self, frame):
         if not self._seek_check(frame):
             return
         if frame < self.__frame:
-            if frame != 0:
-                self.im = None
+            self.im = None
             self._seek(0)
 
         last_frame = self.__frame
@@ -136,27 +154,22 @@
                 self.seek(last_frame)
                 raise EOFError("no more images in GIF file") from e
 
-    def _seek(self, frame):
+    def _seek(self, frame, update_image=True):
 
         if frame == 0:
             # rewind
             self.__offset = 0
             self.dispose = None
-            self.dispose_extent = [0, 0, 0, 0]  # x0, y0, x1, y1
             self.__frame = -1
             self.__fp.seek(self.__rewind)
-            self._prev_im = None
             self.disposal_method = 0
         else:
             # ensure that the previous frame was loaded
-            if not self.im:
+            if self.tile and update_image:
                 self.load()
 
         if frame != self.__frame + 1:
             raise ValueError(f"cannot seek to frame {frame}")
-        self.__frame = frame
-
-        self.tile = []
 
         self.fp = self.__fp
         if self.__offset:
@@ -166,17 +179,24 @@
                 pass
             self.__offset = 0
 
-        if self.dispose:
-            self.im.paste(self.dispose, self.dispose_extent)
-
-        from copy import copy
-
-        self.palette = copy(self.global_palette)
+        s = self.fp.read(1)
+        if not s or s == b";":
+            raise EOFError
+
+        self.__frame = frame
+
+        self.tile = []
+
+        palette = None
 
         info = {}
+        frame_transparency = None
+        interlace = None
+        frame_dispose_extent = None
         while True:
 
-            s = self.fp.read(1)
+            if not s:
+                s = self.fp.read(1)
             if not s or s == b";":
                 break
 
@@ -192,7 +212,7 @@
                     #
                     flags = block[0]
                     if flags & 1:
-                        info["transparency"] = block[3]
+                        frame_transparency = block[3]
                     info["duration"] = i16(block, 1) * 10
 
                     # disposal method - find the value of bits 4 - 6
@@ -214,6 +234,7 @@
                         else:
                             info["comment"] = block
                         block = self.data()
+                    s = None
                     continue
                 elif s[0] == 255:
                     #
@@ -236,78 +257,191 @@
                 # extent
                 x0, y0 = i16(s, 0), i16(s, 2)
                 x1, y1 = x0 + i16(s, 4), y0 + i16(s, 6)
-                if x1 > self.size[0] or y1 > self.size[1]:
+                if (x1 > self.size[0] or y1 > self.size[1]) and update_image:
                     self._size = max(x1, self.size[0]), max(y1, self.size[1])
-                self.dispose_extent = x0, y0, x1, y1
+                frame_dispose_extent = x0, y0, x1, y1
                 flags = s[8]
 
                 interlace = (flags & 64) != 0
 
                 if flags & 128:
                     bits = (flags & 7) + 1
-                    self.palette = ImagePalette.raw("RGB", self.fp.read(3 << bits))
+                    p = self.fp.read(3 << bits)
+                    if self._is_palette_needed(p):
+                        palette = ImagePalette.raw("RGB", p)
 
                 # image data
                 bits = self.fp.read(1)[0]
                 self.__offset = self.fp.tell()
-                self.tile = [
-                    ("gif", (x0, y0, x1, y1), self.__offset, (bits, interlace))
-                ]
                 break
 
             else:
                 pass
                 # raise OSError, "illegal GIF tag `%x`" % s[0]
-
+            s = None
+
+        if interlace is None:
+            # self.__fp = None
+            raise EOFError
+        if not update_image:
+            return
+
+        if self.dispose:
+            self.im.paste(self.dispose, self.dispose_extent)
+
+        self._frame_palette = palette or self.global_palette
+        if frame == 0:
+            if self._frame_palette:
+                self.mode = (
+                    "RGB" if LOADING_STRATEGY == LoadingStrategy.RGB_ALWAYS else "P"
+                )
+            else:
+                self.mode = "L"
+
+            if not palette and self.global_palette:
+                from copy import copy
+
+                palette = copy(self.global_palette)
+            self.palette = palette
+        else:
+            self._frame_transparency = frame_transparency
+            if self.mode == "P":
+                if (
+                    LOADING_STRATEGY != LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY
+                    or palette
+                ):
+                    self.pyaccess = None
+                    if "transparency" in self.info:
+                        self.im.putpalettealpha(self.info["transparency"], 0)
+                        self.im = self.im.convert("RGBA", Image.Dither.FLOYDSTEINBERG)
+                        self.mode = "RGBA"
+                        del self.info["transparency"]
+                    else:
+                        self.mode = "RGB"
+                        self.im = self.im.convert("RGB", Image.Dither.FLOYDSTEINBERG)
+
+        def _rgb(color):
+            if self._frame_palette:
+                color = tuple(self._frame_palette.palette[color * 3 : color * 3 + 3])
+            else:
+                color = (color, color, color)
+            return color
+
+        self.dispose_extent = frame_dispose_extent
         try:
             if self.disposal_method < 2:
                 # do not dispose or none specified
                 self.dispose = None
             elif self.disposal_method == 2:
                 # replace with background colour
-                Image._decompression_bomb_check(self.size)
-                self.dispose = Image.core.fill("P", self.size, self.info["background"])
+
+                # only dispose the extent in this frame
+                x0, y0, x1, y1 = self.dispose_extent
+                dispose_size = (x1 - x0, y1 - y0)
+
+                Image._decompression_bomb_check(dispose_size)
+
+                # by convention, attempt to use transparency first
+                dispose_mode = "P"
+                color = self.info.get("transparency", frame_transparency)
+                if color is not None:
+                    if self.mode in ("RGB", "RGBA"):
+                        dispose_mode = "RGBA"
+                        color = _rgb(color) + (0,)
+                else:
+                    color = self.info.get("background", 0)
+                    if self.mode in ("RGB", "RGBA"):
+                        dispose_mode = "RGB"
+                        color = _rgb(color)
+                self.dispose = Image.core.fill(dispose_mode, dispose_size, color)
             else:
                 # replace with previous contents
-                if self.im:
-                    self.dispose = self.im.copy()
-
-            # only dispose the extent in this frame
-            if self.dispose:
-                self.dispose = self._crop(self.dispose, self.dispose_extent)
-        except (AttributeError, KeyError):
+                if self.im is not None:
+                    # only dispose the extent in this frame
+                    self.dispose = self._crop(self.im, self.dispose_extent)
+                elif frame_transparency is not None:
+                    x0, y0, x1, y1 = self.dispose_extent
+                    dispose_size = (x1 - x0, y1 - y0)
+
+                    Image._decompression_bomb_check(dispose_size)
+                    dispose_mode = "P"
+                    color = frame_transparency
+                    if self.mode in ("RGB", "RGBA"):
+                        dispose_mode = "RGBA"
+                        color = _rgb(frame_transparency) + (0,)
+                    self.dispose = Image.core.fill(dispose_mode, dispose_size, color)
+        except AttributeError:
             pass
 
-        if not self.tile:
-            # self.__fp = None
-            raise EOFError
-
-        for k in ["transparency", "duration", "comment", "extension", "loop"]:
+        if interlace is not None:
+            transparency = -1
+            if frame_transparency is not None:
+                if frame == 0:
+                    self.info["transparency"] = frame_transparency
+                elif self.mode not in ("RGB", "RGBA"):
+                    transparency = frame_transparency
+            self.tile = [
+                (
+                    "gif",
+                    (x0, y0, x1, y1),
+                    self.__offset,
+                    (bits, interlace, transparency),
+                )
+            ]
+
+        for k in ["duration", "comment", "extension", "loop"]:
             if k in info:
                 self.info[k] = info[k]
             elif k in self.info:
                 del self.info[k]
 
-        self.mode = "L"
-        if self.palette:
-            self.mode = "P"
+    def load_prepare(self):
+        temp_mode = "P" if self._frame_palette else "L"
+        self._prev_im = None
+        if self.__frame == 0:
+            if "transparency" in self.info:
+                self.im = Image.core.fill(
+                    temp_mode, self.size, self.info["transparency"]
+                )
+        elif self.mode in ("RGB", "RGBA"):
+            self._prev_im = self.im
+            if self._frame_palette:
+                self.im = Image.core.fill("P", self.size, self._frame_transparency or 0)
+                self.im.putpalette(*self._frame_palette.getdata())
+            else:
+                self.im = None
+        self.mode = temp_mode
+        self._frame_palette = None
+
+        super().load_prepare()
+
+    def load_end(self):
+        if self.__frame == 0:
+            if self.mode == "P" and LOADING_STRATEGY == LoadingStrategy.RGB_ALWAYS:
+                self.mode = "RGB"
+                self.im = self.im.convert("RGB", Image.Dither.FLOYDSTEINBERG)
+            return
+        if self.mode == "P" and self._prev_im:
+            if self._frame_transparency is not None:
+                self.im.putpalettealpha(self._frame_transparency, 0)
+                frame_im = self.im.convert("RGBA")
+            else:
+                frame_im = self.im.convert("RGB")
+        else:
+            if not self._prev_im:
+                return
+            frame_im = self.im
+        frame_im = self._crop(frame_im, self.dispose_extent)
+
+        self.im = self._prev_im
+        self.mode = self.im.mode
+        if frame_im.mode == "RGBA":
+            self.im.paste(frame_im, self.dispose_extent, frame_im)
+        else:
+            self.im.paste(frame_im, self.dispose_extent)
 
     def tell(self):
         return self.__frame
-
-    def load_end(self):
-        ImageFile.ImageFile.load_end(self)
-
-        # if the disposal method is 'do not dispose', transparent
-        # pixels should show the content of the previous frame
-        if self._prev_im and self._prev_disposal_method == 1:
-            # we do this by pasting the updated area onto the previous
-            # frame which we then use as the current image content
-            updated = self._crop(self.im, self.dispose_extent)
-            self._prev_im.paste(updated, self.dispose_extent, updated.convert("RGBA"))
-            self.im = self._prev_im
-        self._prev_im = self.im.copy()
-        self._prev_disposal_method = self.disposal_method
 
     def _close__fp(self):
         try:
@@ -326,7 +460,7 @@
 RAWMODE = {"1": "L", "L": "L", "P": "P"}
 
 
-def _normalize_mode(im, initial_call=False):
+def _normalize_mode(im):
     """
     Takes an image (or frame), returns an image in a mode that is appropriate
     for saving in a Gif.
@@ -334,25 +468,20 @@
     It may return the original image, or it may return an image converted to
     palette or 'L' mode.
 
-    UNDONE: What is the point of mucking with the initial call palette, for
-    an image that shouldn't have a palette, or it would be a mode 'P' and
-    get returned in the RAWMODE clause.
-
     :param im: Image object
-    :param initial_call: Default false, set to true for a single frame.
     :returns: Image object
     """
     if im.mode in RAWMODE:
         im.load()
         return im
     if Image.getmodebase(im.mode) == "RGB":
-        if initial_call:
-            palette_size = 256
-            if im.palette:
-                palette_size = len(im.palette.getdata()[1]) // 3
-            return im.convert("P", palette=Image.ADAPTIVE, colors=palette_size)
-        else:
-            return im.convert("P")
+        im = im.convert("P", palette=Image.Palette.ADAPTIVE)
+        if im.palette.mode == "RGBA":
+            for rgba in im.palette.colors.keys():
+                if rgba[3] == 0:
+                    im.info["transparency"] = im.palette.colors[rgba]
+                    break
+        return im
     return im.convert("L")
 
 
@@ -374,15 +503,7 @@
         if isinstance(palette, (bytes, bytearray, list)):
             source_palette = bytearray(palette[:768])
         if isinstance(palette, ImagePalette.ImagePalette):
-            source_palette = bytearray(
-                itertools.chain.from_iterable(
-                    zip(
-                        palette.palette[:256],
-                        palette.palette[256:512],
-                        palette.palette[512:768],
-                    )
-                )
-            )
+            source_palette = bytearray(palette.palette)
 
     if im.mode == "P":
         if not source_palette:
@@ -392,16 +513,33 @@
             source_palette = bytearray(i // 3 for i in range(768))
         im.palette = ImagePalette.ImagePalette("RGB", palette=source_palette)
 
-    used_palette_colors = _get_optimize(im, info)
-    if used_palette_colors is not None:
-        return im.remap_palette(used_palette_colors, source_palette)
+    if palette:
+        used_palette_colors = []
+        for i in range(0, len(source_palette), 3):
+            source_color = tuple(source_palette[i : i + 3])
+            try:
+                index = im.palette.colors[source_color]
+            except KeyError:
+                index = None
+            used_palette_colors.append(index)
+        for i, index in enumerate(used_palette_colors):
+            if index is None:
+                for j in range(len(used_palette_colors)):
+                    if j not in used_palette_colors:
+                        used_palette_colors[i] = j
+                        break
+        im = im.remap_palette(used_palette_colors)
+    else:
+        used_palette_colors = _get_optimize(im, info)
+        if used_palette_colors is not None:
+            return im.remap_palette(used_palette_colors, source_palette)
 
     im.palette.palette = source_palette
     return im
 
 
 def _write_single_frame(im, fp, palette):
-    im_out = _normalize_mode(im, True)
+    im_out = _normalize_mode(im)
     for k, v in im_out.info.items():
         im.encoderinfo.setdefault(k, v)
     im_out = _normalize_palette(im_out, palette, im.encoderinfo)
@@ -450,10 +588,10 @@
                 previous = im_frames[-1]
                 if encoderinfo.get("disposal") == 2:
                     if background_im is None:
-                        background = _get_background(
-                            im,
-                            im.encoderinfo.get("background", im.info.get("background")),
+                        color = im.encoderinfo.get(
+                            "transparency", im.info.get("transparency", (0, 0, 0))
                         )
+                        background = _get_background(im_frame, color)
                         background_im = Image.new("P", im_frame.size, background)
                         background_im.putpalette(im_frames[0]["im"].palette)
                     base_im = background_im
@@ -485,7 +623,8 @@
                 offset = (0, 0)
             else:
                 # compress difference
-                frame_data["encoderinfo"]["include_color_table"] = True
+                if not palette:
+                    frame_data["encoderinfo"]["include_color_table"] = True
 
                 im_frame = im_frame.crop(frame_data["bbox"])
                 offset = frame_data["bbox"][:2]
@@ -532,11 +671,14 @@
 def _write_local_header(fp, im, offset, flags):
     transparent_color_exists = False
     try:
-        transparency = im.encoderinfo["transparency"]
-    except KeyError:
+        if "transparency" in im.encoderinfo:
+            transparency = im.encoderinfo["transparency"]
+        else:
+            transparency = im.info["transparency"]
+        transparency = int(transparency)
+    except (KeyError, ValueError):
         pass
     else:
-        transparency = int(transparency)
         # optimize the block away if transparent color is not used
         transparent_color_exists = True
 
@@ -749,7 +891,15 @@
             # WebPImagePlugin stores an RGBA value in info["background"]
             # So it must be converted to the same format as GifImagePlugin's
             # info["background"] - a global color table index
-            background = im.palette.getcolor(background)
+            try:
+                background = im.palette.getcolor(background, im)
+            except ValueError as e:
+                if str(e) == "cannot allocate more than 256 colors":
+                    # If all 256 colors are in use,
+                    # then there is no need for the background color
+                    return 0
+                else:
+                    raise
     return background
 
 
@@ -757,7 +907,7 @@
     """Return a list of strings representing a GIF header"""
 
     # Header Block
-    # http://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp
+    # https://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp
 
     version = b"87a"
     for extensionKey in ["transparency", "duration", "loop", "comment"]:
('src/PIL', 'ImageQt.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,6 +23,7 @@
 from ._util import isPath
 
 qt_versions = [
+    ["6", "PyQt6"],
     ["side6", "PySide6"],
     ["5", "PyQt5"],
     ["side2", "PySide2"],
@@ -32,7 +33,10 @@
 qt_versions.sort(key=lambda qt_version: qt_version[1] in sys.modules, reverse=True)
 for qt_version, qt_module in qt_versions:
     try:
-        if qt_module == "PySide6":
+        if qt_module == "PyQt6":
+            from PyQt6.QtCore import QBuffer, QIODevice
+            from PyQt6.QtGui import QImage, QPixmap, qRgba
+        elif qt_module == "PySide6":
             from PySide6.QtCore import QBuffer, QIODevice
             from PySide6.QtGui import QImage, QPixmap, qRgba
         elif qt_module == "PyQt5":
@@ -59,11 +63,17 @@
 
 def fromqimage(im):
     """
-    :param im: A PIL Image object, or a file name
-    (given either as Python string or a PyQt string object)
+    :param im: QImage or PIL ImageQt object
     """
     buffer = QBuffer()
-    buffer.open(QIODevice.ReadWrite)
+    if qt_version == "6":
+        try:
+            qt_openmode = QIODevice.OpenModeFlag
+        except AttributeError:
+            qt_openmode = QIODevice.OpenMode
+    else:
+        qt_openmode = QIODevice
+    buffer.open(qt_openmode.ReadWrite)
     # preserve alpha channel with png
     # otherwise ppm is more friendly with Image.open
     if im.hasAlphaChannel():
@@ -98,7 +108,7 @@
     converts each scanline of data from 8 bit to 32 bit aligned
     """
 
-    bits_per_pixel = {"1": 1, "L": 8, "P": 8}[mode]
+    bits_per_pixel = {"1": 1, "L": 8, "P": 8, "I;16": 16}[mode]
 
     # calculate bytes per line and the extra padding if needed
     bits_per_line = bits_per_pixel * width
@@ -124,6 +134,7 @@
 def _toqclass_helper(im):
     data = None
     colortable = None
+    exclusive_fp = False
 
     # handle filename, if given instead of image name
     if hasattr(im, "toUtf8"):
@@ -131,31 +142,45 @@
         im = str(im.toUtf8(), "utf-8")
     if isPath(im):
         im = Image.open(im)
-
+        exclusive_fp = True
+
+    qt_format = QImage.Format if qt_version == "6" else QImage
     if im.mode == "1":
-        format = QImage.Format_Mono
+        format = qt_format.Format_Mono
     elif im.mode == "L":
-        format = QImage.Format_Indexed8
+        format = qt_format.Format_Indexed8
         colortable = []
         for i in range(256):
             colortable.append(rgb(i, i, i))
     elif im.mode == "P":
-        format = QImage.Format_Indexed8
+        format = qt_format.Format_Indexed8
         colortable = []
         palette = im.getpalette()
         for i in range(0, len(palette), 3):
             colortable.append(rgb(*palette[i : i + 3]))
     elif im.mode == "RGB":
-        data = im.tobytes("raw", "BGRX")
-        format = QImage.Format_RGB32
+        # Populate the 4th channel with 255
+        im = im.convert("RGBA")
+
+        data = im.tobytes("raw", "BGRA")
+        format = qt_format.Format_RGB32
     elif im.mode == "RGBA":
         data = im.tobytes("raw", "BGRA")
-        format = QImage.Format_ARGB32
+        format = qt_format.Format_ARGB32
+    elif im.mode == "I;16" and hasattr(qt_format, "Format_Grayscale16"):  # Qt 5.13+
+        im = im.point(lambda i: i * 256)
+
+        format = qt_format.Format_Grayscale16
     else:
+        if exclusive_fp:
+            im.close()
         raise ValueError(f"unsupported image mode {repr(im.mode)}")
 
-    __data = data or align8to32(im.tobytes(), im.size[0], im.mode)
-    return {"data": __data, "im": im, "format": format, "colortable": colortable}
+    size = im.size
+    __data = data or align8to32(im.tobytes(), size[0], im.mode)
+    if exclusive_fp:
+        im.close()
+    return {"data": __data, "size": size, "format": format, "colortable": colortable}
 
 
 if qt_is_installed:
@@ -177,8 +202,8 @@
             self.__data = im_data["data"]
             super().__init__(
                 self.__data,
-                im_data["im"].size[0],
-                im_data["im"].size[1],
+                im_data["size"][0],
+                im_data["size"][1],
                 im_data["format"],
             )
             if im_data["colortable"]:
@@ -192,11 +217,7 @@
 def toqpixmap(im):
     # # This doesn't work. For now using a dumb approach.
     # im_data = _toqclass_helper(im)
-    # result = QPixmap(im_data['im'].size[0], im_data['im'].size[1])
-    # result.loadFromData(im_data['data'])
-    # Fix some strange bug that causes
-    if im.mode == "RGB":
-        im = im.convert("RGBA")
-
+    # result = QPixmap(im_data["size"][0], im_data["size"][1])
+    # result.loadFromData(im_data["data"])
     qimage = toqimage(im)
     return QPixmap.fromImage(qimage)
('src/PIL', 'ImageMath.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -18,8 +18,6 @@
 import builtins
 
 from . import Image, _imagingmath
-
-VERBOSE = 0
 
 
 def _isconstant(v):
@@ -69,8 +67,6 @@
                     im1 = im1.convert("F")
                 if im2.mode != "F":
                     im2 = im2.convert("F")
-                if im1.mode != im2.mode:
-                    raise ValueError("mode mismatch")
             if im1.size != im2.size:
                 # crop both arguments to a common size
                 size = (min(im1.size[0], im2.size[0]), min(im1.size[1], im2.size[1]))
@@ -78,9 +74,7 @@
                     im1 = im1.crop((0, 0) + size)
                 if im2.size != size:
                     im2 = im2.crop((0, 0) + size)
-                out = Image.new(mode or im1.mode, size, None)
-            else:
-                out = Image.new(mode or im1.mode, im1.size, None)
+            out = Image.new(mode or im1.mode, im1.size, None)
             im1.load()
             im2.load()
             try:
@@ -246,7 +240,19 @@
         if hasattr(v, "im"):
             args[k] = _Operand(v)
 
-    out = builtins.eval(expression, args)
+    compiled_code = compile(expression, "<string>", "eval")
+
+    def scan(code):
+        for const in code.co_consts:
+            if type(const) == type(compiled_code):
+                scan(const)
+
+        for name in code.co_names:
+            if name not in args and name != "abs":
+                raise ValueError(f"'{name}' not allowed")
+
+    scan(compiled_code)
+    out = builtins.eval(expression, {"__builtins": {"abs": abs}}, args)
     try:
         return out.im
     except AttributeError:
('src/PIL', 'PdfParser.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -330,6 +330,8 @@
         return bytes(x)
     elif isinstance(x, int):
         return str(x).encode("us-ascii")
+    elif isinstance(x, float):
+        return str(x).encode("us-ascii")
     elif isinstance(x, time.struct_time):
         return b"(D:" + time.strftime("%Y%m%d%H%M%SZ", x).encode("us-ascii") + b")"
     elif isinstance(x, dict):
@@ -423,7 +425,7 @@
         self.f.write(b"%PDF-1.4\n")
 
     def write_comment(self, s):
-        self.f.write(f"% {s}\n".encode("utf-8"))
+        self.f.write(f"% {s}\n".encode())
 
     def write_catalog(self):
         self.del_root()
@@ -574,40 +576,42 @@
             self.xref_table[reference.object_id] = (offset, 0)
         return reference
 
-    delimiter = br"[][()<>{}/%]"
-    delimiter_or_ws = br"[][()<>{}/%\000\011\012\014\015\040]"
-    whitespace = br"[\000\011\012\014\015\040]"
-    whitespace_or_hex = br"[\000\011\012\014\015\0400-9a-fA-F]"
+    delimiter = rb"[][()<>{}/%]"
+    delimiter_or_ws = rb"[][()<>{}/%\000\011\012\014\015\040]"
+    whitespace = rb"[\000\011\012\014\015\040]"
+    whitespace_or_hex = rb"[\000\011\012\014\015\0400-9a-fA-F]"
     whitespace_optional = whitespace + b"*"
     whitespace_mandatory = whitespace + b"+"
-    newline_only = br"[\r\n]+"
-    newline = whitespace_optional + newline_only + whitespace_optional
+    # No "\012" aka "\n" or "\015" aka "\r":
+    whitespace_optional_no_nl = rb"[\000\011\014\040]*"
+    newline_only = rb"[\r\n]+"
+    newline = whitespace_optional_no_nl + newline_only + whitespace_optional_no_nl
     re_trailer_end = re.compile(
         whitespace_mandatory
-        + br"trailer"
+        + rb"trailer"
         + whitespace_optional
-        + br"\<\<(.*\>\>)"
+        + rb"\<\<(.*\>\>)"
         + newline
-        + br"startxref"
+        + rb"startxref"
         + newline
-        + br"([0-9]+)"
+        + rb"([0-9]+)"
         + newline
-        + br"%%EOF"
+        + rb"%%EOF"
         + whitespace_optional
-        + br"$",
+        + rb"$",
         re.DOTALL,
     )
     re_trailer_prev = re.compile(
         whitespace_optional
-        + br"trailer"
+        + rb"trailer"
         + whitespace_optional
-        + br"\<\<(.*?\>\>)"
+        + rb"\<\<(.*?\>\>)"
         + newline
-        + br"startxref"
+        + rb"startxref"
         + newline
-        + br"([0-9]+)"
+        + rb"([0-9]+)"
         + newline
-        + br"%%EOF"
+        + rb"%%EOF"
         + whitespace_optional,
         re.DOTALL,
     )
@@ -651,12 +655,12 @@
     re_whitespace_optional = re.compile(whitespace_optional)
     re_name = re.compile(
         whitespace_optional
-        + br"/([!-$&'*-.0-;=?-Z\\^-z|~]+)(?="
+        + rb"/([!-$&'*-.0-;=?-Z\\^-z|~]+)(?="
         + delimiter_or_ws
-        + br")"
-    )
-    re_dict_start = re.compile(whitespace_optional + br"\<\<")
-    re_dict_end = re.compile(whitespace_optional + br"\>\>" + whitespace_optional)
+        + rb")"
+    )
+    re_dict_start = re.compile(whitespace_optional + rb"\<\<")
+    re_dict_end = re.compile(whitespace_optional + rb"\>\>" + whitespace_optional)
 
     @classmethod
     def interpret_trailer(cls, trailer_data):
@@ -685,7 +689,7 @@
         )
         return trailer
 
-    re_hashes_in_name = re.compile(br"([^#]*)(#([0-9a-fA-F]{2}))?")
+    re_hashes_in_name = re.compile(rb"([^#]*)(#([0-9a-fA-F]{2}))?")
 
     @classmethod
     def interpret_name(cls, raw, as_text=False):
@@ -700,53 +704,53 @@
         else:
             return bytes(name)
 
-    re_null = re.compile(whitespace_optional + br"null(?=" + delimiter_or_ws + br")")
-    re_true = re.compile(whitespace_optional + br"true(?=" + delimiter_or_ws + br")")
-    re_false = re.compile(whitespace_optional + br"false(?=" + delimiter_or_ws + br")")
+    re_null = re.compile(whitespace_optional + rb"null(?=" + delimiter_or_ws + rb")")
+    re_true = re.compile(whitespace_optional + rb"true(?=" + delimiter_or_ws + rb")")
+    re_false = re.compile(whitespace_optional + rb"false(?=" + delimiter_or_ws + rb")")
     re_int = re.compile(
-        whitespace_optional + br"([-+]?[0-9]+)(?=" + delimiter_or_ws + br")"
+        whitespace_optional + rb"([-+]?[0-9]+)(?=" + delimiter_or_ws + rb")"
     )
     re_real = re.compile(
         whitespace_optional
-        + br"([-+]?([0-9]+\.[0-9]*|[0-9]*\.[0-9]+))(?="
+        + rb"([-+]?([0-9]+\.[0-9]*|[0-9]*\.[0-9]+))(?="
         + delimiter_or_ws
-        + br")"
-    )
-    re_array_start = re.compile(whitespace_optional + br"\[")
-    re_array_end = re.compile(whitespace_optional + br"]")
+        + rb")"
+    )
+    re_array_start = re.compile(whitespace_optional + rb"\[")
+    re_array_end = re.compile(whitespace_optional + rb"]")
     re_string_hex = re.compile(
-        whitespace_optional + br"\<(" + whitespace_or_hex + br"*)\>"
-    )
-    re_string_lit = re.compile(whitespace_optional + br"\(")
+        whitespace_optional + rb"\<(" + whitespace_or_hex + rb"*)\>"
+    )
+    re_string_lit = re.compile(whitespace_optional + rb"\(")
     re_indirect_reference = re.compile(
         whitespace_optional
-        + br"([-+]?[0-9]+)"
+        + rb"([-+]?[0-9]+)"
         + whitespace_mandatory
-        + br"([-+]?[0-9]+)"
+        + rb"([-+]?[0-9]+)"
         + whitespace_mandatory
-        + br"R(?="
+        + rb"R(?="
         + delimiter_or_ws
-        + br")"
+        + rb")"
     )
     re_indirect_def_start = re.compile(
         whitespace_optional
-        + br"([-+]?[0-9]+)"
+        + rb"([-+]?[0-9]+)"
         + whitespace_mandatory
-        + br"([-+]?[0-9]+)"
+        + rb"([-+]?[0-9]+)"
         + whitespace_mandatory
-        + br"obj(?="
+        + rb"obj(?="
         + delimiter_or_ws
-        + br")"
+        + rb")"
     )
     re_indirect_def_end = re.compile(
-        whitespace_optional + br"endobj(?=" + delimiter_or_ws + br")"
+        whitespace_optional + rb"endobj(?=" + delimiter_or_ws + rb")"
     )
     re_comment = re.compile(
-        br"(" + whitespace_optional + br"%[^\r\n]*" + newline + br")*"
-    )
-    re_stream_start = re.compile(whitespace_optional + br"stream\r?\n")
+        rb"(" + whitespace_optional + rb"%[^\r\n]*" + newline + rb")*"
+    )
+    re_stream_start = re.compile(whitespace_optional + rb"stream\r?\n")
     re_stream_end = re.compile(
-        whitespace_optional + br"endstream(?=" + delimiter_or_ws + br")"
+        whitespace_optional + rb"endstream(?=" + delimiter_or_ws + rb")"
     )
 
     @classmethod
@@ -859,7 +863,7 @@
         if m:
             # filter out whitespace
             hex_string = bytearray(
-                [b for b in m.group(1) if b in b"0123456789abcdefABCDEF"]
+                b for b in m.group(1) if b in b"0123456789abcdefABCDEF"
             )
             if len(hex_string) % 2 == 1:
                 # append a 0 if the length is not even - yes, at the end
@@ -872,7 +876,7 @@
         raise PdfFormatError("unrecognized object: " + repr(data[offset : offset + 32]))
 
     re_lit_str_token = re.compile(
-        br"(\\[nrtbf()\\])|(\\[0-9]{1,3})|(\\(\r\n|\r|\n))|(\r\n|\r|\n)|(\()|(\))"
+        rb"(\\[nrtbf()\\])|(\\[0-9]{1,3})|(\\(\r\n|\r|\n))|(\r\n|\r|\n)|(\()|(\))"
     )
     escaped_chars = {
         b"n": b"\n",
@@ -918,16 +922,16 @@
             offset = m.end()
         raise PdfFormatError("unfinished literal string")
 
-    re_xref_section_start = re.compile(whitespace_optional + br"xref" + newline)
+    re_xref_section_start = re.compile(whitespace_optional + rb"xref" + newline)
     re_xref_subsection_start = re.compile(
         whitespace_optional
-        + br"([0-9]+)"
+        + rb"([0-9]+)"
         + whitespace_mandatory
-        + br"([0-9]+)"
+        + rb"([0-9]+)"
         + whitespace_optional
         + newline_only
     )
-    re_xref_entry = re.compile(br"([0-9]{10}) ([0-9]{5}) ([fn])( \r| \n|\r\n)")
+    re_xref_entry = re.compile(rb"([0-9]{10}) ([0-9]{5}) ([fn])( \r| \n|\r\n)")
 
     def read_xref_table(self, xref_section_offset):
         subsection_found = False
('src/PIL', 'ExifTags.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -17,6 +17,7 @@
 
 TAGS = {
     # possibly incomplete
+    0x0001: "InteropIndex",
     0x000B: "ProcessingSoftware",
     0x00FE: "NewSubfileType",
     0x00FF: "SubfileType",
@@ -121,9 +122,18 @@
     0x8829: "Interlace",
     0x882A: "TimeZoneOffset",
     0x882B: "SelfTimerMode",
+    0x8830: "SensitivityType",
+    0x8831: "StandardOutputSensitivity",
+    0x8832: "RecommendedExposureIndex",
+    0x8833: "ISOSpeed",
+    0x8834: "ISOSpeedLatitudeyyy",
+    0x8835: "ISOSpeedLatitudezzz",
     0x9000: "ExifVersion",
     0x9003: "DateTimeOriginal",
     0x9004: "DateTimeDigitized",
+    0x9010: "OffsetTime",
+    0x9011: "OffsetTimeOriginal",
+    0x9012: "OffsetTimeDigitized",
     0x9101: "ComponentsConfiguration",
     0x9102: "CompressedBitsPerPixel",
     0x9201: "ShutterSpeedValue",
@@ -197,6 +207,9 @@
     0xA433: "LensMake",
     0xA434: "LensModel",
     0xA435: "LensSerialNumber",
+    0xA460: "CompositeImage",
+    0xA461: "CompositeImageCount",
+    0xA462: "CompositeImageExposureTimes",
     0xA500: "Gamma",
     0xC4A5: "PrintImageMatching",
     0xC612: "DNGVersion",
('src/PIL', 'ImageCms.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,6 +16,8 @@
 # below for the original description.
 
 import sys
+import warnings
+from enum import IntEnum
 
 from PIL import Image
 
@@ -34,10 +36,10 @@
     a Python / PIL interface to the littleCMS ICC Color Management System
     Copyright (C) 2002-2003 Kevin Cazabon
     kevin@cazabon.com
-    http://www.cazabon.com
-
-    pyCMS home page:  http://www.cazabon.com/pyCMS
-    littleCMS home page:  http://www.littlecms.com
+    https://www.cazabon.com
+
+    pyCMS home page:  https://www.cazabon.com/pyCMS
+    littleCMS home page:  https://www.littlecms.com
     (littleCMS is Copyright (C) 1998-2001 Marti Maria)
 
     Originally released under LGPL.  Graciously donated to PIL in
@@ -100,14 +102,42 @@
 #
 # intent/direction values
 
-INTENT_PERCEPTUAL = 0
-INTENT_RELATIVE_COLORIMETRIC = 1
-INTENT_SATURATION = 2
-INTENT_ABSOLUTE_COLORIMETRIC = 3
-
-DIRECTION_INPUT = 0
-DIRECTION_OUTPUT = 1
-DIRECTION_PROOF = 2
+
+class Intent(IntEnum):
+    PERCEPTUAL = 0
+    RELATIVE_COLORIMETRIC = 1
+    SATURATION = 2
+    ABSOLUTE_COLORIMETRIC = 3
+
+
+class Direction(IntEnum):
+    INPUT = 0
+    OUTPUT = 1
+    PROOF = 2
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {Intent: "INTENT_", Direction: "DIRECTION_"}.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
+
 
 #
 # flags
@@ -211,9 +241,9 @@
         output,
         input_mode,
         output_mode,
-        intent=INTENT_PERCEPTUAL,
+        intent=Intent.PERCEPTUAL,
         proof=None,
-        proof_intent=INTENT_ABSOLUTE_COLORIMETRIC,
+        proof_intent=Intent.ABSOLUTE_COLORIMETRIC,
         flags=0,
     ):
         if proof is None:
@@ -295,7 +325,7 @@
     im,
     inputProfile,
     outputProfile,
-    renderingIntent=INTENT_PERCEPTUAL,
+    renderingIntent=Intent.PERCEPTUAL,
     outputMode=None,
     inPlace=False,
     flags=0,
@@ -331,10 +361,10 @@
     :param renderingIntent: Integer (0-3) specifying the rendering intent you
         wish to use for the transform
 
-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3
 
         see the pyCMS documentation for details on rendering intents and what
         they do.
@@ -412,7 +442,7 @@
     outputProfile,
     inMode,
     outMode,
-    renderingIntent=INTENT_PERCEPTUAL,
+    renderingIntent=Intent.PERCEPTUAL,
     flags=0,
 ):
     """
@@ -458,10 +488,10 @@
     :param renderingIntent: Integer (0-3) specifying the rendering intent you
         wish to use for the transform
 
-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3
 
         see the pyCMS documentation for details on rendering intents and what
         they do.
@@ -494,8 +524,8 @@
     proofProfile,
     inMode,
     outMode,
-    renderingIntent=INTENT_PERCEPTUAL,
-    proofRenderingIntent=INTENT_ABSOLUTE_COLORIMETRIC,
+    renderingIntent=Intent.PERCEPTUAL,
+    proofRenderingIntent=Intent.ABSOLUTE_COLORIMETRIC,
     flags=FLAGS["SOFTPROOFING"],
 ):
     """
@@ -550,20 +580,20 @@
     :param renderingIntent: Integer (0-3) specifying the rendering intent you
         wish to use for the input->proof (simulated) transform
 
-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3
 
         see the pyCMS documentation for details on rendering intents and what
         they do.
     :param proofRenderingIntent: Integer (0-3) specifying the rendering intent
         you wish to use for proof->output transform
 
-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3
 
         see the pyCMS documentation for details on rendering intents and what
         they do.
@@ -922,10 +952,10 @@
     :returns: Integer 0-3 specifying the default rendering intent for this
         profile.
 
-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3
 
         see the pyCMS documentation for details on rendering intents and what
             they do.
@@ -960,19 +990,19 @@
     :param intent: Integer (0-3) specifying the rendering intent you wish to
         use with this profile
 
-            ImageCms.INTENT_PERCEPTUAL            = 0 (DEFAULT)
-            ImageCms.INTENT_RELATIVE_COLORIMETRIC = 1
-            ImageCms.INTENT_SATURATION            = 2
-            ImageCms.INTENT_ABSOLUTE_COLORIMETRIC = 3
+            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)
+            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1
+            ImageCms.Intent.SATURATION            = 2
+            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3
 
         see the pyCMS documentation for details on rendering intents and what
             they do.
     :param direction: Integer specifying if the profile is to be used for
         input, output, or proof
 
-            INPUT  = 0 (or use ImageCms.DIRECTION_INPUT)
-            OUTPUT = 1 (or use ImageCms.DIRECTION_OUTPUT)
-            PROOF  = 2 (or use ImageCms.DIRECTION_PROOF)
+            INPUT  = 0 (or use ImageCms.Direction.INPUT)
+            OUTPUT = 1 (or use ImageCms.Direction.OUTPUT)
+            PROOF  = 2 (or use ImageCms.Direction.PROOF)
 
     :returns: 1 if the intent/direction are supported, -1 if they are not.
     :exception PyCMSError:
('src/PIL', 'BufrStubImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -59,7 +59,7 @@
 
 
 def _save(im, fp, filename):
-    if _handler is None or not hasattr("_handler", "save"):
+    if _handler is None or not hasattr(_handler, "save"):
         raise OSError("BUFR save handler not installed")
     _handler.save(im, fp, filename)
 
('src/PIL', 'PSDraw.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -26,39 +26,36 @@
 class PSDraw:
     """
     Sets up printing to the given file. If ``fp`` is omitted,
-    :py:data:`sys.stdout` is assumed.
+    ``sys.stdout.buffer`` or ``sys.stdout`` is assumed.
     """
 
     def __init__(self, fp=None):
         if not fp:
-            fp = sys.stdout
+            try:
+                fp = sys.stdout.buffer
+            except AttributeError:
+                fp = sys.stdout
         self.fp = fp
-
-    def _fp_write(self, to_write):
-        if self.fp == sys.stdout:
-            self.fp.write(to_write)
-        else:
-            self.fp.write(bytes(to_write, "UTF-8"))
 
     def begin_document(self, id=None):
         """Set up printing of a document. (Write PostScript DSC header.)"""
         # FIXME: incomplete
-        self._fp_write(
-            "%!PS-Adobe-3.0\n"
-            "save\n"
-            "/showpage { } def\n"
-            "%%EndComments\n"
-            "%%BeginDocument\n"
+        self.fp.write(
+            b"%!PS-Adobe-3.0\n"
+            b"save\n"
+            b"/showpage { } def\n"
+            b"%%EndComments\n"
+            b"%%BeginDocument\n"
         )
-        # self._fp_write(ERROR_PS)  # debugging!
-        self._fp_write(EDROFF_PS)
-        self._fp_write(VDI_PS)
-        self._fp_write("%%EndProlog\n")
+        # self.fp.write(ERROR_PS)  # debugging!
+        self.fp.write(EDROFF_PS)
+        self.fp.write(VDI_PS)
+        self.fp.write(b"%%EndProlog\n")
         self.isofont = {}
 
     def end_document(self):
         """Ends printing. (Write PostScript DSC footer.)"""
-        self._fp_write("%%EndDocument\nrestore showpage\n%%End\n")
+        self.fp.write(b"%%EndDocument\nrestore showpage\n%%End\n")
         if hasattr(self.fp, "flush"):
             self.fp.flush()
 
@@ -69,12 +66,13 @@
         :param font: A PostScript font name
         :param size: Size in points.
         """
+        font = bytes(font, "UTF-8")
         if font not in self.isofont:
             # reencode font
-            self._fp_write(f"/PSDraw-{font} ISOLatin1Encoding /{font} E\n")
+            self.fp.write(b"/PSDraw-%s ISOLatin1Encoding /%s E\n" % (font, font))
             self.isofont[font] = 1
         # rough
-        self._fp_write(f"/F0 {size} /PSDraw-{font} F\n")
+        self.fp.write(b"/F0 %d /PSDraw-%s F\n" % (size, font))
 
     def line(self, xy0, xy1):
         """
@@ -82,7 +80,7 @@
         PostScript point coordinates (72 points per inch, (0, 0) is the lower
         left corner of the page).
         """
-        self._fp_write("%d %d %d %d Vl\n" % (*xy0, *xy1))
+        self.fp.write(b"%d %d %d %d Vl\n" % (*xy0, *xy1))
 
     def rectangle(self, box):
         """
@@ -97,16 +95,18 @@
 
                         %d %d M %d %d 0 Vr\n
         """
-        self._fp_write("%d %d M %d %d 0 Vr\n" % box)
+        self.fp.write(b"%d %d M %d %d 0 Vr\n" % box)
 
     def text(self, xy, text):
         """
         Draws text at the given position. You must use
         :py:meth:`~PIL.PSDraw.PSDraw.setfont` before calling this method.
         """
-        text = "\\(".join(text.split("("))
-        text = "\\)".join(text.split(")"))
-        self._fp_write(f"{xy[0]} {xy[1]} M ({text}) S\n")
+        text = bytes(text, "UTF-8")
+        text = b"\\(".join(text.split(b"("))
+        text = b"\\)".join(text.split(b")"))
+        xy += (text,)
+        self.fp.write(b"%d %d M (%s) S\n" % xy)
 
     def image(self, box, im, dpi=None):
         """Draw a PIL image, centered in the given box."""
@@ -130,14 +130,14 @@
             y = ymax
         dx = (xmax - x) / 2 + box[0]
         dy = (ymax - y) / 2 + box[1]
-        self._fp_write(f"gsave\n{dx:f} {dy:f} translate\n")
+        self.fp.write(b"gsave\n%f %f translate\n" % (dx, dy))
         if (x, y) != im.size:
             # EpsImagePlugin._save prints the image at (0,0,xsize,ysize)
             sx = x / im.size[0]
             sy = y / im.size[1]
-            self._fp_write(f"{sx:f} {sy:f} scale\n")
+            self.fp.write(b"%f %f scale\n" % (sx, sy))
         EpsImagePlugin._save(im, self.fp, None, 0)
-        self._fp_write("\ngrestore\n")
+        self.fp.write(b"\ngrestore\n")
 
 
 # --------------------------------------------------------------------
@@ -153,7 +153,7 @@
 #
 
 
-EDROFF_PS = """\
+EDROFF_PS = b"""\
 /S { show } bind def
 /P { moveto show } bind def
 /M { moveto } bind def
@@ -182,7 +182,7 @@
 # Copyright (c) Fredrik Lundh 1994.
 #
 
-VDI_PS = """\
+VDI_PS = b"""\
 /Vm { moveto } bind def
 /Va { newpath arcn stroke } bind def
 /Vl { moveto lineto stroke } bind def
@@ -207,7 +207,7 @@
 # 89-11-21 fl: created (pslist 1.10)
 #
 
-ERROR_PS = """\
+ERROR_PS = b"""\
 /landscape false def
 /errorBUF 200 string def
 /errorNL { currentpoint 10 sub exch pop 72 exch moveto } def
('src/PIL', 'ImageFilter.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,11 +16,6 @@
 #
 import functools
 
-try:
-    import numpy
-except ImportError:  # pragma: no cover
-    numpy = None
-
 
 class Filter:
     pass
@@ -154,9 +149,11 @@
 
 
 class GaussianBlur(MultibandFilter):
-    """Gaussian blur filter.
-
-    :param radius: Blur radius.
+    """Blurs the image with a sequence of extended box filters, which
+    approximates a Gaussian kernel. For details on accuracy see
+    <https://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf>
+
+    :param radius: Standard deviation of the Gaussian kernel.
     """
 
     name = "GaussianBlur"
@@ -368,6 +365,13 @@
         copy_table = kwargs.get("_copy_table", True)
         items = size[0] * size[1] * size[2]
         wrong_size = False
+
+        numpy = None
+        if hasattr(table, "shape"):
+            try:
+                import numpy
+            except ImportError:  # pragma: no cover
+                pass
 
         if numpy and isinstance(table, numpy.ndarray):
             if copy_table:
@@ -525,7 +529,7 @@
 
         return image.color_lut_3d(
             self.mode or image.mode,
-            Image.LINEAR,
+            Image.Resampling.BILINEAR,
             self.channels,
             self.size[0],
             self.size[1],
('src/PIL', '__init__.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -13,72 +13,12 @@
 ;-)
 """
 
-import sys
-import warnings
-
 from . import _version
 
 # VERSION was removed in Pillow 6.0.0.
+# PILLOW_VERSION was removed in Pillow 9.0.0.
+# Use __version__ instead.
 __version__ = _version.__version__
-
-
-# PILLOW_VERSION is deprecated and will be removed in a future release.
-# Use __version__ instead.
-def _raise_version_warning():
-    warnings.warn(
-        "PILLOW_VERSION is deprecated and will be removed in Pillow 9 (2022-01-02). "
-        "Use __version__ instead.",
-        DeprecationWarning,
-        stacklevel=3,
-    )
-
-
-if sys.version_info >= (3, 7):
-
-    def __getattr__(name):
-        if name == "PILLOW_VERSION":
-            _raise_version_warning()
-            return __version__
-        raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
-
-
-else:
-
-    class _Deprecated_Version(str):
-        def __str__(self):
-            _raise_version_warning()
-            return super().__str__()
-
-        def __getitem__(self, key):
-            _raise_version_warning()
-            return super().__getitem__(key)
-
-        def __eq__(self, other):
-            _raise_version_warning()
-            return super().__eq__(other)
-
-        def __ne__(self, other):
-            _raise_version_warning()
-            return super().__ne__(other)
-
-        def __gt__(self, other):
-            _raise_version_warning()
-            return super().__gt__(other)
-
-        def __lt__(self, other):
-            _raise_version_warning()
-            return super().__lt__(other)
-
-        def __ge__(self, other):
-            _raise_version_warning()
-            return super().__gt__(other)
-
-        def __le__(self, other):
-            _raise_version_warning()
-            return super().__lt__(other)
-
-    PILLOW_VERSION = _Deprecated_Version(__version__)
-
 del _version
 
 
@@ -90,6 +30,7 @@
     "DcxImagePlugin",
     "DdsImagePlugin",
     "EpsImagePlugin",
+    "FitsImagePlugin",
     "FitsStubImagePlugin",
     "FliImagePlugin",
     "FpxImagePlugin",
('src/PIL', 'JpegPresets.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -52,19 +52,11 @@
 
   im.quantization
 
-This will return a dict with a number of arrays. You can pass this dict
+This will return a dict with a number of lists. You can pass this dict
 directly as the qtables argument when saving a JPEG.
 
-The tables format between im.quantization and quantization in presets differ in
-3 ways:
-
-1. The base container of the preset is a list with sublists instead of dict.
-   dict[0] -> list[0], dict[1] -> list[1], ...
-2. Each table in a preset is a list instead of an array.
-3. The zigzag order is remove in the preset (needed by libjpeg >= 6a).
-
-You can convert the dict format to the preset format with the
-:func:`.JpegImagePlugin.convert_dict_qtables()` function.
+The quantization table format in presets is a list with sublists. These formats
+are interchangeable.
 
 Libjpeg ref.:
 https://web.archive.org/web/20120328125543/http://www.jpegcameras.com/libjpeg/libjpeg-3.html
('src/PIL', 'Hdf5StubImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -59,7 +59,7 @@
 
 
 def _save(im, fp, filename):
-    if _handler is None or not hasattr("_handler", "save"):
+    if _handler is None or not hasattr(_handler, "save"):
         raise OSError("HDF5 save handler not installed")
     _handler.save(im, fp, filename)
 
('src/PIL', 'features.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -9,7 +9,7 @@
 
 modules = {
     "pil": ("PIL._imaging", "PILLOW_VERSION"),
-    "tkinter": ("PIL._tkinter_finder", None),
+    "tkinter": ("PIL._tkinter_finder", "tk_version"),
     "freetype2": ("PIL._imagingft", "freetype2_version"),
     "littlecms2": ("PIL._imagingcms", "littlecms_version"),
     "webp": ("PIL._webp", "webpdecoder_version"),
@@ -118,6 +118,8 @@
     "webp_mux": ("PIL._webp", "HAVE_WEBPMUX", None),
     "transp_webp": ("PIL._webp", "HAVE_TRANSPARENCY", None),
     "raqm": ("PIL._imagingft", "HAVE_RAQM", "raqm_version"),
+    "fribidi": ("PIL._imagingft", "HAVE_FRIBIDI", "fribidi_version"),
+    "harfbuzz": ("PIL._imagingft", "HAVE_HARFBUZZ", "harfbuzz_version"),
     "libjpeg_turbo": ("PIL._imaging", "HAVE_LIBJPEGTURBO", "libjpeg_turbo_version"),
     "libimagequant": ("PIL._imaging", "HAVE_LIBIMAGEQUANT", "imagequant_version"),
     "xcb": ("PIL._imaging", "HAVE_XCB", None),
@@ -216,7 +218,7 @@
 def pilinfo(out=None, supported_formats=True):
     """
     Prints information about this installation of Pillow.
-    This function can be called with ``python -m PIL``.
+    This function can be called with ``python3 -m PIL``.
 
     :param out:
         The output stream to print to. Defaults to ``sys.stdout`` if ``None``.
@@ -274,6 +276,11 @@
                     # this check is also in src/_imagingcms.c:setup_module()
                     version_static = tuple(int(x) for x in v.split(".")) < (2, 7)
                 t = "compiled for" if version_static else "loaded"
+                if name == "raqm":
+                    for f in ("fribidi", "harfbuzz"):
+                        v2 = version_feature(f)
+                        if v2 is not None:
+                            v += f", {f} {v2}"
                 print("---", feature, "support ok,", t, v, file=out)
             else:
                 print("---", feature, "support ok", file=out)
('src/PIL', 'ImageDraw.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -33,7 +33,7 @@
 import math
 import numbers
 
-from . import Image, ImageColor
+from . import Image, ImageColor, ImageFont
 
 """
 A simple 2D drawing interface for PIL images.
@@ -70,6 +70,7 @@
             self.palette = im.palette
         else:
             self.palette = None
+        self._image = im
         self.im = im.im
         self.draw = Image.core.draw(self.im, blend)
         self.mode = mode
@@ -108,13 +109,13 @@
                 if isinstance(ink, str):
                     ink = ImageColor.getcolor(ink, self.mode)
                 if self.palette and not isinstance(ink, numbers.Number):
-                    ink = self.palette.getcolor(ink)
+                    ink = self.palette.getcolor(ink, self._image)
                 ink = self.draw.draw_ink(ink)
             if fill is not None:
                 if isinstance(fill, str):
                     fill = ImageColor.getcolor(fill, self.mode)
                 if self.palette and not isinstance(fill, numbers.Number):
-                    fill = self.palette.getcolor(fill)
+                    fill = self.palette.getcolor(fill, self._image)
                 fill = self.draw.draw_ink(fill)
         return ink, fill
 
@@ -173,13 +174,11 @@
                         angle -= 90
                         distance = width / 2 - 1
                         return tuple(
-                            [
-                                p + (math.floor(p_d) if p_d > 0 else math.ceil(p_d))
-                                for p, p_d in (
-                                    (x, distance * math.cos(math.radians(angle))),
-                                    (y, distance * math.sin(math.radians(angle))),
-                                )
-                            ]
+                            p + (math.floor(p_d) if p_d > 0 else math.ceil(p_d))
+                            for p, p_d in (
+                                (x, distance * math.cos(math.radians(angle))),
+                                (y, distance * math.sin(math.radians(angle))),
+                            )
                         )
 
                     flipped = (
@@ -234,13 +233,35 @@
         if ink is not None:
             self.draw.draw_points(xy, ink)
 
-    def polygon(self, xy, fill=None, outline=None):
+    def polygon(self, xy, fill=None, outline=None, width=1):
         """Draw a polygon."""
         ink, fill = self._getink(outline, fill)
         if fill is not None:
             self.draw.draw_polygon(xy, fill, 1)
-        if ink is not None and ink != fill:
-            self.draw.draw_polygon(xy, ink, 0)
+        if ink is not None and ink != fill and width != 0:
+            if width == 1:
+                self.draw.draw_polygon(xy, ink, 0, width)
+            else:
+                # To avoid expanding the polygon outwards,
+                # use the fill as a mask
+                mask = Image.new("1", self.im.size)
+                mask_ink = self._getink(1)[0]
+
+                fill_im = mask.copy()
+                draw = Draw(fill_im)
+                draw.draw.draw_polygon(xy, mask_ink, 1)
+
+                ink_im = mask.copy()
+                draw = Draw(ink_im)
+                width = width * 2 - 1
+                draw.draw.draw_polygon(xy, mask_ink, 0, width)
+
+                mask.paste(ink_im, mask=fill_im)
+
+                im = Image.new(self.mode, self.im.size)
+                draw = Draw(im)
+                draw.draw.draw_polygon(xy, ink, 0, width)
+                self.im.paste(im.im, (0, 0) + im.size, mask.im)
 
     def regular_polygon(
         self, bounding_circle, n_sides, rotation=0, fill=None, outline=None
@@ -256,6 +277,89 @@
             self.draw.draw_rectangle(xy, fill, 1)
         if ink is not None and ink != fill and width != 0:
             self.draw.draw_rectangle(xy, ink, 0, width)
+
+    def rounded_rectangle(self, xy, radius=0, fill=None, outline=None, width=1):
+        """Draw a rounded rectangle."""
+        if isinstance(xy[0], (list, tuple)):
+            (x0, y0), (x1, y1) = xy
+        else:
+            x0, y0, x1, y1 = xy
+
+        d = radius * 2
+
+        full_x = d >= x1 - x0
+        if full_x:
+            # The two left and two right corners are joined
+            d = x1 - x0
+        full_y = d >= y1 - y0
+        if full_y:
+            # The two top and two bottom corners are joined
+            d = y1 - y0
+        if full_x and full_y:
+            # If all corners are joined, that is a circle
+            return self.ellipse(xy, fill, outline, width)
+
+        if d == 0:
+            # If the corners have no curve, that is a rectangle
+            return self.rectangle(xy, fill, outline, width)
+
+        r = d // 2
+        ink, fill = self._getink(outline, fill)
+
+        def draw_corners(pieslice):
+            if full_x:
+                # Draw top and bottom halves
+                parts = (
+                    ((x0, y0, x0 + d, y0 + d), 180, 360),
+                    ((x0, y1 - d, x0 + d, y1), 0, 180),
+                )
+            elif full_y:
+                # Draw left and right halves
+                parts = (
+                    ((x0, y0, x0 + d, y0 + d), 90, 270),
+                    ((x1 - d, y0, x1, y0 + d), 270, 90),
+                )
+            else:
+                # Draw four separate corners
+                parts = (
+                    ((x1 - d, y0, x1, y0 + d), 270, 360),
+                    ((x1 - d, y1 - d, x1, y1), 0, 90),
+                    ((x0, y1 - d, x0 + d, y1), 90, 180),
+                    ((x0, y0, x0 + d, y0 + d), 180, 270),
+                )
+            for part in parts:
+                if pieslice:
+                    self.draw.draw_pieslice(*(part + (fill, 1)))
+                else:
+                    self.draw.draw_arc(*(part + (ink, width)))
+
+        if fill is not None:
+            draw_corners(True)
+
+            if full_x:
+                self.draw.draw_rectangle((x0, y0 + r + 1, x1, y1 - r - 1), fill, 1)
+            else:
+                self.draw.draw_rectangle((x0 + r + 1, y0, x1 - r - 1, y1), fill, 1)
+            if not full_x and not full_y:
+                self.draw.draw_rectangle((x0, y0 + r + 1, x0 + r, y1 - r - 1), fill, 1)
+                self.draw.draw_rectangle((x1 - r, y0 + r + 1, x1, y1 - r - 1), fill, 1)
+        if ink is not None and ink != fill and width != 0:
+            draw_corners(False)
+
+            if not full_x:
+                self.draw.draw_rectangle(
+                    (x0 + r + 1, y0, x1 - r - 1, y0 + width - 1), ink, 1
+                )
+                self.draw.draw_rectangle(
+                    (x0 + r + 1, y1 - width + 1, x1 - r - 1, y1), ink, 1
+                )
+            if not full_y:
+                self.draw.draw_rectangle(
+                    (x0, y0 + r + 1, x0 + width - 1, y1 - r - 1), ink, 1
+                )
+                self.draw.draw_rectangle(
+                    (x1 - width + 1, y0 + r + 1, x1, y1 - r - 1), ink, 1
+                )
 
     def _multiline_check(self, text):
         """Draw text."""
@@ -563,6 +667,8 @@
 
         if font is None:
             font = self.getfont()
+        if not isinstance(font, ImageFont.FreeTypeFont):
+            raise ValueError("Only supported for TrueType fonts")
         mode = "RGBA" if embedded_color else self.fontmode
         bbox = font.getbbox(
             text, mode, direction, features, language, stroke_width, anchor
@@ -893,6 +999,6 @@
     Uses 1-norm distance to calculate difference between two values.
     """
     if isinstance(color2, tuple):
-        return sum([abs(color1[i] - color2[i]) for i in range(0, len(color2))])
+        return sum(abs(color1[i] - color2[i]) for i in range(0, len(color2)))
     else:
         return abs(color1 - color2)
('src/PIL', 'IcoImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -22,7 +22,6 @@
 #   * https://msdn.microsoft.com/en-us/library/ms997538.aspx
 
 
-import struct
 import warnings
 from io import BytesIO
 from math import ceil, log
@@ -30,6 +29,9 @@
 from . import BmpImagePlugin, Image, ImageFile, PngImagePlugin
 from ._binary import i16le as i16
 from ._binary import i32le as i32
+from ._binary import o8
+from ._binary import o16le as o16
+from ._binary import o32le as o32
 
 #
 # --------------------------------------------------------------------
@@ -39,43 +41,72 @@
 
 def _save(im, fp, filename):
     fp.write(_MAGIC)  # (2+2)
+    bmp = im.encoderinfo.get("bitmap_format") == "bmp"
     sizes = im.encoderinfo.get(
         "sizes",
         [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],
     )
+    frames = []
+    provided_ims = [im] + im.encoderinfo.get("append_images", [])
     width, height = im.size
-    sizes = filter(
-        lambda x: False
-        if (x[0] > width or x[1] > height or x[0] > 256 or x[1] > 256)
-        else True,
-        sizes,
-    )
-    sizes = list(sizes)
-    fp.write(struct.pack("<H", len(sizes)))  # idCount(2)
-    offset = fp.tell() + len(sizes) * 16
-    provided_images = {im.size: im for im in im.encoderinfo.get("append_images", [])}
-    for size in sizes:
-        width, height = size
+    for size in sorted(set(sizes)):
+        if size[0] > width or size[1] > height or size[0] > 256 or size[1] > 256:
+            continue
+
+        for provided_im in provided_ims:
+            if provided_im.size != size:
+                continue
+            frames.append(provided_im)
+            if bmp:
+                bits = BmpImagePlugin.SAVE[provided_im.mode][1]
+                bits_used = [bits]
+                for other_im in provided_ims:
+                    if other_im.size != size:
+                        continue
+                    bits = BmpImagePlugin.SAVE[other_im.mode][1]
+                    if bits not in bits_used:
+                        # Another image has been supplied for this size
+                        # with a different bit depth
+                        frames.append(other_im)
+                        bits_used.append(bits)
+            break
+        else:
+            # TODO: invent a more convenient method for proportional scalings
+            frame = provided_im.copy()
+            frame.thumbnail(size, Image.Resampling.LANCZOS, reducing_gap=None)
+            frames.append(frame)
+    fp.write(o16(len(frames)))  # idCount(2)
+    offset = fp.tell() + len(frames) * 16
+    for frame in frames:
+        width, height = frame.size
         # 0 means 256
-        fp.write(struct.pack("B", width if width < 256 else 0))  # bWidth(1)
-        fp.write(struct.pack("B", height if height < 256 else 0))  # bHeight(1)
-        fp.write(b"\0")  # bColorCount(1)
+        fp.write(o8(width if width < 256 else 0))  # bWidth(1)
+        fp.write(o8(height if height < 256 else 0))  # bHeight(1)
+
+        bits, colors = BmpImagePlugin.SAVE[frame.mode][1:] if bmp else (32, 0)
+        fp.write(o8(colors))  # bColorCount(1)
         fp.write(b"\0")  # bReserved(1)
         fp.write(b"\0\0")  # wPlanes(2)
-        fp.write(struct.pack("<H", 32))  # wBitCount(2)
+        fp.write(o16(bits))  # wBitCount(2)
 
         image_io = BytesIO()
-        tmp = provided_images.get(size)
-        if not tmp:
-            # TODO: invent a more convenient method for proportional scalings
-            tmp = im.copy()
-            tmp.thumbnail(size, Image.LANCZOS, reducing_gap=None)
-        tmp.save(image_io, "png")
+        if bmp:
+            frame.save(image_io, "dib")
+
+            if bits != 32:
+                and_mask = Image.new("1", size)
+                ImageFile._save(
+                    and_mask, image_io, [("raw", (0, 0) + size, 0, ("1", 0, -1))]
+                )
+        else:
+            frame.save(image_io, "png")
         image_io.seek(0)
         image_bytes = image_io.read()
+        if bmp:
+            image_bytes = image_bytes[:8] + o32(height * 2) + image_bytes[12:]
         bytes_len = len(image_bytes)
-        fp.write(struct.pack("<I", bytes_len))  # dwBytesInRes(4)
-        fp.write(struct.pack("<I", offset))  # dwImageOffset(4)
+        fp.write(o32(bytes_len))  # dwBytesInRes(4)
+        fp.write(o32(offset))  # dwImageOffset(4)
         current = fp.tell()
         fp.seek(offset)
         fp.write(image_bytes)
@@ -178,6 +209,7 @@
         if data[:8] == PngImagePlugin._MAGIC:
             # png frame
             im = PngImagePlugin.PngImageFile(self.buf)
+            Image._decompression_bomb_check(im.size)
         else:
             # XOR + AND mask bmp frame
             im = BmpImagePlugin.DibImageFile(self.buf)
@@ -189,13 +221,7 @@
             im.tile[0] = d, (0, 0) + im.size, o, a
 
             # figure out where AND mask image starts
-            mode = a[0]
-            bpp = 8
-            for k, v in BmpImagePlugin.BIT2MODE.items():
-                if mode == v[1]:
-                    bpp = k
-                    break
-
+            bpp = header["bpp"]
             if 32 == bpp:
                 # 32-bit color depth icon image allows semitransparent areas
                 # PIL's DIB format ignores transparency bits, recover them.
@@ -225,8 +251,8 @@
                 # the total mask data is
                 # padded row size * height / bits per char
 
-                and_mask_offset = o + int(im.size[0] * im.size[1] * (bpp / 8.0))
                 total_bytes = int((w * im.size[1]) / 8)
+                and_mask_offset = header["offset"] + header["size"] - total_bytes
 
                 self.buf.seek(and_mask_offset)
                 mask_data = self.buf.read(total_bytes)
@@ -266,7 +292,8 @@
     Handles classic, XP and Vista icon formats.
 
     When saving, PNG compression is used. Support for this was only added in
-    Windows Vista.
+    Windows Vista. If you are unable to view the icon in Windows, convert the
+    image to "RGBA" mode before saving.
 
     This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis
     <casadebender@gmail.com>.
@@ -293,9 +320,9 @@
         self._size = value
 
     def load(self):
-        if self.im and self.im.size == self.size:
+        if self.im is not None and self.im.size == self.size:
             # Already loaded
-            return
+            return Image.Image.load(self)
         im = self.ico.getimage(self.size)
         # if tile is PNG, it won't really be loaded yet
         im.load()
('src/PIL', '_tkinter_finder.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -1,9 +1,25 @@
 """ Find compiled module linking to Tcl / Tk libraries
 """
 import sys
+import tkinter
+import warnings
 from tkinter import _tkinter as tk
 
-if hasattr(sys, "pypy_find_executable"):
-    TKINTER_LIB = tk.tklib_cffi.__file__
-else:
-    TKINTER_LIB = tk.__file__
+try:
+    if hasattr(sys, "pypy_find_executable"):
+        TKINTER_LIB = tk.tklib_cffi.__file__
+    else:
+        TKINTER_LIB = tk.__file__
+except AttributeError:
+    # _tkinter may be compiled directly into Python, in which case __file__ is
+    # not available. load_tkinter_funcs will check the binary first in any case.
+    TKINTER_LIB = None
+
+tk_version = str(tkinter.TkVersion)
+if tk_version == "8.4":
+    warnings.warn(
+        "Support for Tk/Tcl 8.4 is deprecated and will be removed"
+        " in Pillow 10 (2023-07-01). Please upgrade to Tk/Tcl 8.5 "
+        "or newer.",
+        DeprecationWarning,
+    )
('src/PIL', 'EpsImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -61,7 +61,7 @@
     return False
 
 
-def Ghostscript(tile, size, fp, scale=1):
+def Ghostscript(tile, size, fp, scale=1, transparency=False):
     """Render an image using Ghostscript"""
 
     # Unpack decoder tile
@@ -108,6 +108,8 @@
                 lengthfile -= len(s)
                 f.write(s)
 
+    device = "pngalpha" if transparency else "ppmraw"
+
     # Build Ghostscript command
     command = [
         "gs",
@@ -117,7 +119,7 @@
         "-dBATCH",  # exit after processing
         "-dNOPAUSE",  # don't pause between pages
         "-dSAFER",  # safe mode
-        "-sDEVICE=ppmraw",  # ppm driver
+        f"-sDEVICE={device}",
         f"-sOutputFile={outfile}",  # output file
         # adjust for image origin
         "-c",
@@ -170,12 +172,12 @@
         self.fp.seek(offset, whence)
 
     def readline(self):
-        s = self.char or b""
+        s = [self.char or b""]
         self.char = None
 
         c = self.fp.read(1)
-        while c not in b"\r\n":
-            s = s + c
+        while (c not in b"\r\n") and len(c):
+            s.append(c)
             c = self.fp.read(1)
 
         self.char = self.fp.read(1)
@@ -183,7 +185,7 @@
         if self.char in b"\r\n":
             self.char = None
 
-        return s.decode("latin-1")
+        return b"".join(s).decode("latin-1")
 
 
 def _accept(prefix):
@@ -325,14 +327,14 @@
 
         return (length, offset)
 
-    def load(self, scale=1):
+    def load(self, scale=1, transparency=False):
         # Load EPS via Ghostscript
-        if not self.tile:
-            return
-        self.im = Ghostscript(self.tile, self.size, self.fp, scale)
-        self.mode = self.im.mode
-        self._size = self.im.size
-        self.tile = []
+        if self.tile:
+            self.im = Ghostscript(self.tile, self.size, self.fp, scale, transparency)
+            self.mode = self.im.mode
+            self._size = self.im.size
+            self.tile = []
+        return Image.Image.load(self)
 
     def load_seek(self, *args, **kwargs):
         # we can't incrementally load, so force ImageFile.parser to
@@ -354,56 +356,46 @@
     #
     # determine PostScript image mode
     if im.mode == "L":
-        operator = (8, 1, "image")
+        operator = (8, 1, b"image")
     elif im.mode == "RGB":
-        operator = (8, 3, "false 3 colorimage")
+        operator = (8, 3, b"false 3 colorimage")
     elif im.mode == "CMYK":
-        operator = (8, 4, "false 4 colorimage")
+        operator = (8, 4, b"false 4 colorimage")
     else:
         raise ValueError("image mode is not supported")
 
-    base_fp = fp
-    wrapped_fp = False
-    if fp != sys.stdout:
-        fp = io.TextIOWrapper(fp, encoding="latin-1")
-        wrapped_fp = True
-
-    try:
-        if eps:
-            #
-            # write EPS header
-            fp.write("%!PS-Adobe-3.0 EPSF-3.0\n")
-            fp.write("%%Creator: PIL 0.1 EpsEncode\n")
-            # fp.write("%%CreationDate: %s"...)
-            fp.write("%%%%BoundingBox: 0 0 %d %d\n" % im.size)
-            fp.write("%%Pages: 1\n")
-            fp.write("%%EndComments\n")
-            fp.write("%%Page: 1 1\n")
-            fp.write("%%ImageData: %d %d " % im.size)
-            fp.write('%d %d 0 1 1 "%s"\n' % operator)
-
+    if eps:
         #
-        # image header
-        fp.write("gsave\n")
-        fp.write("10 dict begin\n")
-        fp.write(f"/buf {im.size[0] * operator[1]} string def\n")
-        fp.write("%d %d scale\n" % im.size)
-        fp.write("%d %d 8\n" % im.size)  # <= bits
-        fp.write(f"[{im.size[0]} 0 0 -{im.size[1]} 0 {im.size[1]}]\n")
-        fp.write("{ currentfile buf readhexstring pop } bind\n")
-        fp.write(operator[2] + "\n")
-        if hasattr(fp, "flush"):
-            fp.flush()
-
-        ImageFile._save(im, base_fp, [("eps", (0, 0) + im.size, 0, None)])
-
-        fp.write("\n%%%%EndBinary\n")
-        fp.write("grestore end\n")
-        if hasattr(fp, "flush"):
-            fp.flush()
-    finally:
-        if wrapped_fp:
-            fp.detach()
+        # write EPS header
+        fp.write(b"%!PS-Adobe-3.0 EPSF-3.0\n")
+        fp.write(b"%%Creator: PIL 0.1 EpsEncode\n")
+        # fp.write("%%CreationDate: %s"...)
+        fp.write(b"%%%%BoundingBox: 0 0 %d %d\n" % im.size)
+        fp.write(b"%%Pages: 1\n")
+        fp.write(b"%%EndComments\n")
+        fp.write(b"%%Page: 1 1\n")
+        fp.write(b"%%ImageData: %d %d " % im.size)
+        fp.write(b'%d %d 0 1 1 "%s"\n' % operator)
+
+    #
+    # image header
+    fp.write(b"gsave\n")
+    fp.write(b"10 dict begin\n")
+    fp.write(b"/buf %d string def\n" % (im.size[0] * operator[1]))
+    fp.write(b"%d %d scale\n" % im.size)
+    fp.write(b"%d %d 8\n" % im.size)  # <= bits
+    fp.write(b"[%d 0 0 -%d 0 %d]\n" % (im.size[0], im.size[1], im.size[1]))
+    fp.write(b"{ currentfile buf readhexstring pop } bind\n")
+    fp.write(operator[2] + b"\n")
+    if hasattr(fp, "flush"):
+        fp.flush()
+
+    ImageFile._save(im, fp, [("eps", (0, 0) + im.size, 0, None)])
+
+    fp.write(b"\n%%%%EndBinary\n")
+    fp.write(b"grestore end\n")
+    if hasattr(fp, "flush"):
+        fp.flush()
 
 
 #
('src/PIL', 'TgaImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -93,9 +93,10 @@
 
         # orientation
         orientation = flags & 0x30
-        if orientation == 0x20:
+        self._flip_horizontally = orientation in [0x10, 0x30]
+        if orientation in [0x20, 0x30]:
             orientation = 1
-        elif not orientation:
+        elif orientation in [0, 0x10]:
             orientation = -1
         else:
             raise SyntaxError("unknown TGA orientation")
@@ -110,10 +111,10 @@
 
         if colormaptype:
             # read palette
-            start, size, mapdepth = i16(s, 3), i16(s, 5), i16(s, 7)
+            start, size, mapdepth = i16(s, 3), i16(s, 5), s[7]
             if mapdepth == 16:
                 self.palette = ImagePalette.raw(
-                    "BGR;16", b"\0" * 2 * start + self.fp.read(2 * size)
+                    "BGR;15", b"\0" * 2 * start + self.fp.read(2 * size)
                 )
             elif mapdepth == 24:
                 self.palette = ImagePalette.raw(
@@ -149,6 +150,10 @@
         except KeyError:
             pass  # cannot decode
 
+    def load_end(self):
+        if self._flip_horizontally:
+            self.im = self.im.transpose(Image.Transpose.FLIP_LEFT_RIGHT)
+
 
 #
 # --------------------------------------------------------------------
('src/PIL', 'ImageMorph.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -196,7 +196,7 @@
             raise Exception("No operator loaded")
 
         if image.mode != "L":
-            raise Exception("Image must be binary, meaning it must use mode L")
+            raise ValueError("Image mode must be L")
         outimage = Image.new(image.mode, image.size, None)
         count = _imagingmorph.apply(bytes(self.lut), image.im.id, outimage.im.id)
         return count, outimage
@@ -211,7 +211,7 @@
             raise Exception("No operator loaded")
 
         if image.mode != "L":
-            raise Exception("Image must be binary, meaning it must use mode L")
+            raise ValueError("Image mode must be L")
         return _imagingmorph.match(bytes(self.lut), image.im.id)
 
     def get_on_pixels(self, image):
@@ -221,7 +221,7 @@
         of all matching pixels. See :ref:`coordinate-system`."""
 
         if image.mode != "L":
-            raise Exception("Image must be binary, meaning it must use mode L")
+            raise ValueError("Image mode must be L")
         return _imagingmorph.get_on_pixels(image.im.id)
 
     def load_lut(self, filename):
('src/PIL', 'Jpeg2KImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,6 +6,7 @@
 #
 # History:
 # 2014-03-12 ajh  Created
+# 2021-06-30 rogermb  Extract dpi information from the 'resc' header box
 #
 # Copyright (c) 2014 Coriolis Systems Limited
 # Copyright (c) 2014 Alastair Houghton
@@ -17,6 +18,79 @@
 import struct
 
 from . import Image, ImageFile
+
+
+class BoxReader:
+    """
+    A small helper class to read fields stored in JPEG2000 header boxes
+    and to easily step into and read sub-boxes.
+    """
+
+    def __init__(self, fp, length=-1):
+        self.fp = fp
+        self.has_length = length >= 0
+        self.length = length
+        self.remaining_in_box = -1
+
+    def _can_read(self, num_bytes):
+        if self.has_length and self.fp.tell() + num_bytes > self.length:
+            # Outside box: ensure we don't read past the known file length
+            return False
+        if self.remaining_in_box >= 0:
+            # Inside box contents: ensure read does not go past box boundaries
+            return num_bytes <= self.remaining_in_box
+        else:
+            return True  # No length known, just read
+
+    def _read_bytes(self, num_bytes):
+        if not self._can_read(num_bytes):
+            raise SyntaxError("Not enough data in header")
+
+        data = self.fp.read(num_bytes)
+        if len(data) < num_bytes:
+            raise OSError(
+                f"Expected to read {num_bytes} bytes but only got {len(data)}."
+            )
+
+        if self.remaining_in_box > 0:
+            self.remaining_in_box -= num_bytes
+        return data
+
+    def read_fields(self, field_format):
+        size = struct.calcsize(field_format)
+        data = self._read_bytes(size)
+        return struct.unpack(field_format, data)
+
+    def read_boxes(self):
+        size = self.remaining_in_box
+        data = self._read_bytes(size)
+        return BoxReader(io.BytesIO(data), size)
+
+    def has_next_box(self):
+        if self.has_length:
+            return self.fp.tell() + self.remaining_in_box < self.length
+        else:
+            return True
+
+    def next_box_type(self):
+        # Skip the rest of the box if it has not been read
+        if self.remaining_in_box > 0:
+            self.fp.seek(self.remaining_in_box, os.SEEK_CUR)
+        self.remaining_in_box = -1
+
+        # Read the length and type of the next box
+        lbox, tbox = self.read_fields(">I4s")
+        if lbox == 1:
+            lbox = self.read_fields(">Q")[0]
+            hlen = 16
+        else:
+            hlen = 8
+
+        if lbox < hlen or not self._can_read(lbox - hlen):
+            raise SyntaxError("Invalid header length")
+
+        self.remaining_in_box = lbox - hlen
+        return tbox
 
 
 def _parse_codestream(fp):
@@ -53,101 +127,71 @@
     return (size, mode)
 
 
+def _res_to_dpi(num, denom, exp):
+    """Convert JPEG2000's (numerator, denominator, exponent-base-10) resolution,
+    calculated as (num / denom) * 10^exp and stored in dots per meter,
+    to floating-point dots per inch."""
+    if denom != 0:
+        return (254 * num * (10**exp)) / (10000 * denom)
+
+
 def _parse_jp2_header(fp):
-    """Parse the JP2 header box to extract size, component count and
-    color space information, returning a (size, mode, mimetype) tuple."""
+    """Parse the JP2 header box to extract size, component count,
+    color space information, and optionally DPI information,
+    returning a (size, mode, mimetype, dpi) tuple."""
 
     # Find the JP2 header box
+    reader = BoxReader(fp)
     header = None
     mimetype = None
-    while True:
-        lbox, tbox = struct.unpack(">I4s", fp.read(8))
-        if lbox == 1:
-            lbox = struct.unpack(">Q", fp.read(8))[0]
-            hlen = 16
-        else:
-            hlen = 8
-
-        if lbox < hlen:
-            raise SyntaxError("Invalid JP2 header length")
+    while reader.has_next_box():
+        tbox = reader.next_box_type()
 
         if tbox == b"jp2h":
-            header = fp.read(lbox - hlen)
+            header = reader.read_boxes()
             break
         elif tbox == b"ftyp":
-            if fp.read(4) == b"jpx ":
+            if reader.read_fields(">4s")[0] == b"jpx ":
                 mimetype = "image/jpx"
-            fp.seek(lbox - hlen - 4, os.SEEK_CUR)
-        else:
-            fp.seek(lbox - hlen, os.SEEK_CUR)
-
-    if header is None:
-        raise SyntaxError("could not find JP2 header")
 
     size = None
     mode = None
     bpc = None
     nc = None
-
-    hio = io.BytesIO(header)
-    while True:
-        lbox, tbox = struct.unpack(">I4s", hio.read(8))
-        if lbox == 1:
-            lbox = struct.unpack(">Q", hio.read(8))[0]
-            hlen = 16
-        else:
-            hlen = 8
-
-        content = hio.read(lbox - hlen)
+    dpi = None  # 2-tuple of DPI info, or None
+
+    while header.has_next_box():
+        tbox = header.next_box_type()
 
         if tbox == b"ihdr":
-            height, width, nc, bpc, c, unkc, ipr = struct.unpack(">IIHBBBB", content)
+            height, width, nc, bpc = header.read_fields(">IIHB")
             size = (width, height)
-            if unkc:
-                if nc == 1 and (bpc & 0x7F) > 8:
-                    mode = "I;16"
-                elif nc == 1:
-                    mode = "L"
-                elif nc == 2:
-                    mode = "LA"
-                elif nc == 3:
-                    mode = "RGB"
-                elif nc == 4:
-                    mode = "RGBA"
-                break
-        elif tbox == b"colr":
-            meth, prec, approx = struct.unpack_from(">BBB", content)
-            if meth == 1:
-                cs = struct.unpack_from(">I", content, 3)[0]
-                if cs == 16:  # sRGB
-                    if nc == 1 and (bpc & 0x7F) > 8:
-                        mode = "I;16"
-                    elif nc == 1:
-                        mode = "L"
-                    elif nc == 3:
-                        mode = "RGB"
-                    elif nc == 4:
-                        mode = "RGBA"
+            if nc == 1 and (bpc & 0x7F) > 8:
+                mode = "I;16"
+            elif nc == 1:
+                mode = "L"
+            elif nc == 2:
+                mode = "LA"
+            elif nc == 3:
+                mode = "RGB"
+            elif nc == 4:
+                mode = "RGBA"
+        elif tbox == b"res ":
+            res = header.read_boxes()
+            while res.has_next_box():
+                tres = res.next_box_type()
+                if tres == b"resc":
+                    vrcn, vrcd, hrcn, hrcd, vrce, hrce = res.read_fields(">HHHHBB")
+                    hres = _res_to_dpi(hrcn, hrcd, hrce)
+                    vres = _res_to_dpi(vrcn, vrcd, vrce)
+                    if hres is not None and vres is not None:
+                        dpi = (hres, vres)
                     break
-                elif cs == 17:  # grayscale
-                    if nc == 1 and (bpc & 0x7F) > 8:
-                        mode = "I;16"
-                    elif nc == 1:
-                        mode = "L"
-                    elif nc == 2:
-                        mode = "LA"
-                    break
-                elif cs == 18:  # sYCC
-                    if nc == 3:
-                        mode = "RGB"
-                    elif nc == 4:
-                        mode = "RGBA"
-                    break
 
     if size is None or mode is None:
-        raise SyntaxError("Malformed jp2 header")
-
-    return (size, mode, mimetype)
+        raise SyntaxError("Malformed JP2 header")
+
+    return (size, mode, mimetype, dpi)
 
 
 ##
@@ -169,7 +213,9 @@
             if sig == b"\x00\x00\x00\x0cjP  \x0d\x0a\x87\x0a":
                 self.codec = "jp2"
                 header = _parse_jp2_header(self.fp)
-                self._size, self.mode, self.custom_mimetype = header
+                self._size, self.mode, self.custom_mimetype, dpi = header
+                if dpi is not None:
+                    self.info["dpi"] = dpi
             else:
                 raise SyntaxError("not a JPEG 2000 file")
 
@@ -244,13 +290,13 @@
 
 
 def _save(im, fp, filename):
-    if filename.endswith(".j2k"):
+    # Get the keyword arguments
+    info = im.encoderinfo
+
+    if filename.endswith(".j2k") or info.get("no_jp2", False):
         kind = "j2k"
     else:
         kind = "jp2"
-
-    # Get the keyword arguments
-    info = im.encoderinfo
 
     offset = info.get("offset", None)
     tile_offset = info.get("tile_offset", None)
@@ -274,6 +320,7 @@
     irreversible = info.get("irreversible", False)
     progression = info.get("progression", "LRCP")
     cinema_mode = info.get("cinema_mode", "no")
+    mct = info.get("mct", 0)
     fd = -1
 
     if hasattr(fp, "fileno"):
@@ -294,6 +341,7 @@
         irreversible,
         progression,
         cinema_mode,
+        mct,
         fd,
     )
 
('src/PIL', 'WalImageFile.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -23,10 +23,39 @@
     To open a WAL file, use the :py:func:`PIL.WalImageFile.open()` function instead.
 """
 
-import builtins
+from . import Image, ImageFile
+from ._binary import i32le as i32
 
-from . import Image
-from ._binary import i32le as i32
+
+class WalImageFile(ImageFile.ImageFile):
+
+    format = "WAL"
+    format_description = "Quake2 Texture"
+
+    def _open(self):
+        self.mode = "P"
+
+        # read header fields
+        header = self.fp.read(32 + 24 + 32 + 12)
+        self._size = i32(header, 32), i32(header, 36)
+        Image._decompression_bomb_check(self.size)
+
+        # load pixel data
+        offset = i32(header, 40)
+        self.fp.seek(offset)
+
+        # strings are null-terminated
+        self.info["name"] = header[:32].split(b"\0", 1)[0]
+        next_name = header[56 : 56 + 32].split(b"\0", 1)[0]
+        if next_name:
+            self.info["next_name"] = next_name
+
+    def load(self):
+        if not self.im:
+            self.im = Image.core.new(self.mode, self.size)
+            self.frombytes(self.fp.read(self.size[0] * self.size[1]))
+            self.putpalette(quake2palette)
+        return Image.Image.load(self)
 
 
 def open(filename):
@@ -39,38 +68,7 @@
     :param filename: WAL file name, or an opened file handle.
     :returns: An image instance.
     """
-    # FIXME: modify to return a WalImageFile instance instead of
-    # plain Image object ?
-
-    def imopen(fp):
-        # read header fields
-        header = fp.read(32 + 24 + 32 + 12)
-        size = i32(header, 32), i32(header, 36)
-        offset = i32(header, 40)
-
-        # load pixel data
-        fp.seek(offset)
-
-        Image._decompression_bomb_check(size)
-        im = Image.frombytes("P", size, fp.read(size[0] * size[1]))
-        im.putpalette(quake2palette)
-
-        im.format = "WAL"
-        im.format_description = "Quake2 Texture"
-
-        # strings are null-terminated
-        im.info["name"] = header[:32].split(b"\0", 1)[0]
-        next_name = header[56 : 56 + 32].split(b"\0", 1)[0]
-        if next_name:
-            im.info["next_name"] = next_name
-
-        return im
-
-    if hasattr(filename, "read"):
-        return imopen(filename)
-    else:
-        with builtins.open(filename, "rb") as fp:
-            return imopen(fp)
+    return WalImageFile(filename)
 
 
 quake2palette = (
('src/PIL', 'BlpImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -29,20 +29,56 @@
   - DXT5 compression is used if alpha_encoding == 7.
 """
 
+import os
 import struct
+import warnings
+from enum import IntEnum
 from io import BytesIO
 
 from . import Image, ImageFile
 
-BLP_FORMAT_JPEG = 0
-
-BLP_ENCODING_UNCOMPRESSED = 1
-BLP_ENCODING_DXT = 2
-BLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3
-
-BLP_ALPHA_ENCODING_DXT1 = 0
-BLP_ALPHA_ENCODING_DXT3 = 1
-BLP_ALPHA_ENCODING_DXT5 = 7
+
+class Format(IntEnum):
+    JPEG = 0
+
+
+class Encoding(IntEnum):
+    UNCOMPRESSED = 1
+    DXT = 2
+    UNCOMPRESSED_RAW_BGRA = 3
+
+
+class AlphaEncoding(IntEnum):
+    DXT1 = 0
+    DXT3 = 1
+    DXT5 = 7
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {
+        Format: "BLP_FORMAT_",
+        Encoding: "BLP_ENCODING_",
+        AlphaEncoding: "BLP_ALPHA_ENCODING_",
+    }.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
 
 
 def unpack_565(i):
@@ -231,6 +267,10 @@
     pass
 
 
+def _accept(prefix):
+    return prefix[:4] in (b"BLP1", b"BLP2")
+
+
 class BlpImageFile(ImageFile.ImageFile):
     """
     Blizzard Mipmap Format
@@ -241,36 +281,20 @@
 
     def _open(self):
         self.magic = self.fp.read(4)
-        self._read_blp_header()
-
-        if self.magic == b"BLP1":
-            decoder = "BLP1"
-            self.mode = "RGB"
-        elif self.magic == b"BLP2":
-            decoder = "BLP2"
-            self.mode = "RGBA" if self._blp_alpha_depth else "RGB"
+
+        self.fp.seek(5, os.SEEK_CUR)
+        (self._blp_alpha_depth,) = struct.unpack("<b", self.fp.read(1))
+
+        self.fp.seek(2, os.SEEK_CUR)
+        self._size = struct.unpack("<II", self.fp.read(8))
+
+        if self.magic in (b"BLP1", b"BLP2"):
+            decoder = self.magic.decode()
         else:
             raise BLPFormatError(f"Bad BLP magic {repr(self.magic)}")
 
+        self.mode = "RGBA" if self._blp_alpha_depth else "RGB"
         self.tile = [(decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]
-
-    def _read_blp_header(self):
-        (self._blp_compression,) = struct.unpack("<i", self.fp.read(4))
-
-        (self._blp_encoding,) = struct.unpack("<b", self.fp.read(1))
-        (self._blp_alpha_depth,) = struct.unpack("<b", self.fp.read(1))
-        (self._blp_alpha_encoding,) = struct.unpack("<b", self.fp.read(1))
-        (self._blp_mips,) = struct.unpack("<b", self.fp.read(1))
-
-        self._size = struct.unpack("<II", self.fp.read(8))
-
-        if self.magic == b"BLP1":
-            # Only present for BLP1
-            (self._blp_encoding,) = struct.unpack("<i", self.fp.read(4))
-            (self._blp_subtype,) = struct.unpack("<i", self.fp.read(4))
-
-        self._blp_offsets = struct.unpack("<16I", self.fp.read(16 * 4))
-        self._blp_lengths = struct.unpack("<16I", self.fp.read(16 * 4))
 
 
 class _BLPBaseDecoder(ImageFile.PyDecoder):
@@ -278,61 +302,69 @@
 
     def decode(self, buffer):
         try:
-            self.fd.seek(0)
-            self.magic = self.fd.read(4)
             self._read_blp_header()
             self._load()
         except struct.error as e:
-            raise OSError("Truncated Blp file") from e
-        return 0, 0
+            raise OSError("Truncated BLP file") from e
+        return -1, 0
+
+    def _read_blp_header(self):
+        self.fd.seek(4)
+        (self._blp_compression,) = struct.unpack("<i", self._safe_read(4))
+
+        (self._blp_encoding,) = struct.unpack("<b", self._safe_read(1))
+        (self._blp_alpha_depth,) = struct.unpack("<b", self._safe_read(1))
+        (self._blp_alpha_encoding,) = struct.unpack("<b", self._safe_read(1))
+        self.fd.seek(1, os.SEEK_CUR)  # mips
+
+        self.size = struct.unpack("<II", self._safe_read(8))
+
+        if isinstance(self, BLP1Decoder):
+            # Only present for BLP1
+            (self._blp_encoding,) = struct.unpack("<i", self._safe_read(4))
+            self.fd.seek(4, os.SEEK_CUR)  # subtype
+
+        self._blp_offsets = struct.unpack("<16I", self._safe_read(16 * 4))
+        self._blp_lengths = struct.unpack("<16I", self._safe_read(16 * 4))
+
+    def _safe_read(self, length):
+        return ImageFile._safe_read(self.fd, length)
 
     def _read_palette(self):
         ret = []
         for i in range(256):
             try:
-                b, g, r, a = struct.unpack("<4B", self.fd.read(4))
+                b, g, r, a = struct.unpack("<4B", self._safe_read(4))
             except struct.error:
                 break
             ret.append((b, g, r, a))
         return ret
 
-    def _read_blp_header(self):
-        (self._blp_compression,) = struct.unpack("<i", self.fd.read(4))
-
-        (self._blp_encoding,) = struct.unpack("<b", self.fd.read(1))
-        (self._blp_alpha_depth,) = struct.unpack("<b", self.fd.read(1))
-        (self._blp_alpha_encoding,) = struct.unpack("<b", self.fd.read(1))
-        (self._blp_mips,) = struct.unpack("<b", self.fd.read(1))
-
-        self.size = struct.unpack("<II", self.fd.read(8))
-
-        if self.magic == b"BLP1":
-            # Only present for BLP1
-            (self._blp_encoding,) = struct.unpack("<i", self.fd.read(4))
-            (self._blp_subtype,) = struct.unpack("<i", self.fd.read(4))
-
-        self._blp_offsets = struct.unpack("<16I", self.fd.read(16 * 4))
-        self._blp_lengths = struct.unpack("<16I", self.fd.read(16 * 4))
+    def _read_bgra(self, palette):
+        data = bytearray()
+        _data = BytesIO(self._safe_read(self._blp_lengths[0]))
+        while True:
+            try:
+                (offset,) = struct.unpack("<B", _data.read(1))
+            except struct.error:
+                break
+            b, g, r, a = palette[offset]
+            d = (r, g, b)
+            if self._blp_alpha_depth:
+                d += (a,)
+            data.extend(d)
+        return data
 
 
 class BLP1Decoder(_BLPBaseDecoder):
     def _load(self):
-        if self._blp_compression == BLP_FORMAT_JPEG:
+        if self._blp_compression == Format.JPEG:
             self._decode_jpeg_stream()
 
         elif self._blp_compression == 1:
             if self._blp_encoding in (4, 5):
-                data = bytearray()
                 palette = self._read_palette()
-                _data = BytesIO(self.fd.read(self._blp_lengths[0]))
-                while True:
-                    try:
-                        (offset,) = struct.unpack("<B", _data.read(1))
-                    except struct.error:
-                        break
-                    b, g, r, a = palette[offset]
-                    data.extend([r, g, b])
-
+                data = self._read_bgra(palette)
                 self.set_as_raw(bytes(data))
             else:
                 raise BLPFormatError(
@@ -344,59 +376,53 @@
             )
 
     def _decode_jpeg_stream(self):
-        from PIL.JpegImagePlugin import JpegImageFile
-
-        (jpeg_header_size,) = struct.unpack("<I", self.fd.read(4))
-        jpeg_header = self.fd.read(jpeg_header_size)
-        self.fd.read(self._blp_offsets[0] - self.fd.tell())  # What IS this?
-        data = self.fd.read(self._blp_lengths[0])
+        from .JpegImagePlugin import JpegImageFile
+
+        (jpeg_header_size,) = struct.unpack("<I", self._safe_read(4))
+        jpeg_header = self._safe_read(jpeg_header_size)
+        self._safe_read(self._blp_offsets[0] - self.fd.tell())  # What IS this?
+        data = self._safe_read(self._blp_lengths[0])
         data = jpeg_header + data
         data = BytesIO(data)
         image = JpegImageFile(data)
-        self.tile = image.tile  # :/
-        self.fd = image.fp
-        self.mode = image.mode
+        Image._decompression_bomb_check(image.size)
+        image.mode = "RGB"
+        image.tile = [("jpeg", (0, 0) + self.size, 0, ("BGRX", ""))]
+        self.set_as_raw(image.tobytes())
 
 
 class BLP2Decoder(_BLPBaseDecoder):
     def _load(self):
         palette = self._read_palette()
 
-        data = bytearray()
         self.fd.seek(self._blp_offsets[0])
 
         if self._blp_compression == 1:
             # Uncompressed or DirectX compression
 
-            if self._blp_encoding == BLP_ENCODING_UNCOMPRESSED:
-                _data = BytesIO(self.fd.read(self._blp_lengths[0]))
-                while True:
-                    try:
-                        (offset,) = struct.unpack("<B", _data.read(1))
-                    except struct.error:
-                        break
-                    b, g, r, a = palette[offset]
-                    data.extend((r, g, b))
-
-            elif self._blp_encoding == BLP_ENCODING_DXT:
-                if self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT1:
+            if self._blp_encoding == Encoding.UNCOMPRESSED:
+                data = self._read_bgra(palette)
+
+            elif self._blp_encoding == Encoding.DXT:
+                data = bytearray()
+                if self._blp_alpha_encoding == AlphaEncoding.DXT1:
                     linesize = (self.size[0] + 3) // 4 * 8
                     for yb in range((self.size[1] + 3) // 4):
                         for d in decode_dxt1(
-                            self.fd.read(linesize), alpha=bool(self._blp_alpha_depth)
+                            self._safe_read(linesize), alpha=bool(self._blp_alpha_depth)
                         ):
                             data += d
 
-                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT3:
+                elif self._blp_alpha_encoding == AlphaEncoding.DXT3:
                     linesize = (self.size[0] + 3) // 4 * 16
                     for yb in range((self.size[1] + 3) // 4):
-                        for d in decode_dxt3(self.fd.read(linesize)):
+                        for d in decode_dxt3(self._safe_read(linesize)):
                             data += d
 
-                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT5:
+                elif self._blp_alpha_encoding == AlphaEncoding.DXT5:
                     linesize = (self.size[0] + 3) // 4 * 16
                     for yb in range((self.size[1] + 3) // 4):
-                        for d in decode_dxt5(self.fd.read(linesize)):
+                        for d in decode_dxt5(self._safe_read(linesize)):
                             data += d
                 else:
                     raise BLPFormatError(
@@ -413,10 +439,59 @@
         self.set_as_raw(bytes(data))
 
 
-Image.register_open(
-    BlpImageFile.format, BlpImageFile, lambda p: p[:4] in (b"BLP1", b"BLP2")
-)
+class BLPEncoder(ImageFile.PyEncoder):
+    _pushes_fd = True
+
+    def _write_palette(self):
+        data = b""
+        palette = self.im.getpalette("RGBA", "RGBA")
+        for i in range(256):
+            r, g, b, a = palette[i * 4 : (i + 1) * 4]
+            data += struct.pack("<4B", b, g, r, a)
+        return data
+
+    def encode(self, bufsize):
+        palette_data = self._write_palette()
+
+        offset = 20 + 16 * 4 * 2 + len(palette_data)
+        data = struct.pack("<16I", offset, *((0,) * 15))
+
+        w, h = self.im.size
+        data += struct.pack("<16I", w * h, *((0,) * 15))
+
+        data += palette_data
+
+        for y in range(h):
+            for x in range(w):
+                data += struct.pack("<B", self.im.getpixel((x, y)))
+
+        return len(data), 0, data
+
+
+def _save(im, fp, filename, save_all=False):
+    if im.mode != "P":
+        raise ValueError("Unsupported BLP image mode")
+
+    magic = b"BLP1" if im.encoderinfo.get("blp_version") == "BLP1" else b"BLP2"
+    fp.write(magic)
+
+    fp.write(struct.pack("<i", 1))  # Uncompressed or DirectX compression
+    fp.write(struct.pack("<b", Encoding.UNCOMPRESSED))
+    fp.write(struct.pack("<b", 1 if im.palette.mode == "RGBA" else 0))
+    fp.write(struct.pack("<b", 0))  # alpha encoding
+    fp.write(struct.pack("<b", 0))  # mips
+    fp.write(struct.pack("<II", *im.size))
+    if magic == b"BLP1":
+        fp.write(struct.pack("<i", 5))
+        fp.write(struct.pack("<i", 0))
+
+    ImageFile._save(im, fp, [("BLP", (0, 0) + im.size, 0, im.mode)])
+
+
+Image.register_open(BlpImageFile.format, BlpImageFile, _accept)
 Image.register_extension(BlpImageFile.format, ".blp")
-
 Image.register_decoder("BLP1", BLP1Decoder)
 Image.register_decoder("BLP2", BLP2Decoder)
+
+Image.register_save(BlpImageFile.format, _save)
+Image.register_encoder("BLP", BLPEncoder)
('src/PIL', 'ImageTk.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -56,6 +56,33 @@
         source = BytesIO(kw.pop("data"))
     if source:
         return Image.open(source)
+
+
+def _pyimagingtkcall(command, photo, id):
+    tk = photo.tk
+    try:
+        tk.call(command, photo, id)
+    except tkinter.TclError:
+        # activate Tkinter hook
+        # may raise an error if it cannot attach to Tkinter
+        from . import _imagingtk
+
+        try:
+            if hasattr(tk, "interp"):
+                # Required for PyPy, which always has CFFI installed
+                from cffi import FFI
+
+                ffi = FFI()
+
+                # PyPy is using an FFI CDATA element
+                # (Pdb) self.tk.interp
+                #  <cdata 'Tcl_Interp *' 0x3061b50>
+                _imagingtk.tkinit(int(ffi.cast("uintptr_t", tk.interp)), 1)
+            else:
+                _imagingtk.tkinit(tk.interpaddr(), 1)
+        except AttributeError:
+            _imagingtk.tkinit(id(tk), 0)
+        tk.call(command, photo, id)
 
 
 # --------------------------------------------------------------------
@@ -170,33 +197,7 @@
             block = image.new_block(self.__mode, im.size)
             image.convert2(block, image)  # convert directly between buffers
 
-        tk = self.__photo.tk
-
-        try:
-            tk.call("PyImagingPhoto", self.__photo, block.id)
-        except tkinter.TclError:
-            # activate Tkinter hook
-            try:
-                from . import _imagingtk
-
-                try:
-                    if hasattr(tk, "interp"):
-                        # Required for PyPy, which always has CFFI installed
-                        from cffi import FFI
-
-                        ffi = FFI()
-
-                        # PyPy is using an FFI CDATA element
-                        # (Pdb) self.tk.interp
-                        #  <cdata 'Tcl_Interp *' 0x3061b50>
-                        _imagingtk.tkinit(int(ffi.cast("uintptr_t", tk.interp)), 1)
-                    else:
-                        _imagingtk.tkinit(tk.interpaddr(), 1)
-                except AttributeError:
-                    _imagingtk.tkinit(id(tk), 0)
-                tk.call("PyImagingPhoto", self.__photo, block.id)
-            except (ImportError, AttributeError, tkinter.TclError):
-                raise  # configuration problem; cannot attach to Tkinter
+        _pyimagingtkcall("PyImagingPhoto", self.__photo, block.id)
 
 
 # --------------------------------------------------------------------
@@ -276,7 +277,7 @@
     im = Image.new("RGBA", (photo.width(), photo.height()))
     block = im.im
 
-    photo.tk.call("PyImagingPhotoGet", photo, block.id)
+    _pyimagingtkcall("PyImagingPhotoGet", photo, block.id)
 
     return im
 
('src/PIL', 'GbrImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -43,9 +43,9 @@
 
     def _open(self):
         header_size = i32(self.fp.read(4))
-        version = i32(self.fp.read(4))
         if header_size < 20:
             raise SyntaxError("not a GIMP brush")
+        version = i32(self.fp.read(4))
         if version not in (1, 2):
             raise SyntaxError(f"Unsupported GIMP brush version: {version}")
 
@@ -84,12 +84,10 @@
         self._data_size = width * height * color_depth
 
     def load(self):
-        if self.im:
-            # Already loaded
-            return
-
-        self.im = Image.core.new(self.mode, self.size)
-        self.frombytes(self.fp.read(self._data_size))
+        if not self.im:
+            self.im = Image.core.new(self.mode, self.size)
+            self.frombytes(self.fp.read(self._data_size))
+        return Image.Image.load(self)
 
 
 #
('src/PIL', 'ImageOps.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -19,6 +19,7 @@
 
 import functools
 import operator
+import re
 
 from . import Image
 
@@ -61,7 +62,7 @@
 # actions
 
 
-def autocontrast(image, cutoff=0, ignore=None, mask=None):
+def autocontrast(image, cutoff=0, ignore=None, mask=None, preserve_tone=False):
     """
     Maximize (normalize) image contrast. This function calculates a
     histogram of the input image (or mask region), removes ``cutoff`` percent of the
@@ -77,9 +78,17 @@
     :param mask: Histogram used in contrast operation is computed using pixels
                  within the mask. If no mask is given the entire image is used
                  for histogram computation.
-    :return: An image.
-    """
-    histogram = image.histogram(mask)
+    :param preserve_tone: Preserve image tone in Photoshop-like style autocontrast.
+
+                          .. versionadded:: 8.2.0
+
+    :return: An image.
+    """
+    if preserve_tone:
+        histogram = image.convert("L").histogram(mask)
+    else:
+        histogram = image.histogram(mask)
+
     lut = []
     for layer in range(0, len(histogram), 256):
         h = histogram[layer : layer + 256]
@@ -228,15 +237,43 @@
     return _lut(image, red + green + blue)
 
 
-def pad(image, size, method=Image.BICUBIC, color=None, centering=(0.5, 0.5)):
-    """
-    Returns a sized and padded version of the image, expanded to fill the
-    requested aspect ratio and size.
-
-    :param image: The image to size and crop.
+def contain(image, size, method=Image.Resampling.BICUBIC):
+    """
+    Returns a resized version of the image, set to the maximum width and height
+    within the requested size, while maintaining the original aspect ratio.
+
+    :param image: The image to resize and crop.
     :param size: The requested output size in pixels, given as a
                  (width, height) tuple.
-    :param method: What resampling method to use. Default is
+    :param method: Resampling method to use. Default is
+                   :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
+    :return: An image.
+    """
+
+    im_ratio = image.width / image.height
+    dest_ratio = size[0] / size[1]
+
+    if im_ratio != dest_ratio:
+        if im_ratio > dest_ratio:
+            new_height = int(image.height / image.width * size[0])
+            if new_height != size[1]:
+                size = (size[0], new_height)
+        else:
+            new_width = int(image.width / image.height * size[1])
+            if new_width != size[0]:
+                size = (new_width, size[1])
+    return image.resize(size, resample=method)
+
+
+def pad(image, size, method=Image.Resampling.BICUBIC, color=None, centering=(0.5, 0.5)):
+    """
+    Returns a resized and padded version of the image, expanded to fill the
+    requested aspect ratio and size.
+
+    :param image: The image to resize and crop.
+    :param size: The requested output size in pixels, given as a
+                 (width, height) tuple.
+    :param method: Resampling method to use. Default is
                    :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
     :param color: The background color of the padded image.
     :param centering: Control the position of the original image within the
@@ -249,27 +286,17 @@
     :return: An image.
     """
 
-    im_ratio = image.width / image.height
-    dest_ratio = size[0] / size[1]
-
-    if im_ratio == dest_ratio:
-        out = image.resize(size, resample=method)
+    resized = contain(image, size, method)
+    if resized.size == size:
+        out = resized
     else:
         out = Image.new(image.mode, size, color)
-        if im_ratio > dest_ratio:
-            new_height = int(image.height / image.width * size[0])
-            if new_height != size[1]:
-                image = image.resize((size[0], new_height), resample=method)
-
-            y = int((size[1] - new_height) * max(0, min(centering[1], 1)))
-            out.paste(image, (0, y))
+        if resized.width != size[0]:
+            x = int((size[0] - resized.width) * max(0, min(centering[0], 1)))
+            out.paste(resized, (x, 0))
         else:
-            new_width = int(image.width / image.height * size[1])
-            if new_width != size[0]:
-                image = image.resize((new_width, size[1]), resample=method)
-
-            x = int((size[0] - new_width) * max(0, min(centering[0], 1)))
-            out.paste(image, (x, 0))
+            y = int((size[1] - resized.height) * max(0, min(centering[1], 1)))
+            out.paste(resized, (0, y))
     return out
 
 
@@ -288,7 +315,7 @@
     return image.crop((left, top, image.size[0] - right, image.size[1] - bottom))
 
 
-def scale(image, factor, resample=Image.BICUBIC):
+def scale(image, factor, resample=Image.Resampling.BICUBIC):
     """
     Returns a rescaled image by a specific factor given in parameter.
     A factor greater than 1 expands the image, between 0 and 1 contracts the
@@ -296,7 +323,7 @@
 
     :param image: The image to rescale.
     :param factor: The expansion factor, as a float.
-    :param resample: What resampling method to use. Default is
+    :param resample: Resampling method to use. Default is
                      :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
     :returns: An :py:class:`~PIL.Image.Image` object.
     """
@@ -309,7 +336,7 @@
         return image.resize(size, resample)
 
 
-def deform(image, deformer, resample=Image.BILINEAR):
+def deform(image, deformer, resample=Image.Resampling.BILINEAR):
     """
     Deform the image.
 
@@ -320,7 +347,9 @@
        in the PIL.Image.transform function.
     :return: An image.
     """
-    return image.transform(image.size, Image.MESH, deformer.getmesh(image), resample)
+    return image.transform(
+        image.size, Image.Transform.MESH, deformer.getmesh(image), resample
+    )
 
 
 def equalize(image, mask=None):
@@ -366,22 +395,32 @@
     left, top, right, bottom = _border(border)
     width = left + image.size[0] + right
     height = top + image.size[1] + bottom
-    out = Image.new(image.mode, (width, height), _color(fill, image.mode))
+    color = _color(fill, image.mode)
+    if image.mode == "P" and image.palette:
+        image.load()
+        palette = image.palette.copy()
+        if isinstance(color, tuple):
+            color = palette.getcolor(color)
+    else:
+        palette = None
+    out = Image.new(image.mode, (width, height), color)
+    if palette:
+        out.putpalette(palette.palette)
     out.paste(image, (left, top))
     return out
 
 
-def fit(image, size, method=Image.BICUBIC, bleed=0.0, centering=(0.5, 0.5)):
-    """
-    Returns a sized and cropped version of the image, cropped to the
+def fit(image, size, method=Image.Resampling.BICUBIC, bleed=0.0, centering=(0.5, 0.5)):
+    """
+    Returns a resized and cropped version of the image, cropped to the
     requested aspect ratio and size.
 
     This function was contributed by Kevin Cazabon.
 
-    :param image: The image to size and crop.
+    :param image: The image to resize and crop.
     :param size: The requested output size in pixels, given as a
                  (width, height) tuple.
-    :param method: What resampling method to use. Default is
+    :param method: Resampling method to use. Default is
                    :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
     :param bleed: Remove a border around the outside of the image from all
                   four edges. The value is a decimal percentage (use 0.01 for
@@ -402,7 +441,7 @@
 
     # by Kevin Cazabon, Feb 17/2000
     # kevin@cazabon.com
-    # http://www.cazabon.com
+    # https://www.cazabon.com
 
     # ensure centering is mutable
     centering = list(centering)
@@ -463,7 +502,7 @@
     :param image: The image to flip.
     :return: An image.
     """
-    return image.transpose(Image.FLIP_TOP_BOTTOM)
+    return image.transpose(Image.Transpose.FLIP_TOP_BOTTOM)
 
 
 def grayscale(image):
@@ -486,7 +525,7 @@
     lut = []
     for i in range(256):
         lut.append(255 - i)
-    return _lut(image, lut)
+    return image.point(lut) if image.mode == "1" else _lut(image, lut)
 
 
 def mirror(image):
@@ -496,7 +535,7 @@
     :param image: The image to mirror.
     :return: An image.
     """
-    return image.transpose(Image.FLIP_LEFT_RIGHT)
+    return image.transpose(Image.Transpose.FLIP_LEFT_RIGHT)
 
 
 def posterize(image, bits):
@@ -542,17 +581,30 @@
     exif = image.getexif()
     orientation = exif.get(0x0112)
     method = {
-        2: Image.FLIP_LEFT_RIGHT,
-        3: Image.ROTATE_180,
-        4: Image.FLIP_TOP_BOTTOM,
-        5: Image.TRANSPOSE,
-        6: Image.ROTATE_270,
-        7: Image.TRANSVERSE,
-        8: Image.ROTATE_90,
+        2: Image.Transpose.FLIP_LEFT_RIGHT,
+        3: Image.Transpose.ROTATE_180,
+        4: Image.Transpose.FLIP_TOP_BOTTOM,
+        5: Image.Transpose.TRANSPOSE,
+        6: Image.Transpose.ROTATE_270,
+        7: Image.Transpose.TRANSVERSE,
+        8: Image.Transpose.ROTATE_90,
     }.get(orientation)
     if method is not None:
         transposed_image = image.transpose(method)
-        del exif[0x0112]
-        transposed_image.info["exif"] = exif.tobytes()
+        transposed_exif = transposed_image.getexif()
+        if 0x0112 in transposed_exif:
+            del transposed_exif[0x0112]
+            if "exif" in transposed_image.info:
+                transposed_image.info["exif"] = transposed_exif.tobytes()
+            elif "Raw profile type exif" in transposed_image.info:
+                transposed_image.info[
+                    "Raw profile type exif"
+                ] = transposed_exif.tobytes().hex()
+            elif "XML:com.adobe.xmp" in transposed_image.info:
+                transposed_image.info["XML:com.adobe.xmp"] = re.sub(
+                    r'tiff:Orientation="([0-9])"',
+                    "",
+                    transposed_image.info["XML:com.adobe.xmp"],
+                )
         return transposed_image
     return image.copy()
('src/PIL', 'PdfImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -124,10 +124,9 @@
             decode = None
 
             if im.mode == "1":
-                filter = "ASCIIHexDecode"
+                filter = "DCTDecode"
                 colorspace = PdfParser.PdfName("DeviceGray")
                 procset = "ImageB"  # grayscale
-                bits = 1
             elif im.mode == "L":
                 filter = "DCTDecode"
                 # params = f"<< /Predictor 15 /Columns {width-2} >>"
@@ -135,7 +134,7 @@
                 procset = "ImageB"  # grayscale
             elif im.mode == "P":
                 filter = "ASCIIHexDecode"
-                palette = im.im.getpalette("RGB")
+                palette = im.getpalette()
                 colorspace = [
                     PdfParser.PdfName("Indexed"),
                     PdfParser.PdfName("DeviceRGB"),
@@ -161,12 +160,6 @@
             op = io.BytesIO()
 
             if filter == "ASCIIHexDecode":
-                if bits == 1:
-                    # FIXME: the hex encoder doesn't support packed 1-bit
-                    # images; do things the hard way...
-                    data = im.tobytes("raw", "1")
-                    im = Image.new("L", im.size)
-                    im.putdata(data)
                 ImageFile._save(im, op, [("hex", (0, 0) + im.size, 0, im.mode)])
             elif filter == "DCTDecode":
                 Image.SAVE["JPEG"](im, op, filename)
@@ -208,8 +201,8 @@
                 MediaBox=[
                     0,
                     0,
-                    int(width * 72.0 / resolution),
-                    int(height * 72.0 / resolution),
+                    width * 72.0 / resolution,
+                    height * 72.0 / resolution,
                 ],
                 Contents=contents_refs[pageNumber],
             )
@@ -217,9 +210,9 @@
             #
             # page contents
 
-            page_contents = b"q %d 0 0 %d 0 0 cm /image Do Q\n" % (
-                int(width * 72.0 / resolution),
-                int(height * 72.0 / resolution),
+            page_contents = b"q %f 0 0 %f 0 0 cm /image Do Q\n" % (
+                width * 72.0 / resolution,
+                height * 72.0 / resolution,
             )
 
             existing_pdf.write_obj(contents_refs[pageNumber], stream=page_contents)
('src/PIL', 'ImageShow.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -15,7 +15,7 @@
 import shutil
 import subprocess
 import sys
-import tempfile
+import warnings
 from shlex import quote
 
 from PIL import Image
@@ -25,7 +25,12 @@
 
 def register(viewer, order=1):
     """
-    The :py:func:`register` function is used to register additional viewers.
+    The :py:func:`register` function is used to register additional viewers::
+
+        from PIL import ImageShow
+        ImageShow.register(MyViewer())  # MyViewer will be used as a last resort
+        ImageShow.register(MySecondViewer(), 0)  # MySecondViewer will be prioritised
+        ImageShow.register(ImageShow.XVViewer(), 0)  # XVViewer will be prioritised
 
     :param viewer: The viewer to be registered.
     :param order:
@@ -54,8 +59,8 @@
     """
     for viewer in _viewers:
         if viewer.show(image, title=title, **options):
-            return 1
-    return 0
+            return True
+    return False
 
 
 class Viewer:
@@ -69,7 +74,6 @@
         Converts the given image to the target format and displays it.
         """
 
-        # save temporary image to disk
         if not (
             image.mode in ("1", "RGBA")
             or (self.format == "PNG" and image.mode in ("I;16", "LA"))
@@ -106,9 +110,25 @@
         """Display the given image."""
         return self.show_file(self.save_image(image), **options)
 
-    def show_file(self, file, **options):
-        """Display the given file."""
-        os.system(self.get_command(file, **options))
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and will be removed in Pillow 10.0.0 (2023-07-01). ``path`` should be used
+        instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        os.system(self.get_command(path, **options))
         return 1
 
 
@@ -134,7 +154,7 @@
 
 
 class MacViewer(Viewer):
-    """The default viewer on MacOS using ``Preview.app``."""
+    """The default viewer on macOS using ``Preview.app``."""
 
     format = "PNG"
     options = {"compress_level": 1}
@@ -146,18 +166,33 @@
         command = f"({command} {quote(file)}; sleep 20; rm -f {quote(file)})&"
         return command
 
-    def show_file(self, file, **options):
-        """Display given file"""
-        fd, path = tempfile.mkstemp()
-        with os.fdopen(fd, "w") as f:
-            f.write(file)
-        with open(path) as f:
-            subprocess.Popen(
-                ["im=$(cat); open -a Preview.app $im; sleep 20; rm -f $im"],
-                shell=True,
-                stdin=f,
-            )
-        os.remove(path)
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and will be removed in Pillow 10.0.0 (2023-07-01). ``path`` should be used
+        instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        subprocess.call(["open", "-a", "Preview.app", path])
+        subprocess.Popen(
+            [
+                sys.executable,
+                "-c",
+                "import os, sys, time; time.sleep(20); os.remove(sys.argv[1])",
+                path,
+            ]
+        )
         return 1
 
 
@@ -171,36 +206,135 @@
 
     def get_command(self, file, **options):
         command = self.get_command_ex(file, **options)[0]
-        return f"({command} {quote(file)}; rm -f {quote(file)})&"
-
-    def show_file(self, file, **options):
-        """Display given file"""
-        fd, path = tempfile.mkstemp()
-        with os.fdopen(fd, "w") as f:
-            f.write(file)
-        with open(path) as f:
-            command = self.get_command_ex(file, **options)[0]
-            subprocess.Popen(
-                ["im=$(cat);" + command + " $im; rm -f $im"], shell=True, stdin=f
-            )
-        os.remove(path)
+        return f"({command} {quote(file)}"
+
+
+class XDGViewer(UnixViewer):
+    """
+    The freedesktop.org ``xdg-open`` command.
+    """
+
+    def get_command_ex(self, file, **options):
+        command = executable = "xdg-open"
+        return command, executable
+
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and will be removed in Pillow 10.0.0 (2023-07-01). ``path`` should be used
+        instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        subprocess.Popen(["xdg-open", path])
         return 1
 
 
 class DisplayViewer(UnixViewer):
-    """The ImageMagick ``display`` command."""
+    """
+    The ImageMagick ``display`` command.
+    This viewer supports the ``title`` parameter.
+    """
+
+    def get_command_ex(self, file, title=None, **options):
+        command = executable = "display"
+        if title:
+            command += f" -title {quote(title)}"
+        return command, executable
+
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and ``path`` should be used instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        args = ["display"]
+        title = options.get("title")
+        if title:
+            args += ["-title", title]
+        args.append(path)
+
+        subprocess.Popen(args)
+        return 1
+
+
+class GmDisplayViewer(UnixViewer):
+    """The GraphicsMagick ``gm display`` command."""
 
     def get_command_ex(self, file, **options):
-        command = executable = "display"
+        executable = "gm"
+        command = "gm display"
         return command, executable
+
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and ``path`` should be used instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        subprocess.Popen(["gm", "display", path])
+        return 1
 
 
 class EogViewer(UnixViewer):
     """The GNOME Image Viewer ``eog`` command."""
 
     def get_command_ex(self, file, **options):
-        command = executable = "eog"
+        executable = "eog"
+        command = "eog -n"
         return command, executable
+
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and ``path`` should be used instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        subprocess.Popen(["eog", "-n", path])
+        return 1
 
 
 class XVViewer(UnixViewer):
@@ -217,19 +351,66 @@
             command += f" -name {quote(title)}"
         return command, executable
 
+    def show_file(self, path=None, **options):
+        """
+        Display given file.
+
+        Before Pillow 9.1.0, the first argument was ``file``. This is now deprecated,
+        and ``path`` should be used instead.
+        """
+        if path is None:
+            if "file" in options:
+                warnings.warn(
+                    "The 'file' argument is deprecated and will be removed in Pillow "
+                    "10 (2023-07-01). Use 'path' instead.",
+                    DeprecationWarning,
+                )
+                path = options.pop("file")
+            else:
+                raise TypeError("Missing required argument: 'path'")
+        args = ["xv"]
+        title = options.get("title")
+        if title:
+            args += ["-name", title]
+        args.append(path)
+
+        subprocess.Popen(args)
+        return 1
+
 
 if sys.platform not in ("win32", "darwin"):  # unixoids
+    if shutil.which("xdg-open"):
+        register(XDGViewer)
     if shutil.which("display"):
         register(DisplayViewer)
+    if shutil.which("gm"):
+        register(GmDisplayViewer)
     if shutil.which("eog"):
         register(EogViewer)
     if shutil.which("xv"):
         register(XVViewer)
 
+
+class IPythonViewer(Viewer):
+    """The viewer for IPython frontends."""
+
+    def show_image(self, image, **options):
+        ipython_display(image)
+        return 1
+
+
+try:
+    from IPython.display import display as ipython_display
+except ImportError:
+    pass
+else:
+    register(IPythonViewer)
+
+
 if __name__ == "__main__":
 
     if len(sys.argv) < 2:
-        print("Syntax: python ImageShow.py imagefile [title]")
+        print("Syntax: python3 ImageShow.py imagefile [title]")
         sys.exit()
 
     with Image.open(sys.argv[1]) as im:
('src/PIL', 'WmfImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -21,7 +21,6 @@
 
 from . import Image, ImageFile
 from ._binary import i16le as word
-from ._binary import i32le as dword
 from ._binary import si16le as short
 from ._binary import si32le as _long
 
@@ -112,7 +111,7 @@
             if s[22:26] != b"\x01\x00\t\x00":
                 raise SyntaxError("Unsupported WMF file format")
 
-        elif dword(s) == 1 and s[40:44] == b" EMF":
+        elif s[:4] == b"\x01\x00\x00\x00" and s[40:44] == b" EMF":
             # enhanced metafile
 
             # get bounding box
@@ -127,8 +126,8 @@
             size = x1 - x0, y1 - y0
 
             # calculate dots per inch from bbox and frame
-            xdpi = int(2540.0 * (x1 - y0) / (frame[2] - frame[0]) + 0.5)
-            ydpi = int(2540.0 * (y1 - y0) / (frame[3] - frame[1]) + 0.5)
+            xdpi = 2540.0 * (x1 - y0) / (frame[2] - frame[0])
+            ydpi = 2540.0 * (y1 - y0) / (frame[3] - frame[1])
 
             self.info["wmf_bbox"] = x0, y0, x1, y1
 
@@ -152,13 +151,13 @@
 
     def load(self, dpi=None):
         if dpi is not None and self._inch is not None:
-            self.info["dpi"] = int(dpi + 0.5)
+            self.info["dpi"] = dpi
             x0, y0, x1, y1 = self.info["wmf_bbox"]
             self._size = (
                 (x1 - x0) * self.info["dpi"] // self._inch,
                 (y1 - y0) * self.info["dpi"] // self._inch,
             )
-        super().load()
+        return super().load()
 
 
 def _save(im, fp, filename):
('src/PIL', 'ImageGrab.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -30,14 +30,18 @@
         if sys.platform == "darwin":
             fh, filepath = tempfile.mkstemp(".png")
             os.close(fh)
-            subprocess.call(["screencapture", "-x", filepath])
+            args = ["screencapture"]
+            if bbox:
+                left, top, right, bottom = bbox
+                args += ["-R", f"{left},{right},{right-left},{bottom-top}"]
+            subprocess.call(args + ["-x", filepath])
             im = Image.open(filepath)
             im.load()
             os.unlink(filepath)
             if bbox:
-                im_cropped = im.crop(bbox)
+                im_resized = im.resize((right - left, bottom - top))
                 im.close()
-                return im_cropped
+                return im_resized
             return im
         elif sys.platform == "win32":
             offset, size, data = Image.core.grabscreen_win32(
('src/PIL', 'WebPImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -96,7 +96,7 @@
     def _getexif(self):
         if "exif" not in self.info:
             return None
-        return dict(self.getexif())
+        return self.getexif()._get_merged_dict()
 
     def seek(self, frame):
         if not self._seek_check(frame):
@@ -190,9 +190,11 @@
             palette = im.getpalette()
             if palette:
                 r, g, b = palette[background * 3 : (background + 1) * 3]
-                background = (r, g, b, 0)
-
-    duration = im.encoderinfo.get("duration", 0)
+                background = (r, g, b, 255)
+            else:
+                background = (background, background, background, 255)
+
+    duration = im.encoderinfo.get("duration", im.info.get("duration", 0))
     loop = im.encoderinfo.get("loop", 0)
     minimize_size = im.encoderinfo.get("minimize_size", False)
     kmin = im.encoderinfo.get("kmin", None)
@@ -202,7 +204,7 @@
     lossless = im.encoderinfo.get("lossless", False)
     quality = im.encoderinfo.get("quality", 80)
     method = im.encoderinfo.get("method", 0)
-    icc_profile = im.encoderinfo.get("icc_profile", "")
+    icc_profile = im.encoderinfo.get("icc_profile") or ""
     exif = im.encoderinfo.get("exif", "")
     if isinstance(exif, Image.Exif):
         exif = exif.tobytes()
@@ -309,18 +311,18 @@
 def _save(im, fp, filename):
     lossless = im.encoderinfo.get("lossless", False)
     quality = im.encoderinfo.get("quality", 80)
-    icc_profile = im.encoderinfo.get("icc_profile", "")
+    icc_profile = im.encoderinfo.get("icc_profile") or ""
     exif = im.encoderinfo.get("exif", "")
     if isinstance(exif, Image.Exif):
         exif = exif.tobytes()
     xmp = im.encoderinfo.get("xmp", "")
-    method = im.encoderinfo.get("method", 0)
+    method = im.encoderinfo.get("method", 4)
 
     if im.mode not in _VALID_WEBP_LEGACY_MODES:
         alpha = (
             "A" in im.mode
             or "a" in im.mode
-            or (im.mode == "P" and "A" in im.im.getpalettemode())
+            or (im.mode == "P" and "transparency" in im.info)
         )
         im = im.convert("RGBA" if alpha else "RGB")
 
('src/PIL', 'FliImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -26,7 +26,11 @@
 
 
 def _accept(prefix):
-    return len(prefix) >= 6 and i16(prefix, 4) in [0xAF11, 0xAF12]
+    return (
+        len(prefix) >= 6
+        and i16(prefix, 4) in [0xAF11, 0xAF12]
+        and i16(prefix, 14) in [0, 3]  # flags
+    )
 
 
 ##
@@ -44,11 +48,7 @@
 
         # HEAD
         s = self.fp.read(128)
-        if not (
-            _accept(s)
-            and i16(s, 14) in [0, 3]  # flags
-            and s[20:22] == b"\x00\x00"  # reserved
-        ):
+        if not (_accept(s) and s[20:22] == b"\x00\x00"):
             raise SyntaxError("not an FLI/FLC file")
 
         # frames
('src/PIL', 'TiffTags.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -33,7 +33,7 @@
         return self.enum.get(value, value) if self.enum else value
 
 
-def lookup(tag):
+def lookup(tag, group=None):
     """
     :param tag: Integer tag number
     :returns: Taginfo namedtuple, From the TAGS_V2 info if possible,
@@ -42,7 +42,11 @@
 
     """
 
-    return TAGS_V2.get(tag, TagInfo(tag, TAGS.get(tag, "unknown")))
+    if group is not None:
+        info = TAGS_V2_GROUPS[group].get(tag) if group in TAGS_V2_GROUPS else None
+    else:
+        info = TAGS_V2.get(tag)
+    return info or TagInfo(tag, TAGS.get(tag, "unknown"))
 
 
 ##
@@ -70,6 +74,7 @@
 FLOAT = 11
 DOUBLE = 12
 IFD = 13
+LONG8 = 16
 
 TAGS_V2 = {
     254: ("NewSubfileType", LONG, 1),
@@ -178,12 +183,15 @@
     532: ("ReferenceBlackWhite", RATIONAL, 6),
     700: ("XMP", BYTE, 0),
     33432: ("Copyright", ASCII, 1),
-    33723: ("IptcNaaInfo", UNDEFINED, 0),
+    33723: ("IptcNaaInfo", UNDEFINED, 1),
     34377: ("PhotoshopInfo", BYTE, 0),
     # FIXME add more tags here
     34665: ("ExifIFD", LONG, 1),
     34675: ("ICCProfile", UNDEFINED, 1),
     34853: ("GPSInfoIFD", LONG, 1),
+    36864: ("ExifVersion", UNDEFINED, 1),
+    40965: ("InteroperabilityIFD", LONG, 1),
+    41730: ("CFAPattern", UNDEFINED, 1),
     # MPInfo
     45056: ("MPFVersion", UNDEFINED, 1),
     45057: ("NumberOfImages", LONG, 1),
@@ -204,10 +212,24 @@
     45579: ("YawAngle", SIGNED_RATIONAL, 1),
     45580: ("PitchAngle", SIGNED_RATIONAL, 1),
     45581: ("RollAngle", SIGNED_RATIONAL, 1),
+    40960: ("FlashPixVersion", UNDEFINED, 1),
     50741: ("MakerNoteSafety", SHORT, 1, {"Unsafe": 0, "Safe": 1}),
     50780: ("BestQualityScale", RATIONAL, 1),
     50838: ("ImageJMetaDataByteCounts", LONG, 0),  # Can be more than one
     50839: ("ImageJMetaData", UNDEFINED, 1),  # see Issue #2006
+}
+TAGS_V2_GROUPS = {
+    # ExifIFD
+    34665: {
+        36864: ("ExifVersion", UNDEFINED, 1),
+        40960: ("FlashPixVersion", UNDEFINED, 1),
+        40965: ("InteroperabilityIFD", LONG, 1),
+        41730: ("CFAPattern", UNDEFINED, 1),
+    },
+    # GPSInfoIFD
+    34853: {},
+    # InteroperabilityIFD
+    40965: {1: ("InteropIndex", ASCII, 1), 2: ("InteropVersion", UNDEFINED, 1)},
 }
 
 # Legacy Tags structure
@@ -367,6 +389,10 @@
 
         TAGS_V2[k] = TagInfo(k, *v)
 
+    for group, tags in TAGS_V2_GROUPS.items():
+        for k, v in tags.items():
+            tags[k] = TagInfo(k, *v)
+
 
 _populate()
 ##
@@ -484,9 +510,6 @@
     65537,
 }
 
-LIBTIFF_CORE.remove(301)  # Array of short, crashes
-LIBTIFF_CORE.remove(532)  # Array of long, crashes
-
 LIBTIFF_CORE.remove(255)  # We don't have support for subfiletypes
 LIBTIFF_CORE.remove(322)  # We don't have support for writing tiled images with libtiff
 LIBTIFF_CORE.remove(323)  # Tiled images
('src/PIL', 'TiffImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -41,6 +41,7 @@
 import io
 import itertools
 import logging
+import math
 import os
 import struct
 import warnings
@@ -48,7 +49,9 @@
 from fractions import Fraction
 from numbers import Number, Rational
 
-from . import Image, ImageFile, ImagePalette, TiffTags
+from . import Image, ImageFile, ImageOps, ImagePalette, TiffTags
+from ._binary import i16be as i16
+from ._binary import i32be as i32
 from ._binary import o8
 from .TiffTags import TYPES
 
@@ -58,6 +61,7 @@
 READ_LIBTIFF = False
 WRITE_LIBTIFF = False
 IFD_LEGACY_API = True
+STRIP_SIZE = 65536
 
 II = b"II"  # little-endian (Intel style)
 MM = b"MM"  # big-endian (Motorola style)
@@ -88,11 +92,15 @@
 ARTIST = 315
 PREDICTOR = 317
 COLORMAP = 320
+TILEWIDTH = 322
+TILELENGTH = 323
 TILEOFFSETS = 324
+TILEBYTECOUNTS = 325
 SUBIFD = 330
 EXTRASAMPLES = 338
 SAMPLEFORMAT = 339
 JPEGTABLES = 347
+YCBCRSUBSAMPLING = 530
 REFERENCEBLACKWHITE = 532
 COPYRIGHT = 33432
 IPTC_NAA_CHUNK = 33723  # newsphoto properties
@@ -167,6 +175,7 @@
     (II, 1, (1,), 1, (12,), ()): ("I;16", "I;12"),
     (II, 1, (1,), 1, (16,), ()): ("I;16", "I;16"),
     (MM, 1, (1,), 1, (16,), ()): ("I;16B", "I;16B"),
+    (II, 1, (1,), 2, (16,), ()): ("I;16", "I;16R"),
     (II, 1, (2,), 1, (16,), ()): ("I", "I;16S"),
     (MM, 1, (2,), 1, (16,), ()): ("I", "I;16BS"),
     (II, 0, (3,), 1, (32,), ()): ("F", "F;32F"),
@@ -252,6 +261,8 @@
     b"II\x2A\x00",  # Valid TIFF header with little-endian byte order
     b"MM\x2A\x00",  # Invalid TIFF header, assume big-endian
     b"II\x00\x2A",  # Invalid TIFF header, assume little-endian
+    b"MM\x00\x2B",  # BigTIFF with big-endian byte order
+    b"II\x2B\x00",  # BigTIFF with little-endian byte order
 ]
 
 
@@ -354,9 +365,22 @@
         return self._val.__hash__()
 
     def __eq__(self, other):
+        val = self._val
         if isinstance(other, IFDRational):
             other = other._val
-        return self._val == other
+        if isinstance(other, float):
+            val = float(val)
+        return val == other
+
+    def __getstate__(self):
+        return [self._val, self._numerator, self._denominator]
+
+    def __setstate__(self, state):
+        IFDRational.__init__(self, 0)
+        _val, _numerator, _denominator = state
+        self._val = _val
+        self._numerator = _numerator
+        self._denominator = _denominator
 
     def _delegate(op):
         def delegate(self, *args):
@@ -423,39 +447,45 @@
 
     Data Structures:
 
-        * self.tagtype = {}
-
-          * Key: numerical tiff tag number
+        * ``self.tagtype = {}``
+
+          * Key: numerical TIFF tag number
           * Value: integer corresponding to the data type from
-                   ~PIL.TiffTags.TYPES`
-
-    .. versionadded:: 3.0.0
+            :py:data:`.TiffTags.TYPES`
+
+          .. versionadded:: 3.0.0
+
+    'Internal' data structures:
+
+        * ``self._tags_v2 = {}``
+
+          * Key: numerical TIFF tag number
+          * Value: decoded data, as tuple for multiple values
+
+        * ``self._tagdata = {}``
+
+          * Key: numerical TIFF tag number
+          * Value: undecoded byte string from file
+
+        * ``self._tags_v1 = {}``
+
+          * Key: numerical TIFF tag number
+          * Value: decoded data in the v1 format
+
+    Tags will be found in the private attributes ``self._tagdata``, and in
+    ``self._tags_v2`` once decoded.
+
+    ``self.legacy_api`` is a value for internal use, and shouldn't be changed
+    from outside code. In cooperation with
+    :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`, if ``legacy_api``
+    is true, then decoded tags will be populated into both ``_tags_v1`` and
+    ``_tags_v2``. ``_tags_v2`` will be used if this IFD is used in the TIFF
+    save routine. Tags should be read from ``_tags_v1`` if
+    ``legacy_api == true``.
+
     """
 
-    """
-    Documentation:
-
-        'internal' data structures:
-        * self._tags_v2 = {} Key: numerical tiff tag number
-                             Value: decoded data, as tuple for multiple values
-        * self._tagdata = {} Key: numerical tiff tag number
-                             Value: undecoded byte string from file
-        * self._tags_v1 = {} Key: numerical tiff tag number
-                             Value: decoded data in the v1 format
-
-    Tags will be found in the private attributes self._tagdata, and in
-    self._tags_v2 once decoded.
-
-    Self.legacy_api is a value for internal use, and shouldn't be
-    changed from outside code. In cooperation with the
-    ImageFileDirectory_v1 class, if legacy_api is true, then decoded
-    tags will be populated into both _tags_v1 and _tags_v2. _Tags_v2
-    will be used if this IFD is used in the TIFF save routine. Tags
-    should be read from tags_v1 if legacy_api == true.
-
-    """
-
-    def __init__(self, ifh=b"II\052\0\0\0\0\0", prefix=None):
+    def __init__(self, ifh=b"II\052\0\0\0\0\0", prefix=None, group=None):
         """Initialize an ImageFileDirectory.
 
         To construct an ImageFileDirectory from a real file, pass the 8-byte
@@ -466,7 +496,7 @@
               endianness.
         :param prefix: Override the endianness of the file.
         """
-        if ifh[:4] not in PREFIXES:
+        if not _accept(ifh):
             raise SyntaxError(f"not a TIFF file (header {repr(ifh)} not valid)")
         self._prefix = prefix if prefix is not None else ifh[:2]
         if self._prefix == MM:
@@ -475,10 +505,14 @@
             self._endian = "<"
         else:
             raise SyntaxError("not a TIFF IFD")
+        self._bigtiff = ifh[2] == 43
+        self.group = group
         self.tagtype = {}
         """ Dictionary of tag types """
         self.reset()
-        (self.next,) = self._unpack("L", ifh[4:])
+        (self.next,) = (
+            self._unpack("Q", ifh[8:]) if self._bigtiff else self._unpack("L", ifh[4:])
+        )
         self._legacy_api = False
 
     prefix = property(lambda self: self._prefix)
@@ -506,7 +540,10 @@
 
         Returns the complete tag dictionary, with named tags where possible.
         """
-        return {TiffTags.lookup(code).name: value for code, value in self.items()}
+        return {
+            TiffTags.lookup(code, self.group).name: value
+            for code, value in self.items()
+        }
 
     def __len__(self):
         return len(set(self._tagdata) | set(self._tags_v2))
@@ -531,7 +568,7 @@
     def _setitem(self, tag, value, legacy_api):
         basetypes = (Number, bytes, str)
 
-        info = TiffTags.lookup(tag)
+        info = TiffTags.lookup(tag, self.group)
         values = [value] if isinstance(value, basetypes) else value
 
         if tag not in self.tagtype:
@@ -546,9 +583,9 @@
                         else TiffTags.SIGNED_RATIONAL
                     )
                 elif all(isinstance(v, int) for v in values):
-                    if all(0 <= v < 2 ** 16 for v in values):
+                    if all(0 <= v < 2**16 for v in values):
                         self.tagtype[tag] = TiffTags.SHORT
-                    elif all(-(2 ** 15) < v < 2 ** 15 for v in values):
+                    elif all(-(2**15) < v < 2**15 for v in values):
                         self.tagtype[tag] = TiffTags.SIGNED_SHORT
                     else:
                         self.tagtype[tag] = (
@@ -565,7 +602,8 @@
 
         if self.tagtype[tag] == TiffTags.UNDEFINED:
             values = [
-                value.encode("ascii", "replace") if isinstance(value, str) else value
+                v.encode("ascii", "replace") if isinstance(v, str) else v
+                for v in values
             ]
         elif self.tagtype[tag] == TiffTags.RATIONAL:
             values = [float(v) if isinstance(v, int) else v for v in values]
@@ -648,7 +686,7 @@
         _load_dispatch[idx] = (  # noqa: F821
             size,
             lambda self, data, legacy_api=True: (
-                self._unpack("{}{}".format(len(data) // size, fmt), data)
+                self._unpack(f"{len(data) // size}{fmt}", data)
             ),
         )
         _write_dispatch[idx] = lambda self, *values: (  # noqa: F821
@@ -667,6 +705,7 @@
                 (TiffTags.FLOAT, "f", "float"),
                 (TiffTags.DOUBLE, "d", "double"),
                 (TiffTags.IFD, "L", "long"),
+                (TiffTags.LONG8, "Q", "long8"),
             ],
         )
     )
@@ -692,7 +731,7 @@
 
     @_register_loader(5, 8)
     def load_rational(self, data, legacy_api=True):
-        vals = self._unpack("{}L".format(len(data) // 4), data)
+        vals = self._unpack(f"{len(data) // 4}L", data)
 
         def combine(a, b):
             return (a, b) if legacy_api else IFDRational(a, b)
@@ -702,7 +741,7 @@
     @_register_writer(5)
     def write_rational(self, *values):
         return b"".join(
-            self._pack("2L", *_limit_rational(frac, 2 ** 32 - 1)) for frac in values
+            self._pack("2L", *_limit_rational(frac, 2**32 - 1)) for frac in values
         )
 
     @_register_loader(7, 1)
@@ -715,7 +754,7 @@
 
     @_register_loader(10, 8)
     def load_signed_rational(self, data, legacy_api=True):
-        vals = self._unpack("{}l".format(len(data) // 4), data)
+        vals = self._unpack(f"{len(data) // 4}l", data)
 
         def combine(a, b):
             return (a, b) if legacy_api else IFDRational(a, b)
@@ -725,7 +764,7 @@
     @_register_writer(10)
     def write_signed_rational(self, *values):
         return b"".join(
-            self._pack("2l", *_limit_signed_rational(frac, 2 ** 31 - 1, -(2 ** 31)))
+            self._pack("2l", *_limit_signed_rational(frac, 2**31 - 1, -(2**31)))
             for frac in values
         )
 
@@ -744,10 +783,19 @@
         self._offset = fp.tell()
 
         try:
-            for i in range(self._unpack("H", self._ensure_read(fp, 2))[0]):
-                tag, typ, count, data = self._unpack("HHL4s", self._ensure_read(fp, 12))
-
-                tagname = TiffTags.lookup(tag).name
+            tag_count = (
+                self._unpack("Q", self._ensure_read(fp, 8))
+                if self._bigtiff
+                else self._unpack("H", self._ensure_read(fp, 2))
+            )[0]
+            for i in range(tag_count):
+                tag, typ, count, data = (
+                    self._unpack("HHQ8s", self._ensure_read(fp, 20))
+                    if self._bigtiff
+                    else self._unpack("HHL4s", self._ensure_read(fp, 12))
+                )
+
+                tagname = TiffTags.lookup(tag, self.group).name
                 typname = TYPES.get(typ, "unknown")
                 msg = f"tag: {tagname} ({tag}) - type: {typname} ({typ})"
 
@@ -757,9 +805,9 @@
                     logger.debug(msg + f" - unsupported type {typ}")
                     continue  # ignore unsupported type
                 size = count * unit_size
-                if size > 4:
+                if size > (8 if self._bigtiff else 4):
                     here = fp.tell()
-                    (offset,) = self._unpack("L", data)
+                    (offset,) = self._unpack("Q" if self._bigtiff else "L", data)
                     msg += f" Tag Location: {here} - Data Location: {offset}"
                     fp.seek(offset)
                     data = ImageFile._safe_read(fp, size)
@@ -788,7 +836,11 @@
                 )
                 logger.debug(msg)
 
-            (self.next,) = self._unpack("L", self._ensure_read(fp, 4))
+            (self.next,) = (
+                self._unpack("Q", self._ensure_read(fp, 8))
+                if self._bigtiff
+                else self._unpack("L", self._ensure_read(fp, 4))
+            )
         except OSError as msg:
             warnings.warn(str(msg))
             return
@@ -814,15 +866,16 @@
                     ifh = b"II\x2A\x00\x08\x00\x00\x00"
                 else:
                     ifh = b"MM\x00\x2A\x00\x00\x00\x08"
-                ifd = ImageFileDirectory_v2(ifh)
-                for ifd_tag, ifd_value in self._tags_v2[tag].items():
+                ifd = ImageFileDirectory_v2(ifh, group=tag)
+                values = self._tags_v2[tag]
+                for ifd_tag, ifd_value in values.items():
                     ifd[ifd_tag] = ifd_value
                 data = ifd.tobytes(offset)
             else:
                 values = value if isinstance(value, tuple) else (value,)
                 data = self._write_dispatch[typ](self, *values)
 
-            tagname = TiffTags.lookup(tag).name
+            tagname = TiffTags.lookup(tag, self.group).name
             typname = "ifd" if is_ifd else TYPES.get(typ, "unknown")
             msg = f"save: {tagname} ({tag}) - type: {typname} ({typ})"
             msg += " - value: " + (
@@ -1009,6 +1062,8 @@
 
         # Header
         ifh = self.fp.read(8)
+        if ifh[2] == 43:
+            ifh += self.fp.read(8)
 
         self.tag_v2 = ImageFileDirectory_v2(ifh)
 
@@ -1052,6 +1107,11 @@
 
     def _seek(self, frame):
         self.fp = self.__fp
+
+        # reset buffered io handle in case fp
+        # was passed to libtiff, invalidating the buffer
+        self.fp.tell()
+
         while len(self._frame_pos) <= frame:
             if not self.__next:
                 raise EOFError("no more images in TIFF file")
@@ -1059,14 +1119,16 @@
                 f"Seeking to frame {frame}, on frame {self.__frame}, "
                 f"__next {self.__next}, location: {self.fp.tell()}"
             )
-            # reset buffered io handle in case fp
-            # was passed to libtiff, invalidating the buffer
-            self.fp.tell()
             self.fp.seek(self.__next)
             self._frame_pos.append(self.__next)
             logger.debug("Loading tags, location: %s" % self.fp.tell())
             self.tag_v2.load(self.fp)
-            self.__next = self.tag_v2.next
+            if self.tag_v2.next in self._frame_pos:
+                # This IFD has already been processed
+                # Declare this to be the end of the image
+                self.__next = 0
+            else:
+                self.__next = self.tag_v2.next
             if self.__next == 0:
                 self._n_frames = frame + 1
             if len(self._frame_pos) == 1:
@@ -1083,6 +1145,36 @@
         """Return the current frame number"""
         return self.__frame
 
+    def getxmp(self):
+        """
+        Returns a dictionary containing the XMP tags.
+        Requires defusedxml to be installed.
+
+        :returns: XMP tags in a dictionary.
+        """
+        return self._getxmp(self.tag_v2[700]) if 700 in self.tag_v2 else {}
+
+    def get_photoshop_blocks(self):
+        """
+        Returns a dictionary of Photoshop "Image Resource Blocks".
+        The keys are the image resource ID. For more information, see
+        https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_pgfId-1037727
+
+        :returns: Photoshop "Image Resource Blocks" in a dictionary.
+        """
+        blocks = {}
+        val = self.tag_v2.get(0x8649)
+        if val:
+            while val[:4] == b"8BIM":
+                id = i16(val[4:6])
+                n = math.ceil((val[6] + 1) / 2) * 2
+                size = i32(val[6 + n : 10 + n])
+                data = val[10 + n : 10 + n + size]
+                blocks[id] = {"data": data}
+
+                val = val[math.ceil((10 + n + size) / 2) * 2 :]
+        return blocks
+
     def load(self):
         if self.tile and self.use_load_libtiff:
             return self._load_libtiff()
@@ -1091,13 +1183,13 @@
     def load_end(self):
         if self._tile_orientation:
             method = {
-                2: Image.FLIP_LEFT_RIGHT,
-                3: Image.ROTATE_180,
-                4: Image.FLIP_TOP_BOTTOM,
-                5: Image.TRANSPOSE,
-                6: Image.ROTATE_270,
-                7: Image.TRANSVERSE,
-                8: Image.ROTATE_90,
+                2: Image.Transpose.FLIP_LEFT_RIGHT,
+                3: Image.Transpose.ROTATE_180,
+                4: Image.Transpose.FLIP_TOP_BOTTOM,
+                5: Image.Transpose.TRANSPOSE,
+                6: Image.Transpose.ROTATE_270,
+                7: Image.Transpose.TRANSVERSE,
+                8: Image.Transpose.ROTATE_90,
             }.get(self._tile_orientation)
             if method is not None:
                 self.im = self.im.transpose(method)
@@ -1107,6 +1199,17 @@
         # This is the ImageFile.load path only, libtiff specific below.
         if not self.is_animated:
             self._close_exclusive_fp_after_loading = True
+
+            # reset buffered io handle in case fp
+            # was passed to libtiff, invalidating the buffer
+            self.fp.tell()
+
+            # load IFD data from fp before it is closed
+            exif = self.getexif()
+            for key in TiffTags.TAGS_V2_GROUPS.keys():
+                if key not in exif:
+                    continue
+                exif.get_ifd(key)
 
     def _load_libtiff(self):
         """Overload method triggered when we detect a compressed tiff
@@ -1178,6 +1281,12 @@
             # UNDONE -- so much for that buffer size thing.
             n, err = decoder.decode(self.fp.read())
 
+        if fp:
+            try:
+                os.close(fp)
+            except OSError:
+                pass
+
         self.tile = []
         self.readonly = 0
 
@@ -1245,10 +1354,22 @@
         else:
             bps_count = 1
         bps_count += len(extra_tuple)
-        # Some files have only one value in bps_tuple,
-        # while should have more. Fix it
-        if bps_count > len(bps_tuple) and len(bps_tuple) == 1:
+        bps_actual_count = len(bps_tuple)
+        if bps_count < bps_actual_count:
+            # If a file has more values in bps_tuple than expected,
+            # remove the excess.
+            bps_tuple = bps_tuple[:bps_count]
+        elif bps_count > bps_actual_count and bps_actual_count == 1:
+            # If a file has only one value in bps_tuple, when it should have more,
+            # presume it is the same number of bits for all of the samples.
             bps_tuple = bps_tuple * bps_count
+
+        samplesPerPixel = self.tag_v2.get(
+            SAMPLESPERPIXEL,
+            3 if self._compression == "tiff_jpeg" and photo in (2, 6) else 1,
+        )
+        if len(bps_tuple) != samplesPerPixel:
+            raise SyntaxError("unknown data organization")
 
         # mode: check photometric interpretation and bits per pixel
         key = (
@@ -1277,11 +1398,11 @@
         if xres and yres:
             resunit = self.tag_v2.get(RESOLUTION_UNIT)
             if resunit == 2:  # dots per inch
-                self.info["dpi"] = int(xres + 0.5), int(yres + 0.5)
+                self.info["dpi"] = (xres, yres)
             elif resunit == 3:  # dots per centimeter. convert to dpi
-                self.info["dpi"] = int(xres * 2.54 + 0.5), int(yres * 2.54 + 0.5)
+                self.info["dpi"] = (xres * 2.54, yres * 2.54)
             elif resunit is None:  # used to default to 1, but now 2)
-                self.info["dpi"] = int(xres + 0.5), int(yres + 0.5)
+                self.info["dpi"] = (xres, yres)
                 # For backward compatibility,
                 # we also preserve the old behavior
                 self.info["resolution"] = xres, yres
@@ -1323,6 +1444,15 @@
                 rawmode = rawmode.replace(";16B", ";16N")
             if ";16L" in rawmode:
                 rawmode = rawmode.replace(";16L", ";16N")
+
+            # YCbCr images with new jpeg compression with pixels in one plane
+            # unpacked straight into RGB values
+            if (
+                photo == 6
+                and self._compression == "jpeg"
+                and self._planar_configuration == 1
+            ):
+                rawmode = "RGB"
 
             # Offset in the tile tuple is 0, we go from 0,0 to
             # w,h, and we only do this once -- eds
@@ -1436,28 +1566,44 @@
 
     ifd = ImageFileDirectory_v2(prefix=prefix)
 
-    compression = im.encoderinfo.get("compression", im.info.get("compression"))
+    encoderinfo = im.encoderinfo
+    encoderconfig = im.encoderconfig
+    compression = encoderinfo.get("compression", im.info.get("compression"))
     if compression is None:
         compression = "raw"
     elif compression == "tiff_jpeg":
         # OJPEG is obsolete, so use new-style JPEG compression instead
         compression = "jpeg"
+    elif compression == "tiff_deflate":
+        compression = "tiff_adobe_deflate"
 
     libtiff = WRITE_LIBTIFF or compression != "raw"
 
     # required for color libtiff images
-    ifd[PLANAR_CONFIGURATION] = getattr(im, "_planar_configuration", 1)
+    ifd[PLANAR_CONFIGURATION] = 1
 
     ifd[IMAGEWIDTH] = im.size[0]
     ifd[IMAGELENGTH] = im.size[1]
 
     # write any arbitrary tags passed in as an ImageFileDirectory
-    info = im.encoderinfo.get("tiffinfo", {})
+    if "tiffinfo" in encoderinfo:
+        info = encoderinfo["tiffinfo"]
+    elif "exif" in encoderinfo:
+        info = encoderinfo["exif"]
+        if isinstance(info, bytes):
+            exif = Image.Exif()
+            exif.load(info)
+            info = exif
+    else:
+        info = {}
     logger.debug("Tiffinfo Keys: %s" % list(info))
     if isinstance(info, ImageFileDirectory_v1):
         info = info.to_v2()
     for key in info:
-        ifd[key] = info.get(key)
+        if isinstance(info, Image.Exif) and key in TiffTags.TAGS_V2_GROUPS.keys():
+            ifd[key] = info.get_ifd(key)
+        else:
+            ifd[key] = info.get(key)
         try:
             ifd.tagtype[key] = info.tagtype[key]
         except Exception:
@@ -1481,8 +1627,9 @@
 
     # preserve ICC profile (should also work when saving other formats
     # which support profiles as TIFF) -- 2008-06-06 Florian Hoech
-    if "icc_profile" in im.info:
-        ifd[ICCPROFILE] = im.info["icc_profile"]
+    icc = encoderinfo.get("icc_profile", im.info.get("icc_profile"))
+    if icc:
+        ifd[ICCPROFILE] = icc
 
     for key, name in [
         (IMAGEDESCRIPTION, "description"),
@@ -1496,14 +1643,14 @@
         (ARTIST, "artist"),
         (COPYRIGHT, "copyright"),
     ]:
-        if name in im.encoderinfo:
-            ifd[key] = im.encoderinfo[name]
-
-    dpi = im.encoderinfo.get("dpi")
+        if name in encoderinfo:
+            ifd[key] = encoderinfo[name]
+
+    dpi = encoderinfo.get("dpi")
     if dpi:
         ifd[RESOLUTION_UNIT] = 2
-        ifd[X_RESOLUTION] = int(dpi[0] + 0.5)
-        ifd[Y_RESOLUTION] = int(dpi[1] + 0.5)
+        ifd[X_RESOLUTION] = dpi[0]
+        ifd[Y_RESOLUTION] = dpi[1]
 
     if bits != (1,):
         ifd[BITSPERSAMPLE] = bits
@@ -1514,25 +1661,59 @@
     if format != 1:
         ifd[SAMPLEFORMAT] = format
 
-    ifd[PHOTOMETRIC_INTERPRETATION] = photo
+    if PHOTOMETRIC_INTERPRETATION not in ifd:
+        ifd[PHOTOMETRIC_INTERPRETATION] = photo
+    elif im.mode in ("1", "L") and ifd[PHOTOMETRIC_INTERPRETATION] == 0:
+        if im.mode == "1":
+            inverted_im = im.copy()
+            px = inverted_im.load()
+            for y in range(inverted_im.height):
+                for x in range(inverted_im.width):
+                    px[x, y] = 0 if px[x, y] == 255 else 255
+            im = inverted_im
+        else:
+            im = ImageOps.invert(im)
 
     if im.mode in ["P", "PA"]:
         lut = im.im.getpalette("RGB", "RGB;L")
         ifd[COLORMAP] = tuple(v * 256 for v in lut)
     # data orientation
     stride = len(bits) * ((im.size[0] * bits[0] + 7) // 8)
-    ifd[ROWSPERSTRIP] = im.size[1]
-    strip_byte_counts = stride * im.size[1]
-    if strip_byte_counts >= 2 ** 16:
+    # aim for given strip size (64 KB by default) when using libtiff writer
+    if libtiff:
+        rows_per_strip = 1 if stride == 0 else min(STRIP_SIZE // stride, im.size[1])
+        # JPEG encoder expects multiple of 8 rows
+        if compression == "jpeg":
+            rows_per_strip = min(((rows_per_strip + 7) // 8) * 8, im.size[1])
+    else:
+        rows_per_strip = im.size[1]
+    if rows_per_strip == 0:
+        rows_per_strip = 1
+    strip_byte_counts = 1 if stride == 0 else stride * rows_per_strip
+    strips_per_image = (im.size[1] + rows_per_strip - 1) // rows_per_strip
+    ifd[ROWSPERSTRIP] = rows_per_strip
+    if strip_byte_counts >= 2**16:
         ifd.tagtype[STRIPBYTECOUNTS] = TiffTags.LONG
-    ifd[STRIPBYTECOUNTS] = strip_byte_counts
-    ifd[STRIPOFFSETS] = 0  # this is adjusted by IFD writer
+    ifd[STRIPBYTECOUNTS] = (strip_byte_counts,) * (strips_per_image - 1) + (
+        stride * im.size[1] - strip_byte_counts * (strips_per_image - 1),
+    )
+    ifd[STRIPOFFSETS] = tuple(
+        range(0, strip_byte_counts * strips_per_image, strip_byte_counts)
+    )  # this is adjusted by IFD writer
     # no compression by default:
     ifd[COMPRESSION] = COMPRESSION_INFO_REV.get(compression, 1)
 
+    if im.mode == "YCbCr":
+        for tag, value in {
+            YCBCRSUBSAMPLING: (1, 1),
+            REFERENCEBLACKWHITE: (0, 255, 128, 255, 128, 255),
+        }.items():
+            ifd.setdefault(tag, value)
+
+    blocklist = [TILEWIDTH, TILELENGTH, TILEOFFSETS, TILEBYTECOUNTS]
     if libtiff:
-        if "quality" in im.encoderinfo:
-            quality = im.encoderinfo["quality"]
+        if "quality" in encoderinfo:
+            quality = encoderinfo["quality"]
             if not isinstance(quality, int) or quality < 0 or quality > 100:
                 raise ValueError("Invalid quality setting")
             if compression != "jpeg":
@@ -1553,17 +1734,14 @@
 
         # optional types for non core tags
         types = {}
-        # SAMPLEFORMAT is determined by the image format and should not be copied
-        # from legacy_ifd.
         # STRIPOFFSETS and STRIPBYTECOUNTS are added by the library
         # based on the data in the strip.
         # The other tags expect arrays with a certain length (fixed or depending on
         # BITSPERSAMPLE, etc), passing arrays with a different length will result in
         # segfaults. Block these tags until we add extra validation.
         # SUBIFD may also cause a segfault.
-        blocklist = [
+        blocklist += [
             REFERENCEBLACKWHITE,
-            SAMPLEFORMAT,
             STRIPBYTECOUNTS,
             STRIPOFFSETS,
             TRANSFERFUNCTION,
@@ -1579,9 +1757,14 @@
         legacy_ifd = {}
         if hasattr(im, "tag"):
             legacy_ifd = im.tag.to_v2()
-        for tag, value in itertools.chain(
-            ifd.items(), getattr(im, "tag_v2", {}).items(), legacy_ifd.items()
-        ):
+
+        # SAMPLEFORMAT is determined by the image format and should not be copied
+        # from legacy_ifd.
+        supplied_tags = {**getattr(im, "tag_v2", {}), **legacy_ifd}
+        if SAMPLEFORMAT in supplied_tags:
+            del supplied_tags[SAMPLEFORMAT]
+
+        for tag, value in itertools.chain(ifd.items(), supplied_tags.items()):
             # Libtiff can only process certain core items without adding
             # them to the custom dictionary.
             # Custom items are supported for int, float, unicode, string and byte
@@ -1606,6 +1789,9 @@
                 else:
                     atts[tag] = value
 
+        if SAMPLEFORMAT in atts and len(atts[SAMPLEFORMAT]) == 1:
+            atts[SAMPLEFORMAT] = atts[SAMPLEFORMAT][0]
+
         logger.debug("Converted items: %s" % sorted(atts.items()))
 
         # libtiff always expects the bytes in native order.
@@ -1621,7 +1807,7 @@
         tags = list(atts.items())
         tags.sort()
         a = (rawmode, compression, _fp, filename, tags, types)
-        e = Image._getencoder(im.mode, "libtiff", a, im.encoderconfig)
+        e = Image._getencoder(im.mode, "libtiff", a, encoderconfig)
         e.setimage(im.im, (0, 0) + im.size)
         while True:
             # undone, change to self.decodermaxblock:
@@ -1634,6 +1820,8 @@
             raise OSError(f"encoder error {s} when writing image file")
 
     else:
+        for tag in blocklist:
+            del ifd[tag]
         offset = ifd.save(fp)
 
         ImageFile._save(
@@ -1641,7 +1829,7 @@
         )
 
     # -- helper for multi-page save --
-    if "_debug_multipage" in im.encoderinfo:
+    if "_debug_multipage" in encoderinfo:
         # just to access o32 and o16 (using correct byte order)
         im._debug_multipage = ifd
 
('src/PIL', 'ImagePalette.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -17,6 +17,7 @@
 #
 
 import array
+import warnings
 
 from . import GimpGradientFile, GimpPaletteFile, ImageColor, PaletteFile
 
@@ -25,27 +26,45 @@
     """
     Color palette for palette mapped images
 
-    :param mode: The mode to use for the Palette. See:
+    :param mode: The mode to use for the palette. See:
         :ref:`concept-modes`. Defaults to "RGB"
     :param palette: An optional palette. If given, it must be a bytearray,
-        an array or a list of ints between 0-255 and of length ``size``
-        times the number of colors in ``mode``. The list must be aligned
-        by channel (All R values must be contiguous in the list before G
-        and B values.) Defaults to 0 through 255 per channel.
-    :param size: An optional palette size. If given, it cannot be equal to
-        or greater than 256. Defaults to 0.
+        an array or a list of ints between 0-255. The list must consist of
+        all channels for one color followed by the next color (e.g. RGBRGBRGB).
+        Defaults to an empty palette.
+    :param size: An optional palette size. If given, an error is raised
+        if ``palette`` is not of equal length.
     """
 
     def __init__(self, mode="RGB", palette=None, size=0):
         self.mode = mode
         self.rawmode = None  # if set, palette contains raw data
-        self.palette = palette or bytearray(range(256)) * len(self.mode)
+        self.palette = palette or bytearray()
+        self.dirty = None
+        if size != 0:
+            warnings.warn(
+                "The size parameter is deprecated and will be removed in Pillow 10 "
+                "(2023-07-01).",
+                DeprecationWarning,
+            )
+            if size != len(self.palette):
+                raise ValueError("wrong palette size")
+
+    @property
+    def palette(self):
+        return self._palette
+
+    @palette.setter
+    def palette(self, palette):
+        self._palette = palette
+
+        mode_len = len(self.mode)
         self.colors = {}
-        self.dirty = None
-        if (size == 0 and len(self.mode) * 256 != len(self.palette)) or (
-            size != 0 and size != len(self.palette)
-        ):
-            raise ValueError("wrong palette size")
+        for i in range(0, len(self.palette), mode_len):
+            color = tuple(self.palette[i : i + mode_len])
+            if color in self.colors:
+                continue
+            self.colors[color] = i // mode_len
 
     def copy(self):
         new = ImagePalette()
@@ -54,7 +73,6 @@
         new.rawmode = self.rawmode
         if self.palette is not None:
             new.palette = self.palette[:]
-        new.colors = self.colors.copy()
         new.dirty = self.dirty
 
         return new
@@ -68,7 +86,7 @@
         """
         if self.rawmode:
             return self.rawmode, self.palette
-        return self.mode + ";L", self.tobytes()
+        return self.mode, self.tobytes()
 
     def tobytes(self):
         """Convert palette to bytes.
@@ -80,14 +98,12 @@
         if isinstance(self.palette, bytes):
             return self.palette
         arr = array.array("B", self.palette)
-        if hasattr(arr, "tobytes"):
-            return arr.tobytes()
-        return arr.tostring()
+        return arr.tobytes()
 
     # Declare tostring as an alias for tobytes
     tostring = tobytes
 
-    def getcolor(self, color):
+    def getcolor(self, color, image=None):
         """Given an rgb tuple, allocate palette entry.
 
         .. warning:: This method is experimental.
@@ -95,19 +111,45 @@
         if self.rawmode:
             raise ValueError("palette contains raw palette data")
         if isinstance(color, tuple):
+            if self.mode == "RGB":
+                if len(color) == 4 and color[3] == 255:
+                    color = color[:3]
+            elif self.mode == "RGBA":
+                if len(color) == 3:
+                    color += (255,)
             try:
                 return self.colors[color]
             except KeyError as e:
                 # allocate new color slot
-                if isinstance(self.palette, bytes):
-                    self.palette = bytearray(self.palette)
-                index = len(self.colors)
+                if not isinstance(self.palette, bytearray):
+                    self._palette = bytearray(self.palette)
+                index = len(self.palette) // 3
+                special_colors = ()
+                if image:
+                    special_colors = (
+                        image.info.get("background"),
+                        image.info.get("transparency"),
+                    )
+                while index in special_colors:
+                    index += 1
                 if index >= 256:
-                    raise ValueError("cannot allocate more than 256 colors") from e
+                    if image:
+                        # Search for an unused index
+                        for i, count in reversed(list(enumerate(image.histogram()))):
+                            if count == 0 and i not in special_colors:
+                                index = i
+                                break
+                    if index >= 256:
+                        raise ValueError("cannot allocate more than 256 colors") from e
                 self.colors[color] = index
-                self.palette[index] = color[0]
-                self.palette[index + 256] = color[1]
-                self.palette[index + 512] = color[2]
+                if index * 3 < len(self.palette):
+                    self._palette = (
+                        self.palette[: index * 3]
+                        + bytes(color)
+                        + self.palette[index * 3 + 3 :]
+                    )
+                else:
+                    self._palette += bytes(color)
                 self.dirty = 1
                 return index
         else:
@@ -169,9 +211,9 @@
 
 
 def negative(mode="RGB"):
-    palette = list(range(256))
+    palette = list(range(256 * len(mode)))
     palette.reverse()
-    return ImagePalette(mode, palette * len(mode))
+    return ImagePalette(mode, [i // len(mode) for i in palette])
 
 
 def random(mode="RGB"):
@@ -184,15 +226,13 @@
 
 
 def sepia(white="#fff0c0"):
-    r, g, b = ImageColor.getrgb(white)
-    r = make_linear_lut(0, r)
-    g = make_linear_lut(0, g)
-    b = make_linear_lut(0, b)
-    return ImagePalette("RGB", r + g + b)
+    bands = [make_linear_lut(0, band) for band in ImageColor.getrgb(white)]
+    return ImagePalette("RGB", [bands[i % 3][i // 3] for i in range(256 * 3)])
 
 
 def wedge(mode="RGB"):
-    return ImagePalette(mode, list(range(256)) * len(mode))
+    palette = list(range(256 * len(mode)))
+    return ImagePalette(mode, [i // len(mode) for i in palette])
 
 
 def load(filename):
('src/PIL', 'BmpImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -24,6 +24,8 @@
 #
 
 
+import os
+
 from . import Image, ImageFile, ImagePalette
 from ._binary import i16le as i16
 from ._binary import i32le as i32
@@ -58,7 +60,7 @@
 # Image plugin for the Windows BMP format.
 # =============================================================================
 class BmpImageFile(ImageFile.ImageFile):
-    """ Image plugin for the Windows Bitmap format (BMP) """
+    """Image plugin for the Windows Bitmap format (BMP)"""
 
     # ------------------------------------------------------------- Description
     format_description = "Windows Bitmap"
@@ -70,7 +72,7 @@
         vars()[k] = v
 
     def _bitmap(self, header=0, offset=0):
-        """ Read relevant info about the BMP """
+        """Read relevant info about the BMP"""
         read, seek = self.fp.read, self.fp.seek
         if header:
             seek(header)
@@ -102,7 +104,7 @@
             file_info["height"] = (
                 i32(header_data, 4)
                 if not file_info["y_flip"]
-                else 2 ** 32 - i32(header_data, 4)
+                else 2**32 - i32(header_data, 4)
             )
             file_info["planes"] = i16(header_data, 8)
             file_info["bits"] = i16(header_data, 10)
@@ -115,9 +117,7 @@
             )
             file_info["colors"] = i32(header_data, 28)
             file_info["palette_padding"] = 4
-            self.info["dpi"] = tuple(
-                int(x / 39.3701 + 0.5) for x in file_info["pixels_per_meter"]
-            )
+            self.info["dpi"] = tuple(x / 39.3701 for x in file_info["pixels_per_meter"])
             if file_info["compression"] == self.BITFIELDS:
                 if len(header_data) >= 52:
                     for idx, mask in enumerate(
@@ -160,6 +160,8 @@
             if file_info.get("colors", 0)
             else (1 << file_info["bits"])
         )
+        if offset == 14 + file_info["header_size"] and file_info["bits"] <= 8:
+            offset += 4 * file_info["colors"]
 
         # ---------------------- Check bit depth for unusual unsupported values
         self.mode, raw_mode = BIT2MODE.get(file_info["bits"], (None, None))
@@ -167,6 +169,7 @@
             raise OSError(f"Unsupported BMP pixel depth ({file_info['bits']})")
 
         # ---------------- Process BMP with Bitfields compression (not palette)
+        decoder_name = "raw"
         if file_info["compression"] == self.BITFIELDS:
             SUPPORTED = {
                 32: [
@@ -208,6 +211,8 @@
         elif file_info["compression"] == self.RAW:
             if file_info["bits"] == 32 and header == 22:  # 32-bit .cur offset
                 raw_mode, self.mode = "BGRA", "RGBA"
+        elif file_info["compression"] == self.RLE8:
+            decoder_name = "bmp_rle"
         else:
             raise OSError(f"Unsupported BMP compression ({file_info['compression']})")
 
@@ -247,7 +252,7 @@
         self.info["compression"] = file_info["compression"]
         self.tile = [
             (
-                "raw",
+                decoder_name,
                 (0, 0, file_info["width"], file_info["height"]),
                 offset or self.fp.tell(),
                 (
@@ -259,7 +264,7 @@
         ]
 
     def _open(self):
-        """ Open file, check magic number and read header """
+        """Open file, check magic number and read header"""
         # read 14 bytes: magic number, filesize, reserved, header final offset
         head_data = self.fp.read(14)
         # choke if the file does not have the required magic bytes
@@ -271,6 +276,57 @@
         self._bitmap(offset=offset)
 
 
+class BmpRleDecoder(ImageFile.PyDecoder):
+    _pulls_fd = True
+
+    def decode(self, buffer):
+        data = bytearray()
+        x = 0
+        while len(data) < self.state.xsize * self.state.ysize:
+            pixels = self.fd.read(1)
+            byte = self.fd.read(1)
+            if not pixels or not byte:
+                break
+            num_pixels = pixels[0]
+            if num_pixels:
+                # encoded mode
+                if x + num_pixels > self.state.xsize:
+                    # Too much data for row
+                    num_pixels = max(0, self.state.xsize - x)
+                data += byte * num_pixels
+                x += num_pixels
+            else:
+                if byte[0] == 0:
+                    # end of line
+                    while len(data) % self.state.xsize != 0:
+                        data += b"\x00"
+                    x = 0
+                elif byte[0] == 1:
+                    # end of bitmap
+                    break
+                elif byte[0] == 2:
+                    # delta
+                    bytes_read = self.fd.read(2)
+                    if len(bytes_read) < 2:
+                        break
+                    right, up = self.fd.read(2)
+                    data += b"\x00" * (right + up * self.state.xsize)
+                    x = len(data) % self.state.xsize
+                else:
+                    # absolute mode
+                    bytes_read = self.fd.read(byte[0])
+                    data += bytes_read
+                    if len(bytes_read) < byte[0]:
+                        break
+                    x += byte[0]
+
+                    # align to 16-bit word boundary
+                    if self.fd.tell() % 2 != 0:
+                        self.fd.seek(1, os.SEEK_CUR)
+        self.set_as_raw(bytes(data), ("P", 0, self.args[-1]))
+        return -1, 0
+
+
 # =============================================================================
 # Image plugin for the DIB format (BMP alias)
 # =============================================================================
@@ -322,7 +378,7 @@
     if bitmap_header:
         offset = 14 + header + colors * 4
         file_size = offset + image
-        if file_size > 2 ** 32 - 1:
+        if file_size > 2**32 - 1:
             raise ValueError("File size is too large for the BMP format")
         fp.write(
             b"BM"  # file type (magic)
@@ -372,6 +428,8 @@
 
 Image.register_mime(BmpImageFile.format, "image/bmp")
 
+Image.register_decoder("bmp_rle", BmpRleDecoder)
+
 Image.register_open(DibImageFile.format, DibImageFile, _dib_accept)
 Image.register_save(DibImageFile.format, _dib_save)
 
('src/PIL', 'ImageTransform.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -47,7 +47,7 @@
         from an affine transform matrix.
     """
 
-    method = Image.AFFINE
+    method = Image.Transform.AFFINE
 
 
 class ExtentTransform(Transform):
@@ -69,7 +69,7 @@
         input image's coordinate system. See :ref:`coordinate-system`.
     """
 
-    method = Image.EXTENT
+    method = Image.Transform.EXTENT
 
 
 class QuadTransform(Transform):
@@ -86,7 +86,7 @@
         source quadrilateral.
     """
 
-    method = Image.QUAD
+    method = Image.Transform.QUAD
 
 
 class MeshTransform(Transform):
@@ -99,4 +99,4 @@
     :param data: A list of (bbox, quad) tuples.
     """
 
-    method = Image.MESH
+    method = Image.Transform.MESH
('src/PIL', 'IcnsImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -6,22 +6,21 @@
 #
 # history:
 # 2004-10-09 fl   Turned into a PIL plugin; removed 2.3 dependencies.
+# 2020-04-04      Allow saving on all operating systems.
 #
 # Copyright (c) 2004 by Bob Ippolito.
 # Copyright (c) 2004 by Secret Labs.
 # Copyright (c) 2004 by Fredrik Lundh.
 # Copyright (c) 2014 by Alastair Houghton.
+# Copyright (c) 2020 by Pan Jing.
 #
 # See the README file for information on usage and redistribution.
 #
 
 import io
 import os
-import shutil
 import struct
-import subprocess
 import sys
-import tempfile
 
 from PIL import Image, ImageFile, PngImagePlugin, features
 
@@ -29,6 +28,7 @@
 if enable_jpeg2k:
     from PIL import Jpeg2KImagePlugin
 
+MAGIC = b"icns"
 HEADERSIZE = 8
 
 
@@ -105,6 +105,7 @@
     if sig[:8] == b"\x89PNG\x0d\x0a\x1a\x0a":
         fobj.seek(start)
         im = PngImagePlugin.PngImageFile(fobj)
+        Image._decompression_bomb_check(im.size)
         return {"RGBA": im}
     elif (
         sig[:4] == b"\xff\x4f\xff\x51"
@@ -121,6 +122,7 @@
         jp2kstream = fobj.read(length)
         f = io.BytesIO(jp2kstream)
         im = Jpeg2KImagePlugin.Jpeg2KImageFile(f)
+        Image._decompression_bomb_check(im.size)
         if im.mode != "RGBA":
             im = im.convert("RGBA")
         return {"RGBA": im}
@@ -165,7 +167,7 @@
         self.dct = dct = {}
         self.fobj = fobj
         sig, filesize = nextheader(fobj)
-        if sig != b"icns":
+        if not _accept(sig):
             raise SyntaxError("not an icns file")
         i = HEADERSIZE
         while i < filesize:
@@ -284,92 +286,99 @@
                 self.best_size[1] * self.best_size[2],
             )
 
-        Image.Image.load(self)
-        if self.im and self.im.size == self.size:
+        px = Image.Image.load(self)
+        if self.im is not None and self.im.size == self.size:
             # Already loaded
-            return
+            return px
         self.load_prepare()
         # This is likely NOT the best way to do it, but whatever.
         im = self.icns.getimage(self.best_size)
 
         # If this is a PNG or JPEG 2000, it won't be loaded yet
-        im.load()
+        px = im.load()
 
         self.im = im.im
         self.mode = im.mode
         self.size = im.size
-        self.load_end()
+
+        return px
 
 
 def _save(im, fp, filename):
     """
     Saves the image as a series of PNG files,
-    that are then converted to a .icns file
-    using the macOS command line utility 'iconutil'.
-
-    macOS only.
+    that are then combined into a .icns file.
     """
     if hasattr(fp, "flush"):
         fp.flush()
 
-    # create the temporary set of pngs
-    with tempfile.TemporaryDirectory(".iconset") as iconset:
-        provided_images = {
-            im.width: im for im in im.encoderinfo.get("append_images", [])
-        }
-        last_w = None
-        second_path = None
-        for w in [16, 32, 128, 256, 512]:
-            prefix = f"icon_{w}x{w}"
-
-            first_path = os.path.join(iconset, prefix + ".png")
-            if last_w == w:
-                shutil.copyfile(second_path, first_path)
-            else:
-                im_w = provided_images.get(w, im.resize((w, w), Image.LANCZOS))
-                im_w.save(first_path)
-
-            second_path = os.path.join(iconset, prefix + "@2x.png")
-            im_w2 = provided_images.get(w * 2, im.resize((w * 2, w * 2), Image.LANCZOS))
-            im_w2.save(second_path)
-            last_w = w * 2
-
-        # iconutil -c icns -o {} {}
-
-        fp_only = not filename
-        if fp_only:
-            f, filename = tempfile.mkstemp(".icns")
-            os.close(f)
-        convert_cmd = ["iconutil", "-c", "icns", "-o", filename, iconset]
-        convert_proc = subprocess.Popen(
-            convert_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL
+    sizes = {
+        b"ic07": 128,
+        b"ic08": 256,
+        b"ic09": 512,
+        b"ic10": 1024,
+        b"ic11": 32,
+        b"ic12": 64,
+        b"ic13": 256,
+        b"ic14": 512,
+    }
+    provided_images = {im.width: im for im in im.encoderinfo.get("append_images", [])}
+    size_streams = {}
+    for size in set(sizes.values()):
+        image = (
+            provided_images[size]
+            if size in provided_images
+            else im.resize((size, size))
         )
 
-        convert_proc.stdout.close()
-
-        retcode = convert_proc.wait()
-
-        if retcode:
-            raise subprocess.CalledProcessError(retcode, convert_cmd)
-
-        if fp_only:
-            with open(filename, "rb") as f:
-                fp.write(f.read())
-
-
-Image.register_open(IcnsImageFile.format, IcnsImageFile, lambda x: x[:4] == b"icns")
+        temp = io.BytesIO()
+        image.save(temp, "png")
+        size_streams[size] = temp.getvalue()
+
+    entries = []
+    for type, size in sizes.items():
+        stream = size_streams[size]
+        entries.append(
+            {"type": type, "size": HEADERSIZE + len(stream), "stream": stream}
+        )
+
+    # Header
+    fp.write(MAGIC)
+    file_length = HEADERSIZE  # Header
+    file_length += HEADERSIZE + 8 * len(entries)  # TOC
+    file_length += sum(entry["size"] for entry in entries)
+    fp.write(struct.pack(">i", file_length))
+
+    # TOC
+    fp.write(b"TOC ")
+    fp.write(struct.pack(">i", HEADERSIZE + len(entries) * HEADERSIZE))
+    for entry in entries:
+        fp.write(entry["type"])
+        fp.write(struct.pack(">i", entry["size"]))
+
+    # Data
+    for entry in entries:
+        fp.write(entry["type"])
+        fp.write(struct.pack(">i", entry["size"]))
+        fp.write(entry["stream"])
+
+    if hasattr(fp, "flush"):
+        fp.flush()
+
+
+def _accept(prefix):
+    return prefix[:4] == MAGIC
+
+
+Image.register_open(IcnsImageFile.format, IcnsImageFile, _accept)
 Image.register_extension(IcnsImageFile.format, ".icns")
 
-if sys.platform == "darwin":
-    Image.register_save(IcnsImageFile.format, _save)
-
-    Image.register_mime(IcnsImageFile.format, "image/icns")
-
+Image.register_save(IcnsImageFile.format, _save)
+Image.register_mime(IcnsImageFile.format, "image/icns")
 
 if __name__ == "__main__":
-
     if len(sys.argv) < 2:
-        print("Syntax: python IcnsImagePlugin.py [file]")
+        print("Syntax: python3 IcnsImagePlugin.py [file]")
         sys.exit()
 
     with open(sys.argv[1], "rb") as fp:
('src/PIL', 'DdsImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -14,6 +14,7 @@
 from io import BytesIO
 
 from . import Image, ImageFile
+from ._binary import o32le as o32
 
 # Magic ("DDS ")
 DDS_MAGIC = 0x20534444
@@ -97,6 +98,9 @@
 DXGI_FORMAT_R8G8B8A8_TYPELESS = 27
 DXGI_FORMAT_R8G8B8A8_UNORM = 28
 DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29
+DXGI_FORMAT_BC5_TYPELESS = 82
+DXGI_FORMAT_BC5_UNORM = 83
+DXGI_FORMAT_BC5_SNORM = 84
 DXGI_FORMAT_BC7_TYPELESS = 97
 DXGI_FORMAT_BC7_UNORM = 98
 DXGI_FORMAT_BC7_UNORM_SRGB = 99
@@ -107,7 +111,9 @@
     format_description = "DirectDraw Surface"
 
     def _open(self):
-        magic, header_size = struct.unpack("<II", self.fp.read(8))
+        if not _accept(self.fp.read(4)):
+            raise SyntaxError("not a DDS file")
+        (header_size,) = struct.unpack("<I", self.fp.read(4))
         if header_size != 124:
             raise OSError(f"Unsupported header size {repr(header_size)}")
         header_bytes = self.fp.read(header_size - 4)
@@ -127,15 +133,17 @@
         fourcc = header.read(4)
         (bitcount,) = struct.unpack("<I", header.read(4))
         masks = struct.unpack("<4I", header.read(16))
-        if pfflags & 0x40:
-            # DDPF_RGB - Texture contains uncompressed RGB data
+        if pfflags & DDPF_RGB:
+            # Texture contains uncompressed RGB data
             masks = {mask: ["R", "G", "B", "A"][i] for i, mask in enumerate(masks)}
             rawmode = ""
             if bitcount == 32:
                 rawmode += masks[0xFF000000]
+            else:
+                self.mode = "RGB"
             rawmode += masks[0xFF0000] + masks[0xFF00] + masks[0xFF]
 
-            self.tile = [("raw", (0, 0) + self.size, 0, (rawmode, 0, 1))]
+            self.tile = [("raw", (0, 0) + self.size, 0, (rawmode[::-1], 0, 1))]
         else:
             data_start = header_size + 4
             n = 0
@@ -148,12 +156,24 @@
             elif fourcc == b"DXT5":
                 self.pixel_format = "DXT5"
                 n = 3
+            elif fourcc == b"BC5S":
+                self.pixel_format = "BC5S"
+                n = 5
+                self.mode = "RGB"
             elif fourcc == b"DX10":
                 data_start += 20
                 # ignoring flags which pertain to volume textures and cubemaps
-                dxt10 = BytesIO(self.fp.read(20))
-                dxgi_format, dimension = struct.unpack("<II", dxt10.read(8))
-                if dxgi_format in (DXGI_FORMAT_BC7_TYPELESS, DXGI_FORMAT_BC7_UNORM):
+                (dxgi_format,) = struct.unpack("<I", self.fp.read(4))
+                self.fp.read(16)
+                if dxgi_format in (DXGI_FORMAT_BC5_TYPELESS, DXGI_FORMAT_BC5_UNORM):
+                    self.pixel_format = "BC5"
+                    n = 5
+                    self.mode = "RGB"
+                elif dxgi_format == DXGI_FORMAT_BC5_SNORM:
+                    self.pixel_format = "BC5S"
+                    n = 5
+                    self.mode = "RGB"
+                elif dxgi_format in (DXGI_FORMAT_BC7_TYPELESS, DXGI_FORMAT_BC7_UNORM):
                     self.pixel_format = "BC7"
                     n = 7
                 elif dxgi_format == DXGI_FORMAT_BC7_UNORM_SRGB:
@@ -176,15 +196,54 @@
             else:
                 raise NotImplementedError(f"Unimplemented pixel format {repr(fourcc)}")
 
-            self.tile = [("bcn", (0, 0) + self.size, data_start, (n))]
+            self.tile = [
+                ("bcn", (0, 0) + self.size, data_start, (n, self.pixel_format))
+            ]
 
     def load_seek(self, pos):
         pass
 
 
-def _validate(prefix):
+def _save(im, fp, filename):
+    if im.mode not in ("RGB", "RGBA"):
+        raise OSError(f"cannot write mode {im.mode} as DDS")
+
+    fp.write(
+        o32(DDS_MAGIC)
+        + o32(124)  # header size
+        + o32(
+            DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | DDSD_PIXELFORMAT
+        )  # flags
+        + o32(im.height)
+        + o32(im.width)
+        + o32((im.width * (32 if im.mode == "RGBA" else 24) + 7) // 8)  # pitch
+        + o32(0)  # depth
+        + o32(0)  # mipmaps
+        + o32(0) * 11  # reserved
+        + o32(32)  # pfsize
+        + o32(DDS_RGBA if im.mode == "RGBA" else DDPF_RGB)  # pfflags
+        + o32(0)  # fourcc
+        + o32(32 if im.mode == "RGBA" else 24)  # bitcount
+        + o32(0xFF0000)  # rbitmask
+        + o32(0xFF00)  # gbitmask
+        + o32(0xFF)  # bbitmask
+        + o32(0xFF000000 if im.mode == "RGBA" else 0)  # abitmask
+        + o32(DDSCAPS_TEXTURE)  # dwCaps
+        + o32(0)  # dwCaps2
+        + o32(0)  # dwCaps3
+        + o32(0)  # dwCaps4
+        + o32(0)  # dwReserved2
+    )
+    if im.mode == "RGBA":
+        r, g, b, a = im.split()
+        im = Image.merge("RGBA", (a, r, g, b))
+    ImageFile._save(im, fp, [("raw", (0, 0) + im.size, 0, (im.mode[::-1], 0, 1))])
+
+
+def _accept(prefix):
     return prefix[:4] == b"DDS "
 
 
-Image.register_open(DdsImageFile.format, DdsImageFile, _validate)
+Image.register_open(DdsImageFile.format, DdsImageFile, _accept)
+Image.register_save(DdsImageFile.format, _save)
 Image.register_extension(DdsImageFile.format, ".dds")
('src/PIL', 'PyAccess.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -54,6 +54,7 @@
         self.image32 = ffi.cast("int **", vals["image32"])
         self.image = ffi.cast("unsigned char **", vals["image"])
         self.xsize, self.ysize = img.im.size
+        self._img = img
 
         # Keep pointer to im object to prevent dereferencing.
         self._im = img.im
@@ -93,7 +94,7 @@
             and len(color) in [3, 4]
         ):
             # RGB or RGBA value for a P image
-            color = self._palette.getcolor(color)
+            color = self._palette.getcolor(color, self._img)
 
         return self.set_pixel(x, y, color)
 
@@ -127,7 +128,7 @@
 
 
 class _PyAccess32_2(PyAccess):
-    """ PA, LA, stored in first and last bytes of a 32 bit word """
+    """PA, LA, stored in first and last bytes of a 32 bit word"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)
@@ -144,7 +145,7 @@
 
 
 class _PyAccess32_3(PyAccess):
-    """ RGB and friends, stored in the first three bytes of a 32 bit word """
+    """RGB and friends, stored in the first three bytes of a 32 bit word"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)
@@ -163,7 +164,7 @@
 
 
 class _PyAccess32_4(PyAccess):
-    """ RGBA etc, all 4 bytes of a 32 bit word """
+    """RGBA etc, all 4 bytes of a 32 bit word"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)
@@ -182,7 +183,7 @@
 
 
 class _PyAccess8(PyAccess):
-    """ 1, L, P, 8 bit images stored as uint8 """
+    """1, L, P, 8 bit images stored as uint8"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = self.image8
@@ -200,7 +201,7 @@
 
 
 class _PyAccessI16_N(PyAccess):
-    """ I;16 access, native bitendian without conversion """
+    """I;16 access, native bitendian without conversion"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("unsigned short **", self.image)
@@ -218,7 +219,7 @@
 
 
 class _PyAccessI16_L(PyAccess):
-    """ I;16L access, with conversion """
+    """I;16L access, with conversion"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_I16 **", self.image)
@@ -239,7 +240,7 @@
 
 
 class _PyAccessI16_B(PyAccess):
-    """ I;16B access, with conversion """
+    """I;16B access, with conversion"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("struct Pixel_I16 **", self.image)
@@ -260,7 +261,7 @@
 
 
 class _PyAccessI32_N(PyAccess):
-    """ Signed Int32 access, native endian """
+    """Signed Int32 access, native endian"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = self.image32
@@ -273,7 +274,7 @@
 
 
 class _PyAccessI32_Swap(PyAccess):
-    """ I;32L/B access, with byteswapping conversion """
+    """I;32L/B access, with byteswapping conversion"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = self.image32
@@ -292,7 +293,7 @@
 
 
 class _PyAccessF(PyAccess):
-    """ 32 bit float access """
+    """32 bit float access"""
 
     def _post_init(self, *args, **kwargs):
         self.pixels = ffi.cast("float **", self.image32)
('src/PIL', '_binary.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -47,6 +47,16 @@
     return unpack_from("<h", c, o)[0]
 
 
+def si16be(c, o=0):
+    """
+    Converts a 2-bytes (16 bits) string to a signed integer, big endian.
+
+    :param c: string containing bytes to convert
+    :param o: offset of bytes to convert in string
+    """
+    return unpack_from(">h", c, o)[0]
+
+
 def i32le(c, o=0):
     """
     Converts a 4-bytes (32 bits) string to an unsigned integer.
('src/PIL', 'Image.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -31,43 +31,81 @@
 import math
 import numbers
 import os
+import re
 import struct
 import sys
 import tempfile
 import warnings
-import xml.etree.ElementTree
 from collections.abc import Callable, MutableMapping
+from enum import IntEnum
 from pathlib import Path
 
+try:
+    import defusedxml.ElementTree as ElementTree
+except ImportError:
+    ElementTree = None
+
 # VERSION was removed in Pillow 6.0.0.
-# PILLOW_VERSION is deprecated and will be removed in a future release.
+# PILLOW_VERSION was removed in Pillow 9.0.0.
 # Use __version__ instead.
-from . import (
-    ImageMode,
-    TiffTags,
-    UnidentifiedImageError,
-    __version__,
-    _plugins,
-    _raise_version_warning,
-)
-from ._binary import i32le
+from . import ImageMode, TiffTags, UnidentifiedImageError, __version__, _plugins
+from ._binary import i32le, o32be, o32le
 from ._util import deferred_error, isPath
 
-if sys.version_info >= (3, 7):
-
-    def __getattr__(name):
-        if name == "PILLOW_VERSION":
-            _raise_version_warning()
-            return __version__
-        raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
-
-
-else:
-
-    from . import PILLOW_VERSION
-
-    # Silence warning
-    assert PILLOW_VERSION
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    categories = {"NORMAL": 0, "SEQUENCE": 1, "CONTAINER": 2}
+    if name in categories:
+        warnings.warn(
+            "Image categories are " + deprecated + "Use is_animated instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return categories[name]
+    elif name in ("NEAREST", "NONE"):
+        warnings.warn(
+            name
+            + " is "
+            + deprecated
+            + "Use Resampling.NEAREST or Dither.NONE instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return 0
+    old_resampling = {
+        "LINEAR": "BILINEAR",
+        "CUBIC": "BICUBIC",
+        "ANTIALIAS": "LANCZOS",
+    }
+    if name in old_resampling:
+        warnings.warn(
+            name
+            + " is "
+            + deprecated
+            + "Use Resampling."
+            + old_resampling[name]
+            + " instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return Resampling[old_resampling[name]]
+    for enum in (Transpose, Transform, Resampling, Dither, Palette, Quantize):
+        if name in enum.__members__:
+            warnings.warn(
+                name
+                + " is "
+                + deprecated
+                + "Use "
+                + enum.__name__
+                + "."
+                + name
+                + " instead.",
+                DeprecationWarning,
+                stacklevel=2,
+            )
+            return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
 
 
 logger = logging.getLogger(__name__)
@@ -143,54 +181,65 @@
 #
 # Constants
 
-NONE = 0
-
 # transpose
-FLIP_LEFT_RIGHT = 0
-FLIP_TOP_BOTTOM = 1
-ROTATE_90 = 2
-ROTATE_180 = 3
-ROTATE_270 = 4
-TRANSPOSE = 5
-TRANSVERSE = 6
+class Transpose(IntEnum):
+    FLIP_LEFT_RIGHT = 0
+    FLIP_TOP_BOTTOM = 1
+    ROTATE_90 = 2
+    ROTATE_180 = 3
+    ROTATE_270 = 4
+    TRANSPOSE = 5
+    TRANSVERSE = 6
+
 
 # transforms (also defined in Imaging.h)
-AFFINE = 0
-EXTENT = 1
-PERSPECTIVE = 2
-QUAD = 3
-MESH = 4
+class Transform(IntEnum):
+    AFFINE = 0
+    EXTENT = 1
+    PERSPECTIVE = 2
+    QUAD = 3
+    MESH = 4
+
 
 # resampling filters (also defined in Imaging.h)
-NEAREST = NONE = 0
-BOX = 4
-BILINEAR = LINEAR = 2
-HAMMING = 5
-BICUBIC = CUBIC = 3
-LANCZOS = ANTIALIAS = 1
-
-_filters_support = {BOX: 0.5, BILINEAR: 1.0, HAMMING: 1.0, BICUBIC: 2.0, LANCZOS: 3.0}
+class Resampling(IntEnum):
+    NEAREST = 0
+    BOX = 4
+    BILINEAR = 2
+    HAMMING = 5
+    BICUBIC = 3
+    LANCZOS = 1
+
+
+_filters_support = {
+    Resampling.BOX: 0.5,
+    Resampling.BILINEAR: 1.0,
+    Resampling.HAMMING: 1.0,
+    Resampling.BICUBIC: 2.0,
+    Resampling.LANCZOS: 3.0,
+}
 
 
 # dithers
-NEAREST = NONE = 0
-ORDERED = 1  # Not yet implemented
-RASTERIZE = 2  # Not yet implemented
-FLOYDSTEINBERG = 3  # default
+class Dither(IntEnum):
+    NONE = 0
+    ORDERED = 1  # Not yet implemented
+    RASTERIZE = 2  # Not yet implemented
+    FLOYDSTEINBERG = 3  # default
+
 
 # palettes/quantizers
-WEB = 0
-ADAPTIVE = 1
-
-MEDIANCUT = 0
-MAXCOVERAGE = 1
-FASTOCTREE = 2
-LIBIMAGEQUANT = 3
-
-# categories
-NORMAL = 0
-SEQUENCE = 1
-CONTAINER = 2
+class Palette(IntEnum):
+    WEB = 0
+    ADAPTIVE = 1
+
+
+class Quantize(IntEnum):
+    MEDIANCUT = 0
+    MAXCOVERAGE = 1
+    FASTOCTREE = 2
+    LIBIMAGEQUANT = 3
+
 
 if hasattr(core, "DEFAULT_STRATEGY"):
     DEFAULT_STRATEGY = core.DEFAULT_STRATEGY
@@ -213,74 +262,21 @@
 ENCODERS = {}
 
 # --------------------------------------------------------------------
-# Modes supported by this version
-
-_MODEINFO = {
-    # NOTE: this table will be removed in future versions.  use
-    # getmode* functions or ImageMode descriptors instead.
-    # official modes
-    "1": ("L", "L", ("1",)),
-    "L": ("L", "L", ("L",)),
-    "I": ("L", "I", ("I",)),
-    "F": ("L", "F", ("F",)),
-    "P": ("P", "L", ("P",)),
-    "RGB": ("RGB", "L", ("R", "G", "B")),
-    "RGBX": ("RGB", "L", ("R", "G", "B", "X")),
-    "RGBA": ("RGB", "L", ("R", "G", "B", "A")),
-    "CMYK": ("RGB", "L", ("C", "M", "Y", "K")),
-    "YCbCr": ("RGB", "L", ("Y", "Cb", "Cr")),
-    "LAB": ("RGB", "L", ("L", "A", "B")),
-    "HSV": ("RGB", "L", ("H", "S", "V")),
-    # Experimental modes include I;16, I;16L, I;16B, RGBa, BGR;15, and
-    # BGR;24.  Use these modes only if you know exactly what you're
-    # doing...
-}
-
-if sys.byteorder == "little":
-    _ENDIAN = "<"
-else:
-    _ENDIAN = ">"
-
-_MODE_CONV = {
-    # official modes
-    "1": ("|b1", None),  # Bits need to be extended to bytes
-    "L": ("|u1", None),
-    "LA": ("|u1", 2),
-    "I": (_ENDIAN + "i4", None),
-    "F": (_ENDIAN + "f4", None),
-    "P": ("|u1", None),
-    "RGB": ("|u1", 3),
-    "RGBX": ("|u1", 4),
-    "RGBA": ("|u1", 4),
-    "CMYK": ("|u1", 4),
-    "YCbCr": ("|u1", 3),
-    "LAB": ("|u1", 3),  # UNDONE - unsigned |u1i1i1
-    "HSV": ("|u1", 3),
-    # I;16 == I;16L, and I;32 == I;32L
-    "I;16": ("<u2", None),
-    "I;16B": (">u2", None),
-    "I;16L": ("<u2", None),
-    "I;16S": ("<i2", None),
-    "I;16BS": (">i2", None),
-    "I;16LS": ("<i2", None),
-    "I;32": ("<u4", None),
-    "I;32B": (">u4", None),
-    "I;32L": ("<u4", None),
-    "I;32S": ("<i4", None),
-    "I;32BS": (">i4", None),
-    "I;32LS": ("<i4", None),
-}
+# Modes
+
+_ENDIAN = "<" if sys.byteorder == "little" else ">"
 
 
 def _conv_type_shape(im):
-    typ, extra = _MODE_CONV[im.mode]
-    if extra is None:
-        return (im.size[1], im.size[0]), typ
-    else:
-        return (im.size[1], im.size[0], extra), typ
-
-
-MODES = sorted(_MODEINFO)
+    m = ImageMode.getmode(im.mode)
+    shape = (im.height, im.width)
+    extra = len(m.bands)
+    if extra != 1:
+        shape += (extra,)
+    return shape, m.typestr
+
+
+MODES = ["1", "CMYK", "F", "HSV", "I", "L", "LAB", "P", "RGB", "RGBA", "RGBX", "YCbCr"]
 
 # raw modes that may be memory mapped.  NOTE: if you change this, you
 # may have to modify the stride calculation in map.c too!
@@ -535,10 +531,21 @@
         self._size = (0, 0)
         self.palette = None
         self.info = {}
-        self.category = NORMAL
+        self._category = 0
         self.readonly = 0
         self.pyaccess = None
         self._exif = None
+
+    def __getattr__(self, name):
+        if name == "category":
+            warnings.warn(
+                "Image categories are deprecated and will be removed in Pillow 10 "
+                "(2023-07-01). Use is_animated instead.",
+                DeprecationWarning,
+                stacklevel=2,
+            )
+            return self._category
+        raise AttributeError(name)
 
     @property
     def width(self):
@@ -586,10 +593,10 @@
         This operation will destroy the image core and release its memory.
         The image data will be unusable afterward.
 
-        This function is only required to close images that have not
-        had their file read and closed by the
-        :py:meth:`~PIL.Image.Image.load` method. See
-        :ref:`file-handling` for more information.
+        This function is required to close images that have multiple frames or
+        have not had their file read and closed by the
+        :py:meth:`~PIL.Image.Image.load` method. See :ref:`file-handling` for
+        more information.
         """
         try:
             if hasattr(self, "_close__fp"):
@@ -648,8 +655,7 @@
             and self.mode == other.mode
             and self.size == other.size
             and self.info == other.info
-            and self.category == other.category
-            and self.readonly == other.readonly
+            and self._category == other._category
             and self.getpalette() == other.getpalette()
             and self.tobytes() == other.tobytes()
         )
@@ -664,6 +670,22 @@
             id(self),
         )
 
+    def _repr_pretty_(self, p, cycle):
+        """IPython plain text display support"""
+
+        # Same as __repr__ but without unpredicatable id(self),
+        # to keep Jupyter notebook `text/plain` output stable.
+        p.text(
+            "<%s.%s image mode=%s size=%dx%d>"
+            % (
+                self.__class__.__module__,
+                self.__class__.__name__,
+                self.mode,
+                self.size[0],
+                self.size[1],
+            )
+        )
+
     def _repr_png_(self):
         """iPython display hook support
 
@@ -676,9 +698,14 @@
             raise ValueError("Could not save to PNG for display") from e
         return b.getvalue()
 
-    @property
-    def __array_interface__(self):
+    class _ArrayData:
+        def __init__(self, new):
+            self.__array_interface__ = new
+
+    def __array__(self, dtype=None):
         # numpy array interface support
+        import numpy as np
+
         new = {}
         shape, typestr = _conv_type_shape(self)
         new["shape"] = shape
@@ -690,7 +717,8 @@
             new["data"] = self.tobytes("raw", "L")
         else:
             new["data"] = self.tobytes()
-        return new
+
+        return np.array(self._ArrayData(new), dtype)
 
     def __getstate__(self):
         return [self.info, self.mode, self.size, self.getpalette(), self.tobytes()]
@@ -732,6 +760,9 @@
             args = self.mode
 
         self.load()
+
+        if self.width == 0 or self.height == 0:
+            return b""
 
         # unpack data
         e = _getencoder(self.mode, encoder_name, args)
@@ -816,28 +847,24 @@
         :returns: An image access object.
         :rtype: :ref:`PixelAccess` or :py:class:`PIL.PyAccess`
         """
-        if self.im and self.palette and self.palette.dirty:
+        if self.im is not None and self.palette and self.palette.dirty:
             # realize palette
             mode, arr = self.palette.getdata()
-            if mode == "RGBA":
-                mode = "RGB"
-                self.info["transparency"] = arr[3::4]
-                arr = bytes(
-                    value for (index, value) in enumerate(arr) if index % 4 != 3
-                )
             self.im.putpalette(mode, arr)
             self.palette.dirty = 0
             self.palette.rawmode = None
-            if "transparency" in self.info:
+            if "transparency" in self.info and mode in ("LA", "PA"):
                 if isinstance(self.info["transparency"], int):
                     self.im.putpalettealpha(self.info["transparency"], 0)
                 else:
                     self.im.putpalettealphas(self.info["transparency"])
                 self.palette.mode = "RGBA"
             else:
-                self.palette.mode = "RGB"
-
-        if self.im:
+                palette_mode = "RGBA" if mode.startswith("RGBA") else "RGB"
+                self.palette.mode = palette_mode
+                self.palette.palette = self.im.getpalette(palette_mode, palette_mode)
+
+        if self.im is not None:
             if cffi and USE_CFFI_ACCESS:
                 if self.pyaccess:
                     return self.pyaccess
@@ -859,7 +886,9 @@
         """
         pass
 
-    def convert(self, mode=None, matrix=None, dither=None, palette=WEB, colors=256):
+    def convert(
+        self, mode=None, matrix=None, dither=None, palette=Palette.WEB, colors=256
+    ):
         """
         Returns a converted copy of this image. For the "P" mode, this
         method translates pixels through the palette.  If mode is
@@ -878,7 +907,7 @@
         The default method of converting a greyscale ("L") or "RGB"
         image into a bilevel (mode "1") image uses Floyd-Steinberg
         dither to approximate the original image luminosity levels. If
-        dither is :data:`NONE`, all values larger than 128 are set to 255 (white),
+        dither is ``None``, all values larger than 127 are set to 255 (white),
         all other values to 0 (black). To use other thresholds, use the
         :py:meth:`~PIL.Image.Image.point` method.
 
@@ -891,28 +920,31 @@
            should be 4- or 12-tuple containing floating point values.
         :param dither: Dithering method, used when converting from
            mode "RGB" to "P" or from "RGB" or "L" to "1".
-           Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
-           Note that this is not used when ``matrix`` is supplied.
+           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`
+           (default). Note that this is not used when ``matrix`` is supplied.
         :param palette: Palette to use when converting from mode "RGB"
-           to "P".  Available palettes are :data:`WEB` or :data:`ADAPTIVE`.
-        :param colors: Number of colors to use for the :data:`ADAPTIVE` palette.
-           Defaults to 256.
+           to "P".  Available palettes are :data:`Palette.WEB` or
+           :data:`Palette.ADAPTIVE`.
+        :param colors: Number of colors to use for the :data:`Palette.ADAPTIVE`
+           palette. Defaults to 256.
         :rtype: :py:class:`~PIL.Image.Image`
         :returns: An :py:class:`~PIL.Image.Image` object.
         """
 
         self.load()
 
+        has_transparency = self.info.get("transparency") is not None
         if not mode and self.mode == "P":
             # determine default mode
             if self.palette:
                 mode = self.palette.mode
             else:
                 mode = "RGB"
+            if mode == "RGB" and has_transparency:
+                mode = "RGBA"
         if not mode or (mode == self.mode and not matrix):
             return self.copy()
 
-        has_transparency = self.info.get("transparency") is not None
         if matrix:
             # matrix conversion
             if mode not in ("L", "RGB"):
@@ -930,12 +962,8 @@
                     transparency = convert_transparency(matrix, transparency)
                 elif len(mode) == 3:
                     transparency = tuple(
-                        [
-                            convert_transparency(
-                                matrix[i * 4 : i * 4 + 4], transparency
-                            )
-                            for i in range(0, len(transparency))
-                        ]
+                        convert_transparency(matrix[i * 4 : i * 4 + 4], transparency)
+                        for i in range(0, len(transparency))
                     )
                 new.info["transparency"] = transparency
             return new
@@ -947,7 +975,9 @@
         delete_trns = False
         # transparency handling
         if has_transparency:
-            if self.mode in ("1", "L", "I", "RGB") and mode == "RGBA":
+            if (self.mode in ("1", "L", "I") and mode in ("LA", "RGBA")) or (
+                self.mode == "RGB" and mode == "RGBA"
+            ):
                 # Use transparent conversion to promote from transparent
                 # color to an alpha channel.
                 new_im = self._new(
@@ -971,23 +1001,30 @@
                     if self.mode == "P":
                         trns_im.putpalette(self.palette)
                         if isinstance(t, tuple):
+                            err = "Couldn't allocate a palette color for transparency"
                             try:
-                                t = trns_im.palette.getcolor(t)
-                            except Exception as e:
-                                raise ValueError(
-                                    "Couldn't allocate a palette color for transparency"
-                                ) from e
-                    trns_im.putpixel((0, 0), t)
-
-                    if mode in ("L", "RGB"):
-                        trns_im = trns_im.convert(mode)
+                                t = trns_im.palette.getcolor(t, self)
+                            except ValueError as e:
+                                if str(e) == "cannot allocate more than 256 colors":
+                                    # If all 256 colors are in use,
+                                    # then there is no need for transparency
+                                    t = None
+                                else:
+                                    raise ValueError(err) from e
+                    if t is None:
+                        trns = None
                     else:
-                        # can't just retrieve the palette number, got to do it
-                        # after quantization.
-                        trns_im = trns_im.convert("RGB")
-                    trns = trns_im.getpixel((0, 0))
-
-            elif self.mode == "P" and mode == "RGBA":
+                        trns_im.putpixel((0, 0), t)
+
+                        if mode in ("L", "RGB"):
+                            trns_im = trns_im.convert(mode)
+                        else:
+                            # can't just retrieve the palette number, got to do it
+                            # after quantization.
+                            trns_im = trns_im.convert("RGB")
+                        trns = trns_im.getpixel((0, 0))
+
+            elif self.mode == "P" and mode in ("LA", "PA", "RGBA"):
                 t = self.info["transparency"]
                 delete_trns = True
 
@@ -998,19 +1035,19 @@
                 else:
                     raise ValueError("Transparency for P mode should be bytes or int")
 
-        if mode == "P" and palette == ADAPTIVE:
+        if mode == "P" and palette == Palette.ADAPTIVE:
             im = self.im.quantize(colors)
             new = self._new(im)
             from . import ImagePalette
 
-            new.palette = ImagePalette.raw("RGB", new.im.getpalette("RGB"))
+            new.palette = ImagePalette.ImagePalette("RGB", new.im.getpalette("RGB"))
             if delete_trns:
                 # This could possibly happen if we requantize to fewer colors.
                 # The transparency would be totally off in that case.
                 del new.info["transparency"]
             if trns is not None:
                 try:
-                    new.info["transparency"] = new.palette.getcolor(trns)
+                    new.info["transparency"] = new.palette.getcolor(trns, new)
                 except Exception:
                     # if we can't make a transparent color, don't leave the old
                     # transparency hanging around to mess us up.
@@ -1020,7 +1057,7 @@
 
         # colorspace conversion
         if dither is None:
-            dither = FLOYDSTEINBERG
+            dither = Dither.FLOYDSTEINBERG
 
         try:
             im = self.im.convert(mode, dither)
@@ -1033,39 +1070,61 @@
                 raise ValueError("illegal conversion") from e
 
         new_im = self._new(im)
+        if mode == "P" and palette != Palette.ADAPTIVE:
+            from . import ImagePalette
+
+            new_im.palette = ImagePalette.ImagePalette("RGB", list(range(256)) * 3)
         if delete_trns:
             # crash fail if we leave a bytes transparency in an rgb/l mode.
             del new_im.info["transparency"]
         if trns is not None:
             if new_im.mode == "P":
                 try:
-                    new_im.info["transparency"] = new_im.palette.getcolor(trns)
-                except Exception:
+                    new_im.info["transparency"] = new_im.palette.getcolor(trns, new_im)
+                except ValueError as e:
                     del new_im.info["transparency"]
-                    warnings.warn("Couldn't allocate palette entry for transparency")
+                    if str(e) != "cannot allocate more than 256 colors":
+                        # If all 256 colors are in use,
+                        # then there is no need for transparency
+                        warnings.warn(
+                            "Couldn't allocate palette entry for transparency"
+                        )
             else:
                 new_im.info["transparency"] = trns
         return new_im
 
-    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1):
+    def quantize(
+        self,
+        colors=256,
+        method=None,
+        kmeans=0,
+        palette=None,
+        dither=Dither.FLOYDSTEINBERG,
+    ):
         """
         Convert the image to 'P' mode with the specified number
         of colors.
 
         :param colors: The desired number of colors, <= 256
-        :param method: :data:`MEDIANCUT` (median cut),
-                       :data:`MAXCOVERAGE` (maximum coverage),
-                       :data:`FASTOCTREE` (fast octree),
-                       :data:`LIBIMAGEQUANT` (libimagequant; check support using
-                       :py:func:`PIL.features.check_feature`
-                       with ``feature="libimagequant"``).
+        :param method: :data:`Quantize.MEDIANCUT` (median cut),
+                       :data:`Quantize.MAXCOVERAGE` (maximum coverage),
+                       :data:`Quantize.FASTOCTREE` (fast octree),
+                       :data:`Quantize.LIBIMAGEQUANT` (libimagequant; check support
+                       using :py:func:`PIL.features.check_feature` with
+                       ``feature="libimagequant"``).
+
+                       By default, :data:`Quantize.MEDIANCUT` will be used.
+
+                       The exception to this is RGBA images. :data:`Quantize.MEDIANCUT`
+                       and :data:`Quantize.MAXCOVERAGE` do not support RGBA images, so
+                       :data:`Quantize.FASTOCTREE` is used by default instead.
         :param kmeans: Integer
         :param palette: Quantize to the palette of given
                         :py:class:`PIL.Image.Image`.
         :param dither: Dithering method, used when converting from
            mode "RGB" to "P" or from "RGB" or "L" to "1".
-           Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
-           Default: 1 (legacy setting)
+           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`
+           (default).
         :returns: A new image
 
         """
@@ -1074,11 +1133,14 @@
 
         if method is None:
             # defaults:
-            method = 0
+            method = Quantize.MEDIANCUT
             if self.mode == "RGBA":
-                method = 2
-
-        if self.mode == "RGBA" and method not in (2, 3):
+                method = Quantize.FASTOCTREE
+
+        if self.mode == "RGBA" and method not in (
+            Quantize.FASTOCTREE,
+            Quantize.LIBIMAGEQUANT,
+        ):
             # Caller specified an invalid mode.
             raise ValueError(
                 "Fast Octree (method == 2) and libimagequant (method == 3) "
@@ -1095,14 +1157,17 @@
                     "only RGB or L mode images can be quantized to a palette"
                 )
             im = self.im.convert("P", dither, palette.im)
-            return self._new(im)
+            new_im = self._new(im)
+            new_im.palette = palette.palette.copy()
+            return new_im
 
         im = self._new(self.im.quantize(colors, method, kmeans))
 
         from . import ImagePalette
 
         mode = im.im.getpalettemode()
-        im.palette = ImagePalette.ImagePalette(mode, im.im.getpalette(mode, mode))
+        palette = im.im.getpalette(mode, mode)[: colors * len(mode)]
+        im.palette = ImagePalette.ImagePalette(mode, palette)
 
         return im
 
@@ -1134,6 +1199,11 @@
 
         if box is None:
             return self.copy()
+
+        if box[2] < box[0]:
+            raise ValueError("Coordinate 'right' is less than 'left'")
+        elif box[3] < box[1]:
+            raise ValueError("Coordinate 'lower' is less than 'upper'")
 
         self.load()
         return self._new(self._crop(self.im, box))
@@ -1242,6 +1312,10 @@
     def getcolors(self, maxcolors=256):
         """
         Returns a list of colors used in this image.
+
+        The colors will be in the image's mode. For example, an RGB image will
+        return a tuple of (red, green, blue) color values, and a P image will
+        return the index of the color in the palette.
 
         :param maxcolors: Maximum number of colors.  If this number is
            exceeded, this method returns None.  The default limit is
@@ -1302,30 +1376,61 @@
             return tuple(extrema)
         return self.im.getextrema()
 
+    def _getxmp(self, xmp_tags):
+        def get_name(tag):
+            return tag.split("}")[1]
+
+        def get_value(element):
+            value = {get_name(k): v for k, v in element.attrib.items()}
+            children = list(element)
+            if children:
+                for child in children:
+                    name = get_name(child.tag)
+                    child_value = get_value(child)
+                    if name in value:
+                        if not isinstance(value[name], list):
+                            value[name] = [value[name]]
+                        value[name].append(child_value)
+                    else:
+                        value[name] = child_value
+            elif value:
+                if element.text:
+                    value["text"] = element.text
+            else:
+                return element.text
+            return value
+
+        if ElementTree is None:
+            warnings.warn("XMP data cannot be read without defusedxml dependency")
+            return {}
+        else:
+            root = ElementTree.fromstring(xmp_tags)
+            return {get_name(root.tag): get_value(root)}
+
     def getexif(self):
         if self._exif is None:
             self._exif = Exif()
 
         exif_info = self.info.get("exif")
-        if exif_info is None and "Raw profile type exif" in self.info:
-            exif_info = bytes.fromhex(
-                "".join(self.info["Raw profile type exif"].split("\n")[3:])
-            )
-        self._exif.load(exif_info)
+        if exif_info is None:
+            if "Raw profile type exif" in self.info:
+                exif_info = bytes.fromhex(
+                    "".join(self.info["Raw profile type exif"].split("\n")[3:])
+                )
+            elif hasattr(self, "tag_v2"):
+                self._exif.bigtiff = self.tag_v2._bigtiff
+                self._exif.endian = self.tag_v2._endian
+                self._exif.load_from_fp(self.fp, self.tag_v2._offset)
+        if exif_info is not None:
+            self._exif.load(exif_info)
 
         # XMP tags
         if 0x0112 not in self._exif:
             xmp_tags = self.info.get("XML:com.adobe.xmp")
             if xmp_tags:
-                root = xml.etree.ElementTree.fromstring(xmp_tags)
-                for elem in root.iter():
-                    if elem.tag.endswith("}Description"):
-                        orientation = elem.attrib.get(
-                            "{http://ns.adobe.com/tiff/1.0/}Orientation"
-                        )
-                        if orientation:
-                            self._exif[0x0112] = int(orientation)
-                        break
+                match = re.search(r'tiff:Orientation="([0-9])"', xmp_tags)
+                if match:
+                    self._exif[0x0112] = int(match[1])
 
         return self._exif
 
@@ -1339,9 +1444,14 @@
         self.load()
         return self.im.ptr
 
-    def getpalette(self):
+    def getpalette(self, rawmode="RGB"):
         """
         Returns the image palette as a list.
+
+        :param rawmode: The mode in which to return the palette. ``None`` will
+           return the palette in its current mode.
+
+           .. versionadded:: 9.1.0
 
         :returns: A list of color values [r, g, b, ...], or None if the
            image has no palette.
@@ -1349,9 +1459,12 @@
 
         self.load()
         try:
-            return list(self.im.getpalette())
+            mode = self.im.getpalettemode()
         except ValueError:
             return None  # no palette
+        if rawmode is None:
+            rawmode = mode
+        return list(self.im.getpalette(mode, rawmode))
 
     def getpixel(self, xy):
         """
@@ -1382,11 +1495,12 @@
 
     def histogram(self, mask=None, extrema=None):
         """
-        Returns a histogram for the image. The histogram is returned as
-        a list of pixel counts, one for each pixel value in the source
-        image. If the image has more than one band, the histograms for
-        all bands are concatenated (for example, the histogram for an
-        "RGB" image contains 768 values).
+        Returns a histogram for the image. The histogram is returned as a
+        list of pixel counts, one for each pixel value in the source
+        image. Counts are grouped into 256 bins for each band, even if
+        the image has more than 8 bits per band. If the image has more
+        than one band, the histograms for all bands are concatenated (for
+        example, the histogram for an "RGB" image contains 768 values).
 
         A bilevel image (mode "1") is treated as a greyscale ("L") image
         by this method.
@@ -1454,8 +1568,8 @@
         also use color strings as supported by the ImageColor module.
 
         If a mask is given, this method updates only the regions
-        indicated by the mask.  You can use either "1", "L" or "RGBA"
-        images (in the latter case, the alpha band is used as mask).
+        indicated by the mask. You can use either "1", "L", "LA", "RGBA"
+        or "RGBa" images (if present, the alpha band is used as mask).
         Where the mask is 255, the given image is copied as is.  Where
         the mask is 0, the current value is preserved.  Intermediate
         values will mix the two images together, including their alpha
@@ -1503,7 +1617,7 @@
         elif isImageType(im):
             im.load()
             if self.mode != im.mode:
-                if self.mode != "RGB" or im.mode not in ("RGBA", "RGBa"):
+                if self.mode != "RGB" or im.mode not in ("LA", "RGBA", "RGBa"):
                     # should use an adapter for this!
                     im = im.convert(self.mode)
             im = im.im
@@ -1540,8 +1654,6 @@
             raise ValueError("Destination must be a 2-tuple")
         if min(source) < 0:
             raise ValueError("Source must be non-negative")
-        if min(dest) < 0:
-            raise ValueError("Destination must be non-negative")
 
         if len(source) == 2:
             source = source + im.size
@@ -1666,13 +1778,14 @@
 
     def putdata(self, data, scale=1.0, offset=0.0):
         """
-        Copies pixel data to this image.  This method copies data from a
-        sequence object into the image, starting at the upper left
-        corner (0, 0), and continuing until either the image or the
-        sequence ends.  The scale and offset values are used to adjust
-        the sequence values: **pixel = value*scale + offset**.
-
-        :param data: A sequence object.
+        Copies pixel data from a flattened sequence object into the image. The
+        values should start at the upper left corner (0, 0), continue to the
+        end of the line, followed directly by the first value of the second
+        line, and so on. Data will be read until either the image or the
+        sequence ends. The scale and offset values are used to adjust the
+        sequence values: **pixel = value*scale + offset**.
+
+        :param data: A flattened sequence object.
         :param scale: An optional scale value.  The default is 1.0.
         :param offset: An optional offset value.  The default is 0.0.
         """
@@ -1686,20 +1799,24 @@
         Attaches a palette to this image.  The image must be a "P", "PA", "L"
         or "LA" image.
 
-        The palette sequence must contain either 768 integer values, or 1024
-        integer values if alpha is included. Each group of values represents
-        the red, green, blue (and alpha if included) values for the
-        corresponding pixel index. Instead of an integer sequence, you can use
-        an 8-bit string.
+        The palette sequence must contain at most 256 colors, made up of one
+        integer value for each channel in the raw mode.
+        For example, if the raw mode is "RGB", then it can contain at most 768
+        values, made up of red, green and blue values for the corresponding pixel
+        index in the 256 colors.
+        If the raw mode is "RGBA", then it can contain at most 1024 values,
+        containing red, green, blue and alpha values.
+
+        Alternatively, an 8-bit string may be used instead of an integer sequence.
 
         :param data: A palette sequence (either a list or a string).
-        :param rawmode: The raw mode of the palette.
+        :param rawmode: The raw mode of the palette. Either "RGB", "RGBA", or a mode
+           that can be transformed to "RGB" or "RGBA" (e.g. "R", "BGR;15", "RGBA;L").
         """
         from . import ImagePalette
 
         if self.mode not in ("L", "LA", "P", "PA"):
             raise ValueError("illegal image mode")
-        self.load()
         if isinstance(data, ImagePalette.ImagePalette):
             palette = ImagePalette.raw(data.rawmode, data.palette)
         else:
@@ -1746,7 +1863,7 @@
             and len(value) in [3, 4]
         ):
             # RGB or RGBA value for a P image
-            value = self.palette.getcolor(value)
+            value = self.palette.getcolor(value, self)
         return self.im.putpixel(xy, value)
 
     def remap_palette(self, dest_map, source_palette=None):
@@ -1767,18 +1884,17 @@
 
         if source_palette is None:
             if self.mode == "P":
-                real_source_palette = self.im.getpalette("RGB")[:768]
+                self.load()
+                source_palette = self.im.getpalette("RGB")[:768]
             else:  # L-mode
-                real_source_palette = bytearray(i // 3 for i in range(768))
-        else:
-            real_source_palette = source_palette
+                source_palette = bytearray(i // 3 for i in range(768))
 
         palette_bytes = b""
         new_positions = [0] * 256
 
         # pick only the used colors from the palette
         for i, oldPosition in enumerate(dest_map):
-            palette_bytes += real_source_palette[oldPosition * 3 : oldPosition * 3 + 3]
+            palette_bytes += source_palette[oldPosition * 3 : oldPosition * 3 + 3]
             new_positions[oldPosition] = i
 
         # replace the palette color id of all pixel with the new id
@@ -1804,23 +1920,19 @@
         m_im = self.copy()
         m_im.mode = "P"
 
-        m_im.palette = ImagePalette.ImagePalette(
-            "RGB", palette=mapping_palette * 3, size=768
-        )
+        m_im.palette = ImagePalette.ImagePalette("RGB", palette=mapping_palette * 3)
         # possibly set palette dirty, then
         # m_im.putpalette(mapping_palette, 'L')  # converts to 'P'
         # or just force it.
         # UNDONE -- this is part of the general issue with palettes
-        m_im.im.putpalette(*m_im.palette.getdata())
+        m_im.im.putpalette("RGB;L", m_im.palette.tobytes())
 
         m_im = m_im.convert("L")
 
         # Internally, we require 768 bytes for a palette.
         new_palette_bytes = palette_bytes + (768 - len(palette_bytes)) * b"\x00"
         m_im.putpalette(new_palette_bytes)
-        m_im.palette = ImagePalette.ImagePalette(
-            "RGB", palette=palette_bytes, size=len(palette_bytes)
-        )
+        m_im.palette = ImagePalette.ImagePalette("RGB", palette=palette_bytes)
 
         return m_im
 
@@ -1841,20 +1953,25 @@
             min(self.size[1], math.ceil(box[3] + support_y)),
         )
 
-    def resize(self, size, resample=BICUBIC, box=None, reducing_gap=None):
+    def resize(self, size, resample=None, box=None, reducing_gap=None):
         """
         Returns a resized copy of this image.
 
         :param size: The requested size in pixels, as a 2-tuple:
            (width, height).
         :param resample: An optional resampling filter.  This can be
-           one of :py:data:`PIL.Image.NEAREST`, :py:data:`PIL.Image.BOX`,
-           :py:data:`PIL.Image.BILINEAR`, :py:data:`PIL.Image.HAMMING`,
-           :py:data:`PIL.Image.BICUBIC` or :py:data:`PIL.Image.LANCZOS`.
-           Default filter is :py:data:`PIL.Image.BICUBIC`.
-           If the image has mode "1" or "P", it is
-           always set to :py:data:`PIL.Image.NEAREST`.
-           See: :ref:`concept-filters`.
+           one of :py:data:`PIL.Image.Resampling.NEAREST`,
+           :py:data:`PIL.Image.Resampling.BOX`,
+           :py:data:`PIL.Image.Resampling.BILINEAR`,
+           :py:data:`PIL.Image.Resampling.HAMMING`,
+           :py:data:`PIL.Image.Resampling.BICUBIC` or
+           :py:data:`PIL.Image.Resampling.LANCZOS`.
+           If the image has mode "1" or "P", it is always set to
+           :py:data:`PIL.Image.Resampling.NEAREST`.
+           If the image mode specifies a number of bits, such as "I;16", then the
+           default filter is :py:data:`PIL.Image.Resampling.NEAREST`.
+           Otherwise, the default filter is
+           :py:data:`PIL.Image.Resampling.BICUBIC`. See: :ref:`concept-filters`.
         :param box: An optional 4-tuple of floats providing
            the source image region to be scaled.
            The values must be within (0, 0, width, height) rectangle.
@@ -1874,18 +1991,28 @@
         :returns: An :py:class:`~PIL.Image.Image` object.
         """
 
-        if resample not in (NEAREST, BILINEAR, BICUBIC, LANCZOS, BOX, HAMMING):
+        if resample is None:
+            type_special = ";" in self.mode
+            resample = Resampling.NEAREST if type_special else Resampling.BICUBIC
+        elif resample not in (
+            Resampling.NEAREST,
+            Resampling.BILINEAR,
+            Resampling.BICUBIC,
+            Resampling.LANCZOS,
+            Resampling.BOX,
+            Resampling.HAMMING,
+        ):
             message = f"Unknown resampling filter ({resample})."
 
             filters = [
-                "{} ({})".format(filter[1], filter[0])
+                f"{filter[1]} ({filter[0]})"
                 for filter in (
-                    (NEAREST, "Image.NEAREST"),
-                    (LANCZOS, "Image.LANCZOS"),
-                    (BILINEAR, "Image.BILINEAR"),
-                    (BICUBIC, "Image.BICUBIC"),
-                    (BOX, "Image.BOX"),
-                    (HAMMING, "Image.HAMMING"),
+                    (Resampling.NEAREST, "Image.Resampling.NEAREST"),
+                    (Resampling.LANCZOS, "Image.Resampling.LANCZOS"),
+                    (Resampling.BILINEAR, "Image.Resampling.BILINEAR"),
+                    (Resampling.BICUBIC, "Image.Resampling.BICUBIC"),
+                    (Resampling.BOX, "Image.Resampling.BOX"),
+                    (Resampling.HAMMING, "Image.Resampling.HAMMING"),
                 )
             ]
             raise ValueError(
@@ -1906,16 +2033,16 @@
             return self.copy()
 
         if self.mode in ("1", "P"):
-            resample = NEAREST
-
-        if self.mode in ["LA", "RGBA"]:
-            im = self.convert(self.mode[:-1] + "a")
+            resample = Resampling.NEAREST
+
+        if self.mode in ["LA", "RGBA"] and resample != Resampling.NEAREST:
+            im = self.convert({"LA": "La", "RGBA": "RGBa"}[self.mode])
             im = im.resize(size, resample, box)
             return im.convert(self.mode)
 
         self.load()
 
-        if reducing_gap is not None and resample != NEAREST:
+        if reducing_gap is not None and resample != Resampling.NEAREST:
             factor_x = int((box[2] - box[0]) / size[0] / reducing_gap) or 1
             factor_y = int((box[3] - box[1]) / size[1] / reducing_gap) or 1
             if factor_x > 1 or factor_y > 1:
@@ -1959,7 +2086,7 @@
             return self.copy()
 
         if self.mode in ["LA", "RGBA"]:
-            im = self.convert(self.mode[:-1] + "a")
+            im = self.convert({"LA": "La", "RGBA": "RGBa"}[self.mode])
             im = im.reduce(factor, box)
             return im.convert(self.mode)
 
@@ -1970,7 +2097,7 @@
     def rotate(
         self,
         angle,
-        resample=NEAREST,
+        resample=Resampling.NEAREST,
         expand=0,
         center=None,
         translate=None,
@@ -1983,12 +2110,12 @@
 
         :param angle: In degrees counter clockwise.
         :param resample: An optional resampling filter.  This can be
-           one of :py:data:`PIL.Image.NEAREST` (use nearest neighbour),
+           one of :py:data:`PIL.Image.Resampling.NEAREST` (use nearest neighbour),
            :py:data:`PIL.Image.BILINEAR` (linear interpolation in a 2x2
-           environment), or :py:data:`PIL.Image.BICUBIC`
+           environment), or :py:data:`PIL.Image.Resampling.BICUBIC`
            (cubic spline interpolation in a 4x4 environment).
            If omitted, or if the image has mode "1" or "P", it is
-           set to :py:data:`PIL.Image.NEAREST`. See :ref:`concept-filters`.
+           set to :py:data:`PIL.Image.Resampling.NEAREST`. See :ref:`concept-filters`.
         :param expand: Optional expansion flag.  If true, expands the output
            image to make it large enough to hold the entire rotated image.
            If false or omitted, make the output image the same size as the
@@ -2009,11 +2136,11 @@
             if angle == 0:
                 return self.copy()
             if angle == 180:
-                return self.transpose(ROTATE_180)
-            if angle == 90 and expand:
-                return self.transpose(ROTATE_90)
-            if angle == 270 and expand:
-                return self.transpose(ROTATE_270)
+                return self.transpose(Transpose.ROTATE_180)
+            if angle in (90, 270) and (expand or self.width == self.height):
+                return self.transpose(
+                    Transpose.ROTATE_90 if angle == 90 else Transpose.ROTATE_270
+                )
 
         # Calculate the affine matrix.  Note that this is the reverse
         # transformation (from destination image to source) because we
@@ -2082,7 +2209,9 @@
             matrix[2], matrix[5] = transform(-(nw - w) / 2.0, -(nh - h) / 2.0, matrix)
             w, h = nw, nh
 
-        return self.transform((w, h), AFFINE, matrix, resample, fillcolor=fillcolor)
+        return self.transform(
+            (w, h), Transform.AFFINE, matrix, resample, fillcolor=fillcolor
+        )
 
     def save(self, fp, format=None, **params):
         """
@@ -2116,12 +2245,17 @@
 
         filename = ""
         open_fp = False
-        if isPath(fp):
+        if isinstance(fp, Path):
+            filename = str(fp)
+            open_fp = True
+        elif isPath(fp):
             filename = fp
             open_fp = True
-        elif isinstance(fp, Path):
-            filename = str(fp)
-            open_fp = True
+        elif fp == sys.stdout:
+            try:
+                fp = sys.stdout.buffer
+            except AttributeError:
+                pass
         if not filename and hasattr(fp, "name") and isPath(fp.name):
             # only set the name for metadata purposes
             filename = fp.name
@@ -2152,7 +2286,9 @@
         else:
             save_handler = SAVE[format.upper()]
 
+        created = False
         if open_fp:
+            created = not os.path.exists(filename)
             if params.get("append", False):
                 # Open also for reading ("+"), because TIFF save_all
                 # writer needs to go back and edit the written data.
@@ -2162,10 +2298,17 @@
 
         try:
             save_handler(self, fp, filename)
-        finally:
-            # do what we can to clean up
+        except Exception:
             if open_fp:
                 fp.close()
+            if created:
+                try:
+                    os.remove(filename)
+                except PermissionError:
+                    pass
+            raise
+        if open_fp:
+            fp.close()
 
     def seek(self, frame):
         """
@@ -2188,7 +2331,7 @@
         if frame != 0:
             raise EOFError
 
-    def show(self, title=None, command=None):
+    def show(self, title=None):
         """
         Displays this image. This method is mainly intended for debugging purposes.
 
@@ -2208,14 +2351,7 @@
         :param title: Optional title to use for the image window, where possible.
         """
 
-        if command is not None:
-            warnings.warn(
-                "The command parameter is deprecated and will be removed in Pillow 9 "
-                "(2022-01-02). Use a subclass of ImageShow.Viewer instead.",
-                DeprecationWarning,
-            )
-
-        _show(self, title=title, command=command)
+        _show(self, title=title)
 
     def split(self):
         """
@@ -2270,7 +2406,7 @@
         """
         return 0
 
-    def thumbnail(self, size, resample=BICUBIC, reducing_gap=2.0):
+    def thumbnail(self, size, resample=Resampling.BICUBIC, reducing_gap=2.0):
         """
         Make this image into a thumbnail.  This method modifies the
         image to contain a thumbnail version of itself, no larger than
@@ -2286,11 +2422,14 @@
 
         :param size: Requested size.
         :param resample: Optional resampling filter.  This can be one
-           of :py:data:`PIL.Image.NEAREST`, :py:data:`PIL.Image.BOX`,
-           :py:data:`PIL.Image.BILINEAR`, :py:data:`PIL.Image.HAMMING`,
-           :py:data:`PIL.Image.BICUBIC` or :py:data:`PIL.Image.LANCZOS`.
-           If omitted, it defaults to :py:data:`PIL.Image.BICUBIC`.
-           (was :py:data:`PIL.Image.NEAREST` prior to version 2.5.0).
+           of :py:data:`PIL.Image.Resampling.NEAREST`,
+           :py:data:`PIL.Image.Resampling.BOX`,
+           :py:data:`PIL.Image.Resampling.BILINEAR`,
+           :py:data:`PIL.Image.Resampling.HAMMING`,
+           :py:data:`PIL.Image.Resampling.BICUBIC` or
+           :py:data:`PIL.Image.Resampling.LANCZOS`.
+           If omitted, it defaults to :py:data:`PIL.Image.Resampling.BICUBIC`.
+           (was :py:data:`PIL.Image.Resampling.NEAREST` prior to version 2.5.0).
            See: :ref:`concept-filters`.
         :param reducing_gap: Apply optimization by resizing the image
            in two steps. First, reducing the image by integer times
@@ -2345,7 +2484,13 @@
     # FIXME: the different transform methods need further explanation
     # instead of bloating the method docs, add a separate chapter.
     def transform(
-        self, size, method, data=None, resample=NEAREST, fill=1, fillcolor=None
+        self,
+        size,
+        method,
+        data=None,
+        resample=Resampling.NEAREST,
+        fill=1,
+        fillcolor=None,
     ):
         """
         Transforms this image.  This method creates a new image with the
@@ -2354,11 +2499,11 @@
 
         :param size: The output size.
         :param method: The transformation method.  This is one of
-          :py:data:`PIL.Image.EXTENT` (cut out a rectangular subregion),
-          :py:data:`PIL.Image.AFFINE` (affine transform),
-          :py:data:`PIL.Image.PERSPECTIVE` (perspective transform),
-          :py:data:`PIL.Image.QUAD` (map a quadrilateral to a rectangle), or
-          :py:data:`PIL.Image.MESH` (map a number of source quadrilaterals
+          :py:data:`PIL.Image.Transform.EXTENT` (cut out a rectangular subregion),
+          :py:data:`PIL.Image.Transform.AFFINE` (affine transform),
+          :py:data:`PIL.Image.Transform.PERSPECTIVE` (perspective transform),
+          :py:data:`PIL.Image.Transform.QUAD` (map a quadrilateral to a rectangle), or
+          :py:data:`PIL.Image.Transform.MESH` (map a number of source quadrilaterals
           in one operation).
 
           It may also be an :py:class:`~PIL.Image.ImageTransformHandler`
@@ -2373,16 +2518,16 @@
 
             class Example:
                 def getdata(self):
-                    method = Image.EXTENT
+                    method = Image.Transform.EXTENT
                     data = (0, 0, 100, 100)
                     return method, data
         :param data: Extra data to the transformation method.
         :param resample: Optional resampling filter.  It can be one of
-           :py:data:`PIL.Image.NEAREST` (use nearest neighbour),
-           :py:data:`PIL.Image.BILINEAR` (linear interpolation in a 2x2
+           :py:data:`PIL.Image.Resampling.NEAREST` (use nearest neighbour),
+           :py:data:`PIL.Image.Resampling.BILINEAR` (linear interpolation in a 2x2
            environment), or :py:data:`PIL.Image.BICUBIC` (cubic spline
            interpolation in a 4x4 environment). If omitted, or if the image
-           has mode "1" or "P", it is set to :py:data:`PIL.Image.NEAREST`.
+           has mode "1" or "P", it is set to :py:data:`PIL.Image.Resampling.NEAREST`.
            See: :ref:`concept-filters`.
         :param fill: If ``method`` is an
           :py:class:`~PIL.Image.ImageTransformHandler` object, this is one of
@@ -2392,18 +2537,11 @@
         :returns: An :py:class:`~PIL.Image.Image` object.
         """
 
-        if self.mode == "LA":
+        if self.mode in ("LA", "RGBA") and resample != Resampling.NEAREST:
             return (
-                self.convert("La")
+                self.convert({"LA": "La", "RGBA": "RGBa"}[self.mode])
                 .transform(size, method, data, resample, fill, fillcolor)
-                .convert("LA")
-            )
-
-        if self.mode == "RGBA":
-            return (
-                self.convert("RGBa")
-                .transform(size, method, data, resample, fill, fillcolor)
-                .convert("RGBA")
+                .convert(self.mode)
             )
 
         if isinstance(method, ImageTransformHandler):
@@ -2417,11 +2555,15 @@
             raise ValueError("missing method data")
 
         im = new(self.mode, size, fillcolor)
+        if self.mode == "P" and self.palette:
+            im.palette = self.palette.copy()
         im.info = self.info.copy()
-        if method == MESH:
+        if method == Transform.MESH:
             # list of quads
             for box, quad in data:
-                im.__transformer(box, self, QUAD, quad, resample, fillcolor is None)
+                im.__transformer(
+                    box, self, Transform.QUAD, quad, resample, fillcolor is None
+                )
         else:
             im.__transformer(
                 (0, 0) + size, self, method, data, resample, fillcolor is None
@@ -2429,25 +2571,27 @@
 
         return im
 
-    def __transformer(self, box, image, method, data, resample=NEAREST, fill=1):
+    def __transformer(
+        self, box, image, method, data, resample=Resampling.NEAREST, fill=1
+    ):
         w = box[2] - box[0]
         h = box[3] - box[1]
 
-        if method == AFFINE:
+        if method == Transform.AFFINE:
             data = data[0:6]
 
-        elif method == EXTENT:
+        elif method == Transform.EXTENT:
             # convert extent to an affine transform
             x0, y0, x1, y1 = data
             xs = (x1 - x0) / w
             ys = (y1 - y0) / h
-            method = AFFINE
+            method = Transform.AFFINE
             data = (xs, 0, x0, 0, ys, y0)
 
-        elif method == PERSPECTIVE:
+        elif method == Transform.PERSPECTIVE:
             data = data[0:8]
 
-        elif method == QUAD:
+        elif method == Transform.QUAD:
             # quadrilateral warp.  data specifies the four corners
             # given as NW, SW, SE, and NE.
             nw = data[0:2]
@@ -2471,22 +2615,26 @@
         else:
             raise ValueError("unknown transformation method")
 
-        if resample not in (NEAREST, BILINEAR, BICUBIC):
-            if resample in (BOX, HAMMING, LANCZOS):
+        if resample not in (
+            Resampling.NEAREST,
+            Resampling.BILINEAR,
+            Resampling.BICUBIC,
+        ):
+            if resample in (Resampling.BOX, Resampling.HAMMING, Resampling.LANCZOS):
                 message = {
-                    BOX: "Image.BOX",
-                    HAMMING: "Image.HAMMING",
-                    LANCZOS: "Image.LANCZOS/Image.ANTIALIAS",
+                    Resampling.BOX: "Image.Resampling.BOX",
+                    Resampling.HAMMING: "Image.Resampling.HAMMING",
+                    Resampling.LANCZOS: "Image.Resampling.LANCZOS",
                 }[resample] + f" ({resample}) cannot be used."
             else:
                 message = f"Unknown resampling filter ({resample})."
 
             filters = [
-                "{} ({})".format(filter[1], filter[0])
+                f"{filter[1]} ({filter[0]})"
                 for filter in (
-                    (NEAREST, "Image.NEAREST"),
-                    (BILINEAR, "Image.BILINEAR"),
-                    (BICUBIC, "Image.BICUBIC"),
+                    (Resampling.NEAREST, "Image.Resampling.NEAREST"),
+                    (Resampling.BILINEAR, "Image.Resampling.BILINEAR"),
+                    (Resampling.BICUBIC, "Image.Resampling.BICUBIC"),
                 )
             ]
             raise ValueError(
@@ -2498,7 +2646,7 @@
         self.load()
 
         if image.mode in ("1", "P"):
-            resample = NEAREST
+            resample = Resampling.NEAREST
 
         self.im.transform2(box, image.im, method, data, resample, fill)
 
@@ -2506,10 +2654,13 @@
         """
         Transpose image (flip or rotate in 90 degree steps)
 
-        :param method: One of :py:data:`PIL.Image.FLIP_LEFT_RIGHT`,
-          :py:data:`PIL.Image.FLIP_TOP_BOTTOM`, :py:data:`PIL.Image.ROTATE_90`,
-          :py:data:`PIL.Image.ROTATE_180`, :py:data:`PIL.Image.ROTATE_270`,
-          :py:data:`PIL.Image.TRANSPOSE` or :py:data:`PIL.Image.TRANSVERSE`.
+        :param method: One of :py:data:`PIL.Image.Transpose.FLIP_LEFT_RIGHT`,
+          :py:data:`PIL.Image.Transpose.FLIP_TOP_BOTTOM`,
+          :py:data:`PIL.Image.Transpose.ROTATE_90`,
+          :py:data:`PIL.Image.Transpose.ROTATE_180`,
+          :py:data:`PIL.Image.Transpose.ROTATE_270`,
+          :py:data:`PIL.Image.Transpose.TRANSPOSE` or
+          :py:data:`PIL.Image.Transpose.TRANSVERSE`.
         :returns: Returns a flipped or rotated copy of this image.
         """
 
@@ -2641,9 +2792,9 @@
     In its simplest form, this function takes three arguments
     (mode, size, and unpacked pixel data).
 
-    You can also use any pixel decoder supported by PIL.  For more
+    You can also use any pixel decoder supported by PIL. For more
     information on available decoders, see the section
-    :ref:`Writing Your Own File Decoder <file-decoders>`.
+    :ref:`Writing Your Own File Codec <file-codecs>`.
 
     Note that this function decodes pixel data only, not entire images.
     If you have an entire image in a string, wrap it in a
@@ -2737,7 +2888,7 @@
 
       from PIL import Image
       import numpy as np
-      im = Image.open('hopper.jpg')
+      im = Image.open("hopper.jpg")
       a = np.asarray(im)
 
     Then this can be used to convert it to a Pillow image::
@@ -2745,8 +2896,21 @@
       im = Image.fromarray(a)
 
     :param obj: Object with array interface
-    :param mode: Mode to use (will be determined from type if None)
-      See: :ref:`concept-modes`.
+    :param mode: Optional mode to use when reading ``obj``. Will be determined from
+      type if ``None``.
+
+      This will not be used to convert the data after reading, but will be used to
+      change how the data is read::
+
+        from PIL import Image
+        import numpy as np
+        a = np.full((1, 1), 300)
+        im = Image.fromarray(a, mode="L")
+        im.getpixel((0, 0))  # 44
+        im = Image.fromarray(a, mode="RGB")
+        im.getpixel((0, 0))  # (44, 1, 0)
+
+      See: :ref:`concept-modes` for general information about modes.
     :returns: An image object.
 
     .. versionadded:: 1.1.6
@@ -2869,7 +3033,7 @@
     :param formats: A list or tuple of formats to attempt to load the file in.
        This can be used to restrict the set of formats checked.
        Pass ``None`` to try all supported formats. You can print the set of
-       available formats by running ``python -m PIL`` or using
+       available formats by running ``python3 -m PIL`` or using
        the :py:func:`PIL.features.pilinfo` function.
     :returns: An :py:class:`~PIL.Image.Image` object.
     :exception FileNotFoundError: If the file cannot be found.
@@ -2918,6 +3082,7 @@
 
     def _open_core(fp, filename, prefix, formats):
         for i in formats:
+            i = i.upper()
             if i not in OPEN:
                 init()
             try:
@@ -2982,7 +3147,7 @@
 def blend(im1, im2, alpha):
     """
     Creates a new image by interpolating between two input images, using
-    a constant alpha.::
+    a constant alpha::
 
         out = image1 * (1.0 - alpha) + image2 * alpha
 
@@ -3178,22 +3343,9 @@
 
 
 def _show(image, **options):
-    options["_internal_pillow"] = True
-    _showxv(image, **options)
-
-
-def _showxv(image, title=None, **options):
     from . import ImageShow
 
-    if "_internal_pillow" in options:
-        del options["_internal_pillow"]
-    else:
-        warnings.warn(
-            "_showxv is deprecated and will be removed in Pillow 9 (2022-01-02). "
-            "Use Image.show instead.",
-            DeprecationWarning,
-        )
-    ImageShow.show(image, title, **options)
+    ImageShow.show(image, **options)
 
 
 # --------------------------------------------------------------------
@@ -3283,7 +3435,8 @@
 
 
 class Exif(MutableMapping):
-    endian = "<"
+    endian = None
+    bigtiff = False
 
     def __init__(self):
         self._data = {}
@@ -3304,11 +3457,11 @@
         # returns a dict with any single item tuples/lists as individual values
         return {k: self._fixup(v) for k, v in src_dict.items()}
 
-    def _get_ifd_dict(self, tag):
+    def _get_ifd_dict(self, offset):
         try:
             # an offset pointer to the location of the nested embedded IFD.
             # It should be a long, but may be corrupted.
-            self.fp.seek(self[tag])
+            self.fp.seek(offset)
         except (KeyError, TypeError):
             pass
         else:
@@ -3317,6 +3470,17 @@
             info = TiffImagePlugin.ImageFileDirectory_v2(self.head)
             info.load(self.fp)
             return self._fixup_dict(info)
+
+    def _get_head(self):
+        version = b"\x2B" if self.bigtiff else b"\x2A"
+        if self.endian == "<":
+            head = b"II" + version + b"\x00" + o32le(8)
+        else:
+            head = b"MM\x00" + version + o32be(8)
+        if self.bigtiff:
+            head += o32le(8) if self.endian == "<" else o32be(8)
+            head += b"\x00\x00\x00\x00"
+        return head
 
     def load(self, data):
         # Extract EXIF information.  This is highly experimental,
@@ -3330,12 +3494,12 @@
         self._loaded_exif = data
         self._data.clear()
         self._ifds.clear()
-        self._info = None
+        if data and data.startswith(b"Exif\x00\x00"):
+            data = data[6:]
         if not data:
+            self._info = None
             return
 
-        if data.startswith(b"Exif\x00\x00"):
-            data = data[6:]
         self.fp = io.BytesIO(data)
         self.head = self.fp.read(8)
         # process dictionary
@@ -3346,106 +3510,150 @@
         self.fp.seek(self._info.next)
         self._info.load(self.fp)
 
+    def load_from_fp(self, fp, offset=None):
+        self._loaded_exif = None
+        self._data.clear()
+        self._ifds.clear()
+
+        # process dictionary
+        from . import TiffImagePlugin
+
+        self.fp = fp
+        if offset is not None:
+            self.head = self._get_head()
+        else:
+            self.head = self.fp.read(8)
+        self._info = TiffImagePlugin.ImageFileDirectory_v2(self.head)
+        if self.endian is None:
+            self.endian = self._info._endian
+        if offset is None:
+            offset = self._info.next
+        self.fp.seek(offset)
+        self._info.load(self.fp)
+
+    def _get_merged_dict(self):
+        merged_dict = dict(self)
+
         # get EXIF extension
-        ifd = self._get_ifd_dict(0x8769)
-        if ifd:
-            self._data.update(ifd)
-            self._ifds[0x8769] = ifd
+        if 0x8769 in self:
+            ifd = self._get_ifd_dict(self[0x8769])
+            if ifd:
+                merged_dict.update(ifd)
+
+        # GPS
+        if 0x8825 in self:
+            merged_dict[0x8825] = self._get_ifd_dict(self[0x8825])
+
+        return merged_dict
 
     def tobytes(self, offset=8):
         from . import TiffImagePlugin
 
-        if self.endian == "<":
-            head = b"II\x2A\x00\x08\x00\x00\x00"
-        else:
-            head = b"MM\x00\x2A\x00\x00\x00\x08"
+        head = self._get_head()
         ifd = TiffImagePlugin.ImageFileDirectory_v2(ifh=head)
         for tag, value in self.items():
+            if tag in [0x8769, 0x8225, 0x8825] and not isinstance(value, dict):
+                value = self.get_ifd(tag)
+                if (
+                    tag == 0x8769
+                    and 0xA005 in value
+                    and not isinstance(value[0xA005], dict)
+                ):
+                    value = value.copy()
+                    value[0xA005] = self.get_ifd(0xA005)
             ifd[tag] = value
         return b"Exif\x00\x00" + head + ifd.tobytes(offset)
 
     def get_ifd(self, tag):
-        if tag not in self._ifds and tag in self:
-            if tag in [0x8825, 0xA005]:
-                # gpsinfo, interop
-                self._ifds[tag] = self._get_ifd_dict(tag)
-            elif tag == 0x927C:  # makernote
-                from .TiffImagePlugin import ImageFileDirectory_v2
-
-                if self[0x927C][:8] == b"FUJIFILM":
-                    exif_data = self[0x927C]
-                    ifd_offset = i32le(exif_data, 8)
-                    ifd_data = exif_data[ifd_offset:]
-
-                    makernote = {}
-                    for i in range(0, struct.unpack("<H", ifd_data[:2])[0]):
-                        ifd_tag, typ, count, data = struct.unpack(
-                            "<HHL4s", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]
-                        )
-                        try:
-                            unit_size, handler = ImageFileDirectory_v2._load_dispatch[
-                                typ
-                            ]
-                        except KeyError:
-                            continue
-                        size = count * unit_size
-                        if size > 4:
-                            (offset,) = struct.unpack("<L", data)
-                            data = ifd_data[offset - 12 : offset + size - 12]
-                        else:
-                            data = data[:size]
-
-                        if len(data) != size:
-                            warnings.warn(
-                                "Possibly corrupt EXIF MakerNote data.  "
-                                f"Expecting to read {size} bytes but only got "
-                                f"{len(data)}. Skipping tag {ifd_tag}"
+        if tag not in self._ifds:
+            if tag in [0x8769, 0x8825]:
+                # exif, gpsinfo
+                if tag in self:
+                    self._ifds[tag] = self._get_ifd_dict(self[tag])
+            elif tag in [0xA005, 0x927C]:
+                # interop, makernote
+                if 0x8769 not in self._ifds:
+                    self.get_ifd(0x8769)
+                tag_data = self._ifds[0x8769][tag]
+                if tag == 0x927C:
+                    # makernote
+                    from .TiffImagePlugin import ImageFileDirectory_v2
+
+                    if tag_data[:8] == b"FUJIFILM":
+                        ifd_offset = i32le(tag_data, 8)
+                        ifd_data = tag_data[ifd_offset:]
+
+                        makernote = {}
+                        for i in range(0, struct.unpack("<H", ifd_data[:2])[0]):
+                            ifd_tag, typ, count, data = struct.unpack(
+                                "<HHL4s", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]
                             )
-                            continue
-
-                        if not data:
-                            continue
-
-                        makernote[ifd_tag] = handler(
-                            ImageFileDirectory_v2(), data, False
-                        )
-                    self._ifds[0x927C] = dict(self._fixup_dict(makernote))
-                elif self.get(0x010F) == "Nintendo":
-                    ifd_data = self[0x927C]
-
-                    makernote = {}
-                    for i in range(0, struct.unpack(">H", ifd_data[:2])[0]):
-                        ifd_tag, typ, count, data = struct.unpack(
-                            ">HHL4s", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]
-                        )
-                        if ifd_tag == 0x1101:
-                            # CameraInfo
-                            (offset,) = struct.unpack(">L", data)
-                            self.fp.seek(offset)
-
-                            camerainfo = {"ModelID": self.fp.read(4)}
-
-                            self.fp.read(4)
-                            # Seconds since 2000
-                            camerainfo["TimeStamp"] = i32le(self.fp.read(12))
-
-                            self.fp.read(4)
-                            camerainfo["InternalSerialNumber"] = self.fp.read(4)
-
-                            self.fp.read(12)
-                            parallax = self.fp.read(4)
-                            handler = ImageFileDirectory_v2._load_dispatch[
-                                TiffTags.FLOAT
-                            ][1]
-                            camerainfo["Parallax"] = handler(
-                                ImageFileDirectory_v2(), parallax, False
+                            try:
+                                (
+                                    unit_size,
+                                    handler,
+                                ) = ImageFileDirectory_v2._load_dispatch[typ]
+                            except KeyError:
+                                continue
+                            size = count * unit_size
+                            if size > 4:
+                                (offset,) = struct.unpack("<L", data)
+                                data = ifd_data[offset - 12 : offset + size - 12]
+                            else:
+                                data = data[:size]
+
+                            if len(data) != size:
+                                warnings.warn(
+                                    "Possibly corrupt EXIF MakerNote data.  "
+                                    f"Expecting to read {size} bytes but only got "
+                                    f"{len(data)}. Skipping tag {ifd_tag}"
+                                )
+                                continue
+
+                            if not data:
+                                continue
+
+                            makernote[ifd_tag] = handler(
+                                ImageFileDirectory_v2(), data, False
                             )
-
-                            self.fp.read(4)
-                            camerainfo["Category"] = self.fp.read(2)
-
-                            makernote = {0x1101: dict(self._fixup_dict(camerainfo))}
-                    self._ifds[0x927C] = makernote
+                        self._ifds[tag] = dict(self._fixup_dict(makernote))
+                    elif self.get(0x010F) == "Nintendo":
+                        makernote = {}
+                        for i in range(0, struct.unpack(">H", tag_data[:2])[0]):
+                            ifd_tag, typ, count, data = struct.unpack(
+                                ">HHL4s", tag_data[i * 12 + 2 : (i + 1) * 12 + 2]
+                            )
+                            if ifd_tag == 0x1101:
+                                # CameraInfo
+                                (offset,) = struct.unpack(">L", data)
+                                self.fp.seek(offset)
+
+                                camerainfo = {"ModelID": self.fp.read(4)}
+
+                                self.fp.read(4)
+                                # Seconds since 2000
+                                camerainfo["TimeStamp"] = i32le(self.fp.read(12))
+
+                                self.fp.read(4)
+                                camerainfo["InternalSerialNumber"] = self.fp.read(4)
+
+                                self.fp.read(12)
+                                parallax = self.fp.read(4)
+                                handler = ImageFileDirectory_v2._load_dispatch[
+                                    TiffTags.FLOAT
+                                ][1]
+                                camerainfo["Parallax"] = handler(
+                                    ImageFileDirectory_v2(), parallax, False
+                                )
+
+                                self.fp.read(4)
+                                camerainfo["Category"] = self.fp.read(2)
+
+                                makernote = {0x1101: dict(self._fixup_dict(camerainfo))}
+                        self._ifds[tag] = makernote
+                else:
+                    # interop
+                    self._ifds[tag] = self._get_ifd_dict(tag_data)
         return self._ifds.get(tag, {})
 
     def __str__(self):
@@ -3465,8 +3673,6 @@
     def __getitem__(self, tag):
         if self._info is not None and tag not in self._data and tag in self._info:
             self._data[tag] = self._fixup(self._info[tag])
-            if tag == 0x8825:
-                self._data[tag] = self.get_ifd(tag)
             del self._info[tag]
         return self._data[tag]
 
('src/PIL', 'SgiImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -193,7 +193,8 @@
     for channel in im.split():
         fp.write(channel.tobytes("raw", rawmode, 0, orientation))
 
-    fp.close()
+    if hasattr(fp, "flush"):
+        fp.flush()
 
 
 class SGI16Decoder(ImageFile.PyDecoder):
('src/PIL', 'ImImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -100,7 +100,7 @@
 # --------------------------------------------------------------------
 # Read IM directory
 
-split = re.compile(br"^([A-Za-z][^:]*):[ \t]*(.*)[ \t]*$")
+split = re.compile(rb"^([A-Za-z][^:]*):[ \t]*(.*)[ \t]*$")
 
 
 def number(s):
('src/PIL', 'PsdImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -22,6 +22,7 @@
 from ._binary import i8
 from ._binary import i16be as i16
 from ._binary import i32be as i32
+from ._binary import si16be as si16
 
 MODES = {
     # (photoshop mode, bits) -> (pil mode, required channels)
@@ -119,7 +120,8 @@
             end = self.fp.tell() + size
             size = i32(read(4))
             if size:
-                self.layers = _layerinfo(self.fp)
+                _layer_data = io.BytesIO(ImageFile._safe_read(self.fp, size))
+                self.layers = _layerinfo(_layer_data, size)
             self.fp.seek(end)
         self.n_frames = len(self.layers)
         self.is_animated = self.n_frames > 1
@@ -153,14 +155,6 @@
         # return layer number (0=image, 1..max=layers)
         return self.frame
 
-    def load_prepare(self):
-        # create image memory if necessary
-        if not self.im or self.im.mode != self.mode or self.im.size != self.size:
-            self.im = Image.core.fill(self.mode, self.size, 0)
-        # create palette (optional)
-        if self.mode == "P":
-            Image.Image.load(self)
-
     def _close__fp(self):
         try:
             if self.__fp != self.fp:
@@ -171,11 +165,20 @@
             self.__fp = None
 
 
-def _layerinfo(file):
+def _layerinfo(fp, ct_bytes):
     # read layerinfo block
     layers = []
-    read = file.read
-    for i in range(abs(i16(read(2)))):
+
+    def read(size):
+        return ImageFile._safe_read(fp, size)
+
+    ct = si16(read(2))
+
+    # sanity check
+    if ct_bytes < (abs(ct) * 20):
+        raise SyntaxError("Layer block too short for number of layers requested")
+
+    for i in range(abs(ct)):
 
         # bounding box
         y0 = i32(read(4))
@@ -184,9 +187,9 @@
         x1 = i32(read(4))
 
         # image info
-        info = []
         mode = []
-        types = list(range(i16(read(2))))
+        ct_types = i16(read(2))
+        types = list(range(ct_types))
         if len(types) > 4:
             continue
 
@@ -199,8 +202,7 @@
                 m = "RGBA"[type]
 
             mode.append(m)
-            size = i32(read(4))
-            info.append((m, size))
+            read(4)  # size
 
         # figure out the image mode
         mode.sort()
@@ -217,28 +219,24 @@
         read(12)  # filler
         name = ""
         size = i32(read(4))  # length of the extra data field
-        combined = 0
         if size:
-            data_end = file.tell() + size
+            data_end = fp.tell() + size
 
             length = i32(read(4))
             if length:
-                file.seek(length - 16, io.SEEK_CUR)
-            combined += length + 4
+                fp.seek(length - 16, io.SEEK_CUR)
 
             length = i32(read(4))
             if length:
-                file.seek(length, io.SEEK_CUR)
-            combined += length + 4
+                fp.seek(length, io.SEEK_CUR)
 
             length = i8(read(1))
             if length:
                 # Don't know the proper encoding,
                 # Latin-1 should be a good guess
                 name = read(length).decode("latin-1", "replace")
-            combined += length + 1
-
-            file.seek(data_end)
+
+            fp.seek(data_end)
         layers.append((name, mode, (x0, y0, x1, y1)))
 
     # get tiles
@@ -246,7 +244,7 @@
     for name, mode, bbox in layers:
         tile = []
         for m in mode:
-            t = _maketile(file, m, bbox, 1)
+            t = _maketile(fp, m, bbox, 1)
             if t:
                 tile.extend(t)
         layers[i] = name, mode, bbox, tile
('src/PIL', 'JpegImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -33,6 +33,7 @@
 #
 import array
 import io
+import math
 import os
 import struct
 import subprocess
@@ -139,8 +140,8 @@
         self.info["adobe"] = i16(s, 5)
         # extract Adobe custom properties
         try:
-            adobe_transform = s[1]
-        except Exception:
+            adobe_transform = s[11]
+        except IndexError:
             pass
         else:
             self.info["adobe_transform"] = adobe_transform
@@ -161,15 +162,17 @@
                 dpi = float(x_resolution[0]) / x_resolution[1]
             except TypeError:
                 dpi = x_resolution
+            if math.isnan(dpi):
+                raise ValueError
             if resolution_unit == 3:  # cm
                 # 1 dpcm = 2.54 dpi
                 dpi *= 2.54
-            self.info["dpi"] = int(dpi + 0.5), int(dpi + 0.5)
-        except (KeyError, SyntaxError, ValueError, ZeroDivisionError):
+            self.info["dpi"] = dpi, dpi
+        except (TypeError, KeyError, SyntaxError, ValueError, ZeroDivisionError):
             # SyntaxError for invalid/unreadable EXIF
             # KeyError for dpi not included
             # ZeroDivisionError for invalid dpi rational value
-            # ValueError for x_resolution[0] being an invalid float
+            # ValueError or TypeError for dpi being an invalid float
             self.info["dpi"] = 72, 72
 
 
@@ -251,7 +254,7 @@
         data = array.array("B" if precision == 1 else "H", s[1:qt_length])
         if sys.byteorder == "little" and precision > 1:
             data.byteswap()  # the values are always big-endian
-        self.quantization[v & 15] = data
+        self.quantization[v & 15] = [data[i] for i in zigzag_index]
         s = s[qt_length:]
 
 
@@ -398,9 +401,10 @@
         """
         s = self.fp.read(read_bytes)
 
-        if not s and ImageFile.LOAD_TRUNCATED_IMAGES:
+        if not s and ImageFile.LOAD_TRUNCATED_IMAGES and not hasattr(self, "_ended"):
             # Premature EOF.
             # Pretend file is finished adding EOI marker
+            self._ended = True
             return b"\xFF\xD9"
 
         return s
@@ -474,11 +478,26 @@
     def _getmp(self):
         return _getmp(self)
 
+    def getxmp(self):
+        """
+        Returns a dictionary containing the XMP tags.
+        Requires defusedxml to be installed.
+
+        :returns: XMP tags in a dictionary.
+        """
+
+        for segment, content in self.applist:
+            if segment == "APP1":
+                marker, xmp_tags = content.rsplit(b"\x00", 1)
+                if marker == b"http://ns.adobe.com/xap/1.0/":
+                    return self._getxmp(xmp_tags)
+        return {}
+
 
 def _getexif(self):
     if "exif" not in self.info:
         return None
-    return dict(self.getexif())
+    return self.getexif()._get_merged_dict()
 
 
 def _getmp(self):
@@ -584,9 +603,11 @@
 
 
 def convert_dict_qtables(qtables):
-    qtables = [qtables[key] for key in range(len(qtables)) if key in qtables]
-    for idx, table in enumerate(qtables):
-        qtables[idx] = [table[i] for i in zigzag_index]
+    warnings.warn(
+        "convert_dict_qtables is deprecated and will be removed in Pillow 10"
+        "(2023-07-01). Conversion is no longer needed.",
+        DeprecationWarning,
+    )
     return qtables
 
 
@@ -605,6 +626,8 @@
 
 
 def _save(im, fp, filename):
+    if im.width == 0 or im.height == 0:
+        raise ValueError("cannot write empty image as JPEG")
 
     try:
         rawmode = RAWMODE[im.mode]
@@ -667,7 +690,9 @@
                 qtables = [lines[s : s + 64] for s in range(0, len(lines), 64)]
         if isinstance(qtables, (tuple, list, dict)):
             if isinstance(qtables, dict):
-                qtables = convert_dict_qtables(qtables)
+                qtables = [
+                    qtables[key] for key in range(len(qtables)) if key in qtables
+                ]
             elif isinstance(qtables, tuple):
                 qtables = list(qtables)
             if not (0 < len(qtables) < 5):
('src/PIL', 'ImageFont.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -29,13 +29,39 @@
 import os
 import sys
 import warnings
+from enum import IntEnum
 from io import BytesIO
 
-from . import Image, features
+from . import Image
 from ._util import isDirectory, isPath
 
-LAYOUT_BASIC = 0
-LAYOUT_RAQM = 1
+
+class Layout(IntEnum):
+    BASIC = 0
+    RAQM = 1
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {Layout: "LAYOUT_"}.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
 
 
 class _imagingft_not_installed:
@@ -165,27 +191,18 @@
         self.index = index
         self.encoding = encoding
 
-        try:
-            from packaging.version import parse as parse_version
-        except ImportError:
-            pass
-        else:
-            freetype_version = parse_version(features.version_module("freetype2"))
-            if freetype_version < parse_version("2.8"):
-                warnings.warn(
-                    "Support for FreeType 2.7 is deprecated and will be removed"
-                    " in Pillow 9 (2022-01-02). Please upgrade to FreeType 2.8 "
-                    "or newer, preferably FreeType 2.10.4 which fixes "
-                    "CVE-2020-15999.",
-                    DeprecationWarning,
-                )
-
-        if layout_engine not in (LAYOUT_BASIC, LAYOUT_RAQM):
-            layout_engine = LAYOUT_BASIC
+        if layout_engine not in (Layout.BASIC, Layout.RAQM):
+            layout_engine = Layout.BASIC
             if core.HAVE_RAQM:
-                layout_engine = LAYOUT_RAQM
-        elif layout_engine == LAYOUT_RAQM and not core.HAVE_RAQM:
-            layout_engine = LAYOUT_BASIC
+                layout_engine = Layout.RAQM
+        elif layout_engine == Layout.RAQM and not core.HAVE_RAQM:
+            import warnings
+
+            warnings.warn(
+                "Raqm layout was requested, but Raqm is not available. "
+                "Falling back to basic layout."
+            )
+            layout_engine = Layout.BASIC
 
         self.layout_engine = layout_engine
 
@@ -212,6 +229,13 @@
         else:
             load_from_bytes(font)
 
+    def __getstate__(self):
+        return [self.path, self.size, self.index, self.encoding, self.layout_engine]
+
+    def __setstate__(self, state):
+        path, size, index, encoding, layout_engine = state
+        self.__init__(path, size, index, encoding, layout_engine)
+
     def _multiline_split(self, text):
         split_character = "\n" if isinstance(text, str) else b"\n"
         return text.split(split_character)
@@ -669,6 +693,7 @@
         )
         size = size[0] + stroke_width * 2, size[1] + stroke_width * 2
         offset = offset[0] - stroke_width, offset[1] - stroke_width
+        Image._decompression_bomb_check(size)
         im = fill("RGBA" if mode == "RGBA" else "L", size, 0)
         self.font.render(
             text, im.id, mode, direction, features, language, stroke_width, ink
@@ -759,15 +784,16 @@
 
         :param font: A font object.
         :param orientation: An optional orientation.  If given, this should
-            be one of Image.FLIP_LEFT_RIGHT, Image.FLIP_TOP_BOTTOM,
-            Image.ROTATE_90, Image.ROTATE_180, or Image.ROTATE_270.
+            be one of Image.Transpose.FLIP_LEFT_RIGHT, Image.Transpose.FLIP_TOP_BOTTOM,
+            Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_180, or
+            Image.Transpose.ROTATE_270.
         """
         self.font = font
         self.orientation = orientation  # any 'transpose' argument, or None
 
     def getsize(self, text, *args, **kwargs):
         w, h = self.font.getsize(text)
-        if self.orientation in (Image.ROTATE_90, Image.ROTATE_270):
+        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):
             return h, w
         return w, h
 
@@ -813,7 +839,7 @@
                  :file:`/System/Library/Fonts/` and :file:`~/Library/Fonts/` on
                  macOS.
 
-    :param size: The requested size, in points.
+    :param size: The requested size, in pixels.
     :param index: Which font face to load (default is first available face).
     :param encoding: Which font encoding to use (default is Unicode). Possible
                      encodings include (see the FreeType documentation for more
@@ -835,7 +861,7 @@
                      This specifies the character set to use. It does not alter the
                      encoding of any text provided in subsequent operations.
     :param layout_engine: Which layout engine to use, if available:
-                     :data:`.ImageFont.LAYOUT_BASIC` or :data:`.ImageFont.LAYOUT_RAQM`.
+                     :data:`.ImageFont.Layout.BASIC` or :data:`.ImageFont.Layout.RAQM`.
 
                      You can check support for Raqm layout using
                      :py:func:`PIL.features.check_feature` with ``feature="raqm"``.
('src/PIL', 'PpmImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -16,6 +16,9 @@
 
 
 from . import Image, ImageFile
+from ._binary import i16be as i16
+from ._binary import o8
+from ._binary import o32le as o32
 
 #
 # --------------------------------------------------------------------
@@ -49,26 +52,46 @@
     format = "PPM"
     format_description = "Pbmplus image"
 
-    def _token(self, s=b""):
-        while True:  # read until next whitespace
+    def _read_magic(self):
+        magic = b""
+        # read until whitespace or longest available magic number
+        for _ in range(6):
             c = self.fp.read(1)
             if not c or c in b_whitespace:
                 break
-            if c > b"\x79":
-                raise ValueError("Expected ASCII value, found binary")
-            s = s + c
-            if len(s) > 9:
-                raise ValueError("Expected int, got > 9 digits")
-        return s
+            magic += c
+        return magic
+
+    def _read_token(self):
+        token = b""
+        while len(token) <= 10:  # read until next whitespace or limit of 10 characters
+            c = self.fp.read(1)
+            if not c:
+                break
+            elif c in b_whitespace:  # token ended
+                if not token:
+                    # skip whitespace at start
+                    continue
+                break
+            elif c == b"#":
+                # ignores rest of the line; stops at CR, LF or EOF
+                while self.fp.read(1) not in b"\r\n":
+                    pass
+                continue
+            token += c
+        if not token:
+            # Token was not even 1 byte
+            raise ValueError("Reached EOF while reading header")
+        elif len(token) > 10:
+            raise ValueError(f"Token too long in file header: {token}")
+        return token
 
     def _open(self):
-
-        # check magic
-        s = self.fp.read(1)
-        if s != b"P":
+        magic_number = self._read_magic()
+        try:
+            mode = MODES[magic_number]
+        except KeyError:
             raise SyntaxError("not a PPM file")
-        magic_number = self._token(s)
-        mode = MODES[magic_number]
 
         self.custom_mimetype = {
             b"P4": "image/x-portable-bitmap",
@@ -82,38 +105,55 @@
         else:
             self.mode = rawmode = mode
 
+        decoder_name = "raw"
         for ix in range(3):
-            while True:
-                while True:
-                    s = self.fp.read(1)
-                    if s not in b_whitespace:
-                        break
-                    if s == b"":
-                        raise ValueError("File does not extend beyond magic number")
-                if s != b"#":
-                    break
-                s = self.fp.readline()
-            s = int(self._token(s))
-            if ix == 0:
-                xsize = s
-            elif ix == 1:
-                ysize = s
+            token = int(self._read_token())
+            if ix == 0:  # token is the x size
+                xsize = token
+            elif ix == 1:  # token is the y size
+                ysize = token
                 if mode == "1":
                     break
-            elif ix == 2:
-                # maxgrey
-                if s > 255:
-                    if not mode == "L":
-                        raise ValueError(f"Too many colors for band: {s}")
-                    if s < 2 ** 16:
-                        self.mode = "I"
-                        rawmode = "I;16B"
-                    else:
-                        self.mode = "I"
-                        rawmode = "I;32B"
+            elif ix == 2:  # token is maxval
+                maxval = token
+                if maxval > 255 and mode == "L":
+                    self.mode = "I"
+
+                # If maxval matches a bit depth, use the raw decoder directly
+                if maxval == 65535 and mode == "L":
+                    rawmode = "I;16B"
+                elif maxval != 255:
+                    decoder_name = "ppm"
+        args = (rawmode, 0, 1) if decoder_name == "raw" else (rawmode, maxval)
 
         self._size = xsize, ysize
-        self.tile = [("raw", (0, 0, xsize, ysize), self.fp.tell(), (rawmode, 0, 1))]
+        self.tile = [(decoder_name, (0, 0, xsize, ysize), self.fp.tell(), args)]
+
+
+class PpmDecoder(ImageFile.PyDecoder):
+    _pulls_fd = True
+
+    def decode(self, buffer):
+        data = bytearray()
+        maxval = min(self.args[-1], 65535)
+        in_byte_count = 1 if maxval < 256 else 2
+        out_byte_count = 4 if self.mode == "I" else 1
+        out_max = 65535 if self.mode == "I" else 255
+        bands = Image.getmodebands(self.mode)
+        while len(data) < self.state.xsize * self.state.ysize * bands * out_byte_count:
+            pixels = self.fd.read(in_byte_count * bands)
+            if len(pixels) < in_byte_count * bands:
+                # eof
+                break
+            for b in range(bands):
+                value = (
+                    pixels[b] if in_byte_count == 1 else i16(pixels, b * in_byte_count)
+                )
+                value = min(out_max, round(value / maxval * out_max))
+                data += o32(value) if self.mode == "I" else o8(value)
+        rawmode = "I;32" if self.mode == "I" else self.mode
+        self.set_as_raw(bytes(data), (rawmode, 0, 1))
+        return -1, 0
 
 
 #
@@ -126,26 +166,19 @@
     elif im.mode == "L":
         rawmode, head = "L", b"P5"
     elif im.mode == "I":
-        if im.getextrema()[1] < 2 ** 16:
-            rawmode, head = "I;16B", b"P5"
-        else:
-            rawmode, head = "I;32B", b"P5"
-    elif im.mode == "RGB":
-        rawmode, head = "RGB", b"P6"
-    elif im.mode == "RGBA":
+        rawmode, head = "I;16B", b"P5"
+    elif im.mode in ("RGB", "RGBA"):
         rawmode, head = "RGB", b"P6"
     else:
         raise OSError(f"cannot write mode {im.mode} as PPM")
-    fp.write(head + ("\n%d %d\n" % im.size).encode("ascii"))
+    fp.write(head + b"\n%d %d\n" % im.size)
     if head == b"P6":
         fp.write(b"255\n")
-    if head == b"P5":
+    elif head == b"P5":
         if rawmode == "L":
             fp.write(b"255\n")
-        elif rawmode == "I;16B":
+        else:
             fp.write(b"65535\n")
-        elif rawmode == "I;32B":
-            fp.write(b"2147483648\n")
     ImageFile._save(im, fp, [("raw", (0, 0) + im.size, 0, (rawmode, 0, 1))])
 
     # ALTERNATIVE: save via builtin debug function
@@ -159,6 +192,8 @@
 Image.register_open(PpmImageFile.format, PpmImageFile, _accept)
 Image.register_save(PpmImageFile.format, _save)
 
+Image.register_decoder("ppm", PpmDecoder)
+
 Image.register_extensions(PpmImageFile.format, [".pbm", ".pgm", ".ppm", ".pnm"])
 
 Image.register_mime(PpmImageFile.format, "image/x-portable-anymap")
('src/PIL', 'FtexImagePlugin.py')
--- /Users/tshi/researchProjs/pillow/Pillow-8.1.0/
+++ /Users/tshi/researchProjs/pillow/Pillow-9.1.0/
@@ -52,13 +52,41 @@
 """
 
 import struct
+import warnings
+from enum import IntEnum
 from io import BytesIO
 
 from . import Image, ImageFile
 
 MAGIC = b"FTEX"
-FORMAT_DXT1 = 0
-FORMAT_UNCOMPRESSED = 1
+
+
+class Format(IntEnum):
+    DXT1 = 0
+    UNCOMPRESSED = 1
+
+
+def __getattr__(name):
+    deprecated = "deprecated and will be removed in Pillow 10 (2023-07-01). "
+    for enum, prefix in {Format: "FORMAT_"}.items():
+        if name.startswith(prefix):
+            name = name[len(prefix) :]
+            if name in enum.__members__:
+                warnings.warn(
+                    prefix
+                    + name
+                    + " is "
+                    + deprecated
+                    + "Use "
+                    + enum.__name__
+                    + "."
+                    + name
+                    + " instead.",
+                    DeprecationWarning,
+                    stacklevel=2,
+                )
+                return enum[name]
+    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
 
 
 class FtexImageFile(ImageFile.ImageFile):
@@ -66,7 +94,8 @@
     format_description = "Texture File Format (IW2:EOC)"
 
     def _open(self):
-        struct.unpack("<I", self.fp.read(4))  # magic
+        if not _accept(self.fp.read(4)):
+            raise SyntaxError("not an FTEX file")
         struct.unpack("<i", self.fp.read(4))  # version
         self._size = struct.unpack("<2i", self.fp.read(8))
         mipmap_count, format_count = struct.unpack("<2i", self.fp.read(8))
@@ -83,10 +112,10 @@
 
         data = self.fp.read(mipmap_size)
 
-        if format == FORMAT_DXT1:
+        if format == Format.DXT1:
             self.mode = "RGBA"
             self.tile = [("bcn", (0, 0) + self.size, 0, (1))]
-        elif format == FORMAT_UNCOMPRESSED:
+        elif format == Format.UNCOMPRESSED:
             self.tile = [("raw", (0, 0) + self.size, 0, ("RGB", 0, 1))]
         else:
             raise ValueError(f"Invalid texture compression format: {repr(format)}")
@@ -98,9 +127,9 @@
         pass
 
 
-def _validate(prefix):
+def _accept(prefix):
     return prefix[:4] == MAGIC
 
 
-Image.register_open(FtexImageFile.format, FtexImageFile, _validate)
+Image.register_open(FtexImageFile.format, FtexImageFile, _accept)
 Image.register_extensions(FtexImageFile.format, [".ftc", ".ftu"])
