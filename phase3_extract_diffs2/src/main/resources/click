('', 'setup.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,40 +1,9 @@
-import io
-import re
-
-from setuptools import find_packages
 from setuptools import setup
-
-with io.open("README.rst", "rt", encoding="utf8") as f:
-    readme = f.read()
-
-with io.open("src/click/__init__.py", "rt", encoding="utf8") as f:
-    version = re.search(r'__version__ = "(.*?)"', f.read()).group(1)

 setup(
     name="click",
-    version=version,
-    url="https://palletsprojects.com/p/click/",
-    project_urls={
-        "Documentation": "https://click.palletsprojects.com/",
-        "Code": "https://github.com/pallets/click",
-        "Issue tracker": "https://github.com/pallets/click/issues",
-    },
-    license="BSD-3-Clause",
-    maintainer="Pallets",
-    maintainer_email="contact@palletsprojects.com",
-    description="Composable command line interface toolkit",
-    long_description=readme,
-    packages=find_packages("src"),
-    package_dir={"": "src"},
-    include_package_data=True,
-    python_requires=">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*",
-    classifiers=[
-        "Development Status :: 5 - Production/Stable",
-        "Intended Audience :: Developers",
-        "License :: OSI Approved :: BSD License",
-        "Operating System :: OS Independent",
-        "Programming Language :: Python",
-        "Programming Language :: Python :: 2",
-        "Programming Language :: Python :: 3",
+    install_requires=[
+        "colorama; platform_system == 'Windows'",
+        "importlib-metadata; python_version < '3.8'",
     ],
 )
('src/click', '_winconsole.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # This module is based on the excellent work by Adam BartoÅ¡ who
 # provided a lot of what went into the implementation here in
 # the discussion to issue1602 in the Python bug tracker.
@@ -6,13 +5,11 @@
 # There are some general differences in regards to how this works
 # compared to the original patches as we do not need to patch
 # the entire interpreter but just work in our little world of
-# echo and prmopt.
-import ctypes
+# echo and prompt.
 import io
-import os
 import sys
 import time
-import zlib
+import typing as t
 from ctypes import byref
 from ctypes import c_char
 from ctypes import c_char_p
@@ -22,28 +19,18 @@
 from ctypes import c_void_p
 from ctypes import POINTER
 from ctypes import py_object
-from ctypes import windll
-from ctypes import WinError
-from ctypes import WINFUNCTYPE
+from ctypes import Structure
 from ctypes.wintypes import DWORD
 from ctypes.wintypes import HANDLE
 from ctypes.wintypes import LPCWSTR
 from ctypes.wintypes import LPWSTR

-import msvcrt
-
 from ._compat import _NonClosingTextIOWrapper
-from ._compat import PY2
-from ._compat import text_type
-
-try:
-    from ctypes import pythonapi
-
-    PyObject_GetBuffer = pythonapi.PyObject_GetBuffer
-    PyBuffer_Release = pythonapi.PyBuffer_Release
-except ImportError:
-    pythonapi = None
-
+
+assert sys.platform == "win32"
+import msvcrt  # noqa: E402
+from ctypes import windll  # noqa: E402
+from ctypes import WINFUNCTYPE  # noqa: E402

 c_ssize_p = POINTER(c_ssize_t)

@@ -57,16 +44,12 @@
 CommandLineToArgvW = WINFUNCTYPE(POINTER(LPWSTR), LPCWSTR, POINTER(c_int))(
     ("CommandLineToArgvW", windll.shell32)
 )
-LocalFree = WINFUNCTYPE(ctypes.c_void_p, ctypes.c_void_p)(
-    ("LocalFree", windll.kernel32)
-)
-
+LocalFree = WINFUNCTYPE(c_void_p, c_void_p)(("LocalFree", windll.kernel32))

 STDIN_HANDLE = GetStdHandle(-10)
 STDOUT_HANDLE = GetStdHandle(-11)
 STDERR_HANDLE = GetStdHandle(-12)

-
 PyBUF_SIMPLE = 0
 PyBUF_WRITABLE = 1

@@ -81,36 +64,37 @@
 EOF = b"\x1a"
 MAX_BYTES_WRITTEN = 32767

-
-class Py_buffer(ctypes.Structure):
-    _fields_ = [
-        ("buf", c_void_p),
-        ("obj", py_object),
-        ("len", c_ssize_t),
-        ("itemsize", c_ssize_t),
-        ("readonly", c_int),
-        ("ndim", c_int),
-        ("format", c_char_p),
-        ("shape", c_ssize_p),
-        ("strides", c_ssize_p),
-        ("suboffsets", c_ssize_p),
-        ("internal", c_void_p),
-    ]
-
-    if PY2:
-        _fields_.insert(-1, ("smalltable", c_ssize_t * 2))
-
-
-# On PyPy we cannot get buffers so our ability to operate here is
-# serverly limited.
-if pythonapi is None:
+try:
+    from ctypes import pythonapi
+except ImportError:
+    # On PyPy we cannot get buffers so our ability to operate here is
+    # severely limited.
     get_buffer = None
 else:
+
+    class Py_buffer(Structure):
+        _fields_ = [
+            ("buf", c_void_p),
+            ("obj", py_object),
+            ("len", c_ssize_t),
+            ("itemsize", c_ssize_t),
+            ("readonly", c_int),
+            ("ndim", c_int),
+            ("format", c_char_p),
+            ("shape", c_ssize_p),
+            ("strides", c_ssize_p),
+            ("suboffsets", c_ssize_p),
+            ("internal", c_void_p),
+        ]
+
+    PyObject_GetBuffer = pythonapi.PyObject_GetBuffer
+    PyBuffer_Release = pythonapi.PyBuffer_Release

     def get_buffer(obj, writable=False):
         buf = Py_buffer()
         flags = PyBUF_WRITABLE if writable else PyBUF_SIMPLE
         PyObject_GetBuffer(py_object(obj), byref(buf), flags)
+
         try:
             buffer_type = c_char * buf.len
             return buffer_type.from_address(buf.buf)
@@ -123,7 +107,7 @@
         self.handle = handle

     def isatty(self):
-        io.RawIOBase.isatty(self)
+        super().isatty()
         return True


@@ -155,7 +139,7 @@
             # wait for KeyboardInterrupt
             time.sleep(0.1)
         if not rv:
-            raise OSError("Windows error: {}".format(GetLastError()))
+            raise OSError(f"Windows error: {GetLastError()}")

         if buffer[0] == EOF:
             return 0
@@ -172,7 +156,7 @@
             return "ERROR_SUCCESS"
         elif errno == ERROR_NOT_ENOUGH_MEMORY:
             return "ERROR_NOT_ENOUGH_MEMORY"
-        return "Windows error {}".format(errno)
+        return f"Windows error {errno}"

     def write(self, b):
         bytes_to_be_written = len(b)
@@ -194,17 +178,17 @@
         return bytes_written


-class ConsoleStream(object):
-    def __init__(self, text_stream, byte_stream):
+class ConsoleStream:
+    def __init__(self, text_stream: t.TextIO, byte_stream: t.BinaryIO) -> None:
         self._text_stream = text_stream
         self.buffer = byte_stream

     @property
-    def name(self):
+    def name(self) -> str:
         return self.buffer.name

-    def write(self, x):
-        if isinstance(x, text_type):
+    def write(self, x: t.AnyStr) -> int:
+        if isinstance(x, str):
             return self._text_stream.write(x)
         try:
             self.flush()
@@ -212,159 +196,84 @@
             pass
         return self.buffer.write(x)

-    def writelines(self, lines):
+    def writelines(self, lines: t.Iterable[t.AnyStr]) -> None:
         for line in lines:
             self.write(line)

-    def __getattr__(self, name):
+    def __getattr__(self, name: str) -> t.Any:
         return getattr(self._text_stream, name)

-    def isatty(self):
+    def isatty(self) -> bool:
         return self.buffer.isatty()

     def __repr__(self):
-        return "<ConsoleStream name={!r} encoding={!r}>".format(
-            self.name, self.encoding
-        )
-
-
-class WindowsChunkedWriter(object):
-    """
-    Wraps a stream (such as stdout), acting as a transparent proxy for all
-    attribute access apart from method 'write()' which we wrap to write in
-    limited chunks due to a Windows limitation on binary console streams.
-    """
-
-    def __init__(self, wrapped):
-        # double-underscore everything to prevent clashes with names of
-        # attributes on the wrapped stream object.
-        self.__wrapped = wrapped
-
-    def __getattr__(self, name):
-        return getattr(self.__wrapped, name)
-
-    def write(self, text):
-        total_to_write = len(text)
-        written = 0
-
-        while written < total_to_write:
-            to_write = min(total_to_write - written, MAX_BYTES_WRITTEN)
-            self.__wrapped.write(text[written : written + to_write])
-            written += to_write
-
-
-_wrapped_std_streams = set()
-
-
-def _wrap_std_stream(name):
-    # Python 2 & Windows 7 and below
-    if (
-        PY2
-        and sys.getwindowsversion()[:2] <= (6, 1)
-        and name not in _wrapped_std_streams
-    ):
-        setattr(sys, name, WindowsChunkedWriter(getattr(sys, name)))
-        _wrapped_std_streams.add(name)
-
-
-def _get_text_stdin(buffer_stream):
+        return f"<ConsoleStream name={self.name!r} encoding={self.encoding!r}>"
+
+
+def _get_text_stdin(buffer_stream: t.BinaryIO) -> t.TextIO:
     text_stream = _NonClosingTextIOWrapper(
         io.BufferedReader(_WindowsConsoleReader(STDIN_HANDLE)),
         "utf-16-le",
         "strict",
         line_buffering=True,
     )
-    return ConsoleStream(text_stream, buffer_stream)
-
-
-def _get_text_stdout(buffer_stream):
+    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))
+
+
+def _get_text_stdout(buffer_stream: t.BinaryIO) -> t.TextIO:
     text_stream = _NonClosingTextIOWrapper(
         io.BufferedWriter(_WindowsConsoleWriter(STDOUT_HANDLE)),
         "utf-16-le",
         "strict",
         line_buffering=True,
     )
-    return ConsoleStream(text_stream, buffer_stream)
-
-
-def _get_text_stderr(buffer_stream):
+    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))
+
+
+def _get_text_stderr(buffer_stream: t.BinaryIO) -> t.TextIO:
     text_stream = _NonClosingTextIOWrapper(
         io.BufferedWriter(_WindowsConsoleWriter(STDERR_HANDLE)),
         "utf-16-le",
         "strict",
         line_buffering=True,
     )
-    return ConsoleStream(text_stream, buffer_stream)
-
-
-if PY2:
-
-    def _hash_py_argv():
-        return zlib.crc32("\x00".join(sys.argv[1:]))
-
-    _initial_argv_hash = _hash_py_argv()
-
-    def _get_windows_argv():
-        argc = c_int(0)
-        argv_unicode = CommandLineToArgvW(GetCommandLineW(), byref(argc))
-        if not argv_unicode:
-            raise WinError()
-        try:
-            argv = [argv_unicode[i] for i in range(0, argc.value)]
-        finally:
-            LocalFree(argv_unicode)
-            del argv_unicode
-
-        if not hasattr(sys, "frozen"):
-            argv = argv[1:]
-            while len(argv) > 0:
-                arg = argv[0]
-                if not arg.startswith("-") or arg == "-":
-                    break
-                argv = argv[1:]
-                if arg.startswith(("-c", "-m")):
-                    break
-
-        return argv[1:]
-
-
-_stream_factories = {
+    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))
+
+
+_stream_factories: t.Mapping[int, t.Callable[[t.BinaryIO], t.TextIO]] = {
     0: _get_text_stdin,
     1: _get_text_stdout,
     2: _get_text_stderr,
 }


-def _is_console(f):
+def _is_console(f: t.TextIO) -> bool:
     if not hasattr(f, "fileno"):
         return False

     try:
         fileno = f.fileno()
-    except OSError:
+    except (OSError, io.UnsupportedOperation):
         return False

     handle = msvcrt.get_osfhandle(fileno)
     return bool(GetConsoleMode(handle, byref(DWORD())))


-def _get_windows_console_stream(f, encoding, errors):
+def _get_windows_console_stream(
+    f: t.TextIO, encoding: t.Optional[str], errors: t.Optional[str]
+) -> t.Optional[t.TextIO]:
     if (
         get_buffer is not None
-        and encoding in ("utf-16-le", None)
-        and errors in ("strict", None)
+        and encoding in {"utf-16-le", None}
+        and errors in {"strict", None}
         and _is_console(f)
     ):
         func = _stream_factories.get(f.fileno())
         if func is not None:
-            if not PY2:
-                f = getattr(f, "buffer", None)
-                if f is None:
-                    return None
-            else:
-                # If we are on Python 2 we need to set the stream that we
-                # deal with to binary mode as otherwise the exercise if a
-                # bit moot.  The same problems apply as for
-                # get_binary_stdin and friends from _compat.
-                msvcrt.setmode(f.fileno(), os.O_BINARY)
-            return func(f)
+            b = getattr(f, "buffer", None)
+
+            if b is None:
+                return None
+
+            return func(b)
('src/click', '_textwrap.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,9 +1,16 @@
 import textwrap
+import typing as t
 from contextlib import contextmanager


 class TextWrapper(textwrap.TextWrapper):
-    def _handle_long_word(self, reversed_chunks, cur_line, cur_len, width):
+    def _handle_long_word(
+        self,
+        reversed_chunks: t.List[str],
+        cur_line: t.List[str],
+        cur_len: int,
+        width: int,
+    ) -> None:
         space_left = max(width - cur_len, 1)

         if self.break_long_words:
@@ -16,22 +23,27 @@
             cur_line.append(reversed_chunks.pop())

     @contextmanager
-    def extra_indent(self, indent):
+    def extra_indent(self, indent: str) -> t.Iterator[None]:
         old_initial_indent = self.initial_indent
         old_subsequent_indent = self.subsequent_indent
         self.initial_indent += indent
         self.subsequent_indent += indent
+
         try:
             yield
         finally:
             self.initial_indent = old_initial_indent
             self.subsequent_indent = old_subsequent_indent

-    def indent_only(self, text):
+    def indent_only(self, text: str) -> str:
         rv = []
+
         for idx, line in enumerate(text.splitlines()):
             indent = self.initial_indent
+
             if idx > 0:
                 indent = self.subsequent_indent
-            rv.append(indent + line)
+
+            rv.append(f"{indent}{line}")
+
         return "\n".join(rv)
('src/click', 'globals.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,9 +1,24 @@
+import typing as t
 from threading import local
+
+if t.TYPE_CHECKING:
+    import typing_extensions as te
+    from .core import Context

 _local = local()


-def get_current_context(silent=False):
+@t.overload
+def get_current_context(silent: "te.Literal[False]" = False) -> "Context":
+    ...
+
+
+@t.overload
+def get_current_context(silent: bool = ...) -> t.Optional["Context"]:
+    ...
+
+
+def get_current_context(silent: bool = False) -> t.Optional["Context"]:
     """Returns the current click context.  This can be used as a way to
     access the current context object from anywhere.  This is a more implicit
     alternative to the :func:`pass_context` decorator.  This function is
@@ -19,29 +34,35 @@
                    :exc:`RuntimeError`.
     """
     try:
-        return _local.stack[-1]
-    except (AttributeError, IndexError):
+        return t.cast("Context", _local.stack[-1])
+    except (AttributeError, IndexError) as e:
         if not silent:
-            raise RuntimeError("There is no active click context.")
+            raise RuntimeError("There is no active click context.") from e
+
+    return None


-def push_context(ctx):
+def push_context(ctx: "Context") -> None:
     """Pushes a new context to the current stack."""
     _local.__dict__.setdefault("stack", []).append(ctx)


-def pop_context():
+def pop_context() -> None:
     """Removes the top level from the stack."""
     _local.stack.pop()


-def resolve_color_default(color=None):
-    """"Internal helper to get the default value of the color flag.  If a
+def resolve_color_default(color: t.Optional[bool] = None) -> t.Optional[bool]:
+    """Internal helper to get the default value of the color flag.  If a
     value is passed it's returned unchanged, otherwise it's looked up from
     the current context.
     """
     if color is not None:
         return color
+
     ctx = get_current_context(silent=True)
+
     if ctx is not None:
         return ctx.color
+
+    return None
('src/click', '__init__.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -4,76 +4,70 @@
 around a simple API that does not come with too much magic and is
 composable.
 """
-from .core import Argument
-from .core import BaseCommand
-from .core import Command
-from .core import CommandCollection
-from .core import Context
-from .core import Group
-from .core import MultiCommand
-from .core import Option
-from .core import Parameter
-from .decorators import argument
-from .decorators import command
-from .decorators import confirmation_option
-from .decorators import group
-from .decorators import help_option
-from .decorators import make_pass_decorator
-from .decorators import option
-from .decorators import pass_context
-from .decorators import pass_obj
-from .decorators import password_option
-from .decorators import version_option
-from .exceptions import Abort
-from .exceptions import BadArgumentUsage
-from .exceptions import BadOptionUsage
-from .exceptions import BadParameter
-from .exceptions import ClickException
-from .exceptions import FileError
-from .exceptions import MissingParameter
-from .exceptions import NoSuchOption
-from .exceptions import UsageError
-from .formatting import HelpFormatter
-from .formatting import wrap_text
-from .globals import get_current_context
-from .parser import OptionParser
-from .termui import clear
-from .termui import confirm
-from .termui import echo_via_pager
-from .termui import edit
-from .termui import get_terminal_size
-from .termui import getchar
-from .termui import launch
-from .termui import pause
-from .termui import progressbar
-from .termui import prompt
-from .termui import secho
-from .termui import style
-from .termui import unstyle
-from .types import BOOL
-from .types import Choice
-from .types import DateTime
-from .types import File
-from .types import FLOAT
-from .types import FloatRange
-from .types import INT
-from .types import IntRange
-from .types import ParamType
-from .types import Path
-from .types import STRING
-from .types import Tuple
-from .types import UNPROCESSED
-from .types import UUID
-from .utils import echo
-from .utils import format_filename
-from .utils import get_app_dir
-from .utils import get_binary_stream
-from .utils import get_os_args
-from .utils import get_text_stream
-from .utils import open_file
+from .core import Argument as Argument
+from .core import BaseCommand as BaseCommand
+from .core import Command as Command
+from .core import CommandCollection as CommandCollection
+from .core import Context as Context
+from .core import Group as Group
+from .core import MultiCommand as MultiCommand
+from .core import Option as Option
+from .core import Parameter as Parameter
+from .decorators import argument as argument
+from .decorators import command as command
+from .decorators import confirmation_option as confirmation_option
+from .decorators import group as group
+from .decorators import help_option as help_option
+from .decorators import make_pass_decorator as make_pass_decorator
+from .decorators import option as option
+from .decorators import pass_context as pass_context
+from .decorators import pass_obj as pass_obj
+from .decorators import password_option as password_option
+from .decorators import version_option as version_option
+from .exceptions import Abort as Abort
+from .exceptions import BadArgumentUsage as BadArgumentUsage
+from .exceptions import BadOptionUsage as BadOptionUsage
+from .exceptions import BadParameter as BadParameter
+from .exceptions import ClickException as ClickException
+from .exceptions import FileError as FileError
+from .exceptions import MissingParameter as MissingParameter
+from .exceptions import NoSuchOption as NoSuchOption
+from .exceptions import UsageError as UsageError
+from .formatting import HelpFormatter as HelpFormatter
+from .formatting import wrap_text as wrap_text
+from .globals import get_current_context as get_current_context
+from .parser import OptionParser as OptionParser
+from .termui import clear as clear
+from .termui import confirm as confirm
+from .termui import echo_via_pager as echo_via_pager
+from .termui import edit as edit
+from .termui import getchar as getchar
+from .termui import launch as launch
+from .termui import pause as pause
+from .termui import progressbar as progressbar
+from .termui import prompt as prompt
+from .termui import secho as secho
+from .termui import style as style
+from .termui import unstyle as unstyle
+from .types import BOOL as BOOL
+from .types import Choice as Choice
+from .types import DateTime as DateTime
+from .types import File as File
+from .types import FLOAT as FLOAT
+from .types import FloatRange as FloatRange
+from .types import INT as INT
+from .types import IntRange as IntRange
+from .types import ParamType as ParamType
+from .types import Path as Path
+from .types import STRING as STRING
+from .types import Tuple as Tuple
+from .types import UNPROCESSED as UNPROCESSED
+from .types import UUID as UUID
+from .utils import echo as echo
+from .utils import format_filename as format_filename
+from .utils import get_app_dir as get_app_dir
+from .utils import get_binary_stream as get_binary_stream
+from .utils import get_text_stream as get_text_stream
+from .utils import open_file as open_file

-# Controls if click should emit the warning about the use of unicode
-# literals.
-disable_unicode_literals_warning = False
-
-__version__ = "7.1"
+__version__ = "8.1.0"
('src/click', 'core.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,17 +1,19 @@
+import enum
 import errno
 import inspect
 import os
 import sys
+import typing as t
+from collections import abc
 from contextlib import contextmanager
+from contextlib import ExitStack
+from functools import partial
 from functools import update_wrapper
+from gettext import gettext as _
+from gettext import ngettext
 from itertools import repeat

-from ._compat import isidentifier
-from ._compat import iteritems
-from ._compat import PY2
-from ._compat import string_types
-from ._unicodefun import _check_for_unicode_literals
-from ._unicodefun import _verify_python3_env
+from . import types
 from .exceptions import Abort
 from .exceptions import BadParameter
 from .exceptions import ClickException
@@ -22,58 +24,49 @@
 from .formatting import join_options
 from .globals import pop_context
 from .globals import push_context
+from .parser import _flag_needs_value
 from .parser import OptionParser
 from .parser import split_opt
 from .termui import confirm
 from .termui import prompt
 from .termui import style
-from .types import BOOL
-from .types import convert_type
-from .types import IntRange
+from .utils import _detect_program_name
+from .utils import _expand_args
 from .utils import echo
-from .utils import get_os_args
 from .utils import make_default_short_help
 from .utils import make_str
 from .utils import PacifyFlushWrapper

-_missing = object()
-
-SUBCOMMAND_METAVAR = "COMMAND [ARGS]..."
-SUBCOMMANDS_METAVAR = "COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]..."
-
-DEPRECATED_HELP_NOTICE = " (DEPRECATED)"
-DEPRECATED_INVOKE_NOTICE = "DeprecationWarning: The command %(name)s is deprecated."
-
-
-def _maybe_show_deprecated_notice(cmd):
-    if cmd.deprecated:
-        echo(style(DEPRECATED_INVOKE_NOTICE % {"name": cmd.name}, fg="red"), err=True)
-
-
-def fast_exit(code):
-    """Exit without garbage collection, this speeds up exit by about 10ms for
-    things like bash completion.
+if t.TYPE_CHECKING:
+    import typing_extensions as te
+    from .shell_completion import CompletionItem
+
+F = t.TypeVar("F", bound=t.Callable[..., t.Any])
+V = t.TypeVar("V")
+
+
+def _complete_visible_commands(
+    ctx: "Context", incomplete: str
+) -> t.Iterator[t.Tuple[str, "Command"]]:
+    """List all the subcommands of a group that start with the
+    incomplete value and aren't hidden.
+
+    :param ctx: Invocation context for the group.
+    :param incomplete: Value being completed. May be empty.
     """
-    sys.stdout.flush()
-    sys.stderr.flush()
-    os._exit(code)
-
-
-def _bashcomplete(cmd, prog_name, complete_var=None):
-    """Internal handler for the bash completion support."""
-    if complete_var is None:
-        complete_var = "_{}_COMPLETE".format(prog_name.replace("-", "_").upper())
-    complete_instr = os.environ.get(complete_var)
-    if not complete_instr:
-        return
-
-    from ._bashcomplete import bashcomplete
-
-    if bashcomplete(cmd, prog_name, complete_var, complete_instr):
-        fast_exit(1)
-
-
-def _check_multicommand(base_command, cmd_name, cmd, register=False):
+    multi = t.cast(MultiCommand, ctx.command)
+
+    for name in multi.list_commands(ctx):
+        if name.startswith(incomplete):
+            command = multi.get_command(ctx, name)
+
+            if command is not None and not command.hidden:
+                yield name, command
+
+
+def _check_multicommand(
+    base_command: "MultiCommand", cmd_name: str, cmd: "Command", register: bool = False
+) -> None:
     if not base_command.chain or not isinstance(cmd, MultiCommand):
         return
     if register:
@@ -87,44 +80,22 @@
             " that is in chain mode. This is not supported."
         )
     raise RuntimeError(
-        "{}. Command '{}' is set to chain and '{}' was added as"
-        " subcommand but it in itself is a multi command. ('{}' is a {}"
-        " within a chained {} named '{}').".format(
-            hint,
-            base_command.name,
-            cmd_name,
-            cmd_name,
-            cmd.__class__.__name__,
-            base_command.__class__.__name__,
-            base_command.name,
-        )
+        f"{hint}. Command {base_command.name!r} is set to chain and"
+        f" {cmd_name!r} was added as a subcommand but it in itself is a"
+        f" multi command. ({cmd_name!r} is a {type(cmd).__name__}"
+        f" within a chained {type(base_command).__name__} named"
+        f" {base_command.name!r})."
     )


-def batch(iterable, batch_size):
+def batch(iterable: t.Iterable[V], batch_size: int) -> t.List[t.Tuple[V, ...]]:
     return list(zip(*repeat(iter(iterable), batch_size)))


-def invoke_param_callback(callback, ctx, param, value):
-    code = getattr(callback, "__code__", None)
-    args = getattr(code, "co_argcount", 3)
-
-    if args < 3:
-        from warnings import warn
-
-        warn(
-            "Parameter callbacks take 3 args, (ctx, param, value). The"
-            " 2-arg style is deprecated and will be removed in 8.0.".format(callback),
-            DeprecationWarning,
-            stacklevel=3,
-        )
-        return callback(ctx, value)
-
-    return callback(ctx, param, value)
-
-
 @contextmanager
-def augment_usage_errors(ctx, param=None):
+def augment_usage_errors(
+    ctx: "Context", param: t.Optional["Parameter"] = None
+) -> t.Iterator[None]:
     """Context manager that attaches extra information to exceptions."""
     try:
         yield
@@ -140,23 +111,53 @@
         raise


-def iter_params_for_processing(invocation_order, declaration_order):
+def iter_params_for_processing(
+    invocation_order: t.Sequence["Parameter"],
+    declaration_order: t.Sequence["Parameter"],
+) -> t.List["Parameter"]:
     """Given a sequence of parameters in the order as should be considered
     for processing and an iterable of parameters that exist, this returns
     a list in the correct order as they should be processed.
     """

-    def sort_key(item):
+    def sort_key(item: "Parameter") -> t.Tuple[bool, float]:
         try:
-            idx = invocation_order.index(item)
+            idx: float = invocation_order.index(item)
         except ValueError:
             idx = float("inf")
-        return (not item.is_eager, idx)
+
+        return not item.is_eager, idx

     return sorted(declaration_order, key=sort_key)


-class Context(object):
+class ParameterSource(enum.Enum):
+    """This is an :class:`~enum.Enum` that indicates the source of a
+    parameter's value.
+
+    Use :meth:`click.Context.get_parameter_source` to get the
+    source for a parameter by name.
+
+    .. versionchanged:: 8.0
+        Use :class:`~enum.Enum` and drop the ``validate`` method.
+
+    .. versionchanged:: 8.0
+        Added the ``PROMPT`` value.
+    """
+
+    COMMANDLINE = enum.auto()
+    """The value was provided by the command line args."""
+    ENVIRONMENT = enum.auto()
+    """The value was provided with an environment variable."""
+    DEFAULT = enum.auto()
+    """Used the default specified by the parameter."""
+    DEFAULT_MAP = enum.auto()
+    """Used a default provided by :attr:`Context.default_map`."""
+    PROMPT = enum.auto()
+    """Used a prompt to confirm a default or provide a value."""
+
+
+class Context:
     """The context is a special internal object that holds state relevant
     for the script execution at every single level.  It's normally invisible
     to commands unless they opt-in to getting access to it.
@@ -167,21 +168,6 @@

     A context can be used as context manager in which case it will call
     :meth:`close` on teardown.
-
-    .. versionadded:: 2.0
-       Added the `resilient_parsing`, `help_option_names`,
-       `token_normalize_func` parameters.
-
-    .. versionadded:: 3.0
-       Added the `allow_extra_args` and `allow_interspersed_args`
-       parameters.
-
-    .. versionadded:: 4.0
-       Added the `color`, `ignore_unknown_options`, and
-       `max_content_width` parameters.
-
-    .. versionadded:: 7.1
-       Added the `show_default` parameter.

     :param command: the command class for this context.
     :param parent: the parent context.
@@ -237,60 +223,95 @@
                   codes are used in texts that Click prints which is by
                   default not the case.  This for instance would affect
                   help output.
-    :param show_default: if True, shows defaults for all options.
-                    Even if an option is later created with show_default=False,
-                    this command-level setting overrides it.
+    :param show_default: Show the default value for commands. If this
+        value is not set, it defaults to the value from the parent
+        context. ``Command.show_default`` overrides this default for the
+        specific command.
+
+    .. versionchanged:: 8.1
+        The ``show_default`` parameter is overridden by
+        ``Command.show_default``, instead of the other way around.
+
+    .. versionchanged:: 8.0
+        The ``show_default`` parameter defaults to the value from the
+        parent context.
+
+    .. versionchanged:: 7.1
+       Added the ``show_default`` parameter.
+
+    .. versionchanged:: 4.0
+        Added the ``color``, ``ignore_unknown_options``, and
+        ``max_content_width`` parameters.
+
+    .. versionchanged:: 3.0
+        Added the ``allow_extra_args`` and ``allow_interspersed_args``
+        parameters.
+
+    .. versionchanged:: 2.0
+        Added the ``resilient_parsing``, ``help_option_names``, and
+        ``token_normalize_func`` parameters.
     """
+
+    #: The formatter class to create with :meth:`make_formatter`.
+    #:
+    #: .. versionadded:: 8.0
+    formatter_class: t.Type["HelpFormatter"] = HelpFormatter

     def __init__(
         self,
-        command,
-        parent=None,
-        info_name=None,
-        obj=None,
-        auto_envvar_prefix=None,
-        default_map=None,
-        terminal_width=None,
-        max_content_width=None,
-        resilient_parsing=False,
-        allow_extra_args=None,
-        allow_interspersed_args=None,
-        ignore_unknown_options=None,
-        help_option_names=None,
-        token_normalize_func=None,
-        color=None,
-        show_default=None,
-    ):
+        command: "Command",
+        parent: t.Optional["Context"] = None,
+        info_name: t.Optional[str] = None,
+        obj: t.Optional[t.Any] = None,
+        auto_envvar_prefix: t.Optional[str] = None,
+        default_map: t.Optional[t.Dict[str, t.Any]] = None,
+        terminal_width: t.Optional[int] = None,
+        max_content_width: t.Optional[int] = None,
+        resilient_parsing: bool = False,
+        allow_extra_args: t.Optional[bool] = None,
+        allow_interspersed_args: t.Optional[bool] = None,
+        ignore_unknown_options: t.Optional[bool] = None,
+        help_option_names: t.Optional[t.List[str]] = None,
+        token_normalize_func: t.Optional[t.Callable[[str], str]] = None,
+        color: t.Optional[bool] = None,
+        show_default: t.Optional[bool] = None,
+    ) -> None:
         #: the parent context or `None` if none exists.
         self.parent = parent
         #: the :class:`Command` for this context.
         self.command = command
         #: the descriptive information name
         self.info_name = info_name
-        #: the parsed parameters except if the value is hidden in which
-        #: case it's not remembered.
-        self.params = {}
+        #: Map of parameter names to their parsed values. Parameters
+        #: with ``expose_value=False`` are not stored.
+        self.params: t.Dict[str, t.Any] = {}
         #: the leftover arguments.
-        self.args = []
+        self.args: t.List[str] = []
         #: protected arguments.  These are arguments that are prepended
         #: to `args` when certain parsing scenarios are encountered but
         #: must be never propagated to another arguments.  This is used
         #: to implement nested parsing.
-        self.protected_args = []
+        self.protected_args: t.List[str] = []
+        #: the collected prefixes of the command's options.
+        self._opt_prefixes: t.Set[str] = set(parent._opt_prefixes) if parent else set()
+
         if obj is None and parent is not None:
             obj = parent.obj
+
         #: the user object stored.
-        self.obj = obj
-        self._meta = getattr(parent, "meta", {})
+        self.obj: t.Any = obj
+        self._meta: t.Dict[str, t.Any] = getattr(parent, "meta", {})

         #: A dictionary (-like object) with defaults for parameters.
         if (
             default_map is None
+            and info_name is not None
             and parent is not None
             and parent.default_map is not None
         ):
             default_map = parent.default_map.get(info_name)
-        self.default_map = default_map
+
+        self.default_map: t.Optional[t.Dict[str, t.Any]] = default_map

         #: This flag indicates if a subcommand is going to be executed. A
         #: group callback can use this information to figure out if it's
@@ -301,22 +322,25 @@
         #: If chaining is enabled this will be set to ``'*'`` in case
         #: any commands are executed.  It is however not possible to
         #: figure out which ones.  If you require this knowledge you
-        #: should use a :func:`resultcallback`.
-        self.invoked_subcommand = None
+        #: should use a :func:`result_callback`.
+        self.invoked_subcommand: t.Optional[str] = None

         if terminal_width is None and parent is not None:
             terminal_width = parent.terminal_width
+
         #: The width of the terminal (None is autodetection).
-        self.terminal_width = terminal_width
+        self.terminal_width: t.Optional[int] = terminal_width

         if max_content_width is None and parent is not None:
             max_content_width = parent.max_content_width
+
         #: The maximum width of formatted content (None implies a sensible
         #: default which is 80 for most things).
-        self.max_content_width = max_content_width
+        self.max_content_width: t.Optional[int] = max_content_width

         if allow_extra_args is None:
             allow_extra_args = command.allow_extra_args
+
         #: Indicates if the context allows extra args or if it should
         #: fail on parsing.
         #:
@@ -325,14 +349,16 @@

         if allow_interspersed_args is None:
             allow_interspersed_args = command.allow_interspersed_args
+
         #: Indicates if the context allows mixing of arguments and
         #: options or not.
         #:
         #: .. versionadded:: 3.0
-        self.allow_interspersed_args = allow_interspersed_args
+        self.allow_interspersed_args: bool = allow_interspersed_args

         if ignore_unknown_options is None:
             ignore_unknown_options = command.ignore_unknown_options
+
         #: Instructs click to ignore options that a command does not
         #: understand and will store it on the context for later
         #: processing.  This is primarily useful for situations where you
@@ -341,7 +367,7 @@
         #: forward all arguments.
         #:
         #: .. versionadded:: 4.0
-        self.ignore_unknown_options = ignore_unknown_options
+        self.ignore_unknown_options: bool = ignore_unknown_options

         if help_option_names is None:
             if parent is not None:
@@ -350,19 +376,21 @@
                 help_option_names = ["--help"]

         #: The names for the help options.
-        self.help_option_names = help_option_names
+        self.help_option_names: t.List[str] = help_option_names

         if token_normalize_func is None and parent is not None:
             token_normalize_func = parent.token_normalize_func

         #: An optional normalization function for tokens.  This is
         #: options, choices, commands etc.
-        self.token_normalize_func = token_normalize_func
+        self.token_normalize_func: t.Optional[
+            t.Callable[[str], str]
+        ] = token_normalize_func

         #: Indicates if resilient parsing is enabled.  In that case Click
         #: will do its best to not cause any failures and default values
         #: will be ignored. Useful for completion.
-        self.resilient_parsing = resilient_parsing
+        self.resilient_parsing: bool = resilient_parsing

         # If there is no envvar prefix yet, but the parent has one and
         # the command on this level has a name, we can expand the envvar
@@ -373,39 +401,68 @@
                 and parent.auto_envvar_prefix is not None
                 and self.info_name is not None
             ):
-                auto_envvar_prefix = "{}_{}".format(
-                    parent.auto_envvar_prefix, self.info_name.upper()
+                auto_envvar_prefix = (
+                    f"{parent.auto_envvar_prefix}_{self.info_name.upper()}"
                 )
         else:
             auto_envvar_prefix = auto_envvar_prefix.upper()
+
         if auto_envvar_prefix is not None:
             auto_envvar_prefix = auto_envvar_prefix.replace("-", "_")
-        self.auto_envvar_prefix = auto_envvar_prefix
+
+        self.auto_envvar_prefix: t.Optional[str] = auto_envvar_prefix

         if color is None and parent is not None:
             color = parent.color

         #: Controls if styling output is wanted or not.
-        self.color = color
-
-        self.show_default = show_default
-
-        self._close_callbacks = []
+        self.color: t.Optional[bool] = color
+
+        if show_default is None and parent is not None:
+            show_default = parent.show_default
+
+        #: Show option default values when formatting help text.
+        self.show_default: t.Optional[bool] = show_default
+
+        self._close_callbacks: t.List[t.Callable[[], t.Any]] = []
         self._depth = 0
-
-    def __enter__(self):
+        self._parameter_source: t.Dict[str, ParameterSource] = {}
+        self._exit_stack = ExitStack()
+
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        """Gather information that could be useful for a tool generating
+        user-facing documentation. This traverses the entire CLI
+        structure.
+
+        .. code-block:: python
+
+            with Context(cli) as ctx:
+                info = ctx.to_info_dict()
+
+        .. versionadded:: 8.0
+        """
+        return {
+            "command": self.command.to_info_dict(self),
+            "info_name": self.info_name,
+            "allow_extra_args": self.allow_extra_args,
+            "allow_interspersed_args": self.allow_interspersed_args,
+            "ignore_unknown_options": self.ignore_unknown_options,
+            "auto_envvar_prefix": self.auto_envvar_prefix,
+        }
+
+    def __enter__(self) -> "Context":
         self._depth += 1
         push_context(self)
         return self

-    def __exit__(self, exc_type, exc_value, tb):
+    def __exit__(self, exc_type, exc_value, tb):  # type: ignore
         self._depth -= 1
         if self._depth == 0:
             self.close()
         pop_context()

     @contextmanager
-    def scope(self, cleanup=True):
+    def scope(self, cleanup: bool = True) -> t.Iterator["Context"]:
         """This helper method can be used with the context object to promote
         it to the current thread local (see :func:`get_current_context`).
         The default behavior of this is to invoke the cleanup functions which
@@ -443,7 +500,7 @@
                 self._depth -= 1

     @property
-    def meta(self):
+    def meta(self) -> t.Dict[str, t.Any]:
         """This is a dictionary which is shared with all the contexts
         that are nested.  It exists so that click utilities can store some
         state here if they need to.  It is however the responsibility of
@@ -470,32 +527,72 @@
         """
         return self._meta

-    def make_formatter(self):
-        """Creates the formatter for the help and usage output."""
-        return HelpFormatter(
+    def make_formatter(self) -> HelpFormatter:
+        """Creates the :class:`~click.HelpFormatter` for the help and
+        usage output.
+
+        To quickly customize the formatter class used without overriding
+        this method, set the :attr:`formatter_class` attribute.
+
+        .. versionchanged:: 8.0
+            Added the :attr:`formatter_class` attribute.
+        """
+        return self.formatter_class(
             width=self.terminal_width, max_width=self.max_content_width
         )

-    def call_on_close(self, f):
-        """This decorator remembers a function as callback that should be
-        executed when the context tears down.  This is most useful to bind
-        resource handling to the script execution.  For instance, file objects
-        opened by the :class:`File` type will register their close callbacks
-        here.
-
-        :param f: the function to execute on teardown.
-        """
-        self._close_callbacks.append(f)
-        return f
-
-    def close(self):
-        """Invokes all close callbacks."""
-        for cb in self._close_callbacks:
-            cb()
-        self._close_callbacks = []
+    def with_resource(self, context_manager: t.ContextManager[V]) -> V:
+        """Register a resource as if it were used in a ``with``
+        statement. The resource will be cleaned up when the context is
+        popped.
+
+        Uses :meth:`contextlib.ExitStack.enter_context`. It calls the
+        resource's ``__enter__()`` method and returns the result. When
+        the context is popped, it closes the stack, which calls the
+        resource's ``__exit__()`` method.
+
+        To register a cleanup function for something that isn't a
+        context manager, use :meth:`call_on_close`. Or use something
+        from :mod:`contextlib` to turn it into a context manager first.
+
+        .. code-block:: python
+
+            @click.group()
+            @click.option("--name")
+            @click.pass_context
+            def cli(ctx):
+                ctx.obj = ctx.with_resource(connect_db(name))
+
+        :param context_manager: The context manager to enter.
+        :return: Whatever ``context_manager.__enter__()`` returns.
+
+        .. versionadded:: 8.0
+        """
+        return self._exit_stack.enter_context(context_manager)
+
+    def call_on_close(self, f: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:
+        """Register a function to be called when the context tears down.
+
+        This can be used to close resources opened during the script
+        execution. Resources that support Python's context manager
+        protocol which would be used in a ``with`` statement should be
+        registered with :meth:`with_resource` instead.
+
+        :param f: The function to execute on teardown.
+        """
+        return self._exit_stack.callback(f)
+
+    def close(self) -> None:
+        """Invoke all close callbacks registered with
+        :meth:`call_on_close`, and exit all context managers entered
+        with :meth:`with_resource`.
+        """
+        self._exit_stack.close()
+        # In case the context is reused, create a new exit stack.
+        self._exit_stack = ExitStack()

     @property
-    def command_path(self):
+    def command_path(self) -> str:
         """The computed command path.  This is used for the ``usage``
         information on the help page.  It's automatically created by
         combining the info names of the chain of contexts to the root.
@@ -504,25 +601,35 @@
         if self.info_name is not None:
             rv = self.info_name
         if self.parent is not None:
-            rv = "{} {}".format(self.parent.command_path, rv)
+            parent_command_path = [self.parent.command_path]
+
+            if isinstance(self.parent.command, Command):
+                for param in self.parent.command.get_params(self):
+                    parent_command_path.extend(param.get_usage_pieces(self))
+
+            rv = f"{' '.join(parent_command_path)} {rv}"
         return rv.lstrip()

-    def find_root(self):
+    def find_root(self) -> "Context":
         """Finds the outermost context."""
         node = self
         while node.parent is not None:
             node = node.parent
         return node

-    def find_object(self, object_type):
+    def find_object(self, object_type: t.Type[V]) -> t.Optional[V]:
         """Finds the closest object of a given type."""
-        node = self
+        node: t.Optional["Context"] = self
+
         while node is not None:
             if isinstance(node.obj, object_type):
                 return node.obj
+
             node = node.parent

-    def ensure_object(self, object_type):
+        return None
+
+    def ensure_object(self, object_type: t.Type[V]) -> V:
         """Like :meth:`find_object` but sets the innermost object to a
         new instance of `object_type` if it does not exist.
         """
@@ -531,17 +638,39 @@
             self.obj = rv = object_type()
         return rv

-    def lookup_default(self, name):
-        """Looks up the default for a parameter name.  This by default
-        looks into the :attr:`default_map` if available.
+    @t.overload
+    def lookup_default(
+        self, name: str, call: "te.Literal[True]" = True
+    ) -> t.Optional[t.Any]:
+        ...
+
+    @t.overload
+    def lookup_default(
+        self, name: str, call: "te.Literal[False]" = ...
+    ) -> t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:
+        ...
+
+    def lookup_default(self, name: str, call: bool = True) -> t.Optional[t.Any]:
+        """Get the default for a parameter from :attr:`default_map`.
+
+        :param name: Name of the parameter.
+        :param call: If the default is a callable, call it. Disable to
+            return the callable instead.
+
+        .. versionchanged:: 8.0
+            Added the ``call`` parameter.
         """
         if self.default_map is not None:
-            rv = self.default_map.get(name)
-            if callable(rv):
-                rv = rv()
-            return rv
-
-    def fail(self, message):
+            value = self.default_map.get(name)
+
+            if call and callable(value):
+                return value()
+
+            return value
+
+        return None
+
+    def fail(self, message: str) -> "te.NoReturn":
         """Aborts the execution of the program with a specific error
         message.

@@ -549,27 +678,40 @@
         """
         raise UsageError(message, self)

-    def abort(self):
+    def abort(self) -> "te.NoReturn":
         """Aborts the script."""
         raise Abort()

-    def exit(self, code=0):
+    def exit(self, code: int = 0) -> "te.NoReturn":
         """Exits the application with a given exit code."""
         raise Exit(code)

-    def get_usage(self):
+    def get_usage(self) -> str:
         """Helper method to get formatted usage string for the current
         context and command.
         """
         return self.command.get_usage(self)

-    def get_help(self):
+    def get_help(self) -> str:
         """Helper method to get formatted help page for the current
         context and command.
         """
         return self.command.get_help(self)

-    def invoke(*args, **kwargs):  # noqa: B902
+    def _make_sub_context(self, command: "Command") -> "Context":
+        """Create a new context of the same type as this context, but
+        for a new command.
+
+        :meta private:
+        """
+        return type(self)(command, info_name=command.name, parent=self)
+
+    def invoke(
+        __self,  # noqa: B902
+        __callback: t.Union["Command", t.Callable[..., t.Any]],
+        *args: t.Any,
+        **kwargs: t.Any,
+    ) -> t.Any:
         """Invokes a command callback in exactly the way it expects.  There
         are two ways to invoke this method:

@@ -584,51 +726,89 @@
         in against the intention of this code and no context was created.  For
         more information about this change and why it was done in a bugfix
         release see :ref:`upgrade-to-3.2`.
-        """
-        self, callback = args[:2]
-        ctx = self
-
-        # It's also possible to invoke another command which might or
-        # might not have a callback.  In that case we also fill
-        # in defaults and make a new context for this command.
-        if isinstance(callback, Command):
-            other_cmd = callback
-            callback = other_cmd.callback
-            ctx = Context(other_cmd, info_name=other_cmd.name, parent=self)
-            if callback is None:
+
+        .. versionchanged:: 8.0
+            All ``kwargs`` are tracked in :attr:`params` so they will be
+            passed if :meth:`forward` is called at multiple levels.
+        """
+        if isinstance(__callback, Command):
+            other_cmd = __callback
+
+            if other_cmd.callback is None:
                 raise TypeError(
                     "The given command does not have a callback that can be invoked."
                 )
+            else:
+                __callback = other_cmd.callback
+
+            ctx = __self._make_sub_context(other_cmd)

             for param in other_cmd.params:
                 if param.name not in kwargs and param.expose_value:
-                    kwargs[param.name] = param.get_default(ctx)
-
-        args = args[2:]
-        with augment_usage_errors(self):
+                    kwargs[param.name] = param.type_cast_value(  # type: ignore
+                        ctx, param.get_default(ctx)
+                    )
+
+            # Track all kwargs as params, so that forward() will pass
+            # them on in subsequent calls.
+            ctx.params.update(kwargs)
+        else:
+            ctx = __self
+
+        with augment_usage_errors(__self):
             with ctx:
-                return callback(*args, **kwargs)
-
-    def forward(*args, **kwargs):  # noqa: B902
+                return __callback(*args, **kwargs)
+
+    def forward(
+        __self, __cmd: "Command", *args: t.Any, **kwargs: t.Any  # noqa: B902
+    ) -> t.Any:
         """Similar to :meth:`invoke` but fills in default keyword
         arguments from the current context if the other command expects
         it.  This cannot invoke callbacks directly, only other commands.
-        """
-        self, cmd = args[:2]
-
-        # It's also possible to invoke another command which might or
-        # might not have a callback.
-        if not isinstance(cmd, Command):
+
+        .. versionchanged:: 8.0
+            All ``kwargs`` are tracked in :attr:`params` so they will be
+            passed if ``forward`` is called at multiple levels.
+        """
+        # Can only forward to other commands, not direct callbacks.
+        if not isinstance(__cmd, Command):
             raise TypeError("Callback is not a command.")

-        for param in self.params:
+        for param in __self.params:
             if param not in kwargs:
-                kwargs[param] = self.params[param]
-
-        return self.invoke(cmd, **kwargs)
-
-
-class BaseCommand(object):
+                kwargs[param] = __self.params[param]
+
+        return __self.invoke(__cmd, *args, **kwargs)
+
+    def set_parameter_source(self, name: str, source: ParameterSource) -> None:
+        """Set the source of a parameter. This indicates the location
+        from which the value of the parameter was obtained.
+
+        :param name: The name of the parameter.
+        :param source: A member of :class:`~click.core.ParameterSource`.
+        """
+        self._parameter_source[name] = source
+
+    def get_parameter_source(self, name: str) -> t.Optional[ParameterSource]:
+        """Get the source of a parameter. This indicates the location
+        from which the value of the parameter was obtained.
+
+        This can be useful for determining when a user specified a value
+        on the command line that is the same as the default value. It
+        will be :attr:`~click.core.ParameterSource.DEFAULT` only if the
+        value was actually taken from the default.
+
+        :param name: The name of the parameter.
+        :rtype: ParameterSource
+
+        .. versionchanged:: 8.0
+            Returns ``None`` if the parameter was not provided from any
+            source.
+        """
+        return self._parameter_source.get(name)
+
+
+class BaseCommand:
     """The base command implements the minimal API contract of commands.
     Most code will never use this as it does not implement a lot of useful
     functionality but it can act as the direct subclass of alternative
@@ -650,6 +830,10 @@
                              passed to the context object.
     """

+    #: The context class to create with :meth:`make_context`.
+    #:
+    #: .. versionadded:: 8.0
+    context_class: t.Type[Context] = Context
     #: the default for the :attr:`Context.allow_extra_args` flag.
     allow_extra_args = False
     #: the default for the :attr:`Context.allow_interspersed_args` flag.
@@ -657,70 +841,158 @@
     #: the default for the :attr:`Context.ignore_unknown_options` flag.
     ignore_unknown_options = False

-    def __init__(self, name, context_settings=None):
+    def __init__(
+        self,
+        name: t.Optional[str],
+        context_settings: t.Optional[t.Dict[str, t.Any]] = None,
+    ) -> None:
         #: the name the command thinks it has.  Upon registering a command
         #: on a :class:`Group` the group will default the command name
         #: with this information.  You should instead use the
         #: :class:`Context`\'s :attr:`~Context.info_name` attribute.
         self.name = name
+
         if context_settings is None:
             context_settings = {}
+
         #: an optional dictionary with defaults passed to the context.
-        self.context_settings = context_settings
-
-    def __repr__(self):
-        return "<{} {}>".format(self.__class__.__name__, self.name)
-
-    def get_usage(self, ctx):
+        self.context_settings: t.Dict[str, t.Any] = context_settings
+
+    def to_info_dict(self, ctx: Context) -> t.Dict[str, t.Any]:
+        """Gather information that could be useful for a tool generating
+        user-facing documentation. This traverses the entire structure
+        below this command.
+
+        Use :meth:`click.Context.to_info_dict` to traverse the entire
+        CLI structure.
+
+        :param ctx: A :class:`Context` representing this command.
+
+        .. versionadded:: 8.0
+        """
+        return {"name": self.name}
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} {self.name}>"
+
+    def get_usage(self, ctx: Context) -> str:
         raise NotImplementedError("Base commands cannot get usage")

-    def get_help(self, ctx):
+    def get_help(self, ctx: Context) -> str:
         raise NotImplementedError("Base commands cannot get help")

-    def make_context(self, info_name, args, parent=None, **extra):
+    def make_context(
+        self,
+        info_name: t.Optional[str],
+        args: t.List[str],
+        parent: t.Optional[Context] = None,
+        **extra: t.Any,
+    ) -> Context:
         """This function when given an info name and arguments will kick
         off the parsing and create a new :class:`Context`.  It does not
         invoke the actual command callback though.

-        :param info_name: the info name for this invokation.  Generally this
+        To quickly customize the context class used without overriding
+        this method, set the :attr:`context_class` attribute.
+
+        :param info_name: the info name for this invocation.  Generally this
                           is the most descriptive name for the script or
                           command.  For the toplevel script it's usually
                           the name of the script, for commands below it it's
-                          the name of the script.
+                          the name of the command.
         :param args: the arguments to parse as list of strings.
         :param parent: the parent context if available.
         :param extra: extra keyword arguments forwarded to the context
                       constructor.
-        """
-        for key, value in iteritems(self.context_settings):
+
+        .. versionchanged:: 8.0
+            Added the :attr:`context_class` attribute.
+        """
+        for key, value in self.context_settings.items():
             if key not in extra:
                 extra[key] = value
-        ctx = Context(self, info_name=info_name, parent=parent, **extra)
+
+        ctx = self.context_class(
+            self, info_name=info_name, parent=parent, **extra  # type: ignore
+        )
+
         with ctx.scope(cleanup=False):
             self.parse_args(ctx, args)
         return ctx

-    def parse_args(self, ctx, args):
+    def parse_args(self, ctx: Context, args: t.List[str]) -> t.List[str]:
         """Given a context and a list of arguments this creates the parser
         and parses the arguments, then modifies the context as necessary.
         This is automatically invoked by :meth:`make_context`.
         """
         raise NotImplementedError("Base commands do not know how to parse arguments.")

-    def invoke(self, ctx):
+    def invoke(self, ctx: Context) -> t.Any:
         """Given a context, this invokes the command.  The default
         implementation is raising a not implemented error.
         """
         raise NotImplementedError("Base commands are not invokable by default")

+    def shell_complete(self, ctx: Context, incomplete: str) -> t.List["CompletionItem"]:
+        """Return a list of completions for the incomplete value. Looks
+        at the names of chained multi-commands.
+
+        Any command could be part of a chained multi-command, so sibling
+        commands are valid at any point during command completion. Other
+        command classes will return more completions.
+
+        :param ctx: Invocation context for this command.
+        :param incomplete: Value being completed. May be empty.
+
+        .. versionadded:: 8.0
+        """
+        from click.shell_completion import CompletionItem
+
+        results: t.List["CompletionItem"] = []
+
+        while ctx.parent is not None:
+            ctx = ctx.parent
+
+            if isinstance(ctx.command, MultiCommand) and ctx.command.chain:
+                results.extend(
+                    CompletionItem(name, help=command.get_short_help_str())
+                    for name, command in _complete_visible_commands(ctx, incomplete)
+                    if name not in ctx.protected_args
+                )
+
+        return results
+
+    @t.overload
     def main(
         self,
-        args=None,
-        prog_name=None,
-        complete_var=None,
-        standalone_mode=True,
-        **extra
-    ):
+        args: t.Optional[t.Sequence[str]] = None,
+        prog_name: t.Optional[str] = None,
+        complete_var: t.Optional[str] = None,
+        standalone_mode: "te.Literal[True]" = True,
+        **extra: t.Any,
+    ) -> "te.NoReturn":
+        ...
+
+    @t.overload
+    def main(
+        self,
+        args: t.Optional[t.Sequence[str]] = None,
+        prog_name: t.Optional[str] = None,
+        complete_var: t.Optional[str] = None,
+        standalone_mode: bool = ...,
+        **extra: t.Any,
+    ) -> t.Any:
+        ...
+
+    def main(
+        self,
+        args: t.Optional[t.Sequence[str]] = None,
+        prog_name: t.Optional[str] = None,
+        complete_var: t.Optional[str] = None,
+        standalone_mode: bool = True,
+        windows_expand_args: bool = True,
+        **extra: t.Any,
+    ) -> t.Any:
         """This is the way to invoke a script with all the bells and
         whistles as a command line application.  This will always terminate
         the application after a call.  If this is not wanted, ``SystemExit``
@@ -728,9 +1000,6 @@

         This method is also available by directly calling the instance of
         a :class:`Command`.
-
-        .. versionadded:: 3.0
-           Added the `standalone_mode` flag to control the standalone mode.

         :param args: the arguments that should be used for parsing.  If not
                      provided, ``sys.argv[1:]`` is used.
@@ -750,31 +1019,35 @@
                                 propagated to the caller and the return
                                 value of this function is the return value
                                 of :meth:`invoke`.
+        :param windows_expand_args: Expand glob patterns, user dir, and
+            env vars in command line args on Windows.
         :param extra: extra keyword arguments are forwarded to the context
                       constructor.  See :class:`Context` for more information.
-        """
-        # If we are in Python 3, we will verify that the environment is
-        # sane at this point or reject further execution to avoid a
-        # broken script.
-        if not PY2:
-            _verify_python3_env()
-        else:
-            _check_for_unicode_literals()
-
+
+        .. versionchanged:: 8.0.1
+            Added the ``windows_expand_args`` parameter to allow
+            disabling command line arg expansion on Windows.
+
+        .. versionchanged:: 8.0
+            When taking arguments from ``sys.argv`` on Windows, glob
+            patterns, user dir, and env vars are expanded.
+
+        .. versionchanged:: 3.0
+           Added the ``standalone_mode`` parameter.
+        """
         if args is None:
-            args = get_os_args()
+            args = sys.argv[1:]
+
+            if os.name == "nt" and windows_expand_args:
+                args = _expand_args(args)
         else:
             args = list(args)

         if prog_name is None:
-            prog_name = make_str(
-                os.path.basename(sys.argv[0] if sys.argv else __file__)
-            )
-
-        # Hook for the Bash completion.  This only activates if the Bash
-        # completion is actually enabled, otherwise this is quite a fast
-        # noop.
-        _bashcomplete(self, prog_name, complete_var)
+            prog_name = _detect_program_name()
+
+        # Process shell completion requests and exit early.
+        self._main_shell_completion(extra, prog_name, complete_var)

         try:
             try:
@@ -792,16 +1065,16 @@
                     ctx.exit()
             except (EOFError, KeyboardInterrupt):
                 echo(file=sys.stderr)
-                raise Abort()
+                raise Abort() from None
             except ClickException as e:
                 if not standalone_mode:
                     raise
                 e.show()
                 sys.exit(e.exit_code)
-            except IOError as e:
+            except OSError as e:
                 if e.errno == errno.EPIPE:
-                    sys.stdout = PacifyFlushWrapper(sys.stdout)
-                    sys.stderr = PacifyFlushWrapper(sys.stderr)
+                    sys.stdout = t.cast(t.TextIO, PacifyFlushWrapper(sys.stdout))
+                    sys.stderr = t.cast(t.TextIO, PacifyFlushWrapper(sys.stderr))
                     sys.exit(1)
                 else:
                     raise
@@ -821,10 +1094,38 @@
         except Abort:
             if not standalone_mode:
                 raise
-            echo("Aborted!", file=sys.stderr)
+            echo(_("Aborted!"), file=sys.stderr)
             sys.exit(1)

-    def __call__(self, *args, **kwargs):
+    def _main_shell_completion(
+        self,
+        ctx_args: t.Dict[str, t.Any],
+        prog_name: str,
+        complete_var: t.Optional[str] = None,
+    ) -> None:
+        """Check if the shell is asking for tab completion, process
+        that, then exit early. Called from :meth:`main` before the
+        program is invoked.
+
+        :param prog_name: Name of the executable in the shell.
+        :param complete_var: Name of the environment variable that holds
+            the completion instruction. Defaults to
+            ``_{PROG_NAME}_COMPLETE``.
+        """
+        if complete_var is None:
+            complete_var = f"_{prog_name}_COMPLETE".replace("-", "_").upper()
+
+        instruction = os.environ.get(complete_var)
+
+        if not instruction:
+            return
+
+        from .shell_completion import shell_complete
+
+        rv = shell_complete(self, ctx_args, prog_name, complete_var, instruction)
+        sys.exit(rv)
+
+    def __call__(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
         """Alias for :meth:`main`."""
         return self.main(*args, **kwargs)

@@ -833,11 +1134,6 @@
     """Commands are the basic building block of command line interfaces in
     Click.  A basic command handles command line parsing and might dispatch
     more parsing to commands nested below it.
-
-    .. versionchanged:: 2.0
-       Added the `context_settings` parameter.
-    .. versionchanged:: 7.1
-       Added the `no_args_is_help` parameter.

     :param name: the name of the command to use unless a group overrides it.
     :param context_settings: an optional dictionary with defaults that are
@@ -860,35 +1156,45 @@

     :param deprecated: issues a message indicating that
                              the command is deprecated.
+
+    .. versionchanged:: 8.1
+        ``help``, ``epilog``, and ``short_help`` are stored unprocessed,
+        all formatting is done when outputting help text, not at init,
+        and is done even if not using the ``@command`` decorator.
+
+    .. versionchanged:: 8.0
+        Added a ``repr`` showing the command name.
+
+    .. versionchanged:: 7.1
+        Added the ``no_args_is_help`` parameter.
+
+    .. versionchanged:: 2.0
+        Added the ``context_settings`` parameter.
     """

     def __init__(
         self,
-        name,
-        context_settings=None,
-        callback=None,
-        params=None,
-        help=None,
-        epilog=None,
-        short_help=None,
-        options_metavar="[OPTIONS]",
-        add_help_option=True,
-        no_args_is_help=False,
-        hidden=False,
-        deprecated=False,
-    ):
-        BaseCommand.__init__(self, name, context_settings)
+        name: t.Optional[str],
+        context_settings: t.Optional[t.Dict[str, t.Any]] = None,
+        callback: t.Optional[t.Callable[..., t.Any]] = None,
+        params: t.Optional[t.List["Parameter"]] = None,
+        help: t.Optional[str] = None,
+        epilog: t.Optional[str] = None,
+        short_help: t.Optional[str] = None,
+        options_metavar: t.Optional[str] = "[OPTIONS]",
+        add_help_option: bool = True,
+        no_args_is_help: bool = False,
+        hidden: bool = False,
+        deprecated: bool = False,
+    ) -> None:
+        super().__init__(name, context_settings)
         #: the callback to execute when the command fires.  This might be
         #: `None` in which case nothing happens.
         self.callback = callback
         #: the list of parameters for this command in the order they
         #: should show up in the help page and execute.  Eager parameters
         #: will automatically be handled before non eager ones.
-        self.params = params or []
-        # if a form feed (page break) is found in the help text, truncate help
-        # text to the content preceding the first form feed
-        if help and "\f" in help:
-            help = help.split("\f", 1)[0]
+        self.params: t.List["Parameter"] = params or []
         self.help = help
         self.epilog = epilog
         self.options_metavar = options_metavar
@@ -898,7 +1204,19 @@
         self.hidden = hidden
         self.deprecated = deprecated

-    def get_usage(self, ctx):
+    def to_info_dict(self, ctx: Context) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict(ctx)
+        info_dict.update(
+            params=[param.to_info_dict() for param in self.get_params(ctx)],
+            help=self.help,
+            epilog=self.epilog,
+            short_help=self.short_help,
+            hidden=self.hidden,
+            deprecated=self.deprecated,
+        )
+        return info_dict
+
+    def get_usage(self, ctx: Context) -> str:
         """Formats the usage line into a string and returns it.

         Calls :meth:`format_usage` internally.
@@ -907,14 +1225,16 @@
         self.format_usage(ctx, formatter)
         return formatter.getvalue().rstrip("\n")

-    def get_params(self, ctx):
+    def get_params(self, ctx: Context) -> t.List["Parameter"]:
         rv = self.params
         help_option = self.get_help_option(ctx)
+
         if help_option is not None:
-            rv = rv + [help_option]
+            rv = [*rv, help_option]
+
         return rv

-    def format_usage(self, ctx, formatter):
+    def format_usage(self, ctx: Context, formatter: HelpFormatter) -> None:
         """Writes the usage line into the formatter.

         This is a low-level method called by :meth:`get_usage`.
@@ -922,30 +1242,33 @@
         pieces = self.collect_usage_pieces(ctx)
         formatter.write_usage(ctx.command_path, " ".join(pieces))

-    def collect_usage_pieces(self, ctx):
+    def collect_usage_pieces(self, ctx: Context) -> t.List[str]:
         """Returns all the pieces that go into the usage line and returns
         it as a list of strings.
         """
-        rv = [self.options_metavar]
+        rv = [self.options_metavar] if self.options_metavar else []
+
         for param in self.get_params(ctx):
             rv.extend(param.get_usage_pieces(ctx))
+
         return rv

-    def get_help_option_names(self, ctx):
+    def get_help_option_names(self, ctx: Context) -> t.List[str]:
         """Returns the names for the help option."""
         all_names = set(ctx.help_option_names)
         for param in self.params:
             all_names.difference_update(param.opts)
             all_names.difference_update(param.secondary_opts)
-        return all_names
-
-    def get_help_option(self, ctx):
+        return list(all_names)
+
+    def get_help_option(self, ctx: Context) -> t.Optional["Option"]:
         """Returns the help option object."""
         help_options = self.get_help_option_names(ctx)
+
         if not help_options or not self.add_help_option:
-            return
-
-        def show_help(ctx, param, value):
+            return None
+
+        def show_help(ctx: Context, param: "Parameter", value: str) -> None:
             if value and not ctx.resilient_parsing:
                 echo(ctx.get_help(), color=ctx.color)
                 ctx.exit()
@@ -956,17 +1279,17 @@
             is_eager=True,
             expose_value=False,
             callback=show_help,
-            help="Show this message and exit.",
+            help=_("Show this message and exit."),
         )

-    def make_parser(self, ctx):
+    def make_parser(self, ctx: Context) -> OptionParser:
         """Creates the underlying option parser for this command."""
         parser = OptionParser(ctx)
         for param in self.get_params(ctx):
             param.add_to_parser(parser, ctx)
         return parser

-    def get_help(self, ctx):
+    def get_help(self, ctx: Context) -> str:
         """Formats the help into a string and returns it.

         Calls :meth:`format_help` internally.
@@ -975,18 +1298,23 @@
         self.format_help(ctx, formatter)
         return formatter.getvalue().rstrip("\n")

-    def get_short_help_str(self, limit=45):
+    def get_short_help_str(self, limit: int = 45) -> str:
         """Gets short help for the command or makes it by shortening the
         long help string.
         """
-        return (
-            self.short_help
-            or self.help
-            and make_default_short_help(self.help, limit)
-            or ""
-        )
-
-    def format_help(self, ctx, formatter):
+        if self.short_help:
+            text = inspect.cleandoc(self.short_help)
+        elif self.help:
+            text = make_default_short_help(self.help, limit)
+        else:
+            text = ""
+
+        if self.deprecated:
+            text = _("(Deprecated) {text}").format(text=text)
+
+        return text.strip()
+
+    def format_help(self, ctx: Context, formatter: HelpFormatter) -> None:
         """Writes the help into the formatter if it exists.

         This is a low-level method called by :meth:`get_help`.
@@ -1003,21 +1331,21 @@
         self.format_options(ctx, formatter)
         self.format_epilog(ctx, formatter)

-    def format_help_text(self, ctx, formatter):
+    def format_help_text(self, ctx: Context, formatter: HelpFormatter) -> None:
         """Writes the help text to the formatter if it exists."""
-        if self.help:
+        text = self.help if self.help is not None else ""
+
+        if self.deprecated:
+            text = _("(Deprecated) {text}").format(text=text)
+
+        if text:
+            text = inspect.cleandoc(text).partition("\f")[0]
             formatter.write_paragraph()
+
             with formatter.indentation():
-                help_text = self.help
-                if self.deprecated:
-                    help_text += DEPRECATED_HELP_NOTICE
-                formatter.write_text(help_text)
-        elif self.deprecated:
-            formatter.write_paragraph()
-            with formatter.indentation():
-                formatter.write_text(DEPRECATED_HELP_NOTICE)
-
-    def format_options(self, ctx, formatter):
+                formatter.write_text(text)
+
+    def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:
         """Writes all the options into the formatter if they exist."""
         opts = []
         for param in self.get_params(ctx):
@@ -1026,17 +1354,19 @@
                 opts.append(rv)

         if opts:
-            with formatter.section("Options"):
+            with formatter.section(_("Options")):
                 formatter.write_dl(opts)

-    def format_epilog(self, ctx, formatter):
+    def format_epilog(self, ctx: Context, formatter: HelpFormatter) -> None:
         """Writes the epilog into the formatter if it exists."""
         if self.epilog:
+            epilog = inspect.cleandoc(self.epilog)
             formatter.write_paragraph()
+
             with formatter.indentation():
-                formatter.write_text(self.epilog)
-
-    def parse_args(self, ctx, args):
+                formatter.write_text(epilog)
+
+    def parse_args(self, ctx: Context, args: t.List[str]) -> t.List[str]:
         if not args and self.no_args_is_help and not ctx.resilient_parsing:
             echo(ctx.get_help(), color=ctx.color)
             ctx.exit()
@@ -1049,21 +1379,64 @@

         if args and not ctx.allow_extra_args and not ctx.resilient_parsing:
             ctx.fail(
-                "Got unexpected extra argument{} ({})".format(
-                    "s" if len(args) != 1 else "", " ".join(map(make_str, args))
-                )
+                ngettext(
+                    "Got unexpected extra argument ({args})",
+                    "Got unexpected extra arguments ({args})",
+                    len(args),
+                ).format(args=" ".join(map(str, args)))
             )

         ctx.args = args
+        ctx._opt_prefixes.update(parser._opt_prefixes)
         return args

-    def invoke(self, ctx):
+    def invoke(self, ctx: Context) -> t.Any:
         """Given a context, this invokes the attached callback (if it exists)
         in the right way.
         """
-        _maybe_show_deprecated_notice(self)
+        if self.deprecated:
+            message = _(
+                "DeprecationWarning: The command {name!r} is deprecated."
+            ).format(name=self.name)
+            echo(style(message, fg="red"), err=True)
+
         if self.callback is not None:
             return ctx.invoke(self.callback, **ctx.params)
+
+    def shell_complete(self, ctx: Context, incomplete: str) -> t.List["CompletionItem"]:
+        """Return a list of completions for the incomplete value. Looks
+        at the names of options and chained multi-commands.
+
+        :param ctx: Invocation context for this command.
+        :param incomplete: Value being completed. May be empty.
+
+        .. versionadded:: 8.0
+        """
+        from click.shell_completion import CompletionItem
+
+        results: t.List["CompletionItem"] = []
+
+        if incomplete and not incomplete[0].isalnum():
+            for param in self.get_params(ctx):
+                if (
+                    not isinstance(param, Option)
+                    or param.hidden
+                    or (
+                        not param.multiple
+                        and ctx.get_parameter_source(param.name)  # type: ignore
+                        is ParameterSource.COMMANDLINE
+                    )
+                ):
+                    continue
+
+                results.extend(
+                    CompletionItem(name, help=param.help)
+                    for name in [*param.opts, *param.secondary_opts]
+                    if name.startswith(incomplete)
+                )
+
+        results.extend(super().shell_complete(ctx, incomplete))
+        return results


 class MultiCommand(Command):
@@ -1086,8 +1459,9 @@
                   is enabled.  This restricts the form of commands in that
                   they cannot have optional arguments but it allows
                   multiple commands to be chained together.
-    :param result_callback: the result callback to attach to this multi
-                            command.
+    :param result_callback: The result callback to attach to this multi
+        command. This can be set or changed later with the
+        :meth:`result_callback` decorator.
     """

     allow_extra_args = True
@@ -1095,29 +1469,33 @@

     def __init__(
         self,
-        name=None,
-        invoke_without_command=False,
-        no_args_is_help=None,
-        subcommand_metavar=None,
-        chain=False,
-        result_callback=None,
-        **attrs
-    ):
-        Command.__init__(self, name, **attrs)
+        name: t.Optional[str] = None,
+        invoke_without_command: bool = False,
+        no_args_is_help: t.Optional[bool] = None,
+        subcommand_metavar: t.Optional[str] = None,
+        chain: bool = False,
+        result_callback: t.Optional[t.Callable[..., t.Any]] = None,
+        **attrs: t.Any,
+    ) -> None:
+        super().__init__(name, **attrs)
+
         if no_args_is_help is None:
             no_args_is_help = not invoke_without_command
+
         self.no_args_is_help = no_args_is_help
         self.invoke_without_command = invoke_without_command
+
         if subcommand_metavar is None:
             if chain:
-                subcommand_metavar = SUBCOMMANDS_METAVAR
+                subcommand_metavar = "COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]..."
             else:
-                subcommand_metavar = SUBCOMMAND_METAVAR
+                subcommand_metavar = "COMMAND [ARGS]..."
+
         self.subcommand_metavar = subcommand_metavar
         self.chain = chain
-        #: The result callback that is stored.  This can be set or
-        #: overridden with the :func:`resultcallback` decorator.
-        self.result_callback = result_callback
+        # The result callback that is stored. This can be set or
+        # overridden with the :func:`result_callback` decorator.
+        self._result_callback = result_callback

         if self.chain:
             for param in self.params:
@@ -1127,17 +1505,35 @@
                         " optional arguments."
                     )

-    def collect_usage_pieces(self, ctx):
-        rv = Command.collect_usage_pieces(self, ctx)
+    def to_info_dict(self, ctx: Context) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict(ctx)
+        commands = {}
+
+        for name in self.list_commands(ctx):
+            command = self.get_command(ctx, name)
+
+            if command is None:
+                continue
+
+            sub_ctx = ctx._make_sub_context(command)
+
+            with sub_ctx.scope(cleanup=False):
+                commands[name] = command.to_info_dict(sub_ctx)
+
+        info_dict.update(commands=commands, chain=self.chain)
+        return info_dict
+
+    def collect_usage_pieces(self, ctx: Context) -> t.List[str]:
+        rv = super().collect_usage_pieces(ctx)
         rv.append(self.subcommand_metavar)
         return rv

-    def format_options(self, ctx, formatter):
-        Command.format_options(self, ctx, formatter)
+    def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:
+        super().format_options(ctx, formatter)
         self.format_commands(ctx, formatter)

-    def resultcallback(self, replace=False):
-        """Adds a result callback to the chain command.  By default if a
+    def result_callback(self, replace: bool = False) -> t.Callable[[F], F]:
+        """Adds a result callback to the command.  By default if a
         result callback is already registered this will chain them but
         this can be disabled with the `replace` parameter.  The result
         callback is invoked with the return value of the subcommand
@@ -1152,31 +1548,36 @@
             def cli(input):
                 return 42

-            @cli.resultcallback()
+            @cli.result_callback()
             def process_result(result, input):
                 return result + input

-        .. versionadded:: 3.0
-
         :param replace: if set to `True` an already existing result
                         callback will be removed.
-        """
-
-        def decorator(f):
-            old_callback = self.result_callback
+
+        .. versionchanged:: 8.0
+            Renamed from ``resultcallback``.
+
+        .. versionadded:: 3.0
+        """
+
+        def decorator(f: F) -> F:
+            old_callback = self._result_callback
+
             if old_callback is None or replace:
-                self.result_callback = f
+                self._result_callback = f
                 return f

-            def function(__value, *args, **kwargs):
-                return f(old_callback(__value, *args, **kwargs), *args, **kwargs)
-
-            self.result_callback = rv = update_wrapper(function, f)
+            def function(__value, *args, **kwargs):  # type: ignore
+                inner = old_callback(__value, *args, **kwargs)  # type: ignore
+                return f(inner, *args, **kwargs)
+
+            self._result_callback = rv = update_wrapper(t.cast(F, function), f)
             return rv

         return decorator

-    def format_commands(self, ctx, formatter):
+    def format_commands(self, ctx: Context, formatter: HelpFormatter) -> None:
         """Extra format methods for multi methods that adds all the commands
         after the options.
         """
@@ -1201,15 +1602,16 @@
                 rows.append((subcommand, help))

             if rows:
-                with formatter.section("Commands"):
+                with formatter.section(_("Commands")):
                     formatter.write_dl(rows)

-    def parse_args(self, ctx, args):
+    def parse_args(self, ctx: Context, args: t.List[str]) -> t.List[str]:
         if not args and self.no_args_is_help and not ctx.resilient_parsing:
             echo(ctx.get_help(), color=ctx.color)
             ctx.exit()

-        rest = Command.parse_args(self, ctx, args)
+        rest = super().parse_args(ctx, args)
+
         if self.chain:
             ctx.protected_args = rest
             ctx.args = []
@@ -1218,29 +1620,24 @@

         return ctx.args

-    def invoke(self, ctx):
-        def _process_result(value):
-            if self.result_callback is not None:
-                value = ctx.invoke(self.result_callback, value, **ctx.params)
+    def invoke(self, ctx: Context) -> t.Any:
+        def _process_result(value: t.Any) -> t.Any:
+            if self._result_callback is not None:
+                value = ctx.invoke(self._result_callback, value, **ctx.params)
             return value

         if not ctx.protected_args:
-            # If we are invoked without command the chain flag controls
-            # how this happens.  If we are not in chain mode, the return
-            # value here is the return value of the command.
-            # If however we are in chain mode, the return value is the
-            # return value of the result processor invoked with an empty
-            # list (which means that no subcommand actually was executed).
             if self.invoke_without_command:
-                if not self.chain:
-                    return Command.invoke(self, ctx)
+                # No subcommand was invoked, so the result callback is
+                # invoked with the group return value for regular
+                # groups, or an empty list for chained groups.
                 with ctx:
-                    Command.invoke(self, ctx)
-                    return _process_result([])
-            ctx.fail("Missing command.")
+                    rv = super().invoke(ctx)
+                    return _process_result([] if self.chain else rv)
+            ctx.fail(_("Missing command."))

         # Fetch args back out
-        args = ctx.protected_args + ctx.args
+        args = [*ctx.protected_args, *ctx.args]
         ctx.args = []
         ctx.protected_args = []

@@ -1252,8 +1649,9 @@
             # resources until the result processor has worked.
             with ctx:
                 cmd_name, cmd, args = self.resolve_command(ctx, args)
+                assert cmd is not None
                 ctx.invoked_subcommand = cmd_name
-                Command.invoke(self, ctx)
+                super().invoke(ctx)
                 sub_ctx = cmd.make_context(cmd_name, args, parent=ctx)
                 with sub_ctx:
                     return _process_result(sub_ctx.command.invoke(sub_ctx))
@@ -1265,7 +1663,7 @@
         # but nothing else.
         with ctx:
             ctx.invoked_subcommand = "*" if args else None
-            Command.invoke(self, ctx)
+            super().invoke(ctx)

             # Otherwise we make every single context and invoke them in a
             # chain.  In that case the return value to the result processor
@@ -1273,6 +1671,7 @@
             contexts = []
             while args:
                 cmd_name, cmd, args = self.resolve_command(ctx, args)
+                assert cmd is not None
                 sub_ctx = cmd.make_context(
                     cmd_name,
                     args,
@@ -1289,7 +1688,9 @@
                     rv.append(sub_ctx.command.invoke(sub_ctx))
             return _process_result(rv)

-    def resolve_command(self, ctx, args):
+    def resolve_command(
+        self, ctx: Context, args: t.List[str]
+    ) -> t.Tuple[t.Optional[str], t.Optional[Command], t.List[str]]:
         cmd_name = make_str(args[0])
         original_cmd_name = cmd_name

@@ -1311,36 +1712,94 @@
         if cmd is None and not ctx.resilient_parsing:
             if split_opt(cmd_name)[0]:
                 self.parse_args(ctx, ctx.args)
-            ctx.fail("No such command '{}'.".format(original_cmd_name))
-
-        return cmd_name, cmd, args[1:]
-
-    def get_command(self, ctx, cmd_name):
+            ctx.fail(_("No such command {name!r}.").format(name=original_cmd_name))
+        return cmd_name if cmd else None, cmd, args[1:]
+
+    def get_command(self, ctx: Context, cmd_name: str) -> t.Optional[Command]:
         """Given a context and a command name, this returns a
         :class:`Command` object if it exists or returns `None`.
         """
-        raise NotImplementedError()
-
-    def list_commands(self, ctx):
+        raise NotImplementedError
+
+    def list_commands(self, ctx: Context) -> t.List[str]:
         """Returns a list of subcommand names in the order they should
         appear.
         """
         return []

+    def shell_complete(self, ctx: Context, incomplete: str) -> t.List["CompletionItem"]:
+        """Return a list of completions for the incomplete value. Looks
+        at the names of options, subcommands, and chained
+        multi-commands.
+
+        :param ctx: Invocation context for this command.
+        :param incomplete: Value being completed. May be empty.
+
+        .. versionadded:: 8.0
+        """
+        from click.shell_completion import CompletionItem
+
+        results = [
+            CompletionItem(name, help=command.get_short_help_str())
+            for name, command in _complete_visible_commands(ctx, incomplete)
+        ]
+        results.extend(super().shell_complete(ctx, incomplete))
+        return results
+

 class Group(MultiCommand):
-    """A group allows a command to have subcommands attached.  This is the
-    most common way to implement nesting in Click.
-
-    :param commands: a dictionary of commands.
+    """A group allows a command to have subcommands attached. This is
+    the most common way to implement nesting in Click.
+
+    :param name: The name of the group command.
+    :param commands: A dict mapping names to :class:`Command` objects.
+        Can also be a list of :class:`Command`, which will use
+        :attr:`Command.name` to create the dict.
+    :param attrs: Other command arguments described in
+        :class:`MultiCommand`, :class:`Command`, and
+        :class:`BaseCommand`.
+
+    .. versionchanged:: 8.0
+        The ``commmands`` argument can be a list of command objects.
     """

-    def __init__(self, name=None, commands=None, **attrs):
-        MultiCommand.__init__(self, name, **attrs)
-        #: the registered subcommands by their exported names.
-        self.commands = commands or {}
-
-    def add_command(self, cmd, name=None):
+    #: If set, this is used by the group's :meth:`command` decorator
+    #: as the default :class:`Command` class. This is useful to make all
+    #: subcommands use a custom command class.
+    #:
+    #: .. versionadded:: 8.0
+    command_class: t.Optional[t.Type[Command]] = None
+
+    #: If set, this is used by the group's :meth:`group` decorator
+    #: as the default :class:`Group` class. This is useful to make all
+    #: subgroups use a custom group class.
+    #:
+    #: If set to the special value :class:`type` (literally
+    #: ``group_class = type``), this group's class will be used as the
+    #: default class. This makes a custom group class continue to make
+    #: custom groups.
+    #:
+    #: .. versionadded:: 8.0
+    group_class: t.Optional[t.Union[t.Type["Group"], t.Type[type]]] = None
+    # Literal[type] isn't valid, so use Type[type]
+
+    def __init__(
+        self,
+        name: t.Optional[str] = None,
+        commands: t.Optional[t.Union[t.Dict[str, Command], t.Sequence[Command]]] = None,
+        **attrs: t.Any,
+    ) -> None:
+        super().__init__(name, **attrs)
+
+        if commands is None:
+            commands = {}
+        elif isinstance(commands, abc.Sequence):
+            commands = {c.name: c for c in commands if c.name is not None}
+
+        #: The registered subcommands by their exported names.
+        self.commands: t.Dict[str, Command] = commands
+
+    def add_command(self, cmd: Command, name: t.Optional[str] = None) -> None:
         """Registers another :class:`Command` with this group.  If the name
         is not provided, the name of the command is used.
         """
@@ -1350,40 +1809,89 @@
         _check_multicommand(self, name, cmd, register=True)
         self.commands[name] = cmd

-    def command(self, *args, **kwargs):
+    def command(
+        self, *args: t.Any, **kwargs: t.Any
+    ) -> t.Union[t.Callable[[t.Callable[..., t.Any]], Command], Command]:
         """A shortcut decorator for declaring and attaching a command to
-        the group.  This takes the same arguments as :func:`command` but
-        immediately registers the created command with this instance by
-        calling into :meth:`add_command`.
+        the group. This takes the same arguments as :func:`command` and
+        immediately registers the created command with this group by
+        calling :meth:`add_command`.
+
+        To customize the command class used, set the
+        :attr:`command_class` attribute.
+
+        .. versionchanged:: 8.1
+            This decorator can be applied without parentheses.
+
+        .. versionchanged:: 8.0
+            Added the :attr:`command_class` attribute.
         """
         from .decorators import command

-        def decorator(f):
-            cmd = command(*args, **kwargs)(f)
+        if self.command_class and kwargs.get("cls") is None:
+            kwargs["cls"] = self.command_class
+
+        func: t.Optional[t.Callable] = None
+
+        if args and callable(args[0]):
+            func = args[0]
+            args = args[1:]
+
+        def decorator(f: t.Callable[..., t.Any]) -> Command:
+            cmd: Command = command(*args, **kwargs)(f)
             self.add_command(cmd)
             return cmd

+        if func is not None:
+            return decorator(func)
+
         return decorator

-    def group(self, *args, **kwargs):
+    def group(
+        self, *args: t.Any, **kwargs: t.Any
+    ) -> t.Union[t.Callable[[t.Callable[..., t.Any]], "Group"], "Group"]:
         """A shortcut decorator for declaring and attaching a group to
-        the group.  This takes the same arguments as :func:`group` but
-        immediately registers the created command with this instance by
-        calling into :meth:`add_command`.
+        the group. This takes the same arguments as :func:`group` and
+        immediately registers the created group with this group by
+        calling :meth:`add_command`.
+
+        To customize the group class used, set the :attr:`group_class`
+        attribute.
+
+        .. versionchanged:: 8.1
+            This decorator can be applied without parentheses.
+
+        .. versionchanged:: 8.0
+            Added the :attr:`group_class` attribute.
         """
         from .decorators import group

-        def decorator(f):
-            cmd = group(*args, **kwargs)(f)
+        func: t.Optional[t.Callable] = None
+
+        if args and callable(args[0]):
+            func = args[0]
+            args = args[1:]
+
+        if self.group_class is not None and kwargs.get("cls") is None:
+            if self.group_class is type:
+                kwargs["cls"] = type(self)
+            else:
+                kwargs["cls"] = self.group_class
+
+        def decorator(f: t.Callable[..., t.Any]) -> "Group":
+            cmd: Group = group(*args, **kwargs)(f)
             self.add_command(cmd)
             return cmd

+        if func is not None:
+            return decorator(func)
+
         return decorator

-    def get_command(self, ctx, cmd_name):
+    def get_command(self, ctx: Context, cmd_name: str) -> t.Optional[Command]:
         return self.commands.get(cmd_name)

-    def list_commands(self, ctx):
+    def list_commands(self, ctx: Context) -> t.List[str]:
         return sorted(self.commands)


@@ -1394,31 +1902,52 @@
     provides all the commands for each of them.
     """

-    def __init__(self, name=None, sources=None, **attrs):
-        MultiCommand.__init__(self, name, **attrs)
+    def __init__(
+        self,
+        name: t.Optional[str] = None,
+        sources: t.Optional[t.List[MultiCommand]] = None,
+        **attrs: t.Any,
+    ) -> None:
+        super().__init__(name, **attrs)
         #: The list of registered multi commands.
-        self.sources = sources or []
-
-    def add_source(self, multi_cmd):
+        self.sources: t.List[MultiCommand] = sources or []
+
+    def add_source(self, multi_cmd: MultiCommand) -> None:
         """Adds a new multi command to the chain dispatcher."""
         self.sources.append(multi_cmd)

-    def get_command(self, ctx, cmd_name):
+    def get_command(self, ctx: Context, cmd_name: str) -> t.Optional[Command]:
         for source in self.sources:
             rv = source.get_command(ctx, cmd_name)
+
             if rv is not None:
                 if self.chain:
                     _check_multicommand(self, cmd_name, rv)
+
                 return rv

-    def list_commands(self, ctx):
-        rv = set()
+        return None
+
+    def list_commands(self, ctx: Context) -> t.List[str]:
+        rv: t.Set[str] = set()
+
         for source in self.sources:
             rv.update(source.list_commands(ctx))
+
         return sorted(rv)


-class Parameter(object):
+def _check_iter(value: t.Any) -> t.Iterator[t.Any]:
+    """Check if the value is iterable but not a string. Raises a type
+    error, or return an iterator over the value.
+    """
+    if isinstance(value, str):
+        raise TypeError
+
+    return iter(value)
+
+
+class Parameter:
     r"""A parameter to a command comes in two versions: they are either
     :class:`Option`\s or :class:`Argument`\s.  Other subclasses are currently
     not supported by design as some of the internals for parsing are
@@ -1436,13 +1965,15 @@
     :param default: the default value if omitted.  This can also be a callable,
                     in which case it's invoked when the default is needed
                     without any arguments.
-    :param callback: a callback that should be executed after the parameter
-                     was matched.  This is called as ``fn(ctx, param,
-                     value)`` and needs to return the value.
+    :param callback: A function to further process or validate the value
+        after type conversion. It is called as ``f(ctx, param, value)``
+        and must return the value. It is called for all sources,
+        including prompts.
     :param nargs: the number of arguments to match.  If not ``1`` the return
                   value is a tuple instead of single value.  The default for
                   nargs is ``1`` (except if the type is a tuple, then it's
-                  the arity of the tuple).
+                  the arity of the tuple). If ``nargs=-1``, all remaining
+                  parameters are collected.
     :param metavar: how the value is represented in the help page.
     :param expose_value: if this is `True` then the value is passed onwards
                          to the command callback and stored on the context,
@@ -1452,6 +1983,32 @@
                      order of processing.
     :param envvar: a string or list of strings that are environment variables
                    that should be checked.
+    :param shell_complete: A function that returns custom shell
+        completions. Used instead of the param's type completion if
+        given. Takes ``ctx, param, incomplete`` and must return a list
+        of :class:`~click.shell_completion.CompletionItem` or a list of
+        strings.
+
+    .. versionchanged:: 8.0
+        ``process_value`` validates required parameters and bounded
+        ``nargs``, and invokes the parameter callback before returning
+        the value. This allows the callback to validate prompts.
+        ``full_process_value`` is removed.
+
+    .. versionchanged:: 8.0
+        ``autocompletion`` is renamed to ``shell_complete`` and has new
+        semantics described above. The old name is deprecated and will
+        be removed in 8.1, until then it will be wrapped to match the
+        new requirements.
+
+    .. versionchanged:: 8.0
+        For ``multiple=True, nargs>1``, the default must be a list of
+        tuples.
+
+    .. versionchanged:: 8.0
+        Setting a default is no longer required for ``nargs>1``, it will
+        default to ``None``. ``multiple=True`` or ``nargs=-1`` will
+        default to ``()``.

     .. versionchanged:: 7.1
         Empty environment variables are ignored rather than taking the
@@ -1463,27 +2020,33 @@
         parameter. The old callback format will still work, but it will
         raise a warning to give you a chance to migrate the code easier.
     """
+
     param_type_name = "parameter"

     def __init__(
         self,
-        param_decls=None,
-        type=None,
-        required=False,
-        default=None,
-        callback=None,
-        nargs=None,
-        metavar=None,
-        expose_value=True,
-        is_eager=False,
-        envvar=None,
-        autocompletion=None,
-    ):
+        param_decls: t.Optional[t.Sequence[str]] = None,
+        type: t.Optional[t.Union[types.ParamType, t.Any]] = None,
+        required: bool = False,
+        default: t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]] = None,
+        callback: t.Optional[t.Callable[[Context, "Parameter", t.Any], t.Any]] = None,
+        nargs: t.Optional[int] = None,
+        multiple: bool = False,
+        metavar: t.Optional[str] = None,
+        expose_value: bool = True,
+        is_eager: bool = False,
+        envvar: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        shell_complete: t.Optional[
+            t.Callable[
+                [Context, "Parameter", str],
+                t.Union[t.List["CompletionItem"], t.List[str]],
+            ]
+        ] = None,
+    ) -> None:
         self.name, self.opts, self.secondary_opts = self._parse_decls(
             param_decls or (), expose_value
         )
-
-        self.type = convert_type(type, default)
+        self.type = types.convert_type(type, default)

         # Default nargs to what the type tells us if we have that
         # information available.
@@ -1496,158 +2059,325 @@
         self.required = required
         self.callback = callback
         self.nargs = nargs
-        self.multiple = False
+        self.multiple = multiple
         self.expose_value = expose_value
         self.default = default
         self.is_eager = is_eager
         self.metavar = metavar
         self.envvar = envvar
-        self.autocompletion = autocompletion
-
-    def __repr__(self):
-        return "<{} {}>".format(self.__class__.__name__, self.name)
+        self._custom_shell_complete = shell_complete
+
+        if __debug__:
+            if self.type.is_composite and nargs != self.type.arity:
+                raise ValueError(
+                    f"'nargs' must be {self.type.arity} (or None) for"
+                    f" type {self.type!r}, but it was {nargs}."
+                )
+
+            # Skip no default or callable default.
+            check_default = default if not callable(default) else None
+
+            if check_default is not None:
+                if multiple:
+                    try:
+                        # Only check the first value against nargs.
+                        check_default = next(_check_iter(check_default), None)
+                    except TypeError:
+                        raise ValueError(
+                            "'default' must be a list when 'multiple' is true."
+                        ) from None
+
+                # Can be None for multiple with empty default.
+                if nargs != 1 and check_default is not None:
+                    try:
+                        _check_iter(check_default)
+                    except TypeError:
+                        if multiple:
+                            message = (
+                                "'default' must be a list of lists when 'multiple' is"
+                                " true and 'nargs' != 1."
+                            )
+                        else:
+                            message = "'default' must be a list when 'nargs' != 1."
+
+                        raise ValueError(message) from None
+
+                    if nargs > 1 and len(check_default) != nargs:
+                        subject = "item length" if multiple else "length"
+                        raise ValueError(
+                            f"'default' {subject} must match nargs={nargs}."
+                        )
+
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        """Gather information that could be useful for a tool generating
+        user-facing documentation.
+
+        Use :meth:`click.Context.to_info_dict` to traverse the entire
+        CLI structure.
+
+        .. versionadded:: 8.0
+        """
+        return {
+            "name": self.name,
+            "param_type_name": self.param_type_name,
+            "opts": self.opts,
+            "secondary_opts": self.secondary_opts,
+            "type": self.type.to_info_dict(),
+            "required": self.required,
+            "nargs": self.nargs,
+            "multiple": self.multiple,
+            "default": self.default,
+            "envvar": self.envvar,
+        }
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} {self.name}>"
+
+    def _parse_decls(
+        self, decls: t.Sequence[str], expose_value: bool
+    ) -> t.Tuple[t.Optional[str], t.List[str], t.List[str]]:
+        raise NotImplementedError()

     @property
-    def human_readable_name(self):
+    def human_readable_name(self) -> str:
         """Returns the human readable name of this parameter.  This is the
         same as the name for options, but the metavar for arguments.
         """
-        return self.name
-
-    def make_metavar(self):
+        return self.name  # type: ignore
+
+    def make_metavar(self) -> str:
         if self.metavar is not None:
             return self.metavar
+
         metavar = self.type.get_metavar(self)
+
         if metavar is None:
             metavar = self.type.name.upper()
+
         if self.nargs != 1:
             metavar += "..."
+
         return metavar

-    def get_default(self, ctx):
-        """Given a context variable this calculates the default value."""
-        # Otherwise go with the regular default.
-        if callable(self.default):
-            rv = self.default()
-        else:
-            rv = self.default
-        return self.type_cast_value(ctx, rv)
-
-    def add_to_parser(self, parser, ctx):
-        pass
-
-    def consume_value(self, ctx, opts):
-        value = opts.get(self.name)
+    @t.overload
+    def get_default(
+        self, ctx: Context, call: "te.Literal[True]" = True
+    ) -> t.Optional[t.Any]:
+        ...
+
+    @t.overload
+    def get_default(
+        self, ctx: Context, call: bool = ...
+    ) -> t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:
+        ...
+
+    def get_default(
+        self, ctx: Context, call: bool = True
+    ) -> t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:
+        """Get the default for the parameter. Tries
+        :meth:`Context.lookup_default` first, then the local default.
+
+        :param ctx: Current context.
+        :param call: If the default is a callable, call it. Disable to
+            return the callable instead.
+
+        .. versionchanged:: 8.0.2
+            Type casting is no longer performed when getting a default.
+
+        .. versionchanged:: 8.0.1
+            Type casting can fail in resilient parsing mode. Invalid
+            defaults will not prevent showing help text.
+
+        .. versionchanged:: 8.0
+            Looks at ``ctx.default_map`` first.
+
+        .. versionchanged:: 8.0
+            Added the ``call`` parameter.
+        """
+        value = ctx.lookup_default(self.name, call=False)  # type: ignore
+
+        if value is None:
+            value = self.default
+
+        if call and callable(value):
+            value = value()
+
+        return value
+
+    def add_to_parser(self, parser: OptionParser, ctx: Context) -> None:
+        raise NotImplementedError()
+
+    def consume_value(
+        self, ctx: Context, opts: t.Mapping[str, t.Any]
+    ) -> t.Tuple[t.Any, ParameterSource]:
+        value = opts.get(self.name)  # type: ignore
+        source = ParameterSource.COMMANDLINE
+
         if value is None:
             value = self.value_from_envvar(ctx)
+            source = ParameterSource.ENVIRONMENT
+
         if value is None:
-            value = ctx.lookup_default(self.name)
-        return value
-
-    def type_cast_value(self, ctx, value):
-        """Given a value this runs it properly through the type system.
-        This automatically handles things like `nargs` and `multiple` as
-        well as composite types.
-        """
-        if self.type.is_composite:
-            if self.nargs <= 1:
-                raise TypeError(
-                    "Attempted to invoke composite type but nargs has"
-                    " been set to {}. This is not supported; nargs"
-                    " needs to be set to a fixed value > 1.".format(self.nargs)
-                )
-            if self.multiple:
-                return tuple(self.type(x or (), self, ctx) for x in value or ())
-            return self.type(value or (), self, ctx)
-
-        def _convert(value, level):
-            if level == 0:
-                return self.type(value, self, ctx)
-            return tuple(_convert(x, level - 1) for x in value or ())
-
-        return _convert(value, (self.nargs != 1) + bool(self.multiple))
-
-    def process_value(self, ctx, value):
-        """Given a value and context this runs the logic to convert the
-        value as necessary.
-        """
-        # If the value we were given is None we do nothing.  This way
-        # code that calls this can easily figure out if something was
-        # not provided.  Otherwise it would be converted into an empty
-        # tuple for multiple invocations which is inconvenient.
-        if value is not None:
-            return self.type_cast_value(ctx, value)
-
-    def value_is_missing(self, value):
+            value = ctx.lookup_default(self.name)  # type: ignore
+            source = ParameterSource.DEFAULT_MAP
+
+        if value is None:
+            value = self.get_default(ctx)
+            source = ParameterSource.DEFAULT
+
+        return value, source
+
+    def type_cast_value(self, ctx: Context, value: t.Any) -> t.Any:
+        """Convert and validate a value against the option's
+        :attr:`type`, :attr:`multiple`, and :attr:`nargs`.
+        """
+        if value is None:
+            return () if self.multiple or self.nargs == -1 else None
+
+        def check_iter(value: t.Any) -> t.Iterator:
+            try:
+                return _check_iter(value)
+            except TypeError:
+                # This should only happen when passing in args manually,
+                # the parser should construct an iterable when parsing
+                # the command line.
+                raise BadParameter(
+                    _("Value must be an iterable."), ctx=ctx, param=self
+                ) from None
+
+        if self.nargs == 1 or self.type.is_composite:
+            convert: t.Callable[[t.Any], t.Any] = partial(
+                self.type, param=self, ctx=ctx
+            )
+        elif self.nargs == -1:
+
+            def convert(value: t.Any) -> t.Tuple:
+                return tuple(self.type(x, self, ctx) for x in check_iter(value))
+
+        else:  # nargs > 1
+
+            def convert(value: t.Any) -> t.Tuple:
+                value = tuple(check_iter(value))
+
+                if len(value) != self.nargs:
+                    raise BadParameter(
+                        ngettext(
+                            "Takes {nargs} values but 1 was given.",
+                            "Takes {nargs} values but {len} were given.",
+                            len(value),
+                        ).format(nargs=self.nargs, len=len(value)),
+                        ctx=ctx,
+                        param=self,
+                    )
+
+                return tuple(self.type(x, self, ctx) for x in value)
+
+        if self.multiple:
+            return tuple(convert(x) for x in check_iter(value))
+
+        return convert(value)
+
+    def value_is_missing(self, value: t.Any) -> bool:
         if value is None:
             return True
+
         if (self.nargs != 1 or self.multiple) and value == ():
             return True
+
         return False

-    def full_process_value(self, ctx, value):
-        value = self.process_value(ctx, value)
-
-        if value is None and not ctx.resilient_parsing:
-            value = self.get_default(ctx)
+    def process_value(self, ctx: Context, value: t.Any) -> t.Any:
+        value = self.type_cast_value(ctx, value)

         if self.required and self.value_is_missing(value):
             raise MissingParameter(ctx=ctx, param=self)

+        if self.callback is not None:
+            value = self.callback(ctx, self, value)
+
         return value

-    def resolve_envvar_value(self, ctx):
+    def resolve_envvar_value(self, ctx: Context) -> t.Optional[str]:
         if self.envvar is None:
-            return
-        if isinstance(self.envvar, (tuple, list)):
+            return None
+
+        if isinstance(self.envvar, str):
+            rv = os.environ.get(self.envvar)
+
+            if rv:
+                return rv
+        else:
             for envvar in self.envvar:
                 rv = os.environ.get(envvar)
-                if rv is not None:
+
+                if rv:
                     return rv
-        else:
-            rv = os.environ.get(self.envvar)
-
-            if rv != "":
-                return rv
-
-    def value_from_envvar(self, ctx):
-        rv = self.resolve_envvar_value(ctx)
+
+        return None
+
+    def value_from_envvar(self, ctx: Context) -> t.Optional[t.Any]:
+        rv: t.Optional[t.Any] = self.resolve_envvar_value(ctx)
+
         if rv is not None and self.nargs != 1:
             rv = self.type.split_envvar_value(rv)
+
         return rv

-    def handle_parse_result(self, ctx, opts, args):
+    def handle_parse_result(
+        self, ctx: Context, opts: t.Mapping[str, t.Any], args: t.List[str]
+    ) -> t.Tuple[t.Any, t.List[str]]:
         with augment_usage_errors(ctx, param=self):
-            value = self.consume_value(ctx, opts)
+            value, source = self.consume_value(ctx, opts)
+            ctx.set_parameter_source(self.name, source)  # type: ignore
+
             try:
-                value = self.full_process_value(ctx, value)
+                value = self.process_value(ctx, value)
             except Exception:
                 if not ctx.resilient_parsing:
                     raise
+
                 value = None
-            if self.callback is not None:
-                try:
-                    value = invoke_param_callback(self.callback, ctx, self, value)
-                except Exception:
-                    if not ctx.resilient_parsing:
-                        raise

         if self.expose_value:
-            ctx.params[self.name] = value
+            ctx.params[self.name] = value  # type: ignore
+
         return value, args

-    def get_help_record(self, ctx):
+    def get_help_record(self, ctx: Context) -> t.Optional[t.Tuple[str, str]]:
         pass

-    def get_usage_pieces(self, ctx):
+    def get_usage_pieces(self, ctx: Context) -> t.List[str]:
         return []

-    def get_error_hint(self, ctx):
+    def get_error_hint(self, ctx: Context) -> str:
         """Get a stringified version of the param for use in error messages to
         indicate which param caused the error.
         """
         hint_list = self.opts or [self.human_readable_name]
-        return " / ".join(repr(x) for x in hint_list)
+        return " / ".join(f"'{x}'" for x in hint_list)
+
+    def shell_complete(self, ctx: Context, incomplete: str) -> t.List["CompletionItem"]:
+        """Return a list of completions for the incomplete value. If a
+        ``shell_complete`` function was given during init, it is used.
+        Otherwise, the :attr:`type`
+        :meth:`~click.types.ParamType.shell_complete` function is used.
+
+        :param ctx: Invocation context for this command.
+        :param incomplete: Value being completed. May be empty.
+
+        .. versionadded:: 8.0
+        """
+        if self._custom_shell_complete is not None:
+            results = self._custom_shell_complete(ctx, self, incomplete)
+
+            if results and isinstance(results[0], str):
+                from click.shell_completion import CompletionItem
+
+                results = [CompletionItem(c) for c in results]
+
+            return t.cast(t.List["CompletionItem"], results)
+
+        return self.type.shell_complete(ctx, self, incomplete)


 class Option(Parameter):
@@ -1656,21 +2386,27 @@

     All other parameters are passed onwards to the parameter constructor.

-    :param show_default: controls if the default value should be shown on the
-                         help page. Normally, defaults are not shown. If this
-                         value is a string, it shows the string instead of the
-                         value. This is particularly useful for dynamic options.
-    :param show_envvar: controls if an environment variable should be shown on
-                        the help page.  Normally, environment variables
-                        are not shown.
-    :param prompt: if set to `True` or a non empty string then the user will be
-                   prompted for input.  If set to `True` the prompt will be the
-                   option name capitalized.
-    :param confirmation_prompt: if set then the value will need to be confirmed
-                                if it was prompted for.
-    :param hide_input: if this is `True` then the input on the prompt will be
-                       hidden from the user.  This is useful for password
-                       input.
+    :param show_default: Show the default value for this option in its
+        help text. Values are not shown by default, unless
+        :attr:`Context.show_default` is ``True``. If this value is a
+        string, it shows that string in parentheses instead of the
+        actual value. This is particularly useful for dynamic options.
+        For single option boolean flags, the default remains hidden if
+        its value is ``False``.
+    :param show_envvar: Controls if an environment variable should be
+        shown on the help page. Normally, environment variables are not
+        shown.
+    :param prompt: If set to ``True`` or a non empty string then the
+        user will be prompted for input. If set to ``True`` the prompt
+        will be the option name capitalized.
+    :param confirmation_prompt: Prompt a second time to confirm the
+        value if it was prompted for. Can be set to a string instead of
+        ``True`` to customize the message.
+    :param prompt_required: If set to ``False``, the user will be
+        prompted for input only when the option was specified as a flag
+        without a value.
+    :param hide_input: If this is ``True`` then the input on the prompt
+        will be hidden from the user. This is useful for password input.
     :param is_flag: forces this option to act as a flag.  The default is
                     auto detection.
     :param flag_value: which value should be used for this flag if it's
@@ -1687,106 +2423,161 @@
                                context.
     :param help: the help string.
     :param hidden: hide this option from help outputs.
+
+    .. versionchanged:: 8.1.0
+        Help text indentation is cleaned here instead of only in the
+        ``@option`` decorator.
+
+    .. versionchanged:: 8.1.0
+        The ``show_default`` parameter overrides
+        ``Context.show_default``.
+
+    .. versionchanged:: 8.1.0
+        The default of a single option boolean flag is not shown if the
+        default value is ``False``.
+
+    .. versionchanged:: 8.0.1
+        ``type`` is detected from ``flag_value`` if given.
     """

     param_type_name = "option"

     def __init__(
         self,
-        param_decls=None,
-        show_default=False,
-        prompt=False,
-        confirmation_prompt=False,
-        hide_input=False,
-        is_flag=None,
-        flag_value=None,
-        multiple=False,
-        count=False,
-        allow_from_autoenv=True,
-        type=None,
-        help=None,
-        hidden=False,
-        show_choices=True,
-        show_envvar=False,
-        **attrs
-    ):
-        default_is_missing = attrs.get("default", _missing) is _missing
-        Parameter.__init__(self, param_decls, type=type, **attrs)
+        param_decls: t.Optional[t.Sequence[str]] = None,
+        show_default: t.Union[bool, str, None] = None,
+        prompt: t.Union[bool, str] = False,
+        confirmation_prompt: t.Union[bool, str] = False,
+        prompt_required: bool = True,
+        hide_input: bool = False,
+        is_flag: t.Optional[bool] = None,
+        flag_value: t.Optional[t.Any] = None,
+        multiple: bool = False,
+        count: bool = False,
+        allow_from_autoenv: bool = True,
+        type: t.Optional[t.Union[types.ParamType, t.Any]] = None,
+        help: t.Optional[str] = None,
+        hidden: bool = False,
+        show_choices: bool = True,
+        show_envvar: bool = False,
+        **attrs: t.Any,
+    ) -> None:
+        if help:
+            help = inspect.cleandoc(help)
+
+        default_is_missing = "default" not in attrs
+        super().__init__(param_decls, type=type, multiple=multiple, **attrs)

         if prompt is True:
-            prompt_text = self.name.replace("_", " ").capitalize()
+            if self.name is None:
+                raise TypeError("'name' is required with 'prompt=True'.")
+
+            prompt_text: t.Optional[str] = self.name.replace("_", " ").capitalize()
         elif prompt is False:
             prompt_text = None
         else:
             prompt_text = prompt
+
         self.prompt = prompt_text
         self.confirmation_prompt = confirmation_prompt
+        self.prompt_required = prompt_required
         self.hide_input = hide_input
         self.hidden = hidden

-        # Flags
+        # If prompt is enabled but not required, then the option can be
+        # used as a flag to indicate using prompt or flag_value.
+        self._flag_needs_value = self.prompt is not None and not self.prompt_required
+
         if is_flag is None:
             if flag_value is not None:
+                # Implicitly a flag because flag_value was set.
                 is_flag = True
+            elif self._flag_needs_value:
+                # Not a flag, but when used as a flag it shows a prompt.
+                is_flag = False
             else:
+                # Implicitly a flag because flag options were given.
                 is_flag = bool(self.secondary_opts)
-        if is_flag and default_is_missing:
-            self.default = False
+        elif is_flag is False and not self._flag_needs_value:
+            # Not a flag, and prompt is not enabled, can be used as a
+            # flag if flag_value is set.
+            self._flag_needs_value = flag_value is not None
+
+        if is_flag and default_is_missing and not self.required:
+            self.default: t.Union[t.Any, t.Callable[[], t.Any]] = False
+
         if flag_value is None:
             flag_value = not self.default
-        self.is_flag = is_flag
-        self.flag_value = flag_value
-        if self.is_flag and isinstance(self.flag_value, bool) and type in [None, bool]:
-            self.type = BOOL
-            self.is_bool_flag = True
-        else:
-            self.is_bool_flag = False
+
+        if is_flag and type is None:
+            # Re-guess the type from the flag value instead of the
+            # default.
+            self.type = types.convert_type(None, flag_value)
+
+        self.is_flag: bool = is_flag
+        self.is_bool_flag = is_flag and isinstance(self.type, types.BoolParamType)
+        self.flag_value: t.Any = flag_value

         # Counting
         self.count = count
         if count:
             if type is None:
-                self.type = IntRange(min=0)
+                self.type = types.IntRange(min=0)
             if default_is_missing:
                 self.default = 0

-        self.multiple = multiple
         self.allow_from_autoenv = allow_from_autoenv
         self.help = help
         self.show_default = show_default
         self.show_choices = show_choices
         self.show_envvar = show_envvar

-        # Sanity check for stuff we don't support
         if __debug__:
-            if self.nargs < 0:
-                raise TypeError("Options cannot have nargs < 0")
+            if self.nargs == -1:
+                raise TypeError("nargs=-1 is not supported for options.")
+
             if self.prompt and self.is_flag and not self.is_bool_flag:
-                raise TypeError("Cannot prompt for flags that are not bools.")
+                raise TypeError("'prompt' is not valid for non-boolean flag.")
+
             if not self.is_bool_flag and self.secondary_opts:
-                raise TypeError("Got secondary option for non boolean flag.")
+                raise TypeError("Secondary flag is not valid for non-boolean flag.")
+
             if self.is_bool_flag and self.hide_input and self.prompt is not None:
-                raise TypeError("Hidden input does not work with boolean flag prompts.")
+                raise TypeError(
+                    "'prompt' with 'hide_input' is not valid for boolean flag."
+                )
+
             if self.count:
                 if self.multiple:
-                    raise TypeError(
-                        "Options cannot be multiple and count at the same time."
-                    )
-                elif self.is_flag:
-                    raise TypeError(
-                        "Options cannot be count and flags at the same time."
-                    )
-
-    def _parse_decls(self, decls, expose_value):
+                    raise TypeError("'count' is not valid with 'multiple'.")
+
+                if self.is_flag:
+                    raise TypeError("'count' is not valid with 'is_flag'.")
+
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict()
+        info_dict.update(
+            help=self.help,
+            prompt=self.prompt,
+            is_flag=self.is_flag,
+            flag_value=self.flag_value,
+            count=self.count,
+            hidden=self.hidden,
+        )
+        return info_dict
+
+    def _parse_decls(
+        self, decls: t.Sequence[str], expose_value: bool
+    ) -> t.Tuple[t.Optional[str], t.List[str], t.List[str]]:
         opts = []
         secondary_opts = []
         name = None
         possible_names = []

         for decl in decls:
-            if isidentifier(decl):
+            if decl.isidentifier():
                 if name is not None:
-                    raise TypeError("Name defined twice")
+                    raise TypeError(f"Name '{name}' defined twice")
                 name = decl
             else:
                 split_char = ";" if decl[:1] == "/" else "/"
@@ -1799,6 +2590,11 @@
                     second = second.lstrip()
                     if second:
                         secondary_opts.append(second.lstrip())
+                    if first == second:
+                        raise ValueError(
+                            f"Boolean option {decl!r} cannot use the"
+                            " same flag for true/false."
+                        )
                 else:
                     possible_names.append(split_opt(decl))
                     opts.append(decl)
@@ -1806,7 +2602,7 @@
         if name is None and possible_names:
             possible_names.sort(key=lambda x: -len(x[0]))  # group long options first
             name = possible_names[0][1].replace("-", "_").lower()
-            if not isidentifier(name):
+            if not name.isidentifier():
                 name = None

         if name is None:
@@ -1816,19 +2612,14 @@

         if not opts and not secondary_opts:
             raise TypeError(
-                "No options defined but a name was passed ({}). Did you"
-                " mean to declare an argument instead of an option?".format(name)
+                f"No options defined but a name was passed ({name})."
+                " Did you mean to declare an argument instead? Did"
+                f" you mean to pass '--{name}'?"
             )

         return name, opts, secondary_opts

-    def add_to_parser(self, parser, ctx):
-        kwargs = {
-            "dest": self.name,
-            "nargs": self.nargs,
-            "obj": self,
-        }
-
+    def add_to_parser(self, parser: OptionParser, ctx: Context) -> None:
         if self.multiple:
             action = "append"
         elif self.count:
@@ -1837,91 +2628,180 @@
             action = "store"

         if self.is_flag:
-            kwargs.pop("nargs", None)
-            action_const = "{}_const".format(action)
+            action = f"{action}_const"
+
             if self.is_bool_flag and self.secondary_opts:
-                parser.add_option(self.opts, action=action_const, const=True, **kwargs)
                 parser.add_option(
-                    self.secondary_opts, action=action_const, const=False, **kwargs
+                    obj=self, opts=self.opts, dest=self.name, action=action, const=True
+                )
+                parser.add_option(
+                    obj=self,
+                    opts=self.secondary_opts,
+                    dest=self.name,
+                    action=action,
+                    const=False,
                 )
             else:
                 parser.add_option(
-                    self.opts, action=action_const, const=self.flag_value, **kwargs
+                    obj=self,
+                    opts=self.opts,
+                    dest=self.name,
+                    action=action,
+                    const=self.flag_value,
                 )
         else:
-            kwargs["action"] = action
-            parser.add_option(self.opts, **kwargs)
-
-    def get_help_record(self, ctx):
+            parser.add_option(
+                obj=self,
+                opts=self.opts,
+                dest=self.name,
+                action=action,
+                nargs=self.nargs,
+            )
+
+    def get_help_record(self, ctx: Context) -> t.Optional[t.Tuple[str, str]]:
         if self.hidden:
-            return
-        any_prefix_is_slash = []
-
-        def _write_opts(opts):
+            return None
+
+        any_prefix_is_slash = False
+
+        def _write_opts(opts: t.Sequence[str]) -> str:
+            nonlocal any_prefix_is_slash
+
             rv, any_slashes = join_options(opts)
+
             if any_slashes:
-                any_prefix_is_slash[:] = [True]
+                any_prefix_is_slash = True
+
             if not self.is_flag and not self.count:
-                rv += " {}".format(self.make_metavar())
+                rv += f" {self.make_metavar()}"
+
             return rv

         rv = [_write_opts(self.opts)]
+
         if self.secondary_opts:
             rv.append(_write_opts(self.secondary_opts))

         help = self.help or ""
         extra = []
+
         if self.show_envvar:
             envvar = self.envvar
+
             if envvar is None:
-                if self.allow_from_autoenv and ctx.auto_envvar_prefix is not None:
-                    envvar = "{}_{}".format(ctx.auto_envvar_prefix, self.name.upper())
+                if (
+                    self.allow_from_autoenv
+                    and ctx.auto_envvar_prefix is not None
+                    and self.name is not None
+                ):
+                    envvar = f"{ctx.auto_envvar_prefix}_{self.name.upper()}"
+
             if envvar is not None:
-                extra.append(
-                    "env var: {}".format(
-                        ", ".join(str(d) for d in envvar)
-                        if isinstance(envvar, (list, tuple))
-                        else envvar
-                    )
+                var_str = (
+                    envvar
+                    if isinstance(envvar, str)
+                    else ", ".join(str(d) for d in envvar)
                 )
-        if self.default is not None and (self.show_default or ctx.show_default):
-            if isinstance(self.show_default, string_types):
-                default_string = "({})".format(self.show_default)
-            elif isinstance(self.default, (list, tuple)):
-                default_string = ", ".join(str(d) for d in self.default)
-            elif inspect.isfunction(self.default):
-                default_string = "(dynamic)"
+                extra.append(_("env var: {var}").format(var=var_str))
+
+        # Temporarily enable resilient parsing to avoid type casting
+        # failing for the default. Might be possible to extend this to
+        # help formatting in general.
+        resilient = ctx.resilient_parsing
+        ctx.resilient_parsing = True
+
+        try:
+            default_value = self.get_default(ctx, call=False)
+        finally:
+            ctx.resilient_parsing = resilient
+
+        show_default = False
+        show_default_is_str = False
+
+        if self.show_default is not None:
+            if isinstance(self.show_default, str):
+                show_default_is_str = show_default = True
             else:
-                default_string = self.default
-            extra.append("default: {}".format(default_string))
+                show_default = self.show_default
+        elif ctx.show_default is not None:
+            show_default = ctx.show_default
+
+        if show_default_is_str or (show_default and (default_value is not None)):
+            if show_default_is_str:
+                default_string = f"({self.show_default})"
+            elif isinstance(default_value, (list, tuple)):
+                default_string = ", ".join(str(d) for d in default_value)
+            elif inspect.isfunction(default_value):
+                default_string = _("(dynamic)")
+            elif self.is_bool_flag and self.secondary_opts:
+                # For boolean flags that have distinct True/False opts,
+                # use the opt without prefix instead of the value.
+                default_string = split_opt(
+                    (self.opts if self.default else self.secondary_opts)[0]
+                )[1]
+            elif self.is_bool_flag and not self.secondary_opts and not default_value:
+                default_string = ""
+            else:
+                default_string = str(default_value)
+
+            if default_string:
+                extra.append(_("default: {default}").format(default=default_string))
+
+        if (
+            isinstance(self.type, types._NumberRangeBase)
+            # skip count with default range type
+            and not (self.count and self.type.min == 0 and self.type.max is None)
+        ):
+            range_str = self.type._describe_range()
+
+            if range_str:
+                extra.append(range_str)

         if self.required:
-            extra.append("required")
+            extra.append(_("required"))
+
         if extra:
-            help = "{}[{}]".format(
-                "{}  ".format(help) if help else "", "; ".join(extra)
-            )
+            extra_str = "; ".join(extra)
+            help = f"{help}  [{extra_str}]" if help else f"[{extra_str}]"

         return ("; " if any_prefix_is_slash else " / ").join(rv), help

-    def get_default(self, ctx):
+    @t.overload
+    def get_default(
+        self, ctx: Context, call: "te.Literal[True]" = True
+    ) -> t.Optional[t.Any]:
+        ...
+
+    @t.overload
+    def get_default(
+        self, ctx: Context, call: bool = ...
+    ) -> t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:
+        ...
+
+    def get_default(
+        self, ctx: Context, call: bool = True
+    ) -> t.Optional[t.Union[t.Any, t.Callable[[], t.Any]]]:
         # If we're a non boolean flag our default is more complex because
         # we need to look at all flags in the same group to figure out
-        # if we're the the default one in which case we return the flag
+        # if we're the default one in which case we return the flag
         # value as default.
         if self.is_flag and not self.is_bool_flag:
             for param in ctx.command.params:
                 if param.name == self.name and param.default:
-                    return param.flag_value
+                    return param.flag_value  # type: ignore
+
             return None
-        return Parameter.get_default(self, ctx)
-
-    def prompt_for_value(self, ctx):
+
+        return super().get_default(ctx, call=call)
+
+    def prompt_for_value(self, ctx: Context) -> t.Any:
         """This is an alternative flow that can be activated in the full
         value processing if a value does not exist.  It will prompt the
         user until a valid value exists and then returns the processed
         value as result.
         """
+        assert self.prompt is not None
+
         # Calculate the default before prompting anything to be stable.
         default = self.get_default(ctx)

@@ -1940,29 +2820,77 @@
             value_proc=lambda x: self.process_value(ctx, x),
         )

-    def resolve_envvar_value(self, ctx):
-        rv = Parameter.resolve_envvar_value(self, ctx)
+    def resolve_envvar_value(self, ctx: Context) -> t.Optional[str]:
+        rv = super().resolve_envvar_value(ctx)
+
         if rv is not None:
             return rv
-        if self.allow_from_autoenv and ctx.auto_envvar_prefix is not None:
-            envvar = "{}_{}".format(ctx.auto_envvar_prefix, self.name.upper())
-            return os.environ.get(envvar)
-
-    def value_from_envvar(self, ctx):
-        rv = self.resolve_envvar_value(ctx)
+
+        if (
+            self.allow_from_autoenv
+            and ctx.auto_envvar_prefix is not None
+            and self.name is not None
+        ):
+            envvar = f"{ctx.auto_envvar_prefix}_{self.name.upper()}"
+            rv = os.environ.get(envvar)
+
+            if rv:
+                return rv
+
+        return None
+
+    def value_from_envvar(self, ctx: Context) -> t.Optional[t.Any]:
+        rv: t.Optional[t.Any] = self.resolve_envvar_value(ctx)
+
         if rv is None:
             return None
+
         value_depth = (self.nargs != 1) + bool(self.multiple)
-        if value_depth > 0 and rv is not None:
+
+        if value_depth > 0:
             rv = self.type.split_envvar_value(rv)
+
             if self.multiple and self.nargs != 1:
                 rv = batch(rv, self.nargs)
+
         return rv

-    def full_process_value(self, ctx, value):
-        if value is None and self.prompt is not None and not ctx.resilient_parsing:
-            return self.prompt_for_value(ctx)
-        return Parameter.full_process_value(self, ctx, value)
+    def consume_value(
+        self, ctx: Context, opts: t.Mapping[str, "Parameter"]
+    ) -> t.Tuple[t.Any, ParameterSource]:
+        value, source = super().consume_value(ctx, opts)
+
+        # The parser will emit a sentinel value if the option can be
+        # given as a flag without a value. This is different from None
+        # to distinguish from the flag not being given at all.
+        if value is _flag_needs_value:
+            if self.prompt is not None and not ctx.resilient_parsing:
+                value = self.prompt_for_value(ctx)
+                source = ParameterSource.PROMPT
+            else:
+                value = self.flag_value
+                source = ParameterSource.COMMANDLINE
+
+        elif (
+            self.multiple
+            and value is not None
+            and any(v is _flag_needs_value for v in value)
+        ):
+            value = [self.flag_value if v is _flag_needs_value else v for v in value]
+            source = ParameterSource.COMMANDLINE
+
+        # The value wasn't set, or used the param's default, prompt if
+        # prompting is enabled.
+        elif (
+            source in {None, ParameterSource.DEFAULT}
+            and self.prompt is not None
+            and (self.required or self.prompt_required)
+            and not ctx.resilient_parsing
+        ):
+            value = self.prompt_for_value(ctx)
+            source = ParameterSource.PROMPT
+
+        return value, source


 class Argument(Parameter):
@@ -1975,37 +2903,48 @@

     param_type_name = "argument"

-    def __init__(self, param_decls, required=None, **attrs):
+    def __init__(
+        self,
+        param_decls: t.Sequence[str],
+        required: t.Optional[bool] = None,
+        **attrs: t.Any,
+    ) -> None:
         if required is None:
             if attrs.get("default") is not None:
                 required = False
             else:
                 required = attrs.get("nargs", 1) > 0
-        Parameter.__init__(self, param_decls, required=required, **attrs)
-        if self.default is not None and self.nargs < 0:
-            raise TypeError(
-                "nargs=-1 in combination with a default value is not supported."
-            )
+
+        if "multiple" in attrs:
+            raise TypeError("__init__() got an unexpected keyword argument 'multiple'.")
+
+        super().__init__(param_decls, required=required, **attrs)
+
+        if __debug__:
+            if self.default is not None and self.nargs == -1:
+                raise TypeError("'default' is not supported for nargs=-1.")

     @property
-    def human_readable_name(self):
+    def human_readable_name(self) -> str:
         if self.metavar is not None:
             return self.metavar
-        return self.name.upper()
-
-    def make_metavar(self):
+        return self.name.upper()  # type: ignore
+
+    def make_metavar(self) -> str:
         if self.metavar is not None:
             return self.metavar
         var = self.type.get_metavar(self)
         if not var:
-            var = self.name.upper()
+            var = self.name.upper()  # type: ignore
         if not self.required:
-            var = "[{}]".format(var)
+            var = f"[{var}]"
         if self.nargs != 1:
             var += "..."
         return var

-    def _parse_decls(self, decls, expose_value):
+    def _parse_decls(
+        self, decls: t.Sequence[str], expose_value: bool
+    ) -> t.Tuple[t.Optional[str], t.List[str], t.List[str]]:
         if not decls:
             if not expose_value:
                 return None, [], []
@@ -2016,15 +2955,15 @@
         else:
             raise TypeError(
                 "Arguments take exactly one parameter declaration, got"
-                " {}".format(len(decls))
+                f" {len(decls)}."
             )
         return name, [arg], []

-    def get_usage_pieces(self, ctx):
+    def get_usage_pieces(self, ctx: Context) -> t.List[str]:
         return [self.make_metavar()]

-    def get_error_hint(self, ctx):
-        return repr(self.make_metavar())
-
-    def add_to_parser(self, parser, ctx):
+    def get_error_hint(self, ctx: Context) -> str:
+        return f"'{self.make_metavar()}'"
+
+    def add_to_parser(self, parser: OptionParser, ctx: Context) -> None:
         parser.add_argument(dest=self.name, nargs=self.nargs, obj=self)
('src/click', 'types.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,37 +1,47 @@
 import os
 import stat
+import typing as t
 from datetime import datetime
+from gettext import gettext as _
+from gettext import ngettext

 from ._compat import _get_argv_encoding
-from ._compat import filename_to_ui
 from ._compat import get_filesystem_encoding
-from ._compat import get_streerror
 from ._compat import open_stream
-from ._compat import PY2
-from ._compat import text_type
 from .exceptions import BadParameter
 from .utils import LazyFile
 from .utils import safecall

-
-class ParamType(object):
-    """Helper for converting values through types.  The following is
-    necessary for a valid type:
-
-    *   it needs a name
-    *   it needs to pass through None unchanged
-    *   it needs to convert from a string
-    *   it needs to convert its result type through unchanged
-        (eg: needs to be idempotent)
-    *   it needs to be able to deal with param and context being `None`.
-        This can be the case when the object is used with prompt
-        inputs.
+if t.TYPE_CHECKING:
+    import typing_extensions as te
+    from .core import Context
+    from .core import Parameter
+    from .shell_completion import CompletionItem
+
+
+class ParamType:
+    """Represents the type of a parameter. Validates and converts values
+    from the command line or Python into the correct type.
+
+    To implement a custom type, subclass and implement at least the
+    following:
+
+    -   The :attr:`name` class attribute must be set.
+    -   Calling an instance of the type with ``None`` must return
+        ``None``. This is already implemented by default.
+    -   :meth:`convert` must convert string values to the correct type.
+    -   :meth:`convert` must accept values that are already the correct
+        type.
+    -   It must be able to convert a value if the ``ctx`` and ``param``
+        arguments are ``None``. This can occur when converting prompt
+        input.
     """

-    is_composite = False
+    is_composite: t.ClassVar[bool] = False
+    arity: t.ClassVar[int] = 1

     #: the descriptive name of this type
-    name = None
+    name: str

     #: if a list of this type is expected and the value is pulled from a
     #: string environment variable, this is what splits it up.  `None`
@@ -39,29 +49,73 @@
     #: whitespace splits them up.  The exception are paths and files which
     #: are split by ``os.path.pathsep`` by default (":" on Unix and ";" on
     #: Windows).
-    envvar_list_splitter = None
-
-    def __call__(self, value, param=None, ctx=None):
+    envvar_list_splitter: t.ClassVar[t.Optional[str]] = None
+
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        """Gather information that could be useful for a tool generating
+        user-facing documentation.
+
+        Use :meth:`click.Context.to_info_dict` to traverse the entire
+        CLI structure.
+
+        .. versionadded:: 8.0
+        """
+        # The class name without the "ParamType" suffix.
+        param_type = type(self).__name__.partition("ParamType")[0]
+        param_type = param_type.partition("ParameterType")[0]
+
+        # Custom subclasses might not remember to set a name.
+        if hasattr(self, "name"):
+            name = self.name
+        else:
+            name = param_type
+
+        return {"param_type": param_type, "name": name}
+
+    def __call__(
+        self,
+        value: t.Any,
+        param: t.Optional["Parameter"] = None,
+        ctx: t.Optional["Context"] = None,
+    ) -> t.Any:
         if value is not None:
             return self.convert(value, param, ctx)

-    def get_metavar(self, param):
+    def get_metavar(self, param: "Parameter") -> t.Optional[str]:
         """Returns the metavar default for this param if it provides one."""

-    def get_missing_message(self, param):
+    def get_missing_message(self, param: "Parameter") -> t.Optional[str]:
         """Optionally might return extra information about a missing
         parameter.

         .. versionadded:: 2.0
         """

-    def convert(self, value, param, ctx):
-        """Converts the value.  This is not invoked for values that are
-        `None` (the missing value).
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
+        """Convert the value to the correct type. This is not called if
+        the value is ``None`` (the missing value).
+
+        This must accept string values from the command line, as well as
+        values that are already the correct type. It may also convert
+        other compatible types.
+
+        The ``param`` and ``ctx`` arguments may be ``None`` in certain
+        situations, such as when converting prompt input.
+
+        If the value cannot be converted, call :meth:`fail` with a
+        descriptive message.
+
+        :param value: The value to convert.
+        :param param: The parameter that is using this type to convert
+            its value. May be ``None``.
+        :param ctx: The current context that arrived at this value. May
+            be ``None``.
         """
         return value

-    def split_envvar_value(self, rv):
+    def split_envvar_value(self, rv: str) -> t.Sequence[str]:
         """Given a value from an environment variable this splits it up
         into small chunks depending on the defined envvar list splitter.

@@ -71,49 +125,83 @@
         """
         return (rv or "").split(self.envvar_list_splitter)

-    def fail(self, message, param=None, ctx=None):
+    def fail(
+        self,
+        message: str,
+        param: t.Optional["Parameter"] = None,
+        ctx: t.Optional["Context"] = None,
+    ) -> "t.NoReturn":
         """Helper method to fail with an invalid value message."""
         raise BadParameter(message, ctx=ctx, param=param)

+    def shell_complete(
+        self, ctx: "Context", param: "Parameter", incomplete: str
+    ) -> t.List["CompletionItem"]:
+        """Return a list of
+        :class:`~click.shell_completion.CompletionItem` objects for the
+        incomplete value. Most types do not provide completions, but
+        some do, and this allows custom types to provide custom
+        completions as well.
+
+        :param ctx: Invocation context for this command.
+        :param param: The parameter that is requesting completion.
+        :param incomplete: Value being completed. May be empty.
+
+        .. versionadded:: 8.0
+        """
+        return []
+

 class CompositeParamType(ParamType):
     is_composite = True

     @property
-    def arity(self):
+    def arity(self) -> int:  # type: ignore
         raise NotImplementedError()


 class FuncParamType(ParamType):
-    def __init__(self, func):
+    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
         self.name = func.__name__
         self.func = func

-    def convert(self, value, param, ctx):
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict()
+        info_dict["func"] = self.func
+        return info_dict
+
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
         try:
             return self.func(value)
         except ValueError:
             try:
-                value = text_type(value)
+                value = str(value)
             except UnicodeError:
-                value = str(value).decode("utf-8", "replace")
+                value = value.decode("utf-8", "replace")
+
             self.fail(value, param, ctx)


 class UnprocessedParamType(ParamType):
     name = "text"

-    def convert(self, value, param, ctx):
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
         return value

-    def __repr__(self):
+    def __repr__(self) -> str:
         return "UNPROCESSED"


 class StringParamType(ParamType):
     name = "text"

-    def convert(self, value, param, ctx):
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
         if isinstance(value, bytes):
             enc = _get_argv_encoding()
             try:
@@ -128,9 +216,9 @@
                 else:
                     value = value.decode("utf-8", "replace")
             return value
-        return value
-
-    def __repr__(self):
+        return str(value)
+
+    def __repr__(self) -> str:
         return "STRING"


@@ -153,17 +241,32 @@

     name = "choice"

-    def __init__(self, choices, case_sensitive=True):
+    def __init__(self, choices: t.Sequence[str], case_sensitive: bool = True) -> None:
         self.choices = choices
         self.case_sensitive = case_sensitive

-    def get_metavar(self, param):
-        return "[{}]".format("|".join(self.choices))
-
-    def get_missing_message(self, param):
-        return "Choose from:\n\t{}.".format(",\n\t".join(self.choices))
-
-    def convert(self, value, param, ctx):
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict()
+        info_dict["choices"] = self.choices
+        info_dict["case_sensitive"] = self.case_sensitive
+        return info_dict
+
+    def get_metavar(self, param: "Parameter") -> str:
+        choices_str = "|".join(self.choices)
+
+        # Use curly braces to indicate a required argument.
+        if param.required and param.param_type_name == "argument":
+            return f"{{{choices_str}}}"
+
+        # Use square braces to indicate an option or optional argument.
+        return f"[{choices_str}]"
+
+    def get_missing_message(self, param: "Parameter") -> str:
+        return _("Choose from:\n\t{choices}").format(choices=",\n\t".join(self.choices))
+
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
         # Match through normalization and case sensitivity
         # first do token_normalize_func, then lowercase
         # preserve original `value` to produce an accurate message in
@@ -179,30 +282,51 @@
             }

         if not self.case_sensitive:
-            if PY2:
-                lower = str.lower
-            else:
-                lower = str.casefold
-
-            normed_value = lower(normed_value)
+            normed_value = normed_value.casefold()
             normed_choices = {
-                lower(normed_choice): original
+                normed_choice.casefold(): original
                 for normed_choice, original in normed_choices.items()
             }

         if normed_value in normed_choices:
             return normed_choices[normed_value]

+        choices_str = ", ".join(map(repr, self.choices))
         self.fail(
-            "invalid choice: {}. (choose from {})".format(
-                value, ", ".join(self.choices)
-            ),
+            ngettext(
+                "{value!r} is not {choice}.",
+                "{value!r} is not one of {choices}.",
+                len(self.choices),
+            ).format(value=value, choice=choices_str, choices=choices_str),
             param,
             ctx,
         )

-    def __repr__(self):
-        return "Choice('{}')".format(list(self.choices))
+    def __repr__(self) -> str:
+        return f"Choice({list(self.choices)})"
+
+    def shell_complete(
+        self, ctx: "Context", param: "Parameter", incomplete: str
+    ) -> t.List["CompletionItem"]:
+        """Complete choices that start with the incomplete value.
+
+        :param ctx: Invocation context for this command.
+        :param param: The parameter that is requesting completion.
+        :param incomplete: Value being completed. May be empty.
+
+        .. versionadded:: 8.0
+        """
+        from click.shell_completion import CompletionItem
+
+        str_choices = map(str, self.choices)
+
+        if self.case_sensitive:
+            matched = (c for c in str_choices if c.startswith(incomplete))
+        else:
+            incomplete = incomplete.lower()
+            matched = (c for c in str_choices if c.lower().startswith(incomplete))
+
+        return [CompletionItem(c) for c in matched]


 class DateTime(ParamType):
@@ -228,212 +352,285 @@

     name = "datetime"

-    def __init__(self, formats=None):
+    def __init__(self, formats: t.Optional[t.Sequence[str]] = None):
         self.formats = formats or ["%Y-%m-%d", "%Y-%m-%dT%H:%M:%S", "%Y-%m-%d %H:%M:%S"]

-    def get_metavar(self, param):
-        return "[{}]".format("|".join(self.formats))
-
-    def _try_to_convert_date(self, value, format):
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict()
+        info_dict["formats"] = self.formats
+        return info_dict
+
+    def get_metavar(self, param: "Parameter") -> str:
+        return f"[{'|'.join(self.formats)}]"
+
+    def _try_to_convert_date(self, value: t.Any, format: str) -> t.Optional[datetime]:
         try:
             return datetime.strptime(value, format)
         except ValueError:
             return None

-    def convert(self, value, param, ctx):
-        # Exact match
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
+        if isinstance(value, datetime):
+            return value
+
         for format in self.formats:
-            dtime = self._try_to_convert_date(value, format)
-            if dtime:
-                return dtime
-
+            converted = self._try_to_convert_date(value, format)
+
+            if converted is not None:
+                return converted
+
+        formats_str = ", ".join(map(repr, self.formats))
         self.fail(
-            "invalid datetime format: {}. (choose from {})".format(
-                value, ", ".join(self.formats)
+            ngettext(
+                "{value!r} does not match the format {format}.",
+                "{value!r} does not match the formats {formats}.",
+                len(self.formats),
+            ).format(value=value, format=formats_str, formats=formats_str),
+            param,
+            ctx,
+        )
+
+    def __repr__(self) -> str:
+        return "DateTime"
+
+
+class _NumberParamTypeBase(ParamType):
+    _number_class: t.ClassVar[t.Type]
+
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
+        try:
+            return self._number_class(value)
+        except ValueError:
+            self.fail(
+                _("{value!r} is not a valid {number_type}.").format(
+                    value=value, number_type=self.name
+                ),
+                param,
+                ctx,
             )
-        )
-
-    def __repr__(self):
-        return "DateTime"
-
-
-class IntParamType(ParamType):
-    name = "integer"
-
-    def convert(self, value, param, ctx):
-        try:
-            return int(value)
-        except ValueError:
-            self.fail("{} is not a valid integer".format(value), param, ctx)
-
-    def __repr__(self):
-        return "INT"
-
-
-class IntRange(IntParamType):
-    """A parameter that works similar to :data:`click.INT` but restricts
-    the value to fit into a range.  The default behavior is to fail if the
-    value falls outside the range, but it can also be silently clamped
-    between the two edges.
-
-    See :ref:`ranges` for an example.
-    """
-
-    name = "integer range"
-
-    def __init__(self, min=None, max=None, clamp=False):
+
+
+class _NumberRangeBase(_NumberParamTypeBase):
+    def __init__(
+        self,
+        min: t.Optional[float] = None,
+        max: t.Optional[float] = None,
+        min_open: bool = False,
+        max_open: bool = False,
+        clamp: bool = False,
+    ) -> None:
         self.min = min
         self.max = max
+        self.min_open = min_open
+        self.max_open = max_open
         self.clamp = clamp

-    def convert(self, value, param, ctx):
-        rv = IntParamType.convert(self, value, param, ctx)
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict()
+        info_dict.update(
+            min=self.min,
+            max=self.max,
+            min_open=self.min_open,
+            max_open=self.max_open,
+            clamp=self.clamp,
+        )
+        return info_dict
+
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
+        import operator
+
+        rv = super().convert(value, param, ctx)
+        lt_min: bool = self.min is not None and (
+            operator.le if self.min_open else operator.lt
+        )(rv, self.min)
+        gt_max: bool = self.max is not None and (
+            operator.ge if self.max_open else operator.gt
+        )(rv, self.max)
+
         if self.clamp:
-            if self.min is not None and rv < self.min:
-                return self.min
-            if self.max is not None and rv > self.max:
-                return self.max
-        if (
-            self.min is not None
-            and rv < self.min
-            or self.max is not None
-            and rv > self.max
-        ):
-            if self.min is None:
-                self.fail(
-                    "{} is bigger than the maximum valid value {}.".format(
-                        rv, self.max
-                    ),
-                    param,
-                    ctx,
-                )
-            elif self.max is None:
-                self.fail(
-                    "{} is smaller than the minimum valid value {}.".format(
-                        rv, self.min
-                    ),
-                    param,
-                    ctx,
-                )
-            else:
-                self.fail(
-                    "{} is not in the valid range of {} to {}.".format(
-                        rv, self.min, self.max
-                    ),
-                    param,
-                    ctx,
-                )
+            if lt_min:
+                return self._clamp(self.min, 1, self.min_open)  # type: ignore
+
+            if gt_max:
+                return self._clamp(self.max, -1, self.max_open)  # type: ignore
+
+        if lt_min or gt_max:
+            self.fail(
+                _("{value} is not in the range {range}.").format(
+                    value=rv, range=self._describe_range()
+                ),
+                param,
+                ctx,
+            )
+
         return rv

-    def __repr__(self):
-        return "IntRange({}, {})".format(self.min, self.max)
-
-
-class FloatParamType(ParamType):
+    def _clamp(self, bound: float, dir: "te.Literal[1, -1]", open: bool) -> float:
+        """Find the valid value to clamp to bound in the given
+        direction.
+
+        :param bound: The boundary value.
+        :param dir: 1 or -1 indicating the direction to move.
+        :param open: If true, the range does not include the bound.
+        """
+        raise NotImplementedError
+
+    def _describe_range(self) -> str:
+        """Describe the range for use in help text."""
+        if self.min is None:
+            op = "<" if self.max_open else "<="
+            return f"x{op}{self.max}"
+
+        if self.max is None:
+            op = ">" if self.min_open else ">="
+            return f"x{op}{self.min}"
+
+        lop = "<" if self.min_open else "<="
+        rop = "<" if self.max_open else "<="
+        return f"{self.min}{lop}x{rop}{self.max}"
+
+    def __repr__(self) -> str:
+        clamp = " clamped" if self.clamp else ""
+        return f"<{type(self).__name__} {self._describe_range()}{clamp}>"
+
+
+class IntParamType(_NumberParamTypeBase):
+    name = "integer"
+    _number_class = int
+
+    def __repr__(self) -> str:
+        return "INT"
+
+
+class IntRange(_NumberRangeBase, IntParamType):
+    """Restrict an :data:`click.INT` value to a range of accepted
+    values. See :ref:`ranges`.
+
+    If ``min`` or ``max`` are not passed, any value is accepted in that
+    direction. If ``min_open`` or ``max_open`` are enabled, the
+    corresponding boundary is not included in the range.
+
+    If ``clamp`` is enabled, a value outside the range is clamped to the
+    boundary instead of failing.
+
+    .. versionchanged:: 8.0
+        Added the ``min_open`` and ``max_open`` parameters.
+    """
+
+    name = "integer range"
+
+    def _clamp(  # type: ignore
+        self, bound: int, dir: "te.Literal[1, -1]", open: bool
+    ) -> int:
+        if not open:
+            return bound
+
+        return bound + dir
+
+
+class FloatParamType(_NumberParamTypeBase):
     name = "float"
-
-    def convert(self, value, param, ctx):
+    _number_class = float
+
+    def __repr__(self) -> str:
+        return "FLOAT"
+
+
+class FloatRange(_NumberRangeBase, FloatParamType):
+    """Restrict a :data:`click.FLOAT` value to a range of accepted
+    values. See :ref:`ranges`.
+
+    If ``min`` or ``max`` are not passed, any value is accepted in that
+    direction. If ``min_open`` or ``max_open`` are enabled, the
+    corresponding boundary is not included in the range.
+
+    If ``clamp`` is enabled, a value outside the range is clamped to the
+    boundary instead of failing. This is not supported if either
+    boundary is marked ``open``.
+
+    .. versionchanged:: 8.0
+        Added the ``min_open`` and ``max_open`` parameters.
+    """
+
+    name = "float range"
+
+    def __init__(
+        self,
+        min: t.Optional[float] = None,
+        max: t.Optional[float] = None,
+        min_open: bool = False,
+        max_open: bool = False,
+        clamp: bool = False,
+    ) -> None:
+        super().__init__(
+            min=min, max=max, min_open=min_open, max_open=max_open, clamp=clamp
+        )
+
+        if (min_open or max_open) and clamp:
+            raise TypeError("Clamping is not supported for open bounds.")
+
+    def _clamp(self, bound: float, dir: "te.Literal[1, -1]", open: bool) -> float:
+        if not open:
+            return bound
+
+        # Could use Python 3.9's math.nextafter here, but clamping an
+        # open float range doesn't seem to be particularly useful. It's
+        # left up to the user to write a callback to do it if needed.
+        raise RuntimeError("Clamping is not supported for open bounds.")
+
+
+class BoolParamType(ParamType):
+    name = "boolean"
+
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
+        if value in {False, True}:
+            return bool(value)
+
+        norm = value.strip().lower()
+
+        if norm in {"1", "true", "t", "yes", "y", "on"}:
+            return True
+
+        if norm in {"0", "false", "f", "no", "n", "off"}:
+            return False
+
+        self.fail(
+            _("{value!r} is not a valid boolean.").format(value=value), param, ctx
+        )
+
+    def __repr__(self) -> str:
+        return "BOOL"
+
+
+class UUIDParameterType(ParamType):
+    name = "uuid"
+
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
+        import uuid
+
+        if isinstance(value, uuid.UUID):
+            return value
+
+        value = value.strip()
+
         try:
-            return float(value)
+            return uuid.UUID(value)
         except ValueError:
             self.fail(
-                "{} is not a valid floating point value".format(value), param, ctx
+                _("{value!r} is not a valid UUID.").format(value=value), param, ctx
             )

-    def __repr__(self):
-        return "FLOAT"
-
-
-class FloatRange(FloatParamType):
-    """A parameter that works similar to :data:`click.FLOAT` but restricts
-    the value to fit into a range.  The default behavior is to fail if the
-    value falls outside the range, but it can also be silently clamped
-    between the two edges.
-
-    See :ref:`ranges` for an example.
-    """
-
-    name = "float range"
-
-    def __init__(self, min=None, max=None, clamp=False):
-        self.min = min
-        self.max = max
-        self.clamp = clamp
-
-    def convert(self, value, param, ctx):
-        rv = FloatParamType.convert(self, value, param, ctx)
-        if self.clamp:
-            if self.min is not None and rv < self.min:
-                return self.min
-            if self.max is not None and rv > self.max:
-                return self.max
-        if (
-            self.min is not None
-            and rv < self.min
-            or self.max is not None
-            and rv > self.max
-        ):
-            if self.min is None:
-                self.fail(
-                    "{} is bigger than the maximum valid value {}.".format(
-                        rv, self.max
-                    ),
-                    param,
-                    ctx,
-                )
-            elif self.max is None:
-                self.fail(
-                    "{} is smaller than the minimum valid value {}.".format(
-                        rv, self.min
-                    ),
-                    param,
-                    ctx,
-                )
-            else:
-                self.fail(
-                    "{} is not in the valid range of {} to {}.".format(
-                        rv, self.min, self.max
-                    ),
-                    param,
-                    ctx,
-                )
-        return rv
-
-    def __repr__(self):
-        return "FloatRange({}, {})".format(self.min, self.max)
-
-
-class BoolParamType(ParamType):
-    name = "boolean"
-
-    def convert(self, value, param, ctx):
-        if isinstance(value, bool):
-            return bool(value)
-        value = value.lower()
-        if value in ("true", "t", "1", "yes", "y"):
-            return True
-        elif value in ("false", "f", "0", "no", "n"):
-            return False
-        self.fail("{} is not a valid boolean".format(value), param, ctx)
-
-    def __repr__(self):
-        return "BOOL"
-
-
-class UUIDParameterType(ParamType):
-    name = "uuid"
-
-    def convert(self, value, param, ctx):
-        import uuid
-
-        try:
-            if PY2 and isinstance(value, text_type):
-                value = value.encode("ascii")
-            return uuid.UUID(value)
-        except ValueError:
-            self.fail("{} is not a valid UUID value".format(value), param, ctx)
-
-    def __repr__(self):
+    def __repr__(self) -> str:
         return "UUID"


@@ -468,15 +665,25 @@
     envvar_list_splitter = os.path.pathsep

     def __init__(
-        self, mode="r", encoding=None, errors="strict", lazy=None, atomic=False
-    ):
+        self,
+        mode: str = "r",
+        encoding: t.Optional[str] = None,
+        errors: t.Optional[str] = "strict",
+        lazy: t.Optional[bool] = None,
+        atomic: bool = False,
+    ) -> None:
         self.mode = mode
         self.encoding = encoding
         self.errors = errors
         self.lazy = lazy
         self.atomic = atomic

-    def resolve_lazy_flag(self, value):
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict()
+        info_dict.update(mode=self.mode, encoding=self.encoding)
+        return info_dict
+
+    def resolve_lazy_flag(self, value: t.Any) -> bool:
         if self.lazy is not None:
             return self.lazy
         if value == "-":
@@ -485,7 +692,9 @@
             return True
         return False

-    def convert(self, value, param, ctx):
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
         try:
             if hasattr(value, "read") or hasattr(value, "write"):
                 return value
@@ -493,16 +702,22 @@
             lazy = self.resolve_lazy_flag(value)

             if lazy:
-                f = LazyFile(
-                    value, self.mode, self.encoding, self.errors, atomic=self.atomic
+                f: t.IO = t.cast(
+                    t.IO,
+                    LazyFile(
+                        value, self.mode, self.encoding, self.errors, atomic=self.atomic
+                    ),
                 )
+
                 if ctx is not None:
-                    ctx.call_on_close(f.close_intelligently)
+                    ctx.call_on_close(f.close_intelligently)  # type: ignore
+
                 return f

             f, should_close = open_stream(
                 value, self.mode, self.encoding, self.errors, atomic=self.atomic
             )
+
             # If a context is provided, we automatically close the file
             # at the end of the context execution (or flush out).  If a
             # context does not exist, it's the caller's responsibility to
@@ -513,96 +728,129 @@
                     ctx.call_on_close(safecall(f.close))
                 else:
                     ctx.call_on_close(safecall(f.flush))
+
             return f
-        except (IOError, OSError) as e:  # noqa: B014
-            self.fail(
-                "Could not open file: {}: {}".format(
-                    filename_to_ui(value), get_streerror(e)
-                ),
-                param,
-                ctx,
-            )
+        except OSError as e:  # noqa: B014
+            self.fail(f"'{os.fsdecode(value)}': {e.strerror}", param, ctx)
+
+    def shell_complete(
+        self, ctx: "Context", param: "Parameter", incomplete: str
+    ) -> t.List["CompletionItem"]:
+        """Return a special completion marker that tells the completion
+        system to use the shell to provide file path completions.
+
+        :param ctx: Invocation context for this command.
+        :param param: The parameter that is requesting completion.
+        :param incomplete: Value being completed. May be empty.
+
+        .. versionadded:: 8.0
+        """
+        from click.shell_completion import CompletionItem
+
+        return [CompletionItem(incomplete, type="file")]


 class Path(ParamType):
-    """The path type is similar to the :class:`File` type but it performs
-    different checks.  First of all, instead of returning an open file
-    handle it returns just the filename.  Secondly, it can perform various
-    basic checks about what the file or directory should be.
+    """The ``Path`` type is similar to the :class:`File` type, but
+    returns the filename instead of an open file. Various checks can be
+    enabled to validate the type of file and permissions.
+
+    :param exists: The file or directory needs to exist for the value to
+        be valid. If this is not set to ``True``, and the file does not
+        exist, then all further checks are silently skipped.
+    :param file_okay: Allow a file as a value.
+    :param dir_okay: Allow a directory as a value.
+    :param readable: if true, a readable check is performed.
+    :param writable: if true, a writable check is performed.
+    :param executable: if true, an executable check is performed.
+    :param resolve_path: Make the value absolute and resolve any
+        symlinks. A ``~`` is not expanded, as this is supposed to be
+        done by the shell only.
+    :param allow_dash: Allow a single dash as a value, which indicates
+        a standard stream (but does not open it). Use
+        :func:`~click.open_file` to handle opening this value.
+    :param path_type: Convert the incoming path value to this type. If
+        ``None``, keep Python's default, which is ``str``. Useful to
+        convert to :class:`pathlib.Path`.
+
+    .. versionchanged:: 8.1
+        Added the ``executable`` parameter.
+
+    .. versionchanged:: 8.0
+        Allow passing ``type=pathlib.Path``.

     .. versionchanged:: 6.0
-       `allow_dash` was added.
-
-    :param exists: if set to true, the file or directory needs to exist for
-                   this value to be valid.  If this is not required and a
-                   file does indeed not exist, then all further checks are
-                   silently skipped.
-    :param file_okay: controls if a file is a possible value.
-    :param dir_okay: controls if a directory is a possible value.
-    :param writable: if true, a writable check is performed.
-    :param readable: if true, a readable check is performed.
-    :param resolve_path: if this is true, then the path is fully resolved
-                         before the value is passed onwards.  This means
-                         that it's absolute and symlinks are resolved.  It
-                         will not expand a tilde-prefix, as this is
-                         supposed to be done by the shell only.
-    :param allow_dash: If this is set to `True`, a single dash to indicate
-                       standard streams is permitted.
-    :param path_type: optionally a string type that should be used to
-                      represent the path.  The default is `None` which
-                      means the return value will be either bytes or
-                      unicode depending on what makes most sense given the
-                      input data Click deals with.
+        Added the ``allow_dash`` parameter.
     """

     envvar_list_splitter = os.path.pathsep

     def __init__(
         self,
-        exists=False,
-        file_okay=True,
-        dir_okay=True,
-        writable=False,
-        readable=True,
-        resolve_path=False,
-        allow_dash=False,
-        path_type=None,
+        exists: bool = False,
+        file_okay: bool = True,
+        dir_okay: bool = True,
+        readable: bool = True,
+        writable: bool = False,
+        executable: bool = False,
+        resolve_path: bool = False,
+        allow_dash: bool = False,
+        path_type: t.Optional[t.Type] = None,
     ):
         self.exists = exists
         self.file_okay = file_okay
         self.dir_okay = dir_okay
+        self.readable = readable
         self.writable = writable
-        self.readable = readable
+        self.executable = executable
         self.resolve_path = resolve_path
         self.allow_dash = allow_dash
         self.type = path_type

         if self.file_okay and not self.dir_okay:
-            self.name = "file"
-            self.path_type = "File"
+            self.name = _("file")
         elif self.dir_okay and not self.file_okay:
-            self.name = "directory"
-            self.path_type = "Directory"
+            self.name = _("directory")
         else:
-            self.name = "path"
-            self.path_type = "Path"
-
-    def coerce_path_result(self, rv):
+            self.name = _("path")
+
+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict()
+        info_dict.update(
+            exists=self.exists,
+            file_okay=self.file_okay,
+            dir_okay=self.dir_okay,
+            writable=self.writable,
+            readable=self.readable,
+            allow_dash=self.allow_dash,
+        )
+        return info_dict
+
+    def coerce_path_result(self, rv: t.Any) -> t.Any:
         if self.type is not None and not isinstance(rv, self.type):
-            if self.type is text_type:
-                rv = rv.decode(get_filesystem_encoding())
+            if self.type is str:
+                rv = os.fsdecode(rv)
+            elif self.type is bytes:
+                rv = os.fsencode(rv)
             else:
-                rv = rv.encode(get_filesystem_encoding())
+                rv = self.type(rv)
+
         return rv

-    def convert(self, value, param, ctx):
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
         rv = value

         is_dash = self.file_okay and self.allow_dash and rv in (b"-", "-")

         if not is_dash:
             if self.resolve_path:
-                rv = os.path.realpath(rv)
+                # os.path.realpath doesn't resolve symlinks on Windows
+                # until Python 3.8. Use pathlib for now.
+                import pathlib
+
+                rv = os.fsdecode(pathlib.Path(rv).resolve())

             try:
                 st = os.stat(rv)
@@ -610,8 +858,8 @@
                 if not self.exists:
                     return self.coerce_path_result(rv)
                 self.fail(
-                    "{} '{}' does not exist.".format(
-                        self.path_type, filename_to_ui(value)
+                    _("{name} {filename!r} does not exist.").format(
+                        name=self.name.title(), filename=os.fsdecode(value)
                     ),
                     param,
                     ctx,
@@ -619,36 +867,67 @@

             if not self.file_okay and stat.S_ISREG(st.st_mode):
                 self.fail(
-                    "{} '{}' is a file.".format(self.path_type, filename_to_ui(value)),
+                    _("{name} {filename!r} is a file.").format(
+                        name=self.name.title(), filename=os.fsdecode(value)
+                    ),
                     param,
                     ctx,
                 )
             if not self.dir_okay and stat.S_ISDIR(st.st_mode):
                 self.fail(
-                    "{} '{}' is a directory.".format(
-                        self.path_type, filename_to_ui(value)
+                    _("{name} '{filename}' is a directory.").format(
+                        name=self.name.title(), filename=os.fsdecode(value)
                     ),
                     param,
                     ctx,
                 )
-            if self.writable and not os.access(value, os.W_OK):
+
+            if self.readable and not os.access(rv, os.R_OK):
                 self.fail(
-                    "{} '{}' is not writable.".format(
-                        self.path_type, filename_to_ui(value)
+                    _("{name} {filename!r} is not executable.").format(
+                        name=self.name.title(), filename=os.fsdecode(value)
                     ),
                     param,
                     ctx,
                 )
-            if self.readable and not os.access(value, os.R_OK):
+
+            if self.writable and not os.access(rv, os.W_OK):
                 self.fail(
-                    "{} '{}' is not readable.".format(
-                        self.path_type, filename_to_ui(value)
+                    _("{name} {filename!r} is not writable.").format(
+                        name=self.name.title(), filename=os.fsdecode(value)
                     ),
                     param,
                     ctx,
                 )

+            if self.executable and not os.access(value, os.X_OK):
+                self.fail(
+                    _("{name} {filename!r} is not executable.").format(
+                        name=self.name.title(), filename=os.fsdecode(value)
+                    ),
+                    param,
+                    ctx,
+                )
+
         return self.coerce_path_result(rv)
+
+    def shell_complete(
+        self, ctx: "Context", param: "Parameter", incomplete: str
+    ) -> t.List["CompletionItem"]:
+        """Return a special completion marker that tells the completion
+        system to use the shell to provide path completions for only
+        directories or any paths.
+
+        :param ctx: Invocation context for this command.
+        :param param: The parameter that is requesting completion.
+        :param incomplete: Value being completed. May be empty.
+
+        .. versionadded:: 8.0
+        """
+        from click.shell_completion import CompletionItem
+
+        type = "dir" if self.dir_okay and not self.file_okay else "file"
+        return [CompletionItem(incomplete, type=type)]


 class Tuple(CompositeParamType):
@@ -665,75 +944,107 @@
     :param types: a list of types that should be used for the tuple items.
     """

-    def __init__(self, types):
+    def __init__(self, types: t.Sequence[t.Union[t.Type, ParamType]]) -> None:
         self.types = [convert_type(ty) for ty in types]

+    def to_info_dict(self) -> t.Dict[str, t.Any]:
+        info_dict = super().to_info_dict()
+        info_dict["types"] = [t.to_info_dict() for t in self.types]
+        return info_dict
+
     @property
-    def name(self):
-        return "<{}>".format(" ".join(ty.name for ty in self.types))
+    def name(self) -> str:  # type: ignore
+        return f"<{' '.join(ty.name for ty in self.types)}>"

     @property
-    def arity(self):
+    def arity(self) -> int:  # type: ignore
         return len(self.types)

-    def convert(self, value, param, ctx):
-        if len(value) != len(self.types):
-            raise TypeError(
-                "It would appear that nargs is set to conflict with the"
-                " composite type arity."
+    def convert(
+        self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
+    ) -> t.Any:
+        len_type = len(self.types)
+        len_value = len(value)
+
+        if len_value != len_type:
+            self.fail(
+                ngettext(
+                    "{len_type} values are required, but {len_value} was given.",
+                    "{len_type} values are required, but {len_value} were given.",
+                    len_value,
+                ).format(len_type=len_type, len_value=len_value),
+                param=param,
+                ctx=ctx,
             )
+
         return tuple(ty(x, param, ctx) for ty, x in zip(self.types, value))


-def convert_type(ty, default=None):
-    """Converts a callable or python type into the most appropriate
-    param type.
+def convert_type(ty: t.Optional[t.Any], default: t.Optional[t.Any] = None) -> ParamType:
+    """Find the most appropriate :class:`ParamType` for the given Python
+    type. If the type isn't provided, it can be inferred from a default
+    value.
     """
     guessed_type = False
+
     if ty is None and default is not None:
-        if isinstance(default, tuple):
-            ty = tuple(map(type, default))
+        if isinstance(default, (tuple, list)):
+            # If the default is empty, ty will remain None and will
+            # return STRING.
+            if default:
+                item = default[0]
+
+                # A tuple of tuples needs to detect the inner types.
+                # Can't call convert recursively because that would
+                # incorrectly unwind the tuple to a single type.
+                if isinstance(item, (tuple, list)):
+                    ty = tuple(map(type, item))
+                else:
+                    ty = type(item)
         else:
             ty = type(default)
+
         guessed_type = True

     if isinstance(ty, tuple):
         return Tuple(ty)
+
     if isinstance(ty, ParamType):
         return ty
-    if ty is text_type or ty is str or ty is None:
+
+    if ty is str or ty is None:
         return STRING
+
     if ty is int:
         return INT
-    # Booleans are only okay if not guessed.  This is done because for
-    # flags the default value is actually a bit of a lie in that it
-    # indicates which of the flags is the one we want.  See get_default()
-    # for more information.
-    if ty is bool and not guessed_type:
-        return BOOL
+
     if ty is float:
         return FLOAT
+
+    if ty is bool:
+        return BOOL
+
     if guessed_type:
         return STRING

-    # Catch a common mistake
     if __debug__:
         try:
             if issubclass(ty, ParamType):
                 raise AssertionError(
-                    "Attempted to use an uninstantiated parameter type ({}).".format(ty)
+                    f"Attempted to use an uninstantiated parameter type ({ty})."
                 )
         except TypeError:
+            # ty is an instance (correct), so issubclass fails.
             pass
+
     return FuncParamType(ty)


 #: A dummy parameter type that just does nothing.  From a user's
-#: perspective this appears to just be the same as `STRING` but internally
-#: no string conversion takes place.  This is necessary to achieve the
-#: same bytes/unicode behavior on Python 2/3 in situations where you want
-#: to not convert argument types.  This is usually useful when working
-#: with file paths as they can appear in bytes and unicode.
+#: perspective this appears to just be the same as `STRING` but
+#: internally no string conversion takes place if the input was bytes.
+#: This is usually useful when working with file paths as they can
+#: appear in bytes and unicode.
 #:
 #: For path related uses the :class:`Path` type is a better choice but
 #: there are situations where an unprocessed type is useful which is why
('src/click', 'formatting.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,30 +1,38 @@
+import typing as t
 from contextlib import contextmanager
+from gettext import gettext as _

 from ._compat import term_len
 from .parser import split_opt
-from .termui import get_terminal_size

 # Can force a width.  This is used by the test system
-FORCED_WIDTH = None
-
-
-def measure_table(rows):
-    widths = {}
+FORCED_WIDTH: t.Optional[int] = None
+
+
+def measure_table(rows: t.Iterable[t.Tuple[str, str]]) -> t.Tuple[int, ...]:
+    widths: t.Dict[int, int] = {}
+
     for row in rows:
         for idx, col in enumerate(row):
             widths[idx] = max(widths.get(idx, 0), term_len(col))
+
     return tuple(y for x, y in sorted(widths.items()))


-def iter_rows(rows, col_count):
+def iter_rows(
+    rows: t.Iterable[t.Tuple[str, str]], col_count: int
+) -> t.Iterator[t.Tuple[str, ...]]:
     for row in rows:
-        row = tuple(row)
         yield row + ("",) * (col_count - len(row))


 def wrap_text(
-    text, width=78, initial_indent="", subsequent_indent="", preserve_paragraphs=False
-):
+    text: str,
+    width: int = 78,
+    initial_indent: str = "",
+    subsequent_indent: str = "",
+    preserve_paragraphs: bool = False,
+) -> str:
     """A helper function that intelligently wraps text.  By default, it
     assumes that it operates on a single paragraph of text but if the
     `preserve_paragraphs` parameter is provided it will intelligently
@@ -55,11 +63,11 @@
     if not preserve_paragraphs:
         return wrapper.fill(text)

-    p = []
-    buf = []
+    p: t.List[t.Tuple[int, bool, str]] = []
+    buf: t.List[str] = []
     indent = None

-    def _flush_par():
+    def _flush_par() -> None:
         if not buf:
             return
         if buf[0].strip() == "\b":
@@ -91,7 +99,7 @@
     return "\n\n".join(rv)


-class HelpFormatter(object):
+class HelpFormatter:
     """This class helps with formatting text-based help pages.  It's
     usually just needed for very special internal cases, but it's also
     exposed so that developers can write their own fancy outputs.
@@ -103,38 +111,51 @@
                   width clamped to a maximum of 78.
     """

-    def __init__(self, indent_increment=2, width=None, max_width=None):
+    def __init__(
+        self,
+        indent_increment: int = 2,
+        width: t.Optional[int] = None,
+        max_width: t.Optional[int] = None,
+    ) -> None:
+        import shutil
+
         self.indent_increment = indent_increment
         if max_width is None:
             max_width = 80
         if width is None:
             width = FORCED_WIDTH
             if width is None:
-                width = max(min(get_terminal_size()[0], max_width) - 2, 50)
+                width = max(min(shutil.get_terminal_size().columns, max_width) - 2, 50)
         self.width = width
         self.current_indent = 0
-        self.buffer = []
-
-    def write(self, string):
+        self.buffer: t.List[str] = []
+
+    def write(self, string: str) -> None:
         """Writes a unicode string into the internal buffer."""
         self.buffer.append(string)

-    def indent(self):
+    def indent(self) -> None:
         """Increases the indentation."""
         self.current_indent += self.indent_increment

-    def dedent(self):
+    def dedent(self) -> None:
         """Decreases the indentation."""
         self.current_indent -= self.indent_increment

-    def write_usage(self, prog, args="", prefix="Usage: "):
+    def write_usage(
+        self, prog: str, args: str = "", prefix: t.Optional[str] = None
+    ) -> None:
         """Writes a usage line into the buffer.

         :param prog: the program name.
         :param args: whitespace separated list of arguments.
-        :param prefix: the prefix for the first line.
+        :param prefix: The prefix for the first line. Defaults to
+            ``"Usage: "``.
         """
-        usage_prefix = "{:>{w}}{} ".format(prefix, prog, w=self.current_indent)
+        if prefix is None:
+            prefix = f"{_('Usage:')} "
+
+        usage_prefix = f"{prefix:>{self.current_indent}}{prog} "
         text_width = self.width - self.current_indent

         if text_width >= (term_len(usage_prefix) + 20):
@@ -161,25 +182,24 @@

         self.write("\n")

-    def write_heading(self, heading):
+    def write_heading(self, heading: str) -> None:
         """Writes a heading into the buffer."""
-        self.write("{:>{w}}{}:\n".format("", heading, w=self.current_indent))
-
-    def write_paragraph(self):
+        self.write(f"{'':>{self.current_indent}}{heading}:\n")
+
+    def write_paragraph(self) -> None:
         """Writes a paragraph into the buffer."""
         if self.buffer:
             self.write("\n")

-    def write_text(self, text):
+    def write_text(self, text: str) -> None:
         """Writes re-indented text into the buffer.  This rewraps and
         preserves paragraphs.
         """
-        text_width = max(self.width - self.current_indent, 11)
         indent = " " * self.current_indent
         self.write(
             wrap_text(
                 text,
-                text_width,
+                self.width,
                 initial_indent=indent,
                 subsequent_indent=indent,
                 preserve_paragraphs=True,
@@ -187,7 +207,12 @@
         )
         self.write("\n")

-    def write_dl(self, rows, col_max=30, col_spacing=2):
+    def write_dl(
+        self,
+        rows: t.Sequence[t.Tuple[str, str]],
+        col_max: int = 30,
+        col_spacing: int = 2,
+    ) -> None:
         """Writes a definition list into the buffer.  This is how options
         and commands are usually formatted.

@@ -204,7 +229,7 @@
         first_col = min(widths[0], col_max) + col_spacing

         for first, second in iter_rows(rows, len(widths)):
-            self.write("{:>{w}}{}".format("", first, w=self.current_indent))
+            self.write(f"{'':>{self.current_indent}}{first}")
             if not second:
                 self.write("\n")
                 continue
@@ -219,23 +244,15 @@
             lines = wrapped_text.splitlines()

             if lines:
-                self.write("{}\n".format(lines[0]))
+                self.write(f"{lines[0]}\n")

                 for line in lines[1:]:
-                    self.write(
-                        "{:>{w}}{}\n".format(
-                            "", line, w=first_col + self.current_indent
-                        )
-                    )
-
-                if len(lines) > 1:
-                    # separate long help from next option
-                    self.write("\n")
+                    self.write(f"{'':>{first_col + self.current_indent}}{line}\n")
             else:
                 self.write("\n")

     @contextmanager
-    def section(self, name):
+    def section(self, name: str) -> t.Iterator[None]:
         """Helpful context manager that writes a paragraph, a heading,
         and the indents.

@@ -250,7 +267,7 @@
             self.dedent()

     @contextmanager
-    def indentation(self):
+    def indentation(self) -> t.Iterator[None]:
         """A context manager that increases the indentation."""
         self.indent()
         try:
@@ -258,12 +275,12 @@
         finally:
             self.dedent()

-    def getvalue(self):
+    def getvalue(self) -> str:
         """Returns the buffer contents."""
         return "".join(self.buffer)


-def join_options(options):
+def join_options(options: t.Sequence[str]) -> t.Tuple[str, bool]:
     """Given a list of option strings this joins them in the most appropriate
     way and returns them in the form ``(formatted_string,
     any_prefix_is_slash)`` where the second item in the tuple is a flag that
@@ -271,13 +288,14 @@
     """
     rv = []
     any_prefix_is_slash = False
+
     for opt in options:
         prefix = split_opt(opt)[0]
+
         if prefix == "/":
             any_prefix_is_slash = True
+
         rv.append((len(prefix), opt))

     rv.sort(key=lambda x: x[0])
-
-    rv = ", ".join(x[1] for x in rv)
-    return rv, any_prefix_is_slash
+    return ", ".join(x[1] for x in rv), any_prefix_is_slash
('src/click', 'parser.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 """
 This module started out as largely a copy paste from the stdlib's
 optparse module with the features removed that we do not need from
@@ -18,16 +17,38 @@
 Copyright 2001-2006 Gregory P. Ward. All rights reserved.
 Copyright 2002-2006 Python Software Foundation. All rights reserved.
 """
-import re
+# This code uses parts of optparse written by Gregory P. Ward and
+# maintained by the Python Software Foundation.
+# Copyright 2001-2006 Gregory P. Ward
+# Copyright 2002-2006 Python Software Foundation
+import typing as t
 from collections import deque
+from gettext import gettext as _
+from gettext import ngettext

 from .exceptions import BadArgumentUsage
 from .exceptions import BadOptionUsage
 from .exceptions import NoSuchOption
 from .exceptions import UsageError

-
-def _unpack_args(args, nargs_spec):
+if t.TYPE_CHECKING:
+    import typing_extensions as te
+    from .core import Argument as CoreArgument
+    from .core import Context
+    from .core import Option as CoreOption
+    from .core import Parameter as CoreParameter
+
+V = t.TypeVar("V")
+
+# Sentinel value that indicates an option was passed as a flag without a
+# value but is not a flag option. Option.consume_value uses this to
+# prompt or use the flag_value.
+_flag_needs_value = object()
+
+
+def _unpack_args(
+    args: t.Sequence[str], nargs_spec: t.Sequence[int]
+) -> t.Tuple[t.Sequence[t.Union[str, t.Sequence[t.Optional[str]], None]], t.List[str]]:
     """Given an iterable of arguments and an iterable of nargs specifications,
     it returns a tuple with all the unpacked arguments at the first index
     and all remaining arguments as the second.
@@ -39,10 +60,10 @@
     """
     args = deque(args)
     nargs_spec = deque(nargs_spec)
-    rv = []
-    spos = None
-
-    def _fetch(c):
+    rv: t.List[t.Union[str, t.Tuple[t.Optional[str], ...], None]] = []
+    spos: t.Optional[int] = None
+
+    def _fetch(c: "te.Deque[V]") -> t.Optional[V]:
         try:
             if spos is None:
                 return c.popleft()
@@ -53,18 +74,25 @@

     while nargs_spec:
         nargs = _fetch(nargs_spec)
+
+        if nargs is None:
+            continue
+
         if nargs == 1:
             rv.append(_fetch(args))
         elif nargs > 1:
             x = [_fetch(args) for _ in range(nargs)]
+
             # If we're reversed, we're pulling in the arguments in reverse,
             # so we need to turn them around.
             if spos is not None:
                 x.reverse()
+
             rv.append(tuple(x))
         elif nargs < 0:
             if spos is not None:
                 raise TypeError("Cannot have two nargs < 0")
+
             spos = len(rv)
             rv.append(None)

@@ -78,13 +106,7 @@
     return tuple(rv), list(args)


-def _error_opt_args(nargs, opt):
-    if nargs == 1:
-        raise BadOptionUsage(opt, "{} option requires an argument".format(opt))
-    raise BadOptionUsage(opt, "{} option requires {} arguments".format(opt, nargs))
-
-
-def split_opt(opt):
+def split_opt(opt: str) -> t.Tuple[str, str]:
     first = opt[:1]
     if first.isalnum():
         return "", opt
@@ -93,34 +115,57 @@
     return first, opt[1:]


-def normalize_opt(opt, ctx):
+def normalize_opt(opt: str, ctx: t.Optional["Context"]) -> str:
     if ctx is None or ctx.token_normalize_func is None:
         return opt
     prefix, opt = split_opt(opt)
-    return prefix + ctx.token_normalize_func(opt)
-
-
-def split_arg_string(string):
-    """Given an argument string this attempts to split it into small parts."""
-    rv = []
-    for match in re.finditer(
-        r"('([^'\\]*(?:\\.[^'\\]*)*)'|\"([^\"\\]*(?:\\.[^\"\\]*)*)\"|\S+)\s*",
-        string,
-        re.S,
+    return f"{prefix}{ctx.token_normalize_func(opt)}"
+
+
+def split_arg_string(string: str) -> t.List[str]:
+    """Split an argument string as with :func:`shlex.split`, but don't
+    fail if the string is incomplete. Ignores a missing closing quote or
+    incomplete escape sequence and uses the partial token as-is.
+
+    .. code-block:: python
+
+        split_arg_string("example 'my file")
+        ["example", "my file"]
+
+        split_arg_string("example my\\")
+        ["example", "my"]
+
+    :param string: String to split.
+    """
+    import shlex
+
+    lex = shlex.shlex(string, posix=True)
+    lex.whitespace_split = True
+    lex.commenters = ""
+    out = []
+
+    try:
+        for token in lex:
+            out.append(token)
+    except ValueError:
+        # Raised when end-of-string is reached in an invalid state. Use
+        # the partial token as-is. The quote or escape character is in
+        # lex.state, not lex.token.
+        out.append(lex.token)
+
+    return out
+
+
+class Option:
+    def __init__(
+        self,
+        obj: "CoreOption",
+        opts: t.Sequence[str],
+        dest: t.Optional[str],
+        action: t.Optional[str] = None,
+        nargs: int = 1,
+        const: t.Optional[t.Any] = None,
     ):
-        arg = match.group().strip()
-        if arg[:1] == arg[-1:] and arg[:1] in "\"'":
-            arg = arg[1:-1].encode("ascii", "backslashreplace").decode("unicode-escape")
-        try:
-            arg = type(string)(arg)
-        except UnicodeError:
-            pass
-        rv.append(arg)
-    return rv
-
-
-class Option(object):
-    def __init__(self, opts, dest, action=None, nargs=1, const=None, obj=None):
         self._short_opts = []
         self._long_opts = []
         self.prefixes = set()
@@ -128,7 +173,7 @@
         for opt in opts:
             prefix, value = split_opt(opt)
             if not prefix:
-                raise ValueError("Invalid start character for option ({})".format(opt))
+                raise ValueError(f"Invalid start character for option ({opt})")
             self.prefixes.add(prefix[0])
             if len(prefix) == 1 and len(value) == 1:
                 self._short_opts.append(opt)
@@ -146,53 +191,66 @@
         self.obj = obj

     @property
-    def takes_value(self):
+    def takes_value(self) -> bool:
         return self.action in ("store", "append")

-    def process(self, value, state):
+    def process(self, value: str, state: "ParsingState") -> None:
         if self.action == "store":
-            state.opts[self.dest] = value
+            state.opts[self.dest] = value  # type: ignore
         elif self.action == "store_const":
-            state.opts[self.dest] = self.const
+            state.opts[self.dest] = self.const  # type: ignore
         elif self.action == "append":
-            state.opts.setdefault(self.dest, []).append(value)
+            state.opts.setdefault(self.dest, []).append(value)  # type: ignore
         elif self.action == "append_const":
-            state.opts.setdefault(self.dest, []).append(self.const)
+            state.opts.setdefault(self.dest, []).append(self.const)  # type: ignore
         elif self.action == "count":
-            state.opts[self.dest] = state.opts.get(self.dest, 0) + 1
+            state.opts[self.dest] = state.opts.get(self.dest, 0) + 1  # type: ignore
         else:
-            raise ValueError("unknown action '{}'".format(self.action))
+            raise ValueError(f"unknown action '{self.action}'")
         state.order.append(self.obj)


-class Argument(object):
-    def __init__(self, dest, nargs=1, obj=None):
+class Argument:
+    def __init__(self, obj: "CoreArgument", dest: t.Optional[str], nargs: int = 1):
         self.dest = dest
         self.nargs = nargs
         self.obj = obj

-    def process(self, value, state):
+    def process(
+        self,
+        value: t.Union[t.Optional[str], t.Sequence[t.Optional[str]]],
+        state: "ParsingState",
+    ) -> None:
         if self.nargs > 1:
+            assert value is not None
             holes = sum(1 for x in value if x is None)
             if holes == len(value):
                 value = None
             elif holes != 0:
                 raise BadArgumentUsage(
-                    "argument {} takes {} values".format(self.dest, self.nargs)
+                    _("Argument {name!r} takes {nargs} values.").format(
+                        name=self.dest, nargs=self.nargs
+                    )
                 )
-        state.opts[self.dest] = value
+
+        if self.nargs == -1 and self.obj.envvar is not None and value == ():
+            # Replace empty tuple with None so that a value from the
+            # environment may be tried.
+            value = None
+
+        state.opts[self.dest] = value  # type: ignore
         state.order.append(self.obj)


-class ParsingState(object):
-    def __init__(self, rargs):
-        self.opts = {}
-        self.largs = []
+class ParsingState:
+    def __init__(self, rargs: t.List[str]) -> None:
+        self.opts: t.Dict[str, t.Any] = {}
+        self.largs: t.List[str] = []
         self.rargs = rargs
-        self.order = []
-
-
-class OptionParser(object):
+        self.order: t.List["CoreParameter"] = []
+
+
+class OptionParser:
     """The option parser is an internal class that is ultimately used to
     parse options and arguments.  It's modelled after optparse and brings
     a similar but vastly simplified API.  It should generally not be used
@@ -206,7 +264,7 @@
                 should go with.
     """

-    def __init__(self, ctx=None):
+    def __init__(self, ctx: t.Optional["Context"] = None) -> None:
         #: The :class:`~click.Context` for this parser.  This might be
         #: `None` for some advanced use cases.
         self.ctx = ctx
@@ -220,44 +278,54 @@
         #: second mode where it will ignore it and continue processing
         #: after shifting all the unknown options into the resulting args.
         self.ignore_unknown_options = False
+
         if ctx is not None:
             self.allow_interspersed_args = ctx.allow_interspersed_args
             self.ignore_unknown_options = ctx.ignore_unknown_options
-        self._short_opt = {}
-        self._long_opt = {}
+
+        self._short_opt: t.Dict[str, Option] = {}
+        self._long_opt: t.Dict[str, Option] = {}
         self._opt_prefixes = {"-", "--"}
-        self._args = []
-
-    def add_option(self, opts, dest, action=None, nargs=1, const=None, obj=None):
+        self._args: t.List[Argument] = []
+
+    def add_option(
+        self,
+        obj: "CoreOption",
+        opts: t.Sequence[str],
+        dest: t.Optional[str],
+        action: t.Optional[str] = None,
+        nargs: int = 1,
+        const: t.Optional[t.Any] = None,
+    ) -> None:
         """Adds a new option named `dest` to the parser.  The destination
         is not inferred (unlike with optparse) and needs to be explicitly
         provided.  Action can be any of ``store``, ``store_const``,
-        ``append``, ``appnd_const`` or ``count``.
+        ``append``, ``append_const`` or ``count``.

         The `obj` can be used to identify the option in the order list
         that is returned from the parser.
         """
-        if obj is None:
-            obj = dest
         opts = [normalize_opt(opt, self.ctx) for opt in opts]
-        option = Option(opts, dest, action=action, nargs=nargs, const=const, obj=obj)
+        option = Option(obj, opts, dest, action=action, nargs=nargs, const=const)
         self._opt_prefixes.update(option.prefixes)
         for opt in option._short_opts:
             self._short_opt[opt] = option
         for opt in option._long_opts:
             self._long_opt[opt] = option

-    def add_argument(self, dest, nargs=1, obj=None):
+    def add_argument(
+        self, obj: "CoreArgument", dest: t.Optional[str], nargs: int = 1
+    ) -> None:
         """Adds a positional argument named `dest` to the parser.

         The `obj` can be used to identify the option in the order list
         that is returned from the parser.
         """
-        if obj is None:
-            obj = dest
-        self._args.append(Argument(dest=dest, nargs=nargs, obj=obj))
-
-    def parse_args(self, args):
+        self._args.append(Argument(obj, dest=dest, nargs=nargs))
+
+    def parse_args(
+        self, args: t.List[str]
+    ) -> t.Tuple[t.Dict[str, t.Any], t.List[str], t.List["CoreParameter"]]:
         """Parses positional arguments and returns ``(values, args, order)``
         for the parsed options and arguments as well as the leftover
         arguments if there are any.  The order is a list of objects as they
@@ -273,7 +341,7 @@
                 raise
         return state.opts, state.largs, state.order

-    def _process_args_for_args(self, state):
+    def _process_args_for_args(self, state: ParsingState) -> None:
         pargs, args = _unpack_args(
             state.largs + state.rargs, [x.nargs for x in self._args]
         )
@@ -284,7 +352,7 @@
         state.largs = args
         state.rargs = []

-    def _process_args_for_options(self, state):
+    def _process_args_for_options(self, state: ParsingState) -> None:
         while state.rargs:
             arg = state.rargs.pop(0)
             arglen = len(arg)
@@ -320,9 +388,13 @@
         # *empty* -- still a subset of [arg0, ..., arg(i-1)], but
         # not a very interesting subset!

-    def _match_long_opt(self, opt, explicit_value, state):
+    def _match_long_opt(
+        self, opt: str, explicit_value: t.Optional[str], state: ParsingState
+    ) -> None:
         if opt not in self._long_opt:
-            possibilities = [word for word in self._long_opt if word.startswith(opt)]
+            from difflib import get_close_matches
+
+            possibilities = get_close_matches(opt, self._long_opt)
             raise NoSuchOption(opt, possibilities=possibilities, ctx=self.ctx)

         option = self._long_opt[opt]
@@ -334,31 +406,26 @@
             if explicit_value is not None:
                 state.rargs.insert(0, explicit_value)

-            nargs = option.nargs
-            if len(state.rargs) < nargs:
-                _error_opt_args(nargs, opt)
-            elif nargs == 1:
-                value = state.rargs.pop(0)
-            else:
-                value = tuple(state.rargs[:nargs])
-                del state.rargs[:nargs]
+            value = self._get_value_from_state(opt, option, state)

         elif explicit_value is not None:
-            raise BadOptionUsage(opt, "{} option does not take a value".format(opt))
+            raise BadOptionUsage(
+                opt, _("Option {name!r} does not take a value.").format(name=opt)
+            )

         else:
             value = None

         option.process(value, state)

-    def _match_short_opt(self, arg, state):
+    def _match_short_opt(self, arg: str, state: ParsingState) -> None:
         stop = False
         i = 1
         prefix = arg[0]
         unknown_options = []

         for ch in arg[1:]:
-            opt = normalize_opt(prefix + ch, self.ctx)
+            opt = normalize_opt(f"{prefix}{ch}", self.ctx)
             option = self._short_opt.get(opt)
             i += 1

@@ -374,14 +441,7 @@
                     state.rargs.insert(0, arg[i:])
                     stop = True

-                nargs = option.nargs
-                if len(state.rargs) < nargs:
-                    _error_opt_args(nargs, opt)
-                elif nargs == 1:
-                    value = state.rargs.pop(0)
-                else:
-                    value = tuple(state.rargs[:nargs])
-                    del state.rargs[:nargs]
+                value = self._get_value_from_state(opt, option, state)

             else:
                 value = None
@@ -396,9 +456,47 @@
         # to the state as new larg.  This way there is basic combinatorics
         # that can be achieved while still ignoring unknown arguments.
         if self.ignore_unknown_options and unknown_options:
-            state.largs.append("{}{}".format(prefix, "".join(unknown_options)))
-
-    def _process_opts(self, arg, state):
+            state.largs.append(f"{prefix}{''.join(unknown_options)}")
+
+    def _get_value_from_state(
+        self, option_name: str, option: Option, state: ParsingState
+    ) -> t.Any:
+        nargs = option.nargs
+
+        if len(state.rargs) < nargs:
+            if option.obj._flag_needs_value:
+                # Option allows omitting the value.
+                value = _flag_needs_value
+            else:
+                raise BadOptionUsage(
+                    option_name,
+                    ngettext(
+                        "Option {name!r} requires an argument.",
+                        "Option {name!r} requires {nargs} arguments.",
+                        nargs,
+                    ).format(name=option_name, nargs=nargs),
+                )
+        elif nargs == 1:
+            next_rarg = state.rargs[0]
+
+            if (
+                option.obj._flag_needs_value
+                and isinstance(next_rarg, str)
+                and next_rarg[:1] in self._opt_prefixes
+                and len(next_rarg) > 1
+            ):
+                # The next arg looks like the start of an option, don't
+                # use it as the value if omitting the value is allowed.
+                value = _flag_needs_value
+            else:
+                value = state.rargs.pop(0)
+        else:
+            value = tuple(state.rargs[:nargs])
+            del state.rargs[:nargs]
+
+        return value
+
+    def _process_opts(self, arg: str, state: ParsingState) -> None:
         explicit_value = None
         # Long option handling happens in two parts.  The first part is
         # supporting explicitly attached values.  In any case, we will try
@@ -422,7 +520,10 @@
             # short option code and will instead raise the no option
             # error.
             if arg[:2] not in self._opt_prefixes:
-                return self._match_short_opt(arg, state)
+                self._match_short_opt(arg, state)
+                return
+
             if not self.ignore_unknown_options:
                 raise
+
             state.largs.append(arg)
('src/click', 'termui.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -2,29 +2,30 @@
 import io
 import itertools
 import os
-import struct
 import sys
-
-from ._compat import DEFAULT_COLUMNS
-from ._compat import get_winterm_size
+import typing as t
+from gettext import gettext as _
+
 from ._compat import isatty
-from ._compat import raw_input
-from ._compat import string_types
 from ._compat import strip_ansi
-from ._compat import text_type
 from ._compat import WIN
 from .exceptions import Abort
 from .exceptions import UsageError
 from .globals import resolve_color_default
 from .types import Choice
 from .types import convert_type
-from .types import Path
+from .types import ParamType
 from .utils import echo
 from .utils import LazyFile

+if t.TYPE_CHECKING:
+    from ._termui_impl import ProgressBar
+
+V = t.TypeVar("V")
+
 # The prompt functions to use.  The doc tools currently override these
 # functions to customize how they work.
-visible_prompt_func = raw_input
+visible_prompt_func: t.Callable[[str], str] = input

 _ansi_colors = {
     "black": 30,
@@ -48,63 +49,61 @@
 _ansi_reset_all = "\033[0m"


-def hidden_prompt_func(prompt):
+def hidden_prompt_func(prompt: str) -> str:
     import getpass

     return getpass.getpass(prompt)


 def _build_prompt(
-    text, suffix, show_default=False, default=None, show_choices=True, type=None
-):
+    text: str,
+    suffix: str,
+    show_default: bool = False,
+    default: t.Optional[t.Any] = None,
+    show_choices: bool = True,
+    type: t.Optional[ParamType] = None,
+) -> str:
     prompt = text
     if type is not None and show_choices and isinstance(type, Choice):
-        prompt += " ({})".format(", ".join(map(str, type.choices)))
+        prompt += f" ({', '.join(map(str, type.choices))})"
     if default is not None and show_default:
-        prompt = "{} [{}]".format(prompt, _format_default(default))
-    return prompt + suffix
-
-
-def _format_default(default):
+        prompt = f"{prompt} [{_format_default(default)}]"
+    return f"{prompt}{suffix}"
+
+
+def _format_default(default: t.Any) -> t.Any:
     if isinstance(default, (io.IOBase, LazyFile)) and hasattr(default, "name"):
-        return default.name
+        return default.name  # type: ignore

     return default


 def prompt(
-    text,
-    default=None,
-    hide_input=False,
-    confirmation_prompt=False,
-    type=None,
-    value_proc=None,
-    prompt_suffix=": ",
-    show_default=True,
-    err=False,
-    show_choices=True,
-):
+    text: str,
+    default: t.Optional[t.Any] = None,
+    hide_input: bool = False,
+    confirmation_prompt: t.Union[bool, str] = False,
+    type: t.Optional[t.Union[ParamType, t.Any]] = None,
+    value_proc: t.Optional[t.Callable[[str], t.Any]] = None,
+    prompt_suffix: str = ": ",
+    show_default: bool = True,
+    err: bool = False,
+    show_choices: bool = True,
+) -> t.Any:
     """Prompts a user for input.  This is a convenience function that can
     be used to prompt a user for input later.

-    If the user aborts the input by sending a interrupt signal, this
+    If the user aborts the input by sending an interrupt signal, this
     function will catch it and raise a :exc:`Abort` exception.
-
-    .. versionadded:: 7.0
-       Added the show_choices parameter.
-
-    .. versionadded:: 6.0
-       Added unicode support for cmd.exe on Windows.
-
-    .. versionadded:: 4.0
-       Added the `err` parameter.

     :param text: the text to show for the prompt.
     :param default: the default value to use if no input happens.  If this
                     is not given it will prompt until it's aborted.
     :param hide_input: if this is set to true then the input value will
                        be hidden.
-    :param confirmation_prompt: asks for confirmation for the value.
+    :param confirmation_prompt: Prompt a second time to confirm the
+        value. Can be set to a string instead of ``True`` to customize
+        the message.
     :param type: the type to use to check the value against.
     :param value_proc: if this parameter is provided it's a function that
                        is invoked instead of the type conversion to
@@ -117,23 +116,37 @@
                          For example if type is a Choice of either day or week,
                          show_choices is true and text is "Group by" then the
                          prompt will be "Group by (day, week): ".
-    """
-    result = None
-
-    def prompt_func(text):
+
+    .. versionadded:: 8.0
+        ``confirmation_prompt`` can be a custom string.
+
+    .. versionadded:: 7.0
+        Added the ``show_choices`` parameter.
+
+    .. versionadded:: 6.0
+        Added unicode support for cmd.exe on Windows.
+
+    .. versionadded:: 4.0
+        Added the `err` parameter.
+
+    """
+
+    def prompt_func(text: str) -> str:
         f = hidden_prompt_func if hide_input else visible_prompt_func
         try:
             # Write the prompt separately so that we get nice
             # coloring through colorama on Windows
-            echo(text, nl=False, err=err)
-            return f("")
+            echo(text.rstrip(" "), nl=False, err=err)
+            # Echo a space to stdout to work around an issue where
+            # readline causes backspace to clear the whole line.
+            return f(" ")
         except (KeyboardInterrupt, EOFError):
             # getpass doesn't print a newline if the user aborts input with ^C.
             # Allegedly this behavior is inherited from getpass(3).
             # A doc bug has been filed at https://bugs.python.org/issue24711
             if hide_input:
                 echo(None, err=err)
-            raise Abort()
+            raise Abort() from None

     if value_proc is None:
         value_proc = convert_type(type, default)
@@ -142,72 +155,94 @@
         text, prompt_suffix, show_default, default, show_choices, type
     )

-    while 1:
-        while 1:
+    if confirmation_prompt:
+        if confirmation_prompt is True:
+            confirmation_prompt = _("Repeat for confirmation")
+
+        confirmation_prompt = _build_prompt(confirmation_prompt, prompt_suffix)
+
+    while True:
+        while True:
             value = prompt_func(prompt)
             if value:
                 break
             elif default is not None:
-                if isinstance(value_proc, Path):
-                    # validate Path default value(exists, dir_okay etc.)
-                    value = default
-                    break
-                return default
+                value = default
+                break
         try:
             result = value_proc(value)
         except UsageError as e:
-            echo("Error: {}".format(e.message), err=err)  # noqa: B306
+            if hide_input:
+                echo(_("Error: The value you entered was invalid."), err=err)
+            else:
+                echo(_("Error: {e.message}").format(e=e), err=err)  # noqa: B306
             continue
         if not confirmation_prompt:
             return result
-        while 1:
-            value2 = prompt_func("Repeat for confirmation: ")
-            if value2:
+        while True:
+            value2 = prompt_func(confirmation_prompt)
+            is_empty = not value and not value2
+            if value2 or is_empty:
                 break
         if value == value2:
             return result
-        echo("Error: the two entered values do not match", err=err)
+        echo(_("Error: The two entered values do not match."), err=err)


 def confirm(
-    text, default=False, abort=False, prompt_suffix=": ", show_default=True, err=False
-):
+    text: str,
+    default: t.Optional[bool] = False,
+    abort: bool = False,
+    prompt_suffix: str = ": ",
+    show_default: bool = True,
+    err: bool = False,
+) -> bool:
     """Prompts for confirmation (yes/no question).

     If the user aborts the input by sending a interrupt signal this
     function will catch it and raise a :exc:`Abort` exception.

-    .. versionadded:: 4.0
-       Added the `err` parameter.
-
     :param text: the question to ask.
-    :param default: the default for the prompt.
+    :param default: The default value to use when no input is given. If
+        ``None``, repeat until input is given.
     :param abort: if this is set to `True` a negative answer aborts the
                   exception by raising :exc:`Abort`.
     :param prompt_suffix: a suffix that should be added to the prompt.
     :param show_default: shows or hides the default value in the prompt.
     :param err: if set to true the file defaults to ``stderr`` instead of
                 ``stdout``, the same as with echo.
+
+    .. versionchanged:: 8.0
+        Repeat until input is given if ``default`` is ``None``.
+
+    .. versionadded:: 4.0
+        Added the ``err`` parameter.
     """
     prompt = _build_prompt(
-        text, prompt_suffix, show_default, "Y/n" if default else "y/N"
+        text,
+        prompt_suffix,
+        show_default,
+        "y/n" if default is None else ("Y/n" if default else "y/N"),
     )
-    while 1:
+
+    while True:
         try:
             # Write the prompt separately so that we get nice
             # coloring through colorama on Windows
-            echo(prompt, nl=False, err=err)
-            value = visible_prompt_func("").lower().strip()
+            echo(prompt.rstrip(" "), nl=False, err=err)
+            # Echo a space to stdout to work around an issue where
+            # readline causes backspace to clear the whole line.
+            value = visible_prompt_func(" ").lower().strip()
         except (KeyboardInterrupt, EOFError):
-            raise Abort()
+            raise Abort() from None
         if value in ("y", "yes"):
             rv = True
         elif value in ("n", "no"):
             rv = False
-        elif value == "":
+        elif default is not None and value == "":
             rv = default
         else:
-            echo("Error: invalid input", err=err)
+            echo(_("Error: invalid input"), err=err)
             continue
         break
     if abort and not rv:
@@ -215,54 +250,10 @@
     return rv


-def get_terminal_size():
-    """Returns the current size of the terminal as tuple in the form
-    ``(width, height)`` in columns and rows.
-    """
-    # If shutil has get_terminal_size() (Python 3.3 and later) use that
-    if sys.version_info >= (3, 3):
-        import shutil
-
-        shutil_get_terminal_size = getattr(shutil, "get_terminal_size", None)
-        if shutil_get_terminal_size:
-            sz = shutil_get_terminal_size()
-            return sz.columns, sz.lines
-
-    # We provide a sensible default for get_winterm_size() when being invoked
-    # inside a subprocess. Without this, it would not provide a useful input.
-    if get_winterm_size is not None:
-        size = get_winterm_size()
-        if size == (0, 0):
-            return (79, 24)
-        else:
-            return size
-
-    def ioctl_gwinsz(fd):
-        try:
-            import fcntl
-            import termios
-
-            cr = struct.unpack("hh", fcntl.ioctl(fd, termios.TIOCGWINSZ, "1234"))
-        except Exception:
-            return
-        return cr
-
-    cr = ioctl_gwinsz(0) or ioctl_gwinsz(1) or ioctl_gwinsz(2)
-    if not cr:
-        try:
-            fd = os.open(os.ctermid(), os.O_RDONLY)
-            try:
-                cr = ioctl_gwinsz(fd)
-            finally:
-                os.close(fd)
-        except Exception:
-            pass
-    if not cr or not cr[0] or not cr[1]:
-        cr = (os.environ.get("LINES", 25), os.environ.get("COLUMNS", DEFAULT_COLUMNS))
-    return int(cr[1]), int(cr[0])
-
-
-def echo_via_pager(text_or_generator, color=None):
+def echo_via_pager(
+    text_or_generator: t.Union[t.Iterable[str], t.Callable[[], t.Iterable[str]], str],
+    color: t.Optional[bool] = None,
+) -> None:
     """This function takes a text and shows it via an environment specific
     pager on stdout.

@@ -277,14 +268,14 @@
     color = resolve_color_default(color)

     if inspect.isgeneratorfunction(text_or_generator):
-        i = text_or_generator()
-    elif isinstance(text_or_generator, string_types):
+        i = t.cast(t.Callable[[], t.Iterable[str]], text_or_generator)()
+    elif isinstance(text_or_generator, str):
         i = [text_or_generator]
     else:
-        i = iter(text_or_generator)
+        i = iter(t.cast(t.Iterable[str], text_or_generator))

     # convert every element of i to a text type if necessary
-    text_generator = (el if isinstance(el, string_types) else text_type(el) for el in i)
+    text_generator = (el if isinstance(el, str) else str(el) for el in i)

     from ._termui_impl import pager

@@ -292,21 +283,22 @@


 def progressbar(
-    iterable=None,
-    length=None,
-    label=None,
-    show_eta=True,
-    show_percent=None,
-    show_pos=False,
-    item_show_func=None,
-    fill_char="#",
-    empty_char="-",
-    bar_template="%(label)s  [%(bar)s]  %(info)s",
-    info_sep="  ",
-    width=36,
-    file=None,
-    color=None,
-):
+    iterable: t.Optional[t.Iterable[V]] = None,
+    length: t.Optional[int] = None,
+    label: t.Optional[str] = None,
+    show_eta: bool = True,
+    show_percent: t.Optional[bool] = None,
+    show_pos: bool = False,
+    item_show_func: t.Optional[t.Callable[[t.Optional[V]], t.Optional[str]]] = None,
+    fill_char: str = "#",
+    empty_char: str = "-",
+    bar_template: str = "%(label)s  [%(bar)s]  %(info)s",
+    info_sep: str = "  ",
+    width: int = 36,
+    file: t.Optional[t.TextIO] = None,
+    color: t.Optional[bool] = None,
+    update_min_steps: int = 1,
+) -> "ProgressBar[V]":
     """This function creates an iterable context manager that can be used
     to iterate over something while showing a progress bar.  It will
     either iterate over the `iterable` or `length` items (that are counted
@@ -346,11 +338,19 @@
                 process_chunk(chunk)
                 bar.update(chunks.bytes)

-    .. versionadded:: 2.0
-
-    .. versionadded:: 4.0
-       Added the `color` parameter.  Added a `update` method to the
-       progressbar object.
+    The ``update()`` method also takes an optional value specifying the
+    ``current_item`` at the new position. This is useful when used
+    together with ``item_show_func`` to customize the output for each
+    manual step::
+
+        with click.progressbar(
+            length=total_size,
+            label='Unzipping archive',
+            item_show_func=lambda a: a.filename
+        ) as bar:
+            for archive in zip_file:
+                archive.extract()
+                bar.update(archive.size, archive)

     :param iterable: an iterable to iterate over.  If not provided the length
                      is required.
@@ -369,10 +369,10 @@
                          `False` if not.
     :param show_pos: enables or disables the absolute position display.  The
                      default is `False`.
-    :param item_show_func: a function called with the current item which
-                           can return a string to show the current item
-                           next to the progress bar.  Note that the current
-                           item can be `None`!
+    :param item_show_func: A function called with the current item which
+        can return a string to show next to the progress bar. If the
+        function returns ``None`` nothing is shown. The current item can
+        be ``None``, such as when entering and exiting the bar.
     :param fill_char: the character to use to show the filled part of the
                       progress bar.
     :param empty_char: the character to use to show the non-filled part of
@@ -384,12 +384,33 @@
     :param info_sep: the separator between multiple info items (eta etc.)
     :param width: the width of the progress bar in characters, 0 means full
                   terminal width
-    :param file: the file to write to.  If this is not a terminal then
-                 only the label is printed.
+    :param file: The file to write to. If this is not a terminal then
+        only the label is printed.
     :param color: controls if the terminal supports ANSI colors or not.  The
                   default is autodetection.  This is only needed if ANSI
                   codes are included anywhere in the progress bar output
                   which is not the case by default.
+    :param update_min_steps: Render only when this many updates have
+        completed. This allows tuning for very fast iterators.
+
+    .. versionchanged:: 8.0
+        Output is shown even if execution time is less than 0.5 seconds.
+
+    .. versionchanged:: 8.0
+        ``item_show_func`` shows the current item, not the previous one.
+
+    .. versionchanged:: 8.0
+        Labels are echoed if the output is not a TTY. Reverts a change
+        in 7.0 that removed all output.
+
+    .. versionadded:: 8.0
+       Added the ``update_min_steps`` parameter.
+
+    .. versionchanged:: 4.0
+        Added the ``color`` parameter. Added the ``update`` method to
+        the object.
+
+    .. versionadded:: 2.0
     """
     from ._termui_impl import ProgressBar

@@ -409,10 +430,11 @@
         label=label,
         width=width,
         color=color,
+        update_min_steps=update_min_steps,
     )


-def clear():
+def clear() -> None:
     """Clears the terminal screen.  This will have the effect of clearing
     the whole visible space of the terminal and moving the cursor to the
     top left.  This does not do anything if not connected to a terminal.
@@ -421,26 +443,39 @@
     """
     if not isatty(sys.stdout):
         return
-    # If we're on Windows and we don't have colorama available, then we
-    # clear the screen by shelling out.  Otherwise we can use an escape
-    # sequence.
     if WIN:
         os.system("cls")
     else:
         sys.stdout.write("\033[2J\033[1;1H")


+def _interpret_color(
+    color: t.Union[int, t.Tuple[int, int, int], str], offset: int = 0
+) -> str:
+    if isinstance(color, int):
+        return f"{38 + offset};5;{color:d}"
+
+    if isinstance(color, (tuple, list)):
+        r, g, b = color
+        return f"{38 + offset};2;{r:d};{g:d};{b:d}"
+
+    return str(_ansi_colors[color] + offset)
+
+
 def style(
-    text,
-    fg=None,
-    bg=None,
-    bold=None,
-    dim=None,
-    underline=None,
-    blink=None,
-    reverse=None,
-    reset=True,
-):
+    text: t.Any,
+    fg: t.Optional[t.Union[int, t.Tuple[int, int, int], str]] = None,
+    bg: t.Optional[t.Union[int, t.Tuple[int, int, int], str]] = None,
+    bold: t.Optional[bool] = None,
+    dim: t.Optional[bool] = None,
+    underline: t.Optional[bool] = None,
+    overline: t.Optional[bool] = None,
+    italic: t.Optional[bool] = None,
+    blink: t.Optional[bool] = None,
+    reverse: t.Optional[bool] = None,
+    strikethrough: t.Optional[bool] = None,
+    reset: bool = True,
+) -> str:
     """Styles a text with ANSI styles and returns the new string.  By
     default the styling is self contained which means that at the end
     of the string a reset code is issued.  This can be prevented by
@@ -451,6 +486,7 @@
         click.echo(click.style('Hello World!', fg='green'))
         click.echo(click.style('ATTENTION!', blink=True))
         click.echo(click.style('Some things', reverse=True, fg='cyan'))
+        click.echo(click.style('More colors', fg=(255, 12, 128), bg=117))

     Supported color names:

@@ -472,10 +508,15 @@
     * ``bright_white``
     * ``reset`` (reset the color code only)

-    .. versionadded:: 2.0
-
-    .. versionadded:: 7.0
-       Added support for bright colors.
+    If the terminal supports it, color may also be specified as:
+
+    -   An integer in the interval [0, 255]. The terminal must support
+        8-bit/256-color mode.
+    -   An RGB tuple of three integers in [0, 255]. The terminal must
+        support 24-bit/true-color mode.
+
+    See https://en.wikipedia.org/wiki/ANSI_color and
+    https://gist.github.com/XVilka/8346728 for more information.

     :param text: the string to style with ansi codes.
     :param fg: if provided this will become the foreground color.
@@ -484,42 +525,73 @@
     :param dim: if provided this will enable or disable dim mode.  This is
                 badly supported.
     :param underline: if provided this will enable or disable underline.
+    :param overline: if provided this will enable or disable overline.
+    :param italic: if provided this will enable or disable italic.
     :param blink: if provided this will enable or disable blinking.
     :param reverse: if provided this will enable or disable inverse
                     rendering (foreground becomes background and the
                     other way round).
+    :param strikethrough: if provided this will enable or disable
+        striking through text.
     :param reset: by default a reset-all code is added at the end of the
                   string which means that styles do not carry over.  This
                   can be disabled to compose styles.
-    """
+
+    .. versionchanged:: 8.0
+        A non-string ``message`` is converted to a string.
+
+    .. versionchanged:: 8.0
+       Added support for 256 and RGB color codes.
+
+    .. versionchanged:: 8.0
+        Added the ``strikethrough``, ``italic``, and ``overline``
+        parameters.
+
+    .. versionchanged:: 7.0
+        Added support for bright colors.
+
+    .. versionadded:: 2.0
+    """
+    if not isinstance(text, str):
+        text = str(text)
+
     bits = []
+
     if fg:
         try:
-            bits.append("\033[{}m".format(_ansi_colors[fg]))
+            bits.append(f"\033[{_interpret_color(fg)}m")
         except KeyError:
-            raise TypeError("Unknown color '{}'".format(fg))
+            raise TypeError(f"Unknown color {fg!r}") from None
+
     if bg:
         try:
-            bits.append("\033[{}m".format(_ansi_colors[bg] + 10))
+            bits.append(f"\033[{_interpret_color(bg, 10)}m")
         except KeyError:
-            raise TypeError("Unknown color '{}'".format(bg))
+            raise TypeError(f"Unknown color {bg!r}") from None
+
     if bold is not None:
-        bits.append("\033[{}m".format(1 if bold else 22))
+        bits.append(f"\033[{1 if bold else 22}m")
     if dim is not None:
-        bits.append("\033[{}m".format(2 if dim else 22))
+        bits.append(f"\033[{2 if dim else 22}m")
     if underline is not None:
-        bits.append("\033[{}m".format(4 if underline else 24))
+        bits.append(f"\033[{4 if underline else 24}m")
+    if overline is not None:
+        bits.append(f"\033[{53 if overline else 55}m")
+    if italic is not None:
+        bits.append(f"\033[{3 if italic else 23}m")
     if blink is not None:
-        bits.append("\033[{}m".format(5 if blink else 25))
+        bits.append(f"\033[{5 if blink else 25}m")
     if reverse is not None:
-        bits.append("\033[{}m".format(7 if reverse else 27))
+        bits.append(f"\033[{7 if reverse else 27}m")
+    if strikethrough is not None:
+        bits.append(f"\033[{9 if strikethrough else 29}m")
     bits.append(text)
     if reset:
         bits.append(_ansi_reset_all)
     return "".join(bits)


-def unstyle(text):
+def unstyle(text: str) -> str:
     """Removes ANSI styling information from a string.  Usually it's not
     necessary to use this function as Click's echo function will
     automatically remove styling if necessary.
@@ -531,7 +603,14 @@
     return strip_ansi(text)


-def secho(message=None, file=None, nl=True, err=False, color=None, **styles):
+def secho(
+    message: t.Optional[t.Any] = None,
+    file: t.Optional[t.IO[t.AnyStr]] = None,
+    nl: bool = True,
+    err: bool = False,
+    color: t.Optional[bool] = None,
+    **styles: t.Any,
+) -> None:
     """This function combines :func:`echo` and :func:`style` into one
     call.  As such the following two calls are the same::

@@ -541,16 +620,31 @@
     All keyword arguments are forwarded to the underlying functions
     depending on which one they go with.

+    Non-string types will be converted to :class:`str`. However,
+    :class:`bytes` are passed directly to :meth:`echo` without applying
+    style. If you want to style bytes that represent text, call
+    :meth:`bytes.decode` first.
+
+    .. versionchanged:: 8.0
+        A non-string ``message`` is converted to a string. Bytes are
+        passed through without style applied.
+
     .. versionadded:: 2.0
     """
-    if message is not None:
+    if message is not None and not isinstance(message, (bytes, bytearray)):
         message = style(message, **styles)
+
     return echo(message, file=file, nl=nl, err=err, color=color)


 def edit(
-    text=None, editor=None, env=None, require_save=True, extension=".txt", filename=None
-):
+    text: t.Optional[t.AnyStr] = None,
+    editor: t.Optional[str] = None,
+    env: t.Optional[t.Mapping[str, str]] = None,
+    require_save: bool = True,
+    extension: str = ".txt",
+    filename: t.Optional[str] = None,
+) -> t.Optional[t.AnyStr]:
     r"""Edits the given text in the defined editor.  If an editor is given
     (should be the full path to the executable but the regular operating
     system search path is used for finding the executable) it overrides
@@ -580,15 +674,16 @@
     """
     from ._termui_impl import Editor

-    editor = Editor(
-        editor=editor, env=env, require_save=require_save, extension=extension
-    )
+    ed = Editor(editor=editor, env=env, require_save=require_save, extension=extension)
+
     if filename is None:
-        return editor.edit(text)
-    editor.edit_file(filename)
-
-
-def launch(url, wait=False, locate=False):
+        return ed.edit(text)
+
+    ed.edit_file(filename)
+    return None
+
+
+def launch(url: str, wait: bool = False, locate: bool = False) -> int:
     """This function launches the given URL (or filename) in the default
     viewer application for this file type.  If this is an executable, it
     might launch the executable in a new session.  The return value is
@@ -603,7 +698,9 @@
     .. versionadded:: 2.0

     :param url: URL or filename of the thing to launch.
-    :param wait: waits for the program to stop.
+    :param wait: Wait for the program to exit before returning. This
+        only works if the launched program blocks. In particular,
+        ``xdg-open`` on Linux does not block.
     :param locate: if this is set to `True` then instead of launching the
                    application associated with the URL it will attempt to
                    launch a file manager with the file located.  This
@@ -617,10 +714,10 @@

 # If this is provided, getchar() calls into this instead.  This is used
 # for unittesting purposes.
-_getchar = None
-
-
-def getchar(echo=False):
+_getchar: t.Optional[t.Callable[[bool], str]] = None
+
+
+def getchar(echo: bool = False) -> str:
     """Fetches a single character from the terminal and returns it.  This
     will always return a unicode character and under certain rare
     circumstances this might return more than one character.  The
@@ -640,19 +737,23 @@
     :param echo: if set to `True`, the character read will also show up on
                  the terminal.  The default is to not show it.
     """
-    f = _getchar
-    if f is None:
+    global _getchar
+
+    if _getchar is None:
         from ._termui_impl import getchar as f
-    return f(echo)
-
-
-def raw_terminal():
+
+        _getchar = f
+
+    return _getchar(echo)
+
+
+def raw_terminal() -> t.ContextManager[int]:
     from ._termui_impl import raw_terminal as f

     return f()


-def pause(info="Press any key to continue ...", err=False):
+def pause(info: t.Optional[str] = None, err: bool = False) -> None:
     """This command stops execution and waits for the user to press any
     key to continue.  This is similar to the Windows batch "pause"
     command.  If the program is not run through a terminal, this command
@@ -663,12 +764,17 @@
     .. versionadded:: 4.0
        Added the `err` parameter.

-    :param info: the info string to print before pausing.
+    :param info: The message to print before pausing. Defaults to
+        ``"Press any key to continue..."``.
     :param err: if set to message goes to ``stderr`` instead of
                 ``stdout``, the same as with echo.
     """
     if not isatty(sys.stdin) or not isatty(sys.stdout):
         return
+
+    if info is None:
+        info = _("Press any key to continue...")
+
     try:
         if info:
             echo(info, nl=False, err=err)
('src/click', 'utils.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,86 +1,106 @@
 import os
+import re
 import sys
+import typing as t
+from functools import update_wrapper
+from types import ModuleType

 from ._compat import _default_text_stderr
 from ._compat import _default_text_stdout
+from ._compat import _find_binary_writer
 from ._compat import auto_wrap_for_ansi
 from ._compat import binary_streams
-from ._compat import filename_to_ui
 from ._compat import get_filesystem_encoding
-from ._compat import get_streerror
-from ._compat import is_bytes
 from ._compat import open_stream
-from ._compat import PY2
 from ._compat import should_strip_ansi
-from ._compat import string_types
 from ._compat import strip_ansi
 from ._compat import text_streams
-from ._compat import text_type
 from ._compat import WIN
 from .globals import resolve_color_default

-if not PY2:
-    from ._compat import _find_binary_writer
-elif WIN:
-    from ._winconsole import _get_windows_argv
-    from ._winconsole import _hash_py_argv
-    from ._winconsole import _initial_argv_hash
-
-echo_native_types = string_types + (bytes, bytearray)
-
-
-def _posixify(name):
+if t.TYPE_CHECKING:
+    import typing_extensions as te
+
+F = t.TypeVar("F", bound=t.Callable[..., t.Any])
+
+
+def _posixify(name: str) -> str:
     return "-".join(name.split()).lower()


-def safecall(func):
+def safecall(func: F) -> F:
     """Wraps a function so that it swallows exceptions."""

-    def wrapper(*args, **kwargs):
+    def wrapper(*args, **kwargs):  # type: ignore
         try:
             return func(*args, **kwargs)
         except Exception:
             pass

-    return wrapper
-
-
-def make_str(value):
+    return update_wrapper(t.cast(F, wrapper), func)
+
+
+def make_str(value: t.Any) -> str:
     """Converts a value into a valid string."""
     if isinstance(value, bytes):
         try:
             return value.decode(get_filesystem_encoding())
         except UnicodeError:
             return value.decode("utf-8", "replace")
-    return text_type(value)
-
-
-def make_default_short_help(help, max_length=45):
-    """Return a condensed version of help string."""
+    return str(value)
+
+
+def make_default_short_help(help: str, max_length: int = 45) -> str:
+    """Returns a condensed version of help string."""
+    # Consider only the first paragraph.
+    paragraph_end = help.find("\n\n")
+
+    if paragraph_end != -1:
+        help = help[:paragraph_end]
+
+    # Collapse newlines, tabs, and spaces.
     words = help.split()
+
+    if not words:
+        return ""
+
+    # The first paragraph started with a "no rewrap" marker, ignore it.
+    if words[0] == "\b":
+        words = words[1:]
+
     total_length = 0
-    result = []
-    done = False
-
-    for word in words:
-        if word[-1:] == ".":
-            done = True
-        new_length = 1 + len(word) if result else len(word)
-        if total_length + new_length > max_length:
-            result.append("...")
-            done = True
-        else:
-            if result:
-                result.append(" ")
-            result.append(word)
-        if done:
+    last_index = len(words) - 1
+
+    for i, word in enumerate(words):
+        total_length += len(word) + (i > 0)
+
+        if total_length > max_length:  # too long, truncate
             break
-        total_length += new_length
-
-    return "".join(result)
-
-
-class LazyFile(object):
+
+        if word[-1] == ".":  # sentence end, truncate without "..."
+            return " ".join(words[: i + 1])
+
+        if total_length == max_length and i != last_index:
+            break  # not at sentence end, truncate with "..."
+    else:
+        return " ".join(words)  # no truncation needed
+
+    # Account for the length of the suffix.
+    total_length += len("...")
+
+    # remove words until the length is short enough
+    while i > 0:
+        total_length -= len(words[i]) + (i > 0)
+
+        if total_length <= max_length:
+            break
+
+        i -= 1
+
+    return " ".join(words[:i]) + "..."
+
+
+class LazyFile:
     """A lazy file works like a regular file but it does not fully open
     the file but it does perform some basic checks early to see if the
     filename parameter does make sense.  This is useful for safely opening
@@ -88,13 +108,19 @@
     """

     def __init__(
-        self, filename, mode="r", encoding=None, errors="strict", atomic=False
+        self,
+        filename: str,
+        mode: str = "r",
+        encoding: t.Optional[str] = None,
+        errors: t.Optional[str] = "strict",
+        atomic: bool = False,
     ):
         self.name = filename
         self.mode = mode
         self.encoding = encoding
         self.errors = errors
         self.atomic = atomic
+        self._f: t.Optional[t.IO]

         if filename == "-":
             self._f, self.should_close = open_stream(filename, mode, encoding, errors)
@@ -107,15 +133,15 @@
             self._f = None
             self.should_close = True

-    def __getattr__(self, name):
+    def __getattr__(self, name: str) -> t.Any:
         return getattr(self.open(), name)

-    def __repr__(self):
+    def __repr__(self) -> str:
         if self._f is not None:
             return repr(self._f)
-        return "<unopened file '{}' {}>".format(self.name, self.mode)
-
-    def open(self):
+        return f"<unopened file '{self.name}' {self.mode}>"
+
+    def open(self) -> t.IO:
         """Opens the file if it's not yet open.  This call might fail with
         a :exc:`FileError`.  Not handling this error will produce an error
         that Click shows.
@@ -126,102 +152,100 @@
             rv, self.should_close = open_stream(
                 self.name, self.mode, self.encoding, self.errors, atomic=self.atomic
             )
-        except (IOError, OSError) as e:  # noqa: E402
+        except OSError as e:  # noqa: E402
             from .exceptions import FileError

-            raise FileError(self.name, hint=get_streerror(e))
+            raise FileError(self.name, hint=e.strerror) from e
         self._f = rv
         return rv

-    def close(self):
+    def close(self) -> None:
         """Closes the underlying file, no matter what."""
         if self._f is not None:
             self._f.close()

-    def close_intelligently(self):
+    def close_intelligently(self) -> None:
         """This function only closes the file if it was opened by the lazy
         file wrapper.  For instance this will never close stdin.
         """
         if self.should_close:
             self.close()

-    def __enter__(self):
+    def __enter__(self) -> "LazyFile":
         return self

-    def __exit__(self, exc_type, exc_value, tb):
+    def __exit__(self, exc_type, exc_value, tb):  # type: ignore
         self.close_intelligently()

-    def __iter__(self):
+    def __iter__(self) -> t.Iterator[t.AnyStr]:
         self.open()
-        return iter(self._f)
-
-
-class KeepOpenFile(object):
-    def __init__(self, file):
+        return iter(self._f)  # type: ignore
+
+
+class KeepOpenFile:
+    def __init__(self, file: t.IO) -> None:
         self._file = file

-    def __getattr__(self, name):
+    def __getattr__(self, name: str) -> t.Any:
         return getattr(self._file, name)

-    def __enter__(self):
+    def __enter__(self) -> "KeepOpenFile":
         return self

-    def __exit__(self, exc_type, exc_value, tb):
+    def __exit__(self, exc_type, exc_value, tb):  # type: ignore
         pass

-    def __repr__(self):
+    def __repr__(self) -> str:
         return repr(self._file)

-    def __iter__(self):
+    def __iter__(self) -> t.Iterator[t.AnyStr]:
         return iter(self._file)


-def echo(message=None, file=None, nl=True, err=False, color=None):
-    """Prints a message plus a newline to the given file or stdout.  On
-    first sight, this looks like the print function, but it has improved
-    support for handling Unicode and binary data that does not fail no
-    matter how badly configured the system is.
-
-    Primarily it means that you can print binary data as well as Unicode
-    data on both 2.x and 3.x to the given file in the most appropriate way
-    possible.  This is a very carefree function in that it will try its
-    best to not fail.  As of Click 6.0 this includes support for unicode
-    output on the Windows console.
-
-    In addition to that, if `colorama`_ is installed, the echo function will
-    also support clever handling of ANSI codes.  Essentially it will then
-    do the following:
-
-    -   add transparent handling of ANSI color codes on Windows.
-    -   hide ANSI codes automatically if the destination file is not a
-        terminal.
-
-    .. _colorama: https://pypi.org/project/colorama/
+def echo(
+    message: t.Optional[t.Any] = None,
+    file: t.Optional[t.IO[t.Any]] = None,
+    nl: bool = True,
+    err: bool = False,
+    color: t.Optional[bool] = None,
+) -> None:
+    """Print a message and newline to stdout or a file. This should be
+    used instead of :func:`print` because it provides better support
+    for different data, files, and environments.
+
+    Compared to :func:`print`, this does the following:
+
+    -   Ensures that the output encoding is not misconfigured on Linux.
+    -   Supports Unicode in the Windows console.
+    -   Supports writing to binary outputs, and supports writing bytes
+        to text outputs.
+    -   Supports colors and styles on Windows.
+    -   Removes ANSI color and style codes if the output does not look
+        like an interactive terminal.
+    -   Always flushes the output.
+
+    :param message: The string or bytes to output. Other objects are
+        converted to strings.
+    :param file: The file to write to. Defaults to ``stdout``.
+    :param err: Write to ``stderr`` instead of ``stdout``.
+    :param nl: Print a newline after the message. Enabled by default.
+    :param color: Force showing or hiding colors and other styles. By
+        default Click will remove color if the output does not look like
+        an interactive terminal.

     .. versionchanged:: 6.0
-       As of Click 6.0 the echo function will properly support unicode
-       output on the windows console.  Not that click does not modify
-       the interpreter in any way which means that `sys.stdout` or the
-       print statement or function will still not provide unicode support.
+        Support Unicode output on the Windows console. Click does not
+        modify ``sys.stdout``, so ``sys.stdout.write()`` and ``print()``
+        will still not support Unicode.
+
+    .. versionchanged:: 4.0
+        Added the ``color`` parameter.
+
+    .. versionadded:: 3.0
+        Added the ``err`` parameter.

     .. versionchanged:: 2.0
-       Starting with version 2.0 of Click, the echo function will work
-       with colorama if it's installed.
-
-    .. versionadded:: 3.0
-       The `err` parameter was added.
-
-    .. versionchanged:: 4.0
-       Added the `color` flag.
-
-    :param message: the message to print
-    :param file: the file to write to (defaults to ``stdout``)
-    :param err: if set to true the file defaults to ``stderr`` instead of
-                ``stdout``.  This is faster and easier than calling
-                :func:`get_text_stderr` yourself.
-    :param nl: if set to `True` (the default) a newline is printed afterwards.
-    :param color: controls if the terminal supports ANSI colors or not.  The
-                  default is autodetection.
+        Support colors on Windows if colorama is installed.
     """
     if file is None:
         if err:
@@ -230,70 +254,73 @@
             file = _default_text_stdout()

     # Convert non bytes/text into the native string type.
-    if message is not None and not isinstance(message, echo_native_types):
-        message = text_type(message)
+    if message is not None and not isinstance(message, (str, bytes, bytearray)):
+        out: t.Optional[t.Union[str, bytes]] = str(message)
+    else:
+        out = message

     if nl:
-        message = message or u""
-        if isinstance(message, text_type):
-            message += u"\n"
+        out = out or ""
+        if isinstance(out, str):
+            out += "\n"
         else:
-            message += b"\n"
-
-    # If there is a message, and we're in Python 3, and the value looks
-    # like bytes, we manually need to find the binary stream and write the
-    # message in there.  This is done separately so that most stream
-    # types will work as you would expect.  Eg: you can write to StringIO
-    # for other cases.
-    if message and not PY2 and is_bytes(message):
+            out += b"\n"
+
+    if not out:
+        file.flush()
+        return
+
+    # If there is a message and the value looks like bytes, we manually
+    # need to find the binary stream and write the message in there.
+    # This is done separately so that most stream types will work as you
+    # would expect. Eg: you can write to StringIO for other cases.
+    if isinstance(out, (bytes, bytearray)):
         binary_file = _find_binary_writer(file)
+
         if binary_file is not None:
             file.flush()
-            binary_file.write(message)
+            binary_file.write(out)
             binary_file.flush()
             return

-    # ANSI-style support.  If there is no message or we are dealing with
-    # bytes nothing is happening.  If we are connected to a file we want
-    # to strip colors.  If we are on windows we either wrap the stream
-    # to strip the color or we use the colorama support to translate the
-    # ansi codes to API calls.
-    if message and not is_bytes(message):
+    # ANSI style code support. For no message or bytes, nothing happens.
+    # When outputting to a file instead of a terminal, strip codes.
+    else:
         color = resolve_color_default(color)
+
         if should_strip_ansi(file, color):
-            message = strip_ansi(message)
+            out = strip_ansi(out)
         elif WIN:
             if auto_wrap_for_ansi is not None:
-                file = auto_wrap_for_ansi(file)
+                file = auto_wrap_for_ansi(file)  # type: ignore
             elif not color:
-                message = strip_ansi(message)
-
-    if message:
-        file.write(message)
+                out = strip_ansi(out)
+
+    file.write(out)  # type: ignore
     file.flush()


-def get_binary_stream(name):
-    """Returns a system stream for byte processing.  This essentially
-    returns the stream from the sys module with the given name but it
-    solves some compatibility issues between different Python versions.
-    Primarily this function is necessary for getting binary streams on
-    Python 3.
+def get_binary_stream(name: "te.Literal['stdin', 'stdout', 'stderr']") -> t.BinaryIO:
+    """Returns a system stream for byte processing.

     :param name: the name of the stream to open.  Valid names are ``'stdin'``,
                  ``'stdout'`` and ``'stderr'``
     """
     opener = binary_streams.get(name)
     if opener is None:
-        raise TypeError("Unknown standard stream '{}'".format(name))
+        raise TypeError(f"Unknown standard stream '{name}'")
     return opener()


-def get_text_stream(name, encoding=None, errors="strict"):
+def get_text_stream(
+    name: "te.Literal['stdin', 'stdout', 'stderr']",
+    encoding: t.Optional[str] = None,
+    errors: t.Optional[str] = "strict",
+) -> t.TextIO:
     """Returns a system stream for text processing.  This usually returns
     a wrapped stream around a binary stream returned from
-    :func:`get_binary_stream` but it also can take shortcuts on Python 3
-    for already correctly configured streams.
+    :func:`get_binary_stream` but it also can take shortcuts for already
+    correctly configured streams.

     :param name: the name of the stream to open.  Valid names are ``'stdin'``,
                  ``'stdout'`` and ``'stderr'``
@@ -302,65 +329,60 @@
     """
     opener = text_streams.get(name)
     if opener is None:
-        raise TypeError("Unknown standard stream '{}'".format(name))
+        raise TypeError(f"Unknown standard stream '{name}'")
     return opener(encoding, errors)


 def open_file(
-    filename, mode="r", encoding=None, errors="strict", lazy=False, atomic=False
-):
-    """This is similar to how the :class:`File` works but for manual
-    usage.  Files are opened non lazy by default.  This can open regular
-    files as well as stdin/stdout if ``'-'`` is passed.
-
-    If stdin/stdout is returned the stream is wrapped so that the context
-    manager will not close the stream accidentally.  This makes it possible
-    to always use the function like this without having to worry to
-    accidentally close a standard stream::
+    filename: str,
+    mode: str = "r",
+    encoding: t.Optional[str] = None,
+    errors: t.Optional[str] = "strict",
+    lazy: bool = False,
+    atomic: bool = False,
+) -> t.IO:
+    """Open a file, with extra behavior to handle ``'-'`` to indicate
+    a standard stream, lazy open on write, and atomic write. Similar to
+    the behavior of the :class:`~click.File` param type.
+
+    If ``'-'`` is given to open ``stdout`` or ``stdin``, the stream is
+    wrapped so that using it in a context manager will not close it.
+    This makes it possible to use the function without accidentally
+    closing a standard stream:
+
+    .. code-block:: python

         with open_file(filename) as f:
             ...

+    :param filename: The name of the file to open, or ``'-'`` for
+        ``stdin``/``stdout``.
+    :param mode: The mode in which to open the file.
+    :param encoding: The encoding to decode or encode a file opened in
+        text mode.
+    :param errors: The error handling mode.
+    :param lazy: Wait to open the file until it is accessed. For read
+        mode, the file is temporarily opened to raise access errors
+        early, then closed until it is read again.
+    :param atomic: Write to a temporary file and replace the given file
+        on close.
+
     .. versionadded:: 3.0
-
-    :param filename: the name of the file to open (or ``'-'`` for stdin/stdout).
-    :param mode: the mode in which to open the file.
-    :param encoding: the encoding to use.
-    :param errors: the error handling for this file.
-    :param lazy: can be flipped to true to open the file lazily.
-    :param atomic: in atomic mode writes go into a temporary file and it's
-                   moved on close.
     """
     if lazy:
-        return LazyFile(filename, mode, encoding, errors, atomic=atomic)
+        return t.cast(t.IO, LazyFile(filename, mode, encoding, errors, atomic=atomic))
+
     f, should_close = open_stream(filename, mode, encoding, errors, atomic=atomic)
+
     if not should_close:
-        f = KeepOpenFile(f)
+        f = t.cast(t.IO, KeepOpenFile(f))
+
     return f


-def get_os_args():
-    """This returns the argument part of sys.argv in the most appropriate
-    form for processing.  What this means is that this return value is in
-    a format that works for Click to process but does not necessarily
-    correspond well to what's actually standard for the interpreter.
-
-    On most environments the return value is ``sys.argv[:1]`` unchanged.
-    However if you are on Windows and running Python 2 the return value
-    will actually be a list of unicode strings instead because the
-    default behavior on that platform otherwise will not be able to
-    carry all possible values that sys.argv can have.
-
-    .. versionadded:: 6.0
-    """
-    # We can only extract the unicode argv if sys.argv has not been
-    # changed since the startup of the application.
-    if PY2 and WIN and _initial_argv_hash == _hash_py_argv():
-        return _get_windows_argv()
-    return sys.argv[1:]
-
-
-def format_filename(filename, shorten=False):
+def format_filename(
+    filename: t.Union[str, bytes, os.PathLike], shorten: bool = False
+) -> str:
     """Formats a filename for user display.  The main purpose of this
     function is to ensure that the filename can be displayed at all.  This
     will decode the filename to unicode if necessary in a way that it will
@@ -374,10 +396,11 @@
     """
     if shorten:
         filename = os.path.basename(filename)
-    return filename_to_ui(filename)
-
-
-def get_app_dir(app_name, roaming=True, force_posix=False):
+
+    return os.fsdecode(filename)
+
+
+def get_app_dir(app_name: str, roaming: bool = True, force_posix: bool = False) -> str:
     r"""Returns the config folder for the application.  The default behavior
     is to return whatever is most appropriate for the operating system.

@@ -392,13 +415,9 @@
       ``~/.config/foo-bar``
     Unix (POSIX):
       ``~/.foo-bar``
-    Win XP (roaming):
-      ``C:\Documents and Settings\<user>\Local Settings\Application Data\Foo Bar``
-    Win XP (not roaming):
-      ``C:\Documents and Settings\<user>\Application Data\Foo Bar``
-    Win 7 (roaming):
+    Windows (roaming):
       ``C:\Users\<user>\AppData\Roaming\Foo Bar``
-    Win 7 (not roaming):
+    Windows (not roaming):
       ``C:\Users\<user>\AppData\Local\Foo Bar``

     .. versionadded:: 2.0
@@ -419,7 +438,7 @@
             folder = os.path.expanduser("~")
         return os.path.join(folder, app_name)
     if force_posix:
-        return os.path.join(os.path.expanduser("~/.{}".format(_posixify(app_name))))
+        return os.path.join(os.path.expanduser(f"~/.{_posixify(app_name)}"))
     if sys.platform == "darwin":
         return os.path.join(
             os.path.expanduser("~/Library/Application Support"), app_name
@@ -430,7 +449,7 @@
     )


-class PacifyFlushWrapper(object):
+class PacifyFlushWrapper:
     """This wrapper is used to catch and suppress BrokenPipeErrors resulting
     from ``.flush()`` being called on broken pipe during the shutdown/final-GC
     of the Python interpreter. Notably ``.flush()`` is always called on
@@ -439,17 +458,123 @@
     pipe, all calls and attributes are proxied.
     """

-    def __init__(self, wrapped):
+    def __init__(self, wrapped: t.IO) -> None:
         self.wrapped = wrapped

-    def flush(self):
+    def flush(self) -> None:
         try:
             self.wrapped.flush()
-        except IOError as e:
+        except OSError as e:
             import errno

             if e.errno != errno.EPIPE:
                 raise

-    def __getattr__(self, attr):
+    def __getattr__(self, attr: str) -> t.Any:
         return getattr(self.wrapped, attr)
+
+
+def _detect_program_name(
+    path: t.Optional[str] = None, _main: t.Optional[ModuleType] = None
+) -> str:
+    """Determine the command used to run the program, for use in help
+    text. If a file or entry point was executed, the file name is
+    returned. If ``python -m`` was used to execute a module or package,
+    ``python -m name`` is returned.
+
+    This doesn't try to be too precise, the goal is to give a concise
+    name for help text. Files are only shown as their name without the
+    path. ``python`` is only shown for modules, and the full path to
+    ``sys.executable`` is not shown.
+
+    :param path: The Python file being executed. Python puts this in
+        ``sys.argv[0]``, which is used by default.
+    :param _main: The ``__main__`` module. This should only be passed
+        during internal testing.
+
+    .. versionadded:: 8.0
+        Based on command args detection in the Werkzeug reloader.
+
+    :meta private:
+    """
+    if _main is None:
+        _main = sys.modules["__main__"]
+
+    if not path:
+        path = sys.argv[0]
+
+    # The value of __package__ indicates how Python was called. It may
+    # not exist if a setuptools script is installed as an egg. It may be
+    # set incorrectly for entry points created with pip on Windows.
+    if getattr(_main, "__package__", None) is None or (
+        os.name == "nt"
+        and _main.__package__ == ""
+        and not os.path.exists(path)
+        and os.path.exists(f"{path}.exe")
+    ):
+        # Executed a file, like "python app.py".
+        return os.path.basename(path)
+
+    # Executed a module, like "python -m example".
+    # Rewritten by Python from "-m script" to "/path/to/script.py".
+    # Need to look at main module to determine how it was executed.
+    py_module = t.cast(str, _main.__package__)
+    name = os.path.splitext(os.path.basename(path))[0]
+
+    # A submodule like "example.cli".
+    if name != "__main__":
+        py_module = f"{py_module}.{name}"
+
+    return f"python -m {py_module.lstrip('.')}"
+
+
+def _expand_args(
+    args: t.Iterable[str],
+    *,
+    user: bool = True,
+    env: bool = True,
+    glob_recursive: bool = True,
+) -> t.List[str]:
+    """Simulate Unix shell expansion with Python functions.
+
+    See :func:`glob.glob`, :func:`os.path.expanduser`, and
+    :func:`os.path.expandvars`.
+
+    This is intended for use on Windows, where the shell does not do any
+    expansion. It may not exactly match what a Unix shell would do.
+
+    :param args: List of command line arguments to expand.
+    :param user: Expand user home directory.
+    :param env: Expand environment variables.
+    :param glob_recursive: ``**`` matches directories recursively.
+
+    .. versionchanged:: 8.1
+        Invalid glob patterns are treated as empty expansions rather
+        than raising an error.
+
+    .. versionadded:: 8.0
+
+    :meta private:
+    """
+    from glob import glob
+
+    out = []
+
+    for arg in args:
+        if user:
+            arg = os.path.expanduser(arg)
+
+        if env:
+            arg = os.path.expandvars(arg)
+
+        try:
+            matches = glob(arg, recursive=glob_recursive)
+        except re.error:
+            matches = []
+
+        if not matches:
+            out.append(arg)
+        else:
+            out.extend(matches)
+
+    return out
('src/click', 'exceptions.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,45 +1,46 @@
-from ._compat import filename_to_ui
+import os
+import typing as t
+from gettext import gettext as _
+from gettext import ngettext
+
 from ._compat import get_text_stderr
-from ._compat import PY2
 from .utils import echo

-
-def _join_param_hints(param_hint):
-    if isinstance(param_hint, (tuple, list)):
+if t.TYPE_CHECKING:
+    from .core import Context
+    from .core import Parameter
+
+
+def _join_param_hints(
+    param_hint: t.Optional[t.Union[t.Sequence[str], str]]
+) -> t.Optional[str]:
+    if param_hint is not None and not isinstance(param_hint, str):
         return " / ".join(repr(x) for x in param_hint)
+
     return param_hint


 class ClickException(Exception):
     """An exception that Click can handle and show to the user."""

-    #: The exit code for this exception
+    #: The exit code for this exception.
     exit_code = 1

-    def __init__(self, message):
-        ctor_msg = message
-        if PY2:
-            if ctor_msg is not None:
-                ctor_msg = ctor_msg.encode("utf-8")
-        Exception.__init__(self, ctor_msg)
+    def __init__(self, message: str) -> None:
+        super().__init__(message)
         self.message = message

-    def format_message(self):
+    def format_message(self) -> str:
         return self.message

-    def __str__(self):
+    def __str__(self) -> str:
         return self.message

-    if PY2:
-        __unicode__ = __str__
-
-        def __str__(self):
-            return self.message.encode("utf-8")
-
-    def show(self, file=None):
+    def show(self, file: t.Optional[t.IO] = None) -> None:
         if file is None:
             file = get_text_stderr()
-        echo("Error: {}".format(self.format_message(), file=file))
+
+        echo(_("Error: {message}").format(message=self.format_message()), file=file)


 class UsageError(ClickException):
@@ -53,24 +54,32 @@

     exit_code = 2

-    def __init__(self, message, ctx=None):
-        ClickException.__init__(self, message)
+    def __init__(self, message: str, ctx: t.Optional["Context"] = None) -> None:
+        super().__init__(message)
         self.ctx = ctx
         self.cmd = self.ctx.command if self.ctx else None

-    def show(self, file=None):
+    def show(self, file: t.Optional[t.IO] = None) -> None:
         if file is None:
             file = get_text_stderr()
         color = None
         hint = ""
-        if self.cmd is not None and self.cmd.get_help_option(self.ctx) is not None:
-            hint = "Try '{} {}' for help.\n".format(
-                self.ctx.command_path, self.ctx.help_option_names[0]
+        if (
+            self.ctx is not None
+            and self.ctx.command.get_help_option(self.ctx) is not None
+        ):
+            hint = _("Try '{command} {option}' for help.").format(
+                command=self.ctx.command_path, option=self.ctx.help_option_names[0]
             )
+            hint = f"{hint}\n"
         if self.ctx is not None:
             color = self.ctx.color
-            echo("{}\n{}".format(self.ctx.get_usage(), hint), file=file, color=color)
-        echo("Error: {}".format(self.format_message()), file=file, color=color)
+            echo(f"{self.ctx.get_usage()}\n{hint}", file=file, color=color)
+        echo(
+            _("Error: {message}").format(message=self.format_message()),
+            file=file,
+            color=color,
+        )


 class BadParameter(UsageError):
@@ -91,21 +100,28 @@
                        each item is quoted and separated.
     """

-    def __init__(self, message, ctx=None, param=None, param_hint=None):
-        UsageError.__init__(self, message, ctx)
+    def __init__(
+        self,
+        message: str,
+        ctx: t.Optional["Context"] = None,
+        param: t.Optional["Parameter"] = None,
+        param_hint: t.Optional[str] = None,
+    ) -> None:
+        super().__init__(message, ctx)
         self.param = param
         self.param_hint = param_hint

-    def format_message(self):
+    def format_message(self) -> str:
         if self.param_hint is not None:
             param_hint = self.param_hint
         elif self.param is not None:
-            param_hint = self.param.get_error_hint(self.ctx)
-        else:
-            return "Invalid value: {}".format(self.message)
-        param_hint = _join_param_hints(param_hint)
-
-        return "Invalid value for {}: {}".format(param_hint, self.message)
+            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore
+        else:
+            return _("Invalid value: {message}").format(message=self.message)
+
+        return _("Invalid value for {param_hint}: {message}").format(
+            param_hint=_join_param_hints(param_hint), message=self.message
+        )


 class MissingParameter(BadParameter):
@@ -121,19 +137,26 @@
     """

     def __init__(
-        self, message=None, ctx=None, param=None, param_hint=None, param_type=None
-    ):
-        BadParameter.__init__(self, message, ctx, param, param_hint)
+        self,
+        message: t.Optional[str] = None,
+        ctx: t.Optional["Context"] = None,
+        param: t.Optional["Parameter"] = None,
+        param_hint: t.Optional[str] = None,
+        param_type: t.Optional[str] = None,
+    ) -> None:
+        super().__init__(message or "", ctx, param, param_hint)
         self.param_type = param_type

-    def format_message(self):
+    def format_message(self) -> str:
         if self.param_hint is not None:
-            param_hint = self.param_hint
+            param_hint: t.Optional[str] = self.param_hint
         elif self.param is not None:
-            param_hint = self.param.get_error_hint(self.ctx)
+            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore
         else:
             param_hint = None
+
         param_hint = _join_param_hints(param_hint)
+        param_hint = f" {param_hint}" if param_hint else ""

         param_type = self.param_type
         if param_type is None and self.param is not None:
@@ -144,29 +167,30 @@
             msg_extra = self.param.type.get_missing_message(self.param)
             if msg_extra:
                 if msg:
-                    msg += ".  {}".format(msg_extra)
+                    msg += f". {msg_extra}"
                 else:
                     msg = msg_extra

-        return "Missing {}{}{}{}".format(
-            param_type,
-            " {}".format(param_hint) if param_hint else "",
-            ".  " if msg else ".",
-            msg or "",
-        )
-
-    def __str__(self):
-        if self.message is None:
+        msg = f" {msg}" if msg else ""
+
+        # Translate param_type for known types.
+        if param_type == "argument":
+            missing = _("Missing argument")
+        elif param_type == "option":
+            missing = _("Missing option")
+        elif param_type == "parameter":
+            missing = _("Missing parameter")
+        else:
+            missing = _("Missing {param_type}").format(param_type=param_type)
+
+        return f"{missing}{param_hint}.{msg}"
+
+    def __str__(self) -> str:
+        if not self.message:
             param_name = self.param.name if self.param else None
-            return "missing parameter: {}".format(param_name)
+            return _("Missing parameter: {param_name}").format(param_name=param_name)
         else:
             return self.message
-
-    if PY2:
-        __unicode__ = __str__
-
-        def __str__(self):
-            return self.__unicode__().encode("utf-8")


 class NoSuchOption(UsageError):
@@ -176,22 +200,31 @@
     .. versionadded:: 4.0
     """

-    def __init__(self, option_name, message=None, possibilities=None, ctx=None):
+    def __init__(
+        self,
+        option_name: str,
+        message: t.Optional[str] = None,
+        possibilities: t.Optional[t.Sequence[str]] = None,
+        ctx: t.Optional["Context"] = None,
+    ) -> None:
         if message is None:
-            message = "no such option: {}".format(option_name)
-        UsageError.__init__(self, message, ctx)
+            message = _("No such option: {name}").format(name=option_name)
+
+        super().__init__(message, ctx)
         self.option_name = option_name
         self.possibilities = possibilities

-    def format_message(self):
-        bits = [self.message]
-        if self.possibilities:
-            if len(self.possibilities) == 1:
-                bits.append("Did you mean {}?".format(self.possibilities[0]))
-            else:
-                possibilities = sorted(self.possibilities)
-                bits.append("(Possible options: {})".format(", ".join(possibilities)))
-        return "  ".join(bits)
+    def format_message(self) -> str:
+        if not self.possibilities:
+            return self.message
+
+        possibility_str = ", ".join(sorted(self.possibilities))
+        suggest = ngettext(
+            "Did you mean {possibility}?",
+            "(Possible options: {possibilities})",
+            len(self.possibilities),
+        ).format(possibility=possibility_str, possibilities=possibility_str)
+        return f"{self.message} {suggest}"


 class BadOptionUsage(UsageError):
@@ -204,8 +237,10 @@
     :param option_name: the name of the option being used incorrectly.
     """

-    def __init__(self, option_name, message, ctx=None):
-        UsageError.__init__(self, message, ctx)
+    def __init__(
+        self, option_name: str, message: str, ctx: t.Optional["Context"] = None
+    ) -> None:
+        super().__init__(message, ctx)
         self.option_name = option_name


@@ -217,23 +252,22 @@
     .. versionadded:: 6.0
     """

-    def __init__(self, message, ctx=None):
-        UsageError.__init__(self, message, ctx)
-

 class FileError(ClickException):
     """Raised if a file cannot be opened."""

-    def __init__(self, filename, hint=None):
-        ui_filename = filename_to_ui(filename)
+    def __init__(self, filename: str, hint: t.Optional[str] = None) -> None:
         if hint is None:
-            hint = "unknown error"
-        ClickException.__init__(self, hint)
-        self.ui_filename = ui_filename
+            hint = _("unknown error")
+
+        super().__init__(hint)
+        self.ui_filename = os.fsdecode(filename)
         self.filename = filename

-    def format_message(self):
-        return "Could not open file {}: {}".format(self.ui_filename, self.message)
+    def format_message(self) -> str:
+        return _("Could not open file {filename!r}: {message}").format(
+            filename=self.ui_filename, message=self.message
+        )


 class Abort(RuntimeError):
@@ -249,5 +283,5 @@

     __slots__ = ("exit_code",)

-    def __init__(self, code=0):
+    def __init__(self, code: int = 0) -> None:
         self.exit_code = code
('src/click', '_compat.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,12 +1,11 @@
-# flake8: noqa
 import codecs
 import io
 import os
 import re
 import sys
+import typing as t
 from weakref import WeakKeyDictionary

-PY2 = sys.version_info[0] == 2
 CYGWIN = sys.platform.startswith("cygwin")
 MSYS2 = sys.platform.startswith("win") and ("GCC" in sys.version)
 # Determine local App Engine environment, per Google's own suggestion
@@ -14,19 +13,21 @@
     "SERVER_SOFTWARE", ""
 )
 WIN = sys.platform.startswith("win") and not APP_ENGINE and not MSYS2
-DEFAULT_COLUMNS = 80
-
-
+auto_wrap_for_ansi: t.Optional[t.Callable[[t.TextIO], t.TextIO]] = None
 _ansi_re = re.compile(r"\033\[[;?0-9]*[a-zA-Z]")


-def get_filesystem_encoding():
+def get_filesystem_encoding() -> str:
     return sys.getfilesystemencoding() or sys.getdefaultencoding()


 def _make_text_stream(
-    stream, encoding, errors, force_readable=False, force_writable=False
-):
+    stream: t.BinaryIO,
+    encoding: t.Optional[str],
+    errors: t.Optional[str],
+    force_readable: bool = False,
+    force_writable: bool = False,
+) -> t.TextIO:
     if encoding is None:
         encoding = get_best_encoding(stream)
     if errors is None:
@@ -41,7 +42,7 @@
     )


-def is_ascii_encoding(encoding):
+def is_ascii_encoding(encoding: str) -> bool:
     """Checks if a given encoding is ascii."""
     try:
         return codecs.lookup(encoding).name == "ascii"
@@ -49,7 +50,7 @@
         return False


-def get_best_encoding(stream):
+def get_best_encoding(stream: t.IO) -> str:
     """Returns the default stream encoding if not found."""
     rv = getattr(stream, "encoding", None) or sys.getdefaultencoding()
     if is_ascii_encoding(rv):
@@ -60,46 +61,30 @@
 class _NonClosingTextIOWrapper(io.TextIOWrapper):
     def __init__(
         self,
-        stream,
-        encoding,
-        errors,
-        force_readable=False,
-        force_writable=False,
-        **extra
-    ):
-        self._stream = stream = _FixupStream(stream, force_readable, force_writable)
-        io.TextIOWrapper.__init__(self, stream, encoding, errors, **extra)
-
-    # The io module is a place where the Python 3 text behavior
-    # was forced upon Python 2, so we need to unbreak
-    # it to look like Python 2.
-    if PY2:
-
-        def write(self, x):
-            if isinstance(x, str) or is_bytes(x):
-                try:
-                    self.flush()
-                except Exception:
-                    pass
-                return self.buffer.write(str(x))
-            return io.TextIOWrapper.write(self, x)
-
-        def writelines(self, lines):
-            for line in lines:
-                self.write(line)
-
-    def __del__(self):
+        stream: t.BinaryIO,
+        encoding: t.Optional[str],
+        errors: t.Optional[str],
+        force_readable: bool = False,
+        force_writable: bool = False,
+        **extra: t.Any,
+    ) -> None:
+        self._stream = stream = t.cast(
+            t.BinaryIO, _FixupStream(stream, force_readable, force_writable)
+        )
+        super().__init__(stream, encoding, errors, **extra)
+
+    def __del__(self) -> None:
         try:
             self.detach()
         except Exception:
             pass

-    def isatty(self):
+    def isatty(self) -> bool:
         # https://bitbucket.org/pypy/pypy/issue/1803
         return self._stream.isatty()


-class _FixupStream(object):
+class _FixupStream:
     """The new io interface needs more from streams than streams
     traditionally implement.  As such, this fix-up code is necessary in
     some circumstances.
@@ -109,45 +94,47 @@
     of jupyter notebook).
     """

-    def __init__(self, stream, force_readable=False, force_writable=False):
+    def __init__(
+        self,
+        stream: t.BinaryIO,
+        force_readable: bool = False,
+        force_writable: bool = False,
+    ):
         self._stream = stream
         self._force_readable = force_readable
         self._force_writable = force_writable

-    def __getattr__(self, name):
+    def __getattr__(self, name: str) -> t.Any:
         return getattr(self._stream, name)

-    def read1(self, size):
+    def read1(self, size: int) -> bytes:
         f = getattr(self._stream, "read1", None)
+
         if f is not None:
-            return f(size)
-        # We only dispatch to readline instead of read in Python 2 as we
-        # do not want cause problems with the different implementation
-        # of line buffering.
-        if PY2:
-            return self._stream.readline(size)
+            return t.cast(bytes, f(size))
+
         return self._stream.read(size)

-    def readable(self):
+    def readable(self) -> bool:
         if self._force_readable:
             return True
         x = getattr(self._stream, "readable", None)
         if x is not None:
-            return x()
+            return t.cast(bool, x())
         try:
             self._stream.read(0)
         except Exception:
             return False
         return True

-    def writable(self):
+    def writable(self) -> bool:
         if self._force_writable:
             return True
         x = getattr(self._stream, "writable", None)
         if x is not None:
-            return x()
-        try:
-            self._stream.write("")
+            return t.cast(bool, x())
+        try:
+            self._stream.write("")  # type: ignore
         except Exception:
             try:
                 self._stream.write(b"")
@@ -155,10 +142,10 @@
                 return False
         return True

-    def seekable(self):
+    def seekable(self) -> bool:
         x = getattr(self._stream, "seekable", None)
         if x is not None:
-            return x()
+            return t.cast(bool, x())
         try:
             self._stream.seek(self._stream.tell())
         except Exception:
@@ -166,360 +153,244 @@
         return True


-if PY2:
-    text_type = unicode
-    raw_input = raw_input
-    string_types = (str, unicode)
-    int_types = (int, long)
-    iteritems = lambda x: x.iteritems()
-    range_type = xrange
-
-    from pipes import quote as shlex_quote
-
-    def is_bytes(x):
-        return isinstance(x, (buffer, bytearray))
-
-    _identifier_re = re.compile(r"^[a-zA-Z_][a-zA-Z0-9_]*$")
-
-    # For Windows, we need to force stdout/stdin/stderr to binary if it's
-    # fetched for that.  This obviously is not the most correct way to do
-    # it as it changes global state.  Unfortunately, there does not seem to
-    # be a clear better way to do it as just reopening the file in binary
-    # mode does not change anything.
-    #
-    # An option would be to do what Python 3 does and to open the file as
-    # binary only, patch it back to the system, and then use a wrapper
-    # stream that converts newlines.  It's not quite clear what's the
-    # correct option here.
-    #
-    # This code also lives in _winconsole for the fallback to the console
-    # emulation stream.
-    #
-    # There are also Windows environments where the `msvcrt` module is not
-    # available (which is why we use try-catch instead of the WIN variable
-    # here), such as the Google App Engine development server on Windows. In
-    # those cases there is just nothing we can do.
-    def set_binary_mode(f):
-        return f
-
+def _is_binary_reader(stream: t.IO, default: bool = False) -> bool:
     try:
-        import msvcrt
-    except ImportError:
-        pass
+        return isinstance(stream.read(0), bytes)
+    except Exception:
+        return default
+        # This happens in some cases where the stream was already
+        # closed.  In this case, we assume the default.
+
+
+def _is_binary_writer(stream: t.IO, default: bool = False) -> bool:
+    try:
+        stream.write(b"")
+    except Exception:
+        try:
+            stream.write("")
+            return False
+        except Exception:
+            pass
+        return default
+    return True
+
+
+def _find_binary_reader(stream: t.IO) -> t.Optional[t.BinaryIO]:
+    # We need to figure out if the given stream is already binary.
+    # This can happen because the official docs recommend detaching
+    # the streams to get binary streams.  Some code might do this, so
+    # we need to deal with this case explicitly.
+    if _is_binary_reader(stream, False):
+        return t.cast(t.BinaryIO, stream)
+
+    buf = getattr(stream, "buffer", None)
+
+    # Same situation here; this time we assume that the buffer is
+    # actually binary in case it's closed.
+    if buf is not None and _is_binary_reader(buf, True):
+        return t.cast(t.BinaryIO, buf)
+
+    return None
+
+
+def _find_binary_writer(stream: t.IO) -> t.Optional[t.BinaryIO]:
+    # We need to figure out if the given stream is already binary.
+    # This can happen because the official docs recommend detaching
+    # the streams to get binary streams.  Some code might do this, so
+    # we need to deal with this case explicitly.
+    if _is_binary_writer(stream, False):
+        return t.cast(t.BinaryIO, stream)
+
+    buf = getattr(stream, "buffer", None)
+
+    # Same situation here; this time we assume that the buffer is
+    # actually binary in case it's closed.
+    if buf is not None and _is_binary_writer(buf, True):
+        return t.cast(t.BinaryIO, buf)
+
+    return None
+
+
+def _stream_is_misconfigured(stream: t.TextIO) -> bool:
+    """A stream is misconfigured if its encoding is ASCII."""
+    # If the stream does not have an encoding set, we assume it's set
+    # to ASCII.  This appears to happen in certain unittest
+    # environments.  It's not quite clear what the correct behavior is
+    # but this at least will force Click to recover somehow.
+    return is_ascii_encoding(getattr(stream, "encoding", None) or "ascii")
+
+
+def _is_compat_stream_attr(stream: t.TextIO, attr: str, value: t.Optional[str]) -> bool:
+    """A stream attribute is compatible if it is equal to the
+    desired value or the desired value is unset and the attribute
+    has a value.
+    """
+    stream_value = getattr(stream, attr, None)
+    return stream_value == value or (value is None and stream_value is not None)
+
+
+def _is_compatible_text_stream(
+    stream: t.TextIO, encoding: t.Optional[str], errors: t.Optional[str]
+) -> bool:
+    """Check if a stream's encoding and errors attributes are
+    compatible with the desired values.
+    """
+    return _is_compat_stream_attr(
+        stream, "encoding", encoding
+    ) and _is_compat_stream_attr(stream, "errors", errors)
+
+
+def _force_correct_text_stream(
+    text_stream: t.IO,
+    encoding: t.Optional[str],
+    errors: t.Optional[str],
+    is_binary: t.Callable[[t.IO, bool], bool],
+    find_binary: t.Callable[[t.IO], t.Optional[t.BinaryIO]],
+    force_readable: bool = False,
+    force_writable: bool = False,
+) -> t.TextIO:
+    if is_binary(text_stream, False):
+        binary_reader = t.cast(t.BinaryIO, text_stream)
     else:
-
-        def set_binary_mode(f):
-            try:
-                fileno = f.fileno()
-            except Exception:
-                pass
-            else:
-                msvcrt.setmode(fileno, os.O_BINARY)
-            return f
-
-    try:
-        import fcntl
-    except ImportError:
-        pass
-    else:
-
-        def set_binary_mode(f):
-            try:
-                fileno = f.fileno()
-            except Exception:
-                pass
-            else:
-                flags = fcntl.fcntl(fileno, fcntl.F_GETFL)
-                fcntl.fcntl(fileno, fcntl.F_SETFL, flags & ~os.O_NONBLOCK)
-            return f
-
-    def isidentifier(x):
-        return _identifier_re.search(x) is not None
-
-    def get_binary_stdin():
-        return set_binary_mode(sys.stdin)
-
-    def get_binary_stdout():
-        _wrap_std_stream("stdout")
-        return set_binary_mode(sys.stdout)
-
-    def get_binary_stderr():
-        _wrap_std_stream("stderr")
-        return set_binary_mode(sys.stderr)
-
-    def get_text_stdin(encoding=None, errors=None):
-        rv = _get_windows_console_stream(sys.stdin, encoding, errors)
-        if rv is not None:
-            return rv
-        return _make_text_stream(sys.stdin, encoding, errors, force_readable=True)
-
-    def get_text_stdout(encoding=None, errors=None):
-        _wrap_std_stream("stdout")
-        rv = _get_windows_console_stream(sys.stdout, encoding, errors)
-        if rv is not None:
-            return rv
-        return _make_text_stream(sys.stdout, encoding, errors, force_writable=True)
-
-    def get_text_stderr(encoding=None, errors=None):
-        _wrap_std_stream("stderr")
-        rv = _get_windows_console_stream(sys.stderr, encoding, errors)
-        if rv is not None:
-            return rv
-        return _make_text_stream(sys.stderr, encoding, errors, force_writable=True)
-
-    def filename_to_ui(value):
-        if isinstance(value, bytes):
-            value = value.decode(get_filesystem_encoding(), "replace")
-        return value
-
-
-else:
-    import io
-
-    text_type = str
-    raw_input = input
-    string_types = (str,)
-    int_types = (int,)
-    range_type = range
-    isidentifier = lambda x: x.isidentifier()
-    iteritems = lambda x: iter(x.items())
-
-    from shlex import quote as shlex_quote
-
-    def is_bytes(x):
-        return isinstance(x, (bytes, memoryview, bytearray))
-
-    def _is_binary_reader(stream, default=False):
-        try:
-            return isinstance(stream.read(0), bytes)
-        except Exception:
-            return default
-            # This happens in some cases where the stream was already
-            # closed.  In this case, we assume the default.
-
-    def _is_binary_writer(stream, default=False):
-        try:
-            stream.write(b"")
-        except Exception:
-            try:
-                stream.write("")
-                return False
-            except Exception:
-                pass
-            return default
-        return True
-
-    def _find_binary_reader(stream):
-        # We need to figure out if the given stream is already binary.
-        # This can happen because the official docs recommend detaching
-        # the streams to get binary streams.  Some code might do this, so
-        # we need to deal with this case explicitly.
-        if _is_binary_reader(stream, False):
-            return stream
-
-        buf = getattr(stream, "buffer", None)
-
-        # Same situation here; this time we assume that the buffer is
-        # actually binary in case it's closed.
-        if buf is not None and _is_binary_reader(buf, True):
-            return buf
-
-    def _find_binary_writer(stream):
-        # We need to figure out if the given stream is already binary.
-        # This can happen because the official docs recommend detatching
-        # the streams to get binary streams.  Some code might do this, so
-        # we need to deal with this case explicitly.
-        if _is_binary_writer(stream, False):
-            return stream
-
-        buf = getattr(stream, "buffer", None)
-
-        # Same situation here; this time we assume that the buffer is
-        # actually binary in case it's closed.
-        if buf is not None and _is_binary_writer(buf, True):
-            return buf
-
-    def _stream_is_misconfigured(stream):
-        """A stream is misconfigured if its encoding is ASCII."""
-        # If the stream does not have an encoding set, we assume it's set
-        # to ASCII.  This appears to happen in certain unittest
-        # environments.  It's not quite clear what the correct behavior is
-        # but this at least will force Click to recover somehow.
-        return is_ascii_encoding(getattr(stream, "encoding", None) or "ascii")
-
-    def _is_compat_stream_attr(stream, attr, value):
-        """A stream attribute is compatible if it is equal to the
-        desired value or the desired value is unset and the attribute
-        has a value.
-        """
-        stream_value = getattr(stream, attr, None)
-        return stream_value == value or (value is None and stream_value is not None)
-
-    def _is_compatible_text_stream(stream, encoding, errors):
-        """Check if a stream's encoding and errors attributes are
-        compatible with the desired values.
-        """
-        return _is_compat_stream_attr(
-            stream, "encoding", encoding
-        ) and _is_compat_stream_attr(stream, "errors", errors)
-
-    def _force_correct_text_stream(
-        text_stream,
+        text_stream = t.cast(t.TextIO, text_stream)
+        # If the stream looks compatible, and won't default to a
+        # misconfigured ascii encoding, return it as-is.
+        if _is_compatible_text_stream(text_stream, encoding, errors) and not (
+            encoding is None and _stream_is_misconfigured(text_stream)
+        ):
+            return text_stream
+
+        # Otherwise, get the underlying binary reader.
+        possible_binary_reader = find_binary(text_stream)
+
+        # If that's not possible, silently use the original reader
+        # and get mojibake instead of exceptions.
+        if possible_binary_reader is None:
+            return text_stream
+
+        binary_reader = possible_binary_reader
+
+    # Default errors to replace instead of strict in order to get
+    # something that works.
+    if errors is None:
+        errors = "replace"
+
+    # Wrap the binary stream in a text stream with the correct
+    # encoding parameters.
+    return _make_text_stream(
+        binary_reader,
         encoding,
         errors,
-        is_binary,
-        find_binary,
-        force_readable=False,
-        force_writable=False,
-    ):
-        if is_binary(text_stream, False):
-            binary_reader = text_stream
-        else:
-            # If the stream looks compatible, and won't default to a
-            # misconfigured ascii encoding, return it as-is.
-            if _is_compatible_text_stream(text_stream, encoding, errors) and not (
-                encoding is None and _stream_is_misconfigured(text_stream)
-            ):
-                return text_stream
-
-            # Otherwise, get the underlying binary reader.
-            binary_reader = find_binary(text_stream)
-
-            # If that's not possible, silently use the original reader
-            # and get mojibake instead of exceptions.
-            if binary_reader is None:
-                return text_stream
-
-        # Default errors to replace instead of strict in order to get
-        # something that works.
-        if errors is None:
-            errors = "replace"
-
-        # Wrap the binary stream in a text stream with the correct
-        # encoding parameters.
-        return _make_text_stream(
-            binary_reader,
-            encoding,
-            errors,
-            force_readable=force_readable,
-            force_writable=force_writable,
-        )
-
-    def _force_correct_text_reader(text_reader, encoding, errors, force_readable=False):
-        return _force_correct_text_stream(
-            text_reader,
-            encoding,
-            errors,
-            _is_binary_reader,
-            _find_binary_reader,
-            force_readable=force_readable,
-        )
-
-    def _force_correct_text_writer(text_writer, encoding, errors, force_writable=False):
-        return _force_correct_text_stream(
-            text_writer,
-            encoding,
-            errors,
-            _is_binary_writer,
-            _find_binary_writer,
-            force_writable=force_writable,
-        )
-
-    def get_binary_stdin():
-        reader = _find_binary_reader(sys.stdin)
-        if reader is None:
-            raise RuntimeError("Was not able to determine binary stream for sys.stdin.")
-        return reader
-
-    def get_binary_stdout():
-        writer = _find_binary_writer(sys.stdout)
-        if writer is None:
-            raise RuntimeError(
-                "Was not able to determine binary stream for sys.stdout."
-            )
-        return writer
-
-    def get_binary_stderr():
-        writer = _find_binary_writer(sys.stderr)
-        if writer is None:
-            raise RuntimeError(
-                "Was not able to determine binary stream for sys.stderr."
-            )
-        return writer
-
-    def get_text_stdin(encoding=None, errors=None):
-        rv = _get_windows_console_stream(sys.stdin, encoding, errors)
-        if rv is not None:
-            return rv
-        return _force_correct_text_reader(
-            sys.stdin, encoding, errors, force_readable=True
-        )
-
-    def get_text_stdout(encoding=None, errors=None):
-        rv = _get_windows_console_stream(sys.stdout, encoding, errors)
-        if rv is not None:
-            return rv
-        return _force_correct_text_writer(
-            sys.stdout, encoding, errors, force_writable=True
-        )
-
-    def get_text_stderr(encoding=None, errors=None):
-        rv = _get_windows_console_stream(sys.stderr, encoding, errors)
-        if rv is not None:
-            return rv
-        return _force_correct_text_writer(
-            sys.stderr, encoding, errors, force_writable=True
-        )
-
-    def filename_to_ui(value):
-        if isinstance(value, bytes):
-            value = value.decode(get_filesystem_encoding(), "replace")
-        else:
-            value = value.encode("utf-8", "surrogateescape").decode("utf-8", "replace")
-        return value
-
-
-def get_streerror(e, default=None):
-    if hasattr(e, "strerror"):
-        msg = e.strerror
-    else:
-        if default is not None:
-            msg = default
-        else:
-            msg = str(e)
-    if isinstance(msg, bytes):
-        msg = msg.decode("utf-8", "replace")
-    return msg
-
-
-def _wrap_io_open(file, mode, encoding, errors):
-    """On Python 2, :func:`io.open` returns a text file wrapper that
-    requires passing ``unicode`` to ``write``. Need to open the file in
-    binary mode then wrap it in a subclass that can write ``str`` and
-    ``unicode``.
-
-    Also handles not passing ``encoding`` and ``errors`` in binary mode.
-    """
+        force_readable=force_readable,
+        force_writable=force_writable,
+    )
+
+
+def _force_correct_text_reader(
+    text_reader: t.IO,
+    encoding: t.Optional[str],
+    errors: t.Optional[str],
+    force_readable: bool = False,
+) -> t.TextIO:
+    return _force_correct_text_stream(
+        text_reader,
+        encoding,
+        errors,
+        _is_binary_reader,
+        _find_binary_reader,
+        force_readable=force_readable,
+    )
+
+
+def _force_correct_text_writer(
+    text_writer: t.IO,
+    encoding: t.Optional[str],
+    errors: t.Optional[str],
+    force_writable: bool = False,
+) -> t.TextIO:
+    return _force_correct_text_stream(
+        text_writer,
+        encoding,
+        errors,
+        _is_binary_writer,
+        _find_binary_writer,
+        force_writable=force_writable,
+    )
+
+
+def get_binary_stdin() -> t.BinaryIO:
+    reader = _find_binary_reader(sys.stdin)
+    if reader is None:
+        raise RuntimeError("Was not able to determine binary stream for sys.stdin.")
+    return reader
+
+
+def get_binary_stdout() -> t.BinaryIO:
+    writer = _find_binary_writer(sys.stdout)
+    if writer is None:
+        raise RuntimeError("Was not able to determine binary stream for sys.stdout.")
+    return writer
+
+
+def get_binary_stderr() -> t.BinaryIO:
+    writer = _find_binary_writer(sys.stderr)
+    if writer is None:
+        raise RuntimeError("Was not able to determine binary stream for sys.stderr.")
+    return writer
+
+
+def get_text_stdin(
+    encoding: t.Optional[str] = None, errors: t.Optional[str] = None
+) -> t.TextIO:
+    rv = _get_windows_console_stream(sys.stdin, encoding, errors)
+    if rv is not None:
+        return rv
+    return _force_correct_text_reader(sys.stdin, encoding, errors, force_readable=True)
+
+
+def get_text_stdout(
+    encoding: t.Optional[str] = None, errors: t.Optional[str] = None
+) -> t.TextIO:
+    rv = _get_windows_console_stream(sys.stdout, encoding, errors)
+    if rv is not None:
+        return rv
+    return _force_correct_text_writer(sys.stdout, encoding, errors, force_writable=True)
+
+
+def get_text_stderr(
+    encoding: t.Optional[str] = None, errors: t.Optional[str] = None
+) -> t.TextIO:
+    rv = _get_windows_console_stream(sys.stderr, encoding, errors)
+    if rv is not None:
+        return rv
+    return _force_correct_text_writer(sys.stderr, encoding, errors, force_writable=True)
+
+
+def _wrap_io_open(
+    file: t.Union[str, os.PathLike, int],
+    mode: str,
+    encoding: t.Optional[str],
+    errors: t.Optional[str],
+) -> t.IO:
+    """Handles not passing ``encoding`` and ``errors`` in binary mode."""
+    if "b" in mode:
+        return open(file, mode)
+
+    return open(file, mode, encoding=encoding, errors=errors)
+
+
+def open_stream(
+    filename: str,
+    mode: str = "r",
+    encoding: t.Optional[str] = None,
+    errors: t.Optional[str] = "strict",
+    atomic: bool = False,
+) -> t.Tuple[t.IO, bool]:
     binary = "b" in mode

-    if binary:
-        kwargs = {}
-    else:
-        kwargs = {"encoding": encoding, "errors": errors}
-
-    if not PY2 or binary:
-        return io.open(file, mode, **kwargs)
-
-    f = io.open(file, "{}b".format(mode.replace("t", "")))
-    return _make_text_stream(f, **kwargs)
-
-
-def open_stream(filename, mode="r", encoding=None, errors="strict", atomic=False):
-    binary = "b" in mode
-
-    # Standard streams first.  These are simple because they don't need
-    # special handling for the atomic flag.  It's entirely ignored.
-    if filename == "-":
+    # Standard streams first. These are simple because they ignore the
+    # atomic flag. Use fsdecode to handle Path("-").
+    if os.fsdecode(filename) == "-":
         if any(m in mode for m in ["w", "a", "x"]):
             if binary:
                 return get_binary_stdout(), False
@@ -553,7 +424,7 @@
     import random

     try:
-        perm = os.stat(filename).st_mode
+        perm: t.Optional[int] = os.stat(filename).st_mode
     except OSError:
         perm = None

@@ -565,7 +436,7 @@
     while True:
         tmp_filename = os.path.join(
             os.path.dirname(filename),
-            ".__atomic-write{:08x}".format(random.randrange(1 << 32)),
+            f".__atomic-write{random.randrange(1 << 32):08x}",
         )
         try:
             fd = os.open(tmp_filename, flags, 0o666 if perm is None else perm)
@@ -584,76 +455,55 @@
         os.chmod(tmp_filename, perm)  # in case perm includes bits in umask

     f = _wrap_io_open(fd, mode, encoding, errors)
-    return _AtomicFile(f, tmp_filename, os.path.realpath(filename)), True
-
-
-# Used in a destructor call, needs extra protection from interpreter cleanup.
-if hasattr(os, "replace"):
-    _replace = os.replace
-    _can_replace = True
-else:
-    _replace = os.rename
-    _can_replace = not WIN
-
-
-class _AtomicFile(object):
-    def __init__(self, f, tmp_filename, real_filename):
+    af = _AtomicFile(f, tmp_filename, os.path.realpath(filename))
+    return t.cast(t.IO, af), True
+
+
+class _AtomicFile:
+    def __init__(self, f: t.IO, tmp_filename: str, real_filename: str) -> None:
         self._f = f
         self._tmp_filename = tmp_filename
         self._real_filename = real_filename
         self.closed = False

     @property
-    def name(self):
+    def name(self) -> str:
         return self._real_filename

-    def close(self, delete=False):
+    def close(self, delete: bool = False) -> None:
         if self.closed:
             return
         self._f.close()
-        if not _can_replace:
-            try:
-                os.remove(self._real_filename)
-            except OSError:
-                pass
-        _replace(self._tmp_filename, self._real_filename)
+        os.replace(self._tmp_filename, self._real_filename)
         self.closed = True

-    def __getattr__(self, name):
+    def __getattr__(self, name: str) -> t.Any:
         return getattr(self._f, name)

-    def __enter__(self):
+    def __enter__(self) -> "_AtomicFile":
         return self

-    def __exit__(self, exc_type, exc_value, tb):
+    def __exit__(self, exc_type, exc_value, tb):  # type: ignore
         self.close(delete=exc_type is not None)

-    def __repr__(self):
+    def __repr__(self) -> str:
         return repr(self._f)


-auto_wrap_for_ansi = None
-colorama = None
-get_winterm_size = None
-
-
-def strip_ansi(value):
+def strip_ansi(value: str) -> str:
     return _ansi_re.sub("", value)


-def _is_jupyter_kernel_output(stream):
-    if WIN:
-        # TODO: Couldn't test on Windows, should't try to support until
-        # someone tests the details wrt colorama.
-        return
-
+def _is_jupyter_kernel_output(stream: t.IO) -> bool:
     while isinstance(stream, (_FixupStream, _NonClosingTextIOWrapper)):
         stream = stream._stream

     return stream.__class__.__module__.startswith("ipykernel.")


-def should_strip_ansi(stream=None, color=None):
+def should_strip_ansi(
+    stream: t.Optional[t.IO] = None, color: t.Optional[bool] = None
+) -> bool:
     if color is None:
         if stream is None:
             stream = sys.stdin
@@ -661,99 +511,84 @@
     return not color


-# If we're on Windows, we provide transparent integration through
-# colorama.  This will make ANSI colors through the echo function
-# work automatically.
-if WIN:
-    # Windows has a smaller terminal
-    DEFAULT_COLUMNS = 79
-
-    from ._winconsole import _get_windows_console_stream, _wrap_std_stream
-
-    def _get_argv_encoding():
+# On Windows, wrap the output streams with colorama to support ANSI
+# color codes.
+# NOTE: double check is needed so mypy does not analyze this on Linux
+if sys.platform.startswith("win") and WIN:
+    from ._winconsole import _get_windows_console_stream
+
+    def _get_argv_encoding() -> str:
         import locale

         return locale.getpreferredencoding()

-    if PY2:
-
-        def raw_input(prompt=""):
-            sys.stderr.flush()
-            if prompt:
-                stdout = _default_text_stdout()
-                stdout.write(prompt)
-            stdin = _default_text_stdin()
-            return stdin.readline().rstrip("\r\n")
-
-    try:
+    _ansi_stream_wrappers: t.MutableMapping[t.TextIO, t.TextIO] = WeakKeyDictionary()
+
+    def auto_wrap_for_ansi(
+        stream: t.TextIO, color: t.Optional[bool] = None
+    ) -> t.TextIO:
+        """Support ANSI color and style codes on Windows by wrapping a
+        stream with colorama.
+        """
+        try:
+            cached = _ansi_stream_wrappers.get(stream)
+        except Exception:
+            cached = None
+
+        if cached is not None:
+            return cached
+
         import colorama
-    except ImportError:
-        pass
-    else:
-        _ansi_stream_wrappers = WeakKeyDictionary()
-
-        def auto_wrap_for_ansi(stream, color=None):
-            """This function wraps a stream so that calls through colorama
-            are issued to the win32 console API to recolor on demand.  It
-            also ensures to reset the colors if a write call is interrupted
-            to not destroy the console afterwards.
-            """
+
+        strip = should_strip_ansi(stream, color)
+        ansi_wrapper = colorama.AnsiToWin32(stream, strip=strip)
+        rv = t.cast(t.TextIO, ansi_wrapper.stream)
+        _write = rv.write
+
+        def _safe_write(s):
             try:
-                cached = _ansi_stream_wrappers.get(stream)
-            except Exception:
-                cached = None
-            if cached is not None:
-                return cached
-            strip = should_strip_ansi(stream, color)
-            ansi_wrapper = colorama.AnsiToWin32(stream, strip=strip)
-            rv = ansi_wrapper.stream
-            _write = rv.write
-
-            def _safe_write(s):
-                try:
-                    return _write(s)
-                except:
-                    ansi_wrapper.reset_all()
-                    raise
-
-            rv.write = _safe_write
-            try:
-                _ansi_stream_wrappers[stream] = rv
-            except Exception:
-                pass
-            return rv
-
-        def get_winterm_size():
-            win = colorama.win32.GetConsoleScreenBufferInfo(
-                colorama.win32.STDOUT
-            ).srWindow
-            return win.Right - win.Left, win.Bottom - win.Top
-
+                return _write(s)
+            except BaseException:
+                ansi_wrapper.reset_all()
+                raise
+
+        rv.write = _safe_write
+
+        try:
+            _ansi_stream_wrappers[stream] = rv
+        except Exception:
+            pass
+
+        return rv

 else:

-    def _get_argv_encoding():
+    def _get_argv_encoding() -> str:
         return getattr(sys.stdin, "encoding", None) or get_filesystem_encoding()

-    _get_windows_console_stream = lambda *x: None
-    _wrap_std_stream = lambda *x: None
-
-
-def term_len(x):
+    def _get_windows_console_stream(
+        f: t.TextIO, encoding: t.Optional[str], errors: t.Optional[str]
+    ) -> t.Optional[t.TextIO]:
+        return None
+
+
+def term_len(x: str) -> int:
     return len(strip_ansi(x))


-def isatty(stream):
+def isatty(stream: t.IO) -> bool:
     try:
         return stream.isatty()
     except Exception:
         return False


-def _make_cached_stream_func(src_func, wrapper_func):
-    cache = WeakKeyDictionary()
-
-    def func():
+def _make_cached_stream_func(
+    src_func: t.Callable[[], t.TextIO], wrapper_func: t.Callable[[], t.TextIO]
+) -> t.Callable[[], t.TextIO]:
+    cache: t.MutableMapping[t.TextIO, t.TextIO] = WeakKeyDictionary()
+
+    def func() -> t.TextIO:
         stream = src_func()
         try:
             rv = cache.get(stream)
@@ -763,7 +598,6 @@
             return rv
         rv = wrapper_func()
         try:
-            stream = src_func()  # In case wrapper_func() modified the stream
             cache[stream] = rv
         except Exception:
             pass
@@ -777,13 +611,15 @@
 _default_text_stderr = _make_cached_stream_func(lambda: sys.stderr, get_text_stderr)


-binary_streams = {
+binary_streams: t.Mapping[str, t.Callable[[], t.BinaryIO]] = {
     "stdin": get_binary_stdin,
     "stdout": get_binary_stdout,
     "stderr": get_binary_stderr,
 }

-text_streams = {
+text_streams: t.Mapping[
+    str, t.Callable[[t.Optional[str], t.Optional[str]], t.TextIO]
+] = {
     "stdin": get_text_stdin,
     "stdout": get_text_stdout,
     "stderr": get_text_stderr,
('src/click', '_termui_impl.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 """
 This module contains implementations for the termui module. To keep the
 import time of Click down, some infrequently used functionality is
@@ -9,20 +8,21 @@
 import os
 import sys
 import time
+import typing as t
+from gettext import gettext as _

 from ._compat import _default_text_stdout
 from ._compat import CYGWIN
 from ._compat import get_best_encoding
-from ._compat import int_types
 from ._compat import isatty
 from ._compat import open_stream
-from ._compat import range_type
-from ._compat import shlex_quote
 from ._compat import strip_ansi
 from ._compat import term_len
 from ._compat import WIN
 from .exceptions import ClickException
 from .utils import echo
+
+V = t.TypeVar("V")

 if os.name == "nt":
     BEFORE_BAR = "\r"
@@ -32,42 +32,25 @@
     AFTER_BAR = "\033[?25h\n"


-def _length_hint(obj):
-    """Returns the length hint of an object."""
-    try:
-        return len(obj)
-    except (AttributeError, TypeError):
-        try:
-            get_hint = type(obj).__length_hint__
-        except AttributeError:
-            return None
-        try:
-            hint = get_hint(obj)
-        except TypeError:
-            return None
-        if hint is NotImplemented or not isinstance(hint, int_types) or hint < 0:
-            return None
-        return hint
-
-
-class ProgressBar(object):
+class ProgressBar(t.Generic[V]):
     def __init__(
         self,
-        iterable,
-        length=None,
-        fill_char="#",
-        empty_char=" ",
-        bar_template="%(bar)s",
-        info_sep="  ",
-        show_eta=True,
-        show_percent=None,
-        show_pos=False,
-        item_show_func=None,
-        label=None,
-        file=None,
-        color=None,
-        width=30,
-    ):
+        iterable: t.Optional[t.Iterable[V]],
+        length: t.Optional[int] = None,
+        fill_char: str = "#",
+        empty_char: str = " ",
+        bar_template: str = "%(bar)s",
+        info_sep: str = "  ",
+        show_eta: bool = True,
+        show_percent: t.Optional[bool] = None,
+        show_pos: bool = False,
+        item_show_func: t.Optional[t.Callable[[t.Optional[V]], t.Optional[str]]] = None,
+        label: t.Optional[str] = None,
+        file: t.Optional[t.TextIO] = None,
+        color: t.Optional[bool] = None,
+        update_min_steps: int = 1,
+        width: int = 30,
+    ) -> None:
         self.fill_char = fill_char
         self.empty_char = empty_char
         self.bar_template = bar_template
@@ -81,45 +64,50 @@
             file = _default_text_stdout()
         self.file = file
         self.color = color
+        self.update_min_steps = update_min_steps
+        self._completed_intervals = 0
         self.width = width
         self.autowidth = width == 0

         if length is None:
-            length = _length_hint(iterable)
+            from operator import length_hint
+
+            length = length_hint(iterable, -1)
+
+            if length == -1:
+                length = None
         if iterable is None:
             if length is None:
                 raise TypeError("iterable or length is required")
-            iterable = range_type(length)
+            iterable = t.cast(t.Iterable[V], range(length))
         self.iter = iter(iterable)
         self.length = length
-        self.length_known = length is not None
         self.pos = 0
-        self.avg = []
+        self.avg: t.List[float] = []
         self.start = self.last_eta = time.time()
         self.eta_known = False
         self.finished = False
-        self.max_width = None
+        self.max_width: t.Optional[int] = None
         self.entered = False
-        self.current_item = None
+        self.current_item: t.Optional[V] = None
         self.is_hidden = not isatty(self.file)
-        self._last_line = None
-        self.short_limit = 0.5
-
-    def __enter__(self):
+        self._last_line: t.Optional[str] = None
+
+    def __enter__(self) -> "ProgressBar":
         self.entered = True
         self.render_progress()
         return self

-    def __exit__(self, exc_type, exc_value, tb):
+    def __exit__(self, exc_type, exc_value, tb):  # type: ignore
         self.render_finish()

-    def __iter__(self):
+    def __iter__(self) -> t.Iterator[V]:
         if not self.entered:
             raise RuntimeError("You need to use progress bars in a with block.")
         self.render_progress()
         return self.generator()

-    def __next__(self):
+    def __next__(self) -> V:
         # Iteration is defined in terms of a generator function,
         # returned by iter(self); use that to define next(). This works
         # because `self.iter` is an iterable consumed by that generator,
@@ -127,37 +115,31 @@
         # twice works and does "what you want".
         return next(iter(self))

-    # Python 2 compat
-    next = __next__
-
-    def is_fast(self):
-        return time.time() - self.start <= self.short_limit
-
-    def render_finish(self):
-        if self.is_hidden or self.is_fast():
+    def render_finish(self) -> None:
+        if self.is_hidden:
             return
         self.file.write(AFTER_BAR)
         self.file.flush()

     @property
-    def pct(self):
+    def pct(self) -> float:
         if self.finished:
             return 1.0
-        return min(self.pos / (float(self.length) or 1), 1.0)
+        return min(self.pos / (float(self.length or 1) or 1), 1.0)

     @property
-    def time_per_iteration(self):
+    def time_per_iteration(self) -> float:
         if not self.avg:
             return 0.0
         return sum(self.avg) / float(len(self.avg))

     @property
-    def eta(self):
-        if self.length_known and not self.finished:
+    def eta(self) -> float:
+        if self.length is not None and not self.finished:
             return self.time_per_iteration * (self.length - self.pos)
         return 0.0

-    def format_eta(self):
+    def format_eta(self) -> str:
         if self.eta_known:
             t = int(self.eta)
             seconds = t % 60
@@ -167,44 +149,44 @@
             hours = t % 24
             t //= 24
             if t > 0:
-                return "{}d {:02}:{:02}:{:02}".format(t, hours, minutes, seconds)
+                return f"{t}d {hours:02}:{minutes:02}:{seconds:02}"
             else:
-                return "{:02}:{:02}:{:02}".format(hours, minutes, seconds)
+                return f"{hours:02}:{minutes:02}:{seconds:02}"
         return ""

-    def format_pos(self):
+    def format_pos(self) -> str:
         pos = str(self.pos)
-        if self.length_known:
-            pos += "/{}".format(self.length)
+        if self.length is not None:
+            pos += f"/{self.length}"
         return pos

-    def format_pct(self):
-        return "{: 4}%".format(int(self.pct * 100))[1:]
-
-    def format_bar(self):
-        if self.length_known:
+    def format_pct(self) -> str:
+        return f"{int(self.pct * 100): 4}%"[1:]
+
+    def format_bar(self) -> str:
+        if self.length is not None:
             bar_length = int(self.pct * self.width)
             bar = self.fill_char * bar_length
             bar += self.empty_char * (self.width - bar_length)
         elif self.finished:
             bar = self.fill_char * self.width
         else:
-            bar = list(self.empty_char * (self.width or 1))
+            chars = list(self.empty_char * (self.width or 1))
             if self.time_per_iteration != 0:
-                bar[
+                chars[
                     int(
                         (math.cos(self.pos * self.time_per_iteration) / 2.0 + 0.5)
                         * self.width
                     )
                 ] = self.fill_char
-            bar = "".join(bar)
+            bar = "".join(chars)
         return bar

-    def format_progress_line(self):
+    def format_progress_line(self) -> str:
         show_percent = self.show_percent

         info_bits = []
-        if self.length_known and show_percent is None:
+        if self.length is not None and show_percent is None:
             show_percent = not self.show_pos

         if self.show_pos:
@@ -227,10 +209,16 @@
             }
         ).rstrip()

-    def render_progress(self):
-        from .termui import get_terminal_size
+    def render_progress(self) -> None:
+        import shutil

         if self.is_hidden:
+            # Only output the label as it changes if the output is not a
+            # TTY. Use file=stderr if you expect to be piping stdout.
+            if self._last_line != self.label:
+                self._last_line = self.label
+                echo(self.label, file=self.file, color=self.color)
+
             return

         buf = []
@@ -239,10 +227,10 @@
             old_width = self.width
             self.width = 0
             clutter_length = term_len(self.format_progress_line())
-            new_width = max(0, get_terminal_size()[0] - clutter_length)
+            new_width = max(0, shutil.get_terminal_size().columns - clutter_length)
             if new_width < old_width:
                 buf.append(BEFORE_BAR)
-                buf.append(" " * self.max_width)
+                buf.append(" " * self.max_width)  # type: ignore
                 self.max_width = new_width
             self.width = new_width

@@ -261,14 +249,14 @@
         line = "".join(buf)
         # Render the line only if it changed.

-        if line != self._last_line and not self.is_fast():
+        if line != self._last_line:
             self._last_line = line
             echo(line, file=self.file, color=self.color, nl=False)
             self.file.flush()

-    def make_step(self, n_steps):
+    def make_step(self, n_steps: int) -> None:
         self.pos += n_steps
-        if self.length_known and self.pos >= self.length:
+        if self.length is not None and self.pos >= self.length:
             self.finished = True

         if (time.time() - self.last_eta) < 1.0:
@@ -286,18 +274,40 @@

         self.avg = self.avg[-6:] + [step]

-        self.eta_known = self.length_known
-
-    def update(self, n_steps):
-        self.make_step(n_steps)
-        self.render_progress()
-
-    def finish(self):
-        self.eta_known = 0
+        self.eta_known = self.length is not None
+
+    def update(self, n_steps: int, current_item: t.Optional[V] = None) -> None:
+        """Update the progress bar by advancing a specified number of
+        steps, and optionally set the ``current_item`` for this new
+        position.
+
+        :param n_steps: Number of steps to advance.
+        :param current_item: Optional item to set as ``current_item``
+            for the updated position.
+
+        .. versionchanged:: 8.0
+            Added the ``current_item`` optional parameter.
+
+        .. versionchanged:: 8.0
+            Only render when the number of steps meets the
+            ``update_min_steps`` threshold.
+        """
+        if current_item is not None:
+            self.current_item = current_item
+
+        self._completed_intervals += n_steps
+
+        if self._completed_intervals >= self.update_min_steps:
+            self.make_step(self._completed_intervals)
+            self.render_progress()
+            self._completed_intervals = 0
+
+    def finish(self) -> None:
+        self.eta_known = False
         self.current_item = None
         self.finished = True

-    def generator(self):
+    def generator(self) -> t.Iterator[V]:
         """Return a generator which yields the items added to the bar
         during construction, and updates the progress bar *after* the
         yielded block returns.
@@ -313,18 +323,25 @@
             raise RuntimeError("You need to use progress bars in a with block.")

         if self.is_hidden:
-            for rv in self.iter:
-                yield rv
+            yield from self.iter
         else:
             for rv in self.iter:
                 self.current_item = rv
+
+                # This allows show_item_func to be updated before the
+                # item is processed. Only trigger at the beginning of
+                # the update interval.
+                if self._completed_intervals == 0:
+                    self.render_progress()
+
                 yield rv
                 self.update(1)
+
             self.finish()
             self.render_progress()


-def pager(generator, color=None):
+def pager(generator: t.Iterable[str], color: t.Optional[bool] = None) -> None:
     """Decide what method to use for paging through text."""
     stdout = _default_text_stdout()
     if not isatty(sys.stdin) or not isatty(stdout):
@@ -346,17 +363,14 @@
     fd, filename = tempfile.mkstemp()
     os.close(fd)
     try:
-        if (
-            hasattr(os, "system")
-            and os.system("more {}".format(shlex_quote(filename))) == 0
-        ):
+        if hasattr(os, "system") and os.system(f'more "{filename}"') == 0:
             return _pipepager(generator, "more", color)
         return _nullpager(stdout, generator, color)
     finally:
         os.unlink(filename)


-def _pipepager(generator, cmd, color):
+def _pipepager(generator: t.Iterable[str], cmd: str, color: t.Optional[bool]) -> None:
     """Page through text by feeding it to another program.  Invoking a
     pager through this might support colors.
     """
@@ -368,7 +382,7 @@
     # condition that
     cmd_detail = cmd.rsplit("/", 1)[-1].split()
     if color is None and cmd_detail[0] == "less":
-        less_flags = "{}{}".format(os.environ.get("LESS", ""), " ".join(cmd_detail[1:]))
+        less_flags = f"{os.environ.get('LESS', '')}{' '.join(cmd_detail[1:])}"
         if not less_flags:
             env["LESS"] = "-R"
             color = True
@@ -376,17 +390,18 @@
             color = True

     c = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, env=env)
-    encoding = get_best_encoding(c.stdin)
+    stdin = t.cast(t.BinaryIO, c.stdin)
+    encoding = get_best_encoding(stdin)
     try:
         for text in generator:
             if not color:
                 text = strip_ansi(text)

-            c.stdin.write(text.encode(encoding, "replace"))
-    except (IOError, KeyboardInterrupt):
+            stdin.write(text.encode(encoding, "replace"))
+    except (OSError, KeyboardInterrupt):
         pass
     else:
-        c.stdin.close()
+        stdin.close()

     # Less doesn't respect ^C, but catches it for its own UI purposes (aborting
     # search or other commands inside less).
@@ -405,11 +420,13 @@
             break


-def _tempfilepager(generator, cmd, color):
+def _tempfilepager(
+    generator: t.Iterable[str], cmd: str, color: t.Optional[bool]
+) -> None:
     """Page through text by invoking a program on a temporary file."""
     import tempfile

-    filename = tempfile.mktemp()
+    fd, filename = tempfile.mkstemp()
     # TODO: This never terminates if the passed generator never terminates.
     text = "".join(generator)
     if not color:
@@ -418,12 +435,15 @@
     with open_stream(filename, "wb")[0] as f:
         f.write(text.encode(encoding))
     try:
-        os.system("{} {}".format(shlex_quote(cmd), shlex_quote(filename)))
+        os.system(f'{cmd} "{filename}"')
     finally:
+        os.close(fd)
         os.unlink(filename)


-def _nullpager(stream, generator, color):
+def _nullpager(
+    stream: t.TextIO, generator: t.Iterable[str], color: t.Optional[bool]
+) -> None:
     """Simply print unformatted text.  This is the ultimate fallback."""
     for text in generator:
         if not color:
@@ -431,14 +451,20 @@
         stream.write(text)


-class Editor(object):
-    def __init__(self, editor=None, env=None, require_save=True, extension=".txt"):
+class Editor:
+    def __init__(
+        self,
+        editor: t.Optional[str] = None,
+        env: t.Optional[t.Mapping[str, str]] = None,
+        require_save: bool = True,
+        extension: str = ".txt",
+    ) -> None:
         self.editor = editor
         self.env = env
         self.require_save = require_save
         self.extension = extension

-    def get_editor(self):
+    def get_editor(self) -> str:
         if self.editor is not None:
             return self.editor
         for key in "VISUAL", "EDITOR":
@@ -448,50 +474,62 @@
         if WIN:
             return "notepad"
         for editor in "sensible-editor", "vim", "nano":
-            if os.system("which {} >/dev/null 2>&1".format(editor)) == 0:
+            if os.system(f"which {editor} >/dev/null 2>&1") == 0:
                 return editor
         return "vi"

-    def edit_file(self, filename):
+    def edit_file(self, filename: str) -> None:
         import subprocess

         editor = self.get_editor()
+        environ: t.Optional[t.Dict[str, str]] = None
+
         if self.env:
             environ = os.environ.copy()
             environ.update(self.env)
-        else:
-            environ = None
+
         try:
-            c = subprocess.Popen(
-                "{} {}".format(shlex_quote(editor), shlex_quote(filename)),
-                env=environ,
-                shell=True,
-            )
+            c = subprocess.Popen(f'{editor} "{filename}"', env=environ, shell=True)
             exit_code = c.wait()
             if exit_code != 0:
-                raise ClickException("{}: Editing failed!".format(editor))
+                raise ClickException(
+                    _("{editor}: Editing failed").format(editor=editor)
+                )
         except OSError as e:
-            raise ClickException("{}: Editing failed: {}".format(editor, e))
-
-    def edit(self, text):
+            raise ClickException(
+                _("{editor}: Editing failed: {e}").format(editor=editor, e=e)
+            ) from e
+
+    def edit(self, text: t.Optional[t.AnyStr]) -> t.Optional[t.AnyStr]:
         import tempfile

-        text = text or ""
-        if text and not text.endswith("\n"):
-            text += "\n"
+        if not text:
+            data = b""
+        elif isinstance(text, (bytes, bytearray)):
+            data = text
+        else:
+            if text and not text.endswith("\n"):
+                text += "\n"
+
+            if WIN:
+                data = text.replace("\n", "\r\n").encode("utf-8-sig")
+            else:
+                data = text.encode("utf-8")

         fd, name = tempfile.mkstemp(prefix="editor-", suffix=self.extension)
+        f: t.BinaryIO
+
         try:
-            if WIN:
-                encoding = "utf-8-sig"
-                text = text.replace("\n", "\r\n")
-            else:
-                encoding = "utf-8"
-            text = text.encode(encoding)
-
-            f = os.fdopen(fd, "wb")
-            f.write(text)
-            f.close()
+            with os.fdopen(fd, "wb") as f:
+                f.write(data)
+
+            # If the filesystem resolution is 1 second, like Mac OS
+            # 10.12 Extended, or 2 seconds, like FAT32, and the editor
+            # closes very fast, require_save can fail. Set the modified
+            # time to be 2 seconds in the past to work around this.
+            os.utime(name, (os.path.getatime(name), os.path.getmtime(name) - 2))
+            # Depending on the resolution, the exact value might not be
+            # recorded, so get the new recorded value.
             timestamp = os.path.getmtime(name)

             self.edit_file(name)
@@ -499,26 +537,26 @@
             if self.require_save and os.path.getmtime(name) == timestamp:
                 return None

-            f = open(name, "rb")
-            try:
+            with open(name, "rb") as f:
                 rv = f.read()
-            finally:
-                f.close()
-            return rv.decode("utf-8-sig").replace("\r\n", "\n")
+
+            if isinstance(text, (bytes, bytearray)):
+                return rv
+
+            return rv.decode("utf-8-sig").replace("\r\n", "\n")  # type: ignore
         finally:
             os.unlink(name)


-def open_url(url, wait=False, locate=False):
+def open_url(url: str, wait: bool = False, locate: bool = False) -> int:
     import subprocess

-    def _unquote_file(url):
-        try:
-            import urllib
-        except ImportError:
-            import urllib
+    def _unquote_file(url: str) -> str:
+        from urllib.parse import unquote
+
         if url.startswith("file://"):
-            url = urllib.unquote(url[7:])
+            url = unquote(url[7:])
+
         return url

     if sys.platform == "darwin":
@@ -535,17 +573,21 @@
             null.close()
     elif WIN:
         if locate:
-            url = _unquote_file(url)
-            args = "explorer /select,{}".format(shlex_quote(url))
-        else:
-            args = 'start {} "" {}'.format("/WAIT" if wait else "", shlex_quote(url))
+            url = _unquote_file(url.replace('"', ""))
+            args = f'explorer /select,"{url}"'
+        else:
+            url = url.replace('"', "")
+            wait_str = "/WAIT" if wait else ""
+            args = f'start {wait_str} "" "{url}"'
         return os.system(args)
     elif CYGWIN:
         if locate:
-            url = _unquote_file(url)
-            args = "cygstart {}".format(shlex_quote(os.path.dirname(url)))
-        else:
-            args = "cygstart {} {}".format("-w" if wait else "", shlex_quote(url))
+            url = os.path.dirname(_unquote_file(url).replace('"', ""))
+            args = f'cygstart "{url}"'
+        else:
+            url = url.replace('"', "")
+            wait_str = "-w" if wait else ""
+            args = f'cygstart {wait_str} "{url}"'
         return os.system(args)

     try:
@@ -566,23 +608,27 @@
         return 1


-def _translate_ch_to_exc(ch):
-    if ch == u"\x03":
+def _translate_ch_to_exc(ch: str) -> t.Optional[BaseException]:
+    if ch == "\x03":
         raise KeyboardInterrupt()
-    if ch == u"\x04" and not WIN:  # Unix-like, Ctrl+D
+
+    if ch == "\x04" and not WIN:  # Unix-like, Ctrl+D
         raise EOFError()
-    if ch == u"\x1a" and WIN:  # Windows, Ctrl+Z
+
+    if ch == "\x1a" and WIN:  # Windows, Ctrl+Z
         raise EOFError()
+
+    return None


 if WIN:
     import msvcrt

     @contextlib.contextmanager
-    def raw_terminal():
-        yield
-
-    def getchar(echo):
+    def raw_terminal() -> t.Iterator[int]:
+        yield -1
+
+    def getchar(echo: bool) -> str:
         # The function `getch` will return a bytes object corresponding to
         # the pressed character. Since Windows 10 build 1803, it will also
         # return \x00 when called a second time after pressing a regular key.
@@ -612,50 +658,60 @@
         #
         # Anyway, Click doesn't claim to do this Right(tm), and using `getwch`
         # is doing the right thing in more situations than with `getch`.
+        func: t.Callable[[], str]
+
         if echo:
-            func = msvcrt.getwche
-        else:
-            func = msvcrt.getwch
+            func = msvcrt.getwche  # type: ignore
+        else:
+            func = msvcrt.getwch  # type: ignore

         rv = func()
-        if rv in (u"\x00", u"\xe0"):
+
+        if rv in ("\x00", "\xe0"):
             # \x00 and \xe0 are control characters that indicate special key,
             # see above.
             rv += func()
+
         _translate_ch_to_exc(rv)
         return rv
-

 else:
     import tty
     import termios

     @contextlib.contextmanager
-    def raw_terminal():
+    def raw_terminal() -> t.Iterator[int]:
+        f: t.Optional[t.TextIO]
+        fd: int
+
         if not isatty(sys.stdin):
             f = open("/dev/tty")
             fd = f.fileno()
         else:
             fd = sys.stdin.fileno()
             f = None
+
         try:
             old_settings = termios.tcgetattr(fd)
+
             try:
                 tty.setraw(fd)
                 yield fd
             finally:
                 termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
                 sys.stdout.flush()
+
                 if f is not None:
                     f.close()
         except termios.error:
             pass

-    def getchar(echo):
+    def getchar(echo: bool) -> str:
         with raw_terminal() as fd:
-            ch = os.read(fd, 32)
-            ch = ch.decode(get_best_encoding(sys.stdin), "replace")
+            ch = os.read(fd, 32).decode(get_best_encoding(sys.stdin), "replace")
+
             if echo and isatty(sys.stdout):
                 sys.stdout.write(ch)
+
             _translate_ch_to_exc(ch)
             return ch
('src/click', 'testing.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,77 +1,117 @@
 import contextlib
+import io
 import os
 import shlex
 import shutil
 import sys
 import tempfile
+import typing as t
+from types import TracebackType

 from . import formatting
 from . import termui
 from . import utils
-from ._compat import iteritems
-from ._compat import PY2
-from ._compat import string_types
-
-
-if PY2:
-    from cStringIO import StringIO
-else:
-    import io
-    from ._compat import _find_binary_reader
-
-
-class EchoingStdin(object):
-    def __init__(self, input, output):
+from ._compat import _find_binary_reader
+
+if t.TYPE_CHECKING:
+    from .core import BaseCommand
+
+
+class EchoingStdin:
+    def __init__(self, input: t.BinaryIO, output: t.BinaryIO) -> None:
         self._input = input
         self._output = output
-
-    def __getattr__(self, x):
+        self._paused = False
+
+    def __getattr__(self, x: str) -> t.Any:
         return getattr(self._input, x)

-    def _echo(self, rv):
-        self._output.write(rv)
+    def _echo(self, rv: bytes) -> bytes:
+        if not self._paused:
+            self._output.write(rv)
+
         return rv

-    def read(self, n=-1):
+    def read(self, n: int = -1) -> bytes:
         return self._echo(self._input.read(n))

-    def readline(self, n=-1):
+    def read1(self, n: int = -1) -> bytes:
+        return self._echo(self._input.read1(n))  # type: ignore
+
+    def readline(self, n: int = -1) -> bytes:
         return self._echo(self._input.readline(n))

-    def readlines(self):
+    def readlines(self) -> t.List[bytes]:
         return [self._echo(x) for x in self._input.readlines()]

-    def __iter__(self):
+    def __iter__(self) -> t.Iterator[bytes]:
         return iter(self._echo(x) for x in self._input)

-    def __repr__(self):
+    def __repr__(self) -> str:
         return repr(self._input)


-def make_input_stream(input, charset):
+@contextlib.contextmanager
+def _pause_echo(stream: t.Optional[EchoingStdin]) -> t.Iterator[None]:
+    if stream is None:
+        yield
+    else:
+        stream._paused = True
+        yield
+        stream._paused = False
+
+
+class _NamedTextIOWrapper(io.TextIOWrapper):
+    def __init__(
+        self, buffer: t.BinaryIO, name: str, mode: str, **kwargs: t.Any
+    ) -> None:
+        super().__init__(buffer, **kwargs)
+        self._name = name
+        self._mode = mode
+
+    @property
+    def name(self) -> str:
+        return self._name
+
+    @property
+    def mode(self) -> str:
+        return self._mode
+
+
+def make_input_stream(
+    input: t.Optional[t.Union[str, bytes, t.IO]], charset: str
+) -> t.BinaryIO:
     # Is already an input stream.
     if hasattr(input, "read"):
-        if PY2:
-            return input
-        rv = _find_binary_reader(input)
+        rv = _find_binary_reader(t.cast(t.IO, input))
+
         if rv is not None:
             return rv
+
         raise TypeError("Could not find binary reader for input stream.")

     if input is None:
         input = b""
-    elif not isinstance(input, bytes):
+    elif isinstance(input, str):
         input = input.encode(charset)
-    if PY2:
-        return StringIO(input)
-    return io.BytesIO(input)
-
-
-class Result(object):
+
+    return io.BytesIO(t.cast(bytes, input))
+
+
+class Result:
     """Holds the captured result of an invoked CLI script."""

     def __init__(
-        self, runner, stdout_bytes, stderr_bytes, exit_code, exception, exc_info=None
+        self,
+        runner: "CliRunner",
+        stdout_bytes: bytes,
+        stderr_bytes: t.Optional[bytes],
+        return_value: t.Any,
+        exit_code: int,
+        exception: t.Optional[BaseException],
+        exc_info: t.Optional[
+            t.Tuple[t.Type[BaseException], BaseException, TracebackType]
+        ] = None,
     ):
         #: The runner that created the result
         self.runner = runner
@@ -79,6 +119,10 @@
         self.stdout_bytes = stdout_bytes
         #: The standard error as bytes, or None if not available
         self.stderr_bytes = stderr_bytes
+        #: The value returned from the invoked command.
+        #:
+        #: .. versionadded:: 8.0
+        self.return_value = return_value
         #: The exit code as integer.
         self.exit_code = exit_code
         #: The exception that happened if one did.
@@ -87,19 +131,19 @@
         self.exc_info = exc_info

     @property
-    def output(self):
+    def output(self) -> str:
         """The (standard) output as unicode string."""
         return self.stdout

     @property
-    def stdout(self):
+    def stdout(self) -> str:
         """The standard output as unicode string."""
         return self.stdout_bytes.decode(self.runner.charset, "replace").replace(
             "\r\n", "\n"
         )

     @property
-    def stderr(self):
+    def stderr(self) -> str:
         """The standard error as unicode string."""
         if self.stderr_bytes is None:
             raise ValueError("stderr not separately captured")
@@ -107,21 +151,18 @@
             "\r\n", "\n"
         )

-    def __repr__(self):
-        return "<{} {}>".format(
-            type(self).__name__, repr(self.exception) if self.exception else "okay"
-        )
-
-
-class CliRunner(object):
+    def __repr__(self) -> str:
+        exc_str = repr(self.exception) if self.exception else "okay"
+        return f"<{type(self).__name__} {exc_str}>"
+
+
+class CliRunner:
     """The CLI runner provides functionality to invoke a Click command line
     script for unittesting purposes in a isolated environment.  This only
     works in single-threaded systems without any concurrency as it changes the
     global interpreter state.

-    :param charset: the character set for the input and output data.  This is
-                    UTF-8 by default and should not be changed currently as
-                    the reporting to Click only works in Python 2 properly.
+    :param charset: the character set for the input and output data.
     :param env: a dictionary with environment variables for overriding.
     :param echo_stdin: if this is set to `True`, then reading from stdin writes
                        to stdout.  This is useful for showing examples in
@@ -134,22 +175,28 @@
                        independently
     """

-    def __init__(self, charset=None, env=None, echo_stdin=False, mix_stderr=True):
-        if charset is None:
-            charset = "utf-8"
+    def __init__(
+        self,
+        charset: str = "utf-8",
+        env: t.Optional[t.Mapping[str, t.Optional[str]]] = None,
+        echo_stdin: bool = False,
+        mix_stderr: bool = True,
+    ) -> None:
         self.charset = charset
         self.env = env or {}
         self.echo_stdin = echo_stdin
         self.mix_stderr = mix_stderr

-    def get_default_prog_name(self, cli):
+    def get_default_prog_name(self, cli: "BaseCommand") -> str:
         """Given a command object it will return the default program name
         for it.  The default is the `name` attribute or ``"root"`` if not
         set.
         """
         return cli.name or "root"

-    def make_env(self, overrides=None):
+    def make_env(
+        self, overrides: t.Optional[t.Mapping[str, t.Optional[str]]] = None
+    ) -> t.Mapping[str, t.Optional[str]]:
         """Returns the environment overrides for invoking a script."""
         rv = dict(self.env)
         if overrides:
@@ -157,7 +204,12 @@
         return rv

     @contextlib.contextmanager
-    def isolation(self, input=None, env=None, color=False):
+    def isolation(
+        self,
+        input: t.Optional[t.Union[str, bytes, t.IO]] = None,
+        env: t.Optional[t.Mapping[str, t.Optional[str]]] = None,
+        color: bool = False,
+    ) -> t.Iterator[t.Tuple[io.BytesIO, t.Optional[io.BytesIO]]]:
         """A context manager that sets up the isolation for invoking of a
         command line tool.  This sets up stdin with the given input data
         and `os.environ` with the overrides from the given dictionary.
@@ -166,15 +218,20 @@

         This is automatically done in the :meth:`invoke` method.

-        .. versionadded:: 4.0
-           The ``color`` parameter was added.
-
         :param input: the input stream to put into sys.stdin.
         :param env: the environment overrides as dictionary.
         :param color: whether the output should contain color codes. The
                       application can still override this explicitly.
+
+        .. versionchanged:: 8.0
+            ``stderr`` is opened with ``errors="backslashreplace"``
+            instead of the default ``"strict"``.
+
+        .. versionchanged:: 4.0
+            Added the ``color`` parameter.
         """
-        input = make_input_stream(input, self.charset)
+        bytes_input = make_input_stream(input, self.charset)
+        echo_input = None

         old_stdin = sys.stdin
         old_stdout = sys.stdout
@@ -184,51 +241,68 @@

         env = self.make_env(env)

-        if PY2:
-            bytes_output = StringIO()
-            if self.echo_stdin:
-                input = EchoingStdin(input, bytes_output)
-            sys.stdout = bytes_output
-            if not self.mix_stderr:
-                bytes_error = StringIO()
-                sys.stderr = bytes_error
-        else:
-            bytes_output = io.BytesIO()
-            if self.echo_stdin:
-                input = EchoingStdin(input, bytes_output)
-            input = io.TextIOWrapper(input, encoding=self.charset)
-            sys.stdout = io.TextIOWrapper(bytes_output, encoding=self.charset)
-            if not self.mix_stderr:
-                bytes_error = io.BytesIO()
-                sys.stderr = io.TextIOWrapper(bytes_error, encoding=self.charset)
-
+        bytes_output = io.BytesIO()
+
+        if self.echo_stdin:
+            bytes_input = echo_input = t.cast(
+                t.BinaryIO, EchoingStdin(bytes_input, bytes_output)
+            )
+
+        sys.stdin = text_input = _NamedTextIOWrapper(
+            bytes_input, encoding=self.charset, name="<stdin>", mode="r"
+        )
+
+        if self.echo_stdin:
+            # Force unbuffered reads, otherwise TextIOWrapper reads a
+            # large chunk which is echoed early.
+            text_input._CHUNK_SIZE = 1  # type: ignore
+
+        sys.stdout = _NamedTextIOWrapper(
+            bytes_output, encoding=self.charset, name="<stdout>", mode="w"
+        )
+
+        bytes_error = None
         if self.mix_stderr:
             sys.stderr = sys.stdout
-
-        sys.stdin = input
-
-        def visible_input(prompt=None):
+        else:
+            bytes_error = io.BytesIO()
+            sys.stderr = _NamedTextIOWrapper(
+                bytes_error,
+                encoding=self.charset,
+                name="<stderr>",
+                mode="w",
+                errors="backslashreplace",
+            )
+
+        @_pause_echo(echo_input)  # type: ignore
+        def visible_input(prompt: t.Optional[str] = None) -> str:
             sys.stdout.write(prompt or "")
-            val = input.readline().rstrip("\r\n")
-            sys.stdout.write("{}\n".format(val))
+            val = text_input.readline().rstrip("\r\n")
+            sys.stdout.write(f"{val}\n")
             sys.stdout.flush()
             return val

-        def hidden_input(prompt=None):
-            sys.stdout.write("{}\n".format(prompt or ""))
+        @_pause_echo(echo_input)  # type: ignore
+        def hidden_input(prompt: t.Optional[str] = None) -> str:
+            sys.stdout.write(f"{prompt or ''}\n")
             sys.stdout.flush()
-            return input.readline().rstrip("\r\n")
-
-        def _getchar(echo):
+            return text_input.readline().rstrip("\r\n")
+
+        @_pause_echo(echo_input)  # type: ignore
+        def _getchar(echo: bool) -> str:
             char = sys.stdin.read(1)
+
             if echo:
                 sys.stdout.write(char)
-                sys.stdout.flush()
+
+            sys.stdout.flush()
             return char

         default_color = color

-        def should_strip_ansi(stream=None, color=None):
+        def should_strip_ansi(
+            stream: t.Optional[t.IO] = None, color: t.Optional[bool] = None
+        ) -> bool:
             if color is None:
                 return not default_color
             return not color
@@ -236,15 +310,15 @@
         old_visible_prompt_func = termui.visible_prompt_func
         old_hidden_prompt_func = termui.hidden_prompt_func
         old__getchar_func = termui._getchar
-        old_should_strip_ansi = utils.should_strip_ansi
+        old_should_strip_ansi = utils.should_strip_ansi  # type: ignore
         termui.visible_prompt_func = visible_input
         termui.hidden_prompt_func = hidden_input
         termui._getchar = _getchar
-        utils.should_strip_ansi = should_strip_ansi
+        utils.should_strip_ansi = should_strip_ansi  # type: ignore

         old_env = {}
         try:
-            for key, value in iteritems(env):
+            for key, value in env.items():
                 old_env[key] = os.environ.get(key)
                 if value is None:
                     try:
@@ -253,9 +327,9 @@
                         pass
                 else:
                     os.environ[key] = value
-            yield (bytes_output, not self.mix_stderr and bytes_error)
+            yield (bytes_output, bytes_error)
         finally:
-            for key, value in iteritems(old_env):
+            for key, value in old_env.items():
                 if value is None:
                     try:
                         del os.environ[key]
@@ -269,35 +343,25 @@
             termui.visible_prompt_func = old_visible_prompt_func
             termui.hidden_prompt_func = old_hidden_prompt_func
             termui._getchar = old__getchar_func
-            utils.should_strip_ansi = old_should_strip_ansi
+            utils.should_strip_ansi = old_should_strip_ansi  # type: ignore
             formatting.FORCED_WIDTH = old_forced_width

     def invoke(
         self,
-        cli,
-        args=None,
-        input=None,
-        env=None,
-        catch_exceptions=True,
-        color=False,
-        **extra
-    ):
+        cli: "BaseCommand",
+        args: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        input: t.Optional[t.Union[str, bytes, t.IO]] = None,
+        env: t.Optional[t.Mapping[str, t.Optional[str]]] = None,
+        catch_exceptions: bool = True,
+        color: bool = False,
+        **extra: t.Any,
+    ) -> Result:
         """Invokes a command in an isolated environment.  The arguments are
         forwarded directly to the command line script, the `extra` keyword
         arguments are passed to the :meth:`~clickpkg.Command.main` function of
         the command.

         This returns a :class:`Result` object.
-
-        .. versionadded:: 3.0
-           The ``catch_exceptions`` parameter was added.
-
-        .. versionchanged:: 3.0
-           The result object now has an `exc_info` attribute with the
-           traceback if available.
-
-        .. versionadded:: 4.0
-           The ``color`` parameter was added.

         :param cli: the command to invoke
         :param args: the arguments to invoke. It may be given as an iterable
@@ -311,13 +375,28 @@
         :param extra: the keyword arguments to pass to :meth:`main`.
         :param color: whether the output should contain color codes. The
                       application can still override this explicitly.
+
+        .. versionchanged:: 8.0
+            The result object has the ``return_value`` attribute with
+            the value returned from the invoked command.
+
+        .. versionchanged:: 4.0
+            Added the ``color`` parameter.
+
+        .. versionchanged:: 3.0
+            Added the ``catch_exceptions`` parameter.
+
+        .. versionchanged:: 3.0
+            The result object has the ``exc_info`` attribute with the
+            traceback if available.
         """
         exc_info = None
         with self.isolation(input=input, env=env, color=color) as outstreams:
-            exception = None
+            return_value = None
+            exception: t.Optional[BaseException] = None
             exit_code = 0

-            if isinstance(args, string_types):
+            if isinstance(args, str):
                 args = shlex.split(args)

             try:
@@ -326,20 +405,23 @@
                 prog_name = self.get_default_prog_name(cli)

             try:
-                cli.main(args=args or (), prog_name=prog_name, **extra)
+                return_value = cli.main(args=args or (), prog_name=prog_name, **extra)
             except SystemExit as e:
                 exc_info = sys.exc_info()
-                exit_code = e.code
-                if exit_code is None:
-                    exit_code = 0
-
-                if exit_code != 0:
+                e_code = t.cast(t.Optional[t.Union[int, t.Any]], e.code)
+
+                if e_code is None:
+                    e_code = 0
+
+                if e_code != 0:
                     exception = e

-                if not isinstance(exit_code, int):
-                    sys.stdout.write(str(exit_code))
+                if not isinstance(e_code, int):
+                    sys.stdout.write(str(e_code))
                     sys.stdout.write("\n")
-                    exit_code = 1
+                    e_code = 1
+
+                exit_code = e_code

             except Exception as e:
                 if not catch_exceptions:
@@ -353,30 +435,45 @@
                 if self.mix_stderr:
                     stderr = None
                 else:
-                    stderr = outstreams[1].getvalue()
+                    stderr = outstreams[1].getvalue()  # type: ignore

         return Result(
             runner=self,
             stdout_bytes=stdout,
             stderr_bytes=stderr,
+            return_value=return_value,
             exit_code=exit_code,
             exception=exception,
-            exc_info=exc_info,
+            exc_info=exc_info,  # type: ignore
         )

     @contextlib.contextmanager
-    def isolated_filesystem(self):
-        """A context manager that creates a temporary folder and changes
-        the current working directory to it for isolated filesystem tests.
+    def isolated_filesystem(
+        self, temp_dir: t.Optional[t.Union[str, os.PathLike]] = None
+    ) -> t.Iterator[str]:
+        """A context manager that creates a temporary directory and
+        changes the current working directory to it. This isolates tests
+        that affect the contents of the CWD to prevent them from
+        interfering with each other.
+
+        :param temp_dir: Create the temporary directory under this
+            directory. If given, the created directory is not removed
+            when exiting.
+
+        .. versionchanged:: 8.0
+            Added the ``temp_dir`` parameter.
         """
         cwd = os.getcwd()
-        t = tempfile.mkdtemp()
-        os.chdir(t)
+        dt = tempfile.mkdtemp(dir=temp_dir)  # type: ignore[type-var]
+        os.chdir(dt)
+
         try:
-            yield t
+            yield t.cast(str, dt)
         finally:
             os.chdir(cwd)
-            try:
-                shutil.rmtree(t)
-            except (OSError, IOError):  # noqa: B014
-                pass
+
+            if temp_dir is None:
+                try:
+                    shutil.rmtree(dt)
+                except OSError:  # noqa: B014
+                    pass
('src/click', 'decorators.py')
--- /Users/tshi/researchProjs/click/click-7.1.0/
+++ /Users/tshi/researchProjs/click/click-8.1.0/
@@ -1,41 +1,48 @@
 import inspect
-import sys
+import types
+import typing as t
 from functools import update_wrapper
-
-from ._compat import iteritems
-from ._unicodefun import _check_for_unicode_literals
+from gettext import gettext as _
+
 from .core import Argument
 from .core import Command
+from .core import Context
 from .core import Group
 from .core import Option
+from .core import Parameter
 from .globals import get_current_context
 from .utils import echo

-
-def pass_context(f):
+F = t.TypeVar("F", bound=t.Callable[..., t.Any])
+FC = t.TypeVar("FC", bound=t.Union[t.Callable[..., t.Any], Command])
+
+
+def pass_context(f: F) -> F:
     """Marks a callback as wanting to receive the current context
     object as first argument.
     """

-    def new_func(*args, **kwargs):
+    def new_func(*args, **kwargs):  # type: ignore
         return f(get_current_context(), *args, **kwargs)

-    return update_wrapper(new_func, f)
-
-
-def pass_obj(f):
+    return update_wrapper(t.cast(F, new_func), f)
+
+
+def pass_obj(f: F) -> F:
     """Similar to :func:`pass_context`, but only pass the object on the
     context onwards (:attr:`Context.obj`).  This is useful if that object
     represents the state of a nested system.
     """

-    def new_func(*args, **kwargs):
+    def new_func(*args, **kwargs):  # type: ignore
         return f(get_current_context().obj, *args, **kwargs)

-    return update_wrapper(new_func, f)
-
-
-def make_pass_decorator(object_type, ensure=False):
+    return update_wrapper(t.cast(F, new_func), f)
+
+
+def make_pass_decorator(
+    object_type: t.Type, ensure: bool = False
+) -> "t.Callable[[F], F]":
     """Given an object type this creates a decorator that will work
     similar to :func:`pass_obj` but instead of passing the object of the
     current context, it will find the innermost context of type
@@ -58,52 +65,104 @@
                    remembered on the context if it's not there yet.
     """

-    def decorator(f):
-        def new_func(*args, **kwargs):
+    def decorator(f: F) -> F:
+        def new_func(*args, **kwargs):  # type: ignore
             ctx = get_current_context()
+
             if ensure:
                 obj = ctx.ensure_object(object_type)
             else:
                 obj = ctx.find_object(object_type)
+
             if obj is None:
                 raise RuntimeError(
                     "Managed to invoke callback without a context"
-                    " object of type '{}' existing".format(object_type.__name__)
+                    f" object of type {object_type.__name__!r}"
+                    " existing."
                 )
+
             return ctx.invoke(f, obj, *args, **kwargs)

-        return update_wrapper(new_func, f)
+        return update_wrapper(t.cast(F, new_func), f)

     return decorator


-def _make_command(f, name, attrs, cls):
-    if isinstance(f, Command):
-        raise TypeError("Attempted to convert a callback into a command twice.")
-    try:
-        params = f.__click_params__
-        params.reverse()
-        del f.__click_params__
-    except AttributeError:
-        params = []
-    help = attrs.get("help")
-    if help is None:
-        help = inspect.getdoc(f)
-        if isinstance(help, bytes):
-            help = help.decode("utf-8")
-    else:
-        help = inspect.cleandoc(help)
-    attrs["help"] = help
-    _check_for_unicode_literals()
-    return cls(
-        name=name or f.__name__.lower().replace("_", "-"),
-        callback=f,
-        params=params,
-        **attrs
+def pass_meta_key(
+    key: str, *, doc_description: t.Optional[str] = None
+) -> "t.Callable[[F], F]":
+    """Create a decorator that passes a key from
+    :attr:`click.Context.meta` as the first argument to the decorated
+    function.
+
+    :param key: Key in ``Context.meta`` to pass.
+    :param doc_description: Description of the object being passed,
+        inserted into the decorator's docstring. Defaults to "the 'key'
+        key from Context.meta".
+
+    .. versionadded:: 8.0
+    """
+
+    def decorator(f: F) -> F:
+        def new_func(*args, **kwargs):  # type: ignore
+            ctx = get_current_context()
+            obj = ctx.meta[key]
+            return ctx.invoke(f, obj, *args, **kwargs)
+
+        return update_wrapper(t.cast(F, new_func), f)
+
+    if doc_description is None:
+        doc_description = f"the {key!r} key from :attr:`click.Context.meta`"
+
+    decorator.__doc__ = (
+        f"Decorator that passes {doc_description} as the first argument"
+        " to the decorated function."
     )
-
-
-def command(name=None, cls=None, **attrs):
+    return decorator
+
+
+CmdType = t.TypeVar("CmdType", bound=Command)
+
+
+@t.overload
+def command(
+    name: t.Optional[str] = None,
+    cls: t.Type[CmdType] = ...,
+    **attrs: t.Any,
+) -> t.Callable[..., CmdType]:
+    ...
+
+
+@t.overload
+def command(
+    name: t.Optional[str] = None,
+    **attrs: t.Any,
+) -> t.Callable[..., Command]:
+    ...
+
+
+@t.overload
+def command(
+    name: t.Callable,
+    cls: t.Type[CmdType] = ...,
+    **attrs: t.Any,
+) -> CmdType:
+    ...
+
+
+@t.overload
+def command(
+    name: t.Callable,
+    **attrs: t.Any,
+) -> Command:
+    ...
+
+
+def command(
+    name: t.Union[str, t.Callable, None] = None,
+    cls: t.Optional[t.Type[Command]] = None,
+    **attrs: t.Any,
+) -> t.Union[Command, t.Callable[..., Command]]:
     r"""Creates a new :class:`Command` and uses the decorated function as
     callback.  This will also automatically attach all decorated
     :func:`option`\s and :func:`argument`\s as parameters to the command.
@@ -113,6 +172,8 @@
     pass the intended name as the first argument.

     All keyword arguments are forwarded to the underlying command class.
+    For the ``params`` argument, any decorated params are appended to
+    the end of the list.

     Once decorated the function turns into a :class:`Command` instance
     that can be invoked as a command line utility or be attached to a
@@ -122,37 +183,103 @@
                  name with underscores replaced by dashes.
     :param cls: the command class to instantiate.  This defaults to
                 :class:`Command`.
+
+    .. versionchanged:: 8.1
+        This decorator can be applied without parentheses.
+
+    .. versionchanged:: 8.1
+        The ``params`` argument can be used. Decorated params are
+        appended to the end of the list.
     """
     if cls is None:
         cls = Command

-    def decorator(f):
-        cmd = _make_command(f, name, attrs, cls)
+    func: t.Optional[t.Callable] = None
+
+    if callable(name):
+        func = name
+        name = None
+
+    def decorator(f: t.Callable[..., t.Any]) -> Command:
+        if isinstance(f, Command):
+            raise TypeError("Attempted to convert a callback into a command twice.")
+
+        attr_params = attrs.pop("params", None)
+        params = attr_params if attr_params is not None else []
+
+        try:
+            decorator_params = f.__click_params__  # type: ignore
+        except AttributeError:
+            pass
+        else:
+            del f.__click_params__  # type: ignore
+            params.extend(reversed(decorator_params))
+
+        if attrs.get("help") is None:
+            attrs["help"] = f.__doc__
+
+        cmd = cls(  # type: ignore[misc]
+            name=name or f.__name__.lower().replace("_", "-"),  # type: ignore[arg-type]
+            callback=f,
+            params=params,
+            **attrs,
+        )
         cmd.__doc__ = f.__doc__
         return cmd

+    if func is not None:
+        return decorator(func)
+
     return decorator


-def group(name=None, **attrs):
+@t.overload
+def group(
+    name: t.Optional[str] = None,
+    **attrs: t.Any,
+) -> t.Callable[[F], Group]:
+    ...
+
+
+@t.overload
+def group(
+    name: t.Callable,
+    **attrs: t.Any,
+) -> Group:
+    ...
+
+
+def group(
+    name: t.Union[str, t.Callable, None] = None, **attrs: t.Any
+) -> t.Union[Group, t.Callable[[F], Group]]:
     """Creates a new :class:`Group` with a function as callback.  This
     works otherwise the same as :func:`command` just that the `cls`
     parameter is set to :class:`Group`.
-    """
-    attrs.setdefault("cls", Group)
-    return command(name, **attrs)
-
-
-def _param_memo(f, param):
+
+    .. versionchanged:: 8.1
+        This decorator can be applied without parentheses.
+    """
+    if attrs.get("cls") is None:
+        attrs["cls"] = Group
+
+    if callable(name):
+        grp: t.Callable[[F], Group] = t.cast(Group, command(**attrs))
+        return grp(name)
+
+    return t.cast(Group, command(name, **attrs))
+
+
+def _param_memo(f: FC, param: Parameter) -> None:
     if isinstance(f, Command):
         f.params.append(param)
     else:
         if not hasattr(f, "__click_params__"):
-            f.__click_params__ = []
-        f.__click_params__.append(param)
-
-
-def argument(*param_decls, **attrs):
+            f.__click_params__ = []  # type: ignore
+
+        f.__click_params__.append(param)  # type: ignore
+
+
+def argument(*param_decls: str, **attrs: t.Any) -> t.Callable[[FC], FC]:
     """Attaches an argument to the command.  All positional arguments are
     passed as parameter declarations to :class:`Argument`; all keyword
     arguments are forwarded unchanged (except ``cls``).
@@ -163,15 +290,15 @@
                 :class:`Argument`.
     """

-    def decorator(f):
-        ArgumentClass = attrs.pop("cls", Argument)
+    def decorator(f: FC) -> FC:
+        ArgumentClass = attrs.pop("cls", None) or Argument
         _param_memo(f, ArgumentClass(param_decls, **attrs))
         return f

     return decorator


-def option(*param_decls, **attrs):
+def option(*param_decls: str, **attrs: t.Any) -> t.Callable[[FC], FC]:
     """Attaches an option to the command.  All positional arguments are
     passed as parameter declarations to :class:`Option`; all keyword
     arguments are forwarded unchanged (except ``cls``).
@@ -182,152 +309,197 @@
                 :class:`Option`.
     """

-    def decorator(f):
+    def decorator(f: FC) -> FC:
         # Issue 926, copy attrs, so pre-defined options can re-use the same cls=
         option_attrs = attrs.copy()
-
-        if "help" in option_attrs:
-            option_attrs["help"] = inspect.cleandoc(option_attrs["help"])
-        OptionClass = option_attrs.pop("cls", Option)
+        OptionClass = option_attrs.pop("cls", None) or Option
         _param_memo(f, OptionClass(param_decls, **option_attrs))
         return f

     return decorator


-def confirmation_option(*param_decls, **attrs):
-    """Shortcut for confirmation prompts that can be ignored by passing
-    ``--yes`` as parameter.
-
-    This is equivalent to decorating a function with :func:`option` with
-    the following parameters::
-
-        def callback(ctx, param, value):
-            if not value:
-                ctx.abort()
-
-        @click.command()
-        @click.option('--yes', is_flag=True, callback=callback,
-                      expose_value=False, prompt='Do you want to continue?')
-        def dropdb():
-            pass
-    """
-
-    def decorator(f):
-        def callback(ctx, param, value):
-            if not value:
-                ctx.abort()
-
-        attrs.setdefault("is_flag", True)
-        attrs.setdefault("callback", callback)
-        attrs.setdefault("expose_value", False)
-        attrs.setdefault("prompt", "Do you want to continue?")
-        attrs.setdefault("help", "Confirm the action without prompting.")
-        return option(*(param_decls or ("--yes",)), **attrs)(f)
-
-    return decorator
-
-
-def password_option(*param_decls, **attrs):
-    """Shortcut for password prompts.
-
-    This is equivalent to decorating a function with :func:`option` with
-    the following parameters::
-
-        @click.command()
-        @click.option('--password', prompt=True, confirmation_prompt=True,
-                      hide_input=True)
-        def changeadmin(password):
-            pass
-    """
-
-    def decorator(f):
-        attrs.setdefault("prompt", True)
-        attrs.setdefault("confirmation_prompt", True)
-        attrs.setdefault("hide_input", True)
-        return option(*(param_decls or ("--password",)), **attrs)(f)
-
-    return decorator
-
-
-def version_option(version=None, *param_decls, **attrs):
-    """Adds a ``--version`` option which immediately ends the program
-    printing out the version number.  This is implemented as an eager
-    option that prints the version and exits the program in the callback.
-
-    :param version: the version number to show.  If not provided Click
-                    attempts an auto discovery via setuptools.
-    :param prog_name: the name of the program (defaults to autodetection)
-    :param message: custom message to show instead of the default
-                    (``'%(prog)s, version %(version)s'``)
-    :param others: everything else is forwarded to :func:`option`.
-    """
-    if version is None:
-        if hasattr(sys, "_getframe"):
-            module = sys._getframe(1).f_globals.get("__name__")
-        else:
-            module = ""
-
-    def decorator(f):
-        prog_name = attrs.pop("prog_name", None)
-        message = attrs.pop("message", "%(prog)s, version %(version)s")
-
-        def callback(ctx, param, value):
-            if not value or ctx.resilient_parsing:
-                return
-            prog = prog_name
-            if prog is None:
-                prog = ctx.find_root().info_name
-            ver = version
-            if ver is None:
-                try:
-                    import pkg_resources
-                except ImportError:
-                    pass
-                else:
-                    for dist in pkg_resources.working_set:
-                        scripts = dist.get_entry_map().get("console_scripts") or {}
-                        for _, entry_point in iteritems(scripts):
-                            if entry_point.module_name == module:
-                                ver = dist.version
-                                break
-                if ver is None:
-                    raise RuntimeError("Could not determine version")
-            echo(message % {"prog": prog, "version": ver}, color=ctx.color)
-            ctx.exit()
-
-        attrs.setdefault("is_flag", True)
-        attrs.setdefault("expose_value", False)
-        attrs.setdefault("is_eager", True)
-        attrs.setdefault("help", "Show the version and exit.")
-        attrs["callback"] = callback
-        return option(*(param_decls or ("--version",)), **attrs)(f)
-
-    return decorator
-
-
-def help_option(*param_decls, **attrs):
-    """Adds a ``--help`` option which immediately ends the program
-    printing out the help page.  This is usually unnecessary to add as
-    this is added by default to all commands unless suppressed.
-
-    Like :func:`version_option`, this is implemented as eager option that
-    prints in the callback and exits.
-
-    All arguments are forwarded to :func:`option`.
-    """
-
-    def decorator(f):
-        def callback(ctx, param, value):
-            if value and not ctx.resilient_parsing:
-                echo(ctx.get_help(), color=ctx.color)
-                ctx.exit()
-
-        attrs.setdefault("is_flag", True)
-        attrs.setdefault("expose_value", False)
-        attrs.setdefault("help", "Show this message and exit.")
-        attrs.setdefault("is_eager", True)
-        attrs["callback"] = callback
-        return option(*(param_decls or ("--help",)), **attrs)(f)
-
-    return decorator
+def confirmation_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:
+    """Add a ``--yes`` option which shows a prompt before continuing if
+    not passed. If the prompt is declined, the program will exit.
+
+    :param param_decls: One or more option names. Defaults to the single
+        value ``"--yes"``.
+    :param kwargs: Extra arguments are passed to :func:`option`.
+    """
+
+    def callback(ctx: Context, param: Parameter, value: bool) -> None:
+        if not value:
+            ctx.abort()
+
+    if not param_decls:
+        param_decls = ("--yes",)
+
+    kwargs.setdefault("is_flag", True)
+    kwargs.setdefault("callback", callback)
+    kwargs.setdefault("expose_value", False)
+    kwargs.setdefault("prompt", "Do you want to continue?")
+    kwargs.setdefault("help", "Confirm the action without prompting.")
+    return option(*param_decls, **kwargs)
+
+
+def password_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:
+    """Add a ``--password`` option which prompts for a password, hiding
+    input and asking to enter the value again for confirmation.
+
+    :param param_decls: One or more option names. Defaults to the single
+        value ``"--password"``.
+    :param kwargs: Extra arguments are passed to :func:`option`.
+    """
+    if not param_decls:
+        param_decls = ("--password",)
+
+    kwargs.setdefault("prompt", True)
+    kwargs.setdefault("confirmation_prompt", True)
+    kwargs.setdefault("hide_input", True)
+    return option(*param_decls, **kwargs)
+
+
+def version_option(
+    version: t.Optional[str] = None,
+    *param_decls: str,
+    package_name: t.Optional[str] = None,
+    prog_name: t.Optional[str] = None,
+    message: t.Optional[str] = None,
+    **kwargs: t.Any,
+) -> t.Callable[[FC], FC]:
+    """Add a ``--version`` option which immediately prints the version
+    number and exits the program.
+
+    If ``version`` is not provided, Click will try to detect it using
+    :func:`importlib.metadata.version` to get the version for the
+    ``package_name``. On Python < 3.8, the ``importlib_metadata``
+    backport must be installed.
+
+    If ``package_name`` is not provided, Click will try to detect it by
+    inspecting the stack frames. This will be used to detect the
+    version, so it must match the name of the installed package.
+
+    :param version: The version number to show. If not provided, Click
+        will try to detect it.
+    :param param_decls: One or more option names. Defaults to the single
+        value ``"--version"``.
+    :param package_name: The package name to detect the version from. If
+        not provided, Click will try to detect it.
+    :param prog_name: The name of the CLI to show in the message. If not
+        provided, it will be detected from the command.
+    :param message: The message to show. The values ``%(prog)s``,
+        ``%(package)s``, and ``%(version)s`` are available. Defaults to
+        ``"%(prog)s, version %(version)s"``.
+    :param kwargs: Extra arguments are passed to :func:`option`.
+    :raise RuntimeError: ``version`` could not be detected.
+
+    .. versionchanged:: 8.0
+        Add the ``package_name`` parameter, and the ``%(package)s``
+        value for messages.
+
+    .. versionchanged:: 8.0
+        Use :mod:`importlib.metadata` instead of ``pkg_resources``. The
+        version is detected based on the package name, not the entry
+        point name. The Python package name must match the installed
+        package name, or be passed with ``package_name=``.
+    """
+    if message is None:
+        message = _("%(prog)s, version %(version)s")
+
+    if version is None and package_name is None:
+        frame = inspect.currentframe()
+        f_back = frame.f_back if frame is not None else None
+        f_globals = f_back.f_globals if f_back is not None else None
+        # break reference cycle
+        # https://docs.python.org/3/library/inspect.html#the-interpreter-stack
+        del frame
+
+        if f_globals is not None:
+            package_name = f_globals.get("__name__")
+
+            if package_name == "__main__":
+                package_name = f_globals.get("__package__")
+
+            if package_name:
+                package_name = package_name.partition(".")[0]
+
+    def callback(ctx: Context, param: Parameter, value: bool) -> None:
+        if not value or ctx.resilient_parsing:
+            return
+
+        nonlocal prog_name
+        nonlocal version
+
+        if prog_name is None:
+            prog_name = ctx.find_root().info_name
+
+        if version is None and package_name is not None:
+            metadata: t.Optional[types.ModuleType]
+
+            try:
+                from importlib import metadata  # type: ignore
+            except ImportError:
+                # Python < 3.8
+                import importlib_metadata as metadata  # type: ignore
+
+            try:
+                version = metadata.version(package_name)  # type: ignore
+            except metadata.PackageNotFoundError:  # type: ignore
+                raise RuntimeError(
+                    f"{package_name!r} is not installed. Try passing"
+                    " 'package_name' instead."
+                ) from None
+
+        if version is None:
+            raise RuntimeError(
+                f"Could not determine the version for {package_name!r} automatically."
+            )
+
+        echo(
+            t.cast(str, message)
+            % {"prog": prog_name, "package": package_name, "version": version},
+            color=ctx.color,
+        )
+        ctx.exit()
+
+    if not param_decls:
+        param_decls = ("--version",)
+
+    kwargs.setdefault("is_flag", True)
+    kwargs.setdefault("expose_value", False)
+    kwargs.setdefault("is_eager", True)
+    kwargs.setdefault("help", _("Show the version and exit."))
+    kwargs["callback"] = callback
+    return option(*param_decls, **kwargs)
+
+
+def help_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:
+    """Add a ``--help`` option which immediately prints the help page
+    and exits the program.
+
+    This is usually unnecessary, as the ``--help`` option is added to
+    each command automatically unless ``add_help_option=False`` is
+    passed.
+
+    :param param_decls: One or more option names. Defaults to the single
+        value ``"--help"``.
+    :param kwargs: Extra arguments are passed to :func:`option`.
+    """
+
+    def callback(ctx: Context, param: Parameter, value: bool) -> None:
+        if not value or ctx.resilient_parsing:
+            return
+
+        echo(ctx.get_help(), color=ctx.color)
+        ctx.exit()
+
+    if not param_decls:
+        param_decls = ("--help",)
+
+    kwargs.setdefault("is_flag", True)
+    kwargs.setdefault("expose_value", False)
+    kwargs.setdefault("is_eager", True)
+    kwargs.setdefault("help", _("Show this message and exit."))
+    kwargs["callback"] = callback
+    return option(*param_decls, **kwargs)
